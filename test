{Id:1 Path:example/go-datastructures/augmentedtree/atree.go}
{Id:2 Path:example/go-datastructures/augmentedtree/atree_test.go}
{Id:3 Path:example/go-datastructures/augmentedtree/interface.go}
{Id:4 Path:example/go-datastructures/augmentedtree/intervals.go}
{Id:5 Path:example/go-datastructures/augmentedtree/intervals_test.go}
{Id:6 Path:example/go-datastructures/augmentedtree/mock_test.go}
{Id:7 Path:example/go-datastructures/augmentedtree/multidimensional_test.go}
{Id:8 Path:example/go-datastructures/batcher/batcher.go}
{Id:9 Path:example/go-datastructures/batcher/batcher_test.go}
{Id:10 Path:example/go-datastructures/bitarray/and.go}
{Id:11 Path:example/go-datastructures/bitarray/and_test.go}
{Id:12 Path:example/go-datastructures/bitarray/bitarray.go}
{Id:13 Path:example/go-datastructures/bitarray/bitarray_test.go}
{Id:14 Path:example/go-datastructures/bitarray/bitmap.go}
{Id:15 Path:example/go-datastructures/bitarray/bitmap_test.go}
{Id:16 Path:example/go-datastructures/bitarray/block.go}
{Id:17 Path:example/go-datastructures/bitarray/block_test.go}
{Id:18 Path:example/go-datastructures/bitarray/encoding.go}
{Id:19 Path:example/go-datastructures/bitarray/encoding_test.go}
{Id:20 Path:example/go-datastructures/bitarray/error.go}
{Id:21 Path:example/go-datastructures/bitarray/interface.go}
{Id:22 Path:example/go-datastructures/bitarray/iterator.go}
{Id:23 Path:example/go-datastructures/bitarray/nand.go}
{Id:24 Path:example/go-datastructures/bitarray/nand_test.go}
{Id:25 Path:example/go-datastructures/bitarray/or.go}
{Id:26 Path:example/go-datastructures/bitarray/or_test.go}
{Id:27 Path:example/go-datastructures/bitarray/sparse_bitarray.go}
{Id:28 Path:example/go-datastructures/bitarray/sparse_bitarray_test.go}
{Id:29 Path:example/go-datastructures/bitarray/util.go}
{Id:30 Path:example/go-datastructures/btree/_link/interface.go}
{Id:31 Path:example/go-datastructures/btree/_link/key.go}
{Id:32 Path:example/go-datastructures/btree/_link/mock_test.go}
{Id:33 Path:example/go-datastructures/btree/_link/node.go}
{Id:34 Path:example/go-datastructures/btree/_link/node_test.go}
{Id:35 Path:example/go-datastructures/btree/_link/tree.go}
{Id:36 Path:example/go-datastructures/btree/_link/tree_test.go}
{Id:37 Path:example/go-datastructures/btree/immutable/add.go}
{Id:38 Path:example/go-datastructures/btree/immutable/cacher.go}
{Id:39 Path:example/go-datastructures/btree/immutable/config.go}
{Id:40 Path:example/go-datastructures/btree/immutable/delete.go}
{Id:41 Path:example/go-datastructures/btree/immutable/error.go}
{Id:42 Path:example/go-datastructures/btree/immutable/interface.go}
{Id:43 Path:example/go-datastructures/btree/immutable/item.go}
{Id:44 Path:example/go-datastructures/btree/immutable/node.go}
{Id:45 Path:example/go-datastructures/btree/immutable/node_gen.go}
{Id:46 Path:example/go-datastructures/btree/immutable/path.go}
{Id:47 Path:example/go-datastructures/btree/immutable/query.go}
{Id:48 Path:example/go-datastructures/btree/immutable/rt.go}
{Id:49 Path:example/go-datastructures/btree/immutable/rt_gen.go}
{Id:50 Path:example/go-datastructures/btree/immutable/rt_test.go}
{Id:51 Path:example/go-datastructures/btree/palm/action.go}
{Id:52 Path:example/go-datastructures/btree/palm/interface.go}
{Id:53 Path:example/go-datastructures/btree/palm/key.go}
{Id:54 Path:example/go-datastructures/btree/palm/mock_test.go}
{Id:55 Path:example/go-datastructures/btree/palm/node.go}
{Id:56 Path:example/go-datastructures/btree/palm/tree.go}
{Id:57 Path:example/go-datastructures/btree/palm/tree_test.go}
{Id:58 Path:example/go-datastructures/btree/plus/btree.go}
{Id:59 Path:example/go-datastructures/btree/plus/btree_test.go}
{Id:60 Path:example/go-datastructures/btree/plus/interface.go}
{Id:61 Path:example/go-datastructures/btree/plus/iterator.go}
{Id:62 Path:example/go-datastructures/btree/plus/mock_test.go}
{Id:63 Path:example/go-datastructures/btree/plus/node.go}
{Id:64 Path:example/go-datastructures/btree/plus/node_test.go}
{Id:65 Path:example/go-datastructures/cache/cache.go}
{Id:66 Path:example/go-datastructures/cache/cache_test.go}
{Id:67 Path:example/go-datastructures/common/interface.go}
{Id:68 Path:example/go-datastructures/datastructures.go}
{Id:69 Path:example/go-datastructures/fibheap/fibheap.go}
{Id:70 Path:example/go-datastructures/fibheap/fibheap_examples_test.go}
{Id:71 Path:example/go-datastructures/fibheap/fibheap_single_example_test.go}
{Id:72 Path:example/go-datastructures/fibheap/fibheap_test.go}
{Id:73 Path:example/go-datastructures/futures/futures.go}
{Id:74 Path:example/go-datastructures/futures/futures_test.go}
{Id:75 Path:example/go-datastructures/futures/selectable.go}
{Id:76 Path:example/go-datastructures/futures/selectable_test.go}
{Id:77 Path:example/go-datastructures/graph/simple.go}
{Id:78 Path:example/go-datastructures/graph/simple_test.go}
{Id:79 Path:example/go-datastructures/hashmap/fastinteger/hash.go}
{Id:80 Path:example/go-datastructures/hashmap/fastinteger/hash_test.go}
{Id:81 Path:example/go-datastructures/hashmap/fastinteger/hashmap.go}
{Id:82 Path:example/go-datastructures/hashmap/fastinteger/hashmap_test.go}
{Id:83 Path:example/go-datastructures/list/persistent.go}
{Id:84 Path:example/go-datastructures/list/persistent_test.go}
{Id:85 Path:example/go-datastructures/mock/batcher.go}
{Id:86 Path:example/go-datastructures/mock/rangetree.go}
{Id:87 Path:example/go-datastructures/numerics/hilbert/hilbert.go}
{Id:88 Path:example/go-datastructures/numerics/hilbert/hilbert_test.go}
{Id:89 Path:example/go-datastructures/numerics/optimization/global.go}
{Id:90 Path:example/go-datastructures/numerics/optimization/nelder_mead.go}
{Id:91 Path:example/go-datastructures/numerics/optimization/nelder_mead_test.go}
{Id:92 Path:example/go-datastructures/queue/error.go}
{Id:93 Path:example/go-datastructures/queue/mock_test.go}
{Id:94 Path:example/go-datastructures/queue/priority_queue.go}
{Id:95 Path:example/go-datastructures/queue/priority_queue_test.go}
{Id:96 Path:example/go-datastructures/queue/queue.go}
{Id:97 Path:example/go-datastructures/queue/queue_test.go}
{Id:98 Path:example/go-datastructures/queue/ring.go}
{Id:99 Path:example/go-datastructures/queue/ring_test.go}
{Id:100 Path:example/go-datastructures/rangetree/entries.go}
{Id:101 Path:example/go-datastructures/rangetree/entries_test.go}
{Id:102 Path:example/go-datastructures/rangetree/error.go}
{Id:103 Path:example/go-datastructures/rangetree/immutable.go}
{Id:104 Path:example/go-datastructures/rangetree/immutable_test.go}
{Id:105 Path:example/go-datastructures/rangetree/interface.go}
{Id:106 Path:example/go-datastructures/rangetree/mock_test.go}
{Id:107 Path:example/go-datastructures/rangetree/node.go}
{Id:108 Path:example/go-datastructures/rangetree/ordered.go}
{Id:109 Path:example/go-datastructures/rangetree/ordered_test.go}
{Id:110 Path:example/go-datastructures/rangetree/orderedtree.go}
{Id:111 Path:example/go-datastructures/rangetree/orderedtree_test.go}
{Id:112 Path:example/go-datastructures/rangetree/skiplist/mock_test.go}
{Id:113 Path:example/go-datastructures/rangetree/skiplist/skiplist.go}
{Id:114 Path:example/go-datastructures/rangetree/skiplist/skiplist_test.go}
{Id:115 Path:example/go-datastructures/rtree/hilbert/action.go}
{Id:116 Path:example/go-datastructures/rtree/hilbert/hilbert.go}
{Id:117 Path:example/go-datastructures/rtree/hilbert/mock_test.go}
{Id:118 Path:example/go-datastructures/rtree/hilbert/node.go}
{Id:119 Path:example/go-datastructures/rtree/hilbert/rectangle.go}
{Id:120 Path:example/go-datastructures/rtree/hilbert/tree.go}
{Id:121 Path:example/go-datastructures/rtree/hilbert/tree_test.go}
{Id:122 Path:example/go-datastructures/rtree/interface.go}
{Id:123 Path:example/go-datastructures/set/dict.go}
{Id:124 Path:example/go-datastructures/set/dict_test.go}
{Id:125 Path:example/go-datastructures/slice/int64.go}
{Id:126 Path:example/go-datastructures/slice/int64_test.go}
{Id:127 Path:example/go-datastructures/slice/skip/interface.go}
{Id:128 Path:example/go-datastructures/slice/skip/iterator.go}
{Id:129 Path:example/go-datastructures/slice/skip/iterator_test.go}
{Id:130 Path:example/go-datastructures/slice/skip/mock_test.go}
{Id:131 Path:example/go-datastructures/slice/skip/node.go}
{Id:132 Path:example/go-datastructures/slice/skip/skip.go}
{Id:133 Path:example/go-datastructures/slice/skip/skip_test.go}
{Id:134 Path:example/go-datastructures/sort/interface.go}
{Id:135 Path:example/go-datastructures/sort/sort.go}
{Id:136 Path:example/go-datastructures/sort/sort_test.go}
{Id:137 Path:example/go-datastructures/sort/symmerge.go}
{Id:138 Path:example/go-datastructures/sort/symmerge_test.go}
{Id:139 Path:example/go-datastructures/threadsafe/err/error.go}
{Id:140 Path:example/go-datastructures/threadsafe/err/error_test.go}
{Id:141 Path:example/go-datastructures/tree/avl/avl.go}
{Id:142 Path:example/go-datastructures/tree/avl/avl_test.go}
{Id:143 Path:example/go-datastructures/tree/avl/interface.go}
{Id:144 Path:example/go-datastructures/tree/avl/mock_test.go}
{Id:145 Path:example/go-datastructures/tree/avl/node.go}
{Id:146 Path:example/go-datastructures/trie/ctrie/ctrie.go}
{Id:147 Path:example/go-datastructures/trie/ctrie/ctrie_test.go}
{Id:148 Path:example/go-datastructures/trie/dtrie/dtrie.go}
{Id:149 Path:example/go-datastructures/trie/dtrie/dtrie_test.go}
{Id:150 Path:example/go-datastructures/trie/dtrie/node.go}
{Id:151 Path:example/go-datastructures/trie/dtrie/util.go}
{Id:152 Path:example/go-datastructures/trie/xfast/iterator.go}
{Id:153 Path:example/go-datastructures/trie/xfast/iterator_test.go}
{Id:154 Path:example/go-datastructures/trie/xfast/mock_test.go}
{Id:155 Path:example/go-datastructures/trie/xfast/xfast.go}
{Id:156 Path:example/go-datastructures/trie/xfast/xfast_test.go}
{Id:157 Path:example/go-datastructures/trie/yfast/entries.go}
{Id:158 Path:example/go-datastructures/trie/yfast/entries_test.go}
{Id:159 Path:example/go-datastructures/trie/yfast/interface.go}
{Id:160 Path:example/go-datastructures/trie/yfast/iterator.go}
{Id:161 Path:example/go-datastructures/trie/yfast/mock_test.go}
{Id:162 Path:example/go-datastructures/trie/yfast/yfast.go}
{Id:163 Path:example/go-datastructures/trie/yfast/yfast_test.go}
{Id:1 FileId:32 StartLine:21 StartColumn:1 EndLine:32 EndColumn:2 Name:Compare Params:[{Name:other Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000879a60 Body:{
	otherK := other.(mockKey)
	if mk < otherK {
		return -1
	}

	if mk > otherK {
		return 1
	}

	return 0
} PrettyPrintBody:[{ otherK := other.(mockKey) if mk < otherK { return -1 } if mk > otherK { return 1 } return 0 }]}
{Id:2 FileId:107 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:newNode Params:[{Name:value Type:int64} {Name:entry Type:Entry} {Name:needNextDimension Type:bool}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := &node{}
	n.value = value
	if needNextDimension {
		n.orderedNodes = make(orderedNodes, 0, 10)
	} else {
		n.entry = entry
	}

	return n
} PrettyPrintBody:[{ n := &node{} n.value = value if needNextDimension { n.orderedNodes = make(orderedNodes, 0, 10) } else { n.entry = entry } return n }]}
{Id:1 FileId:161 StartLine:24 StartColumn:1 EndLine:26 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0012622a0 Body:{
	return me.key
} PrettyPrintBody:[{ return me.key }]}
{Id:2 FileId:161 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{key}
} PrettyPrintBody:[{ return &mockEntry{key} }]}
{Id:1 FileId:140 StartLine:26 StartColumn:1 EndLine:34 EndColumn:2 Name:TestGetSetError Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	e := New()
	assert.Nil(t, e.Get())

	err := fmt.Errorf(`test`)
	e.Set(err)

	assert.Equal(t, err, e.Get())
} PrettyPrintBody:[{ e := New() assert.Nil(t, e.Get()) err := fmt.Errorf(`test`) e.Set(err) assert.Equal(t, err, e.Get()) }]}
{Id:2 FileId:20 StartLine:26 StartColumn:1 EndLine:28 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc000c7cfe0 Body:{
	return fmt.Sprintf(`Index %d is out of range.`, err)
} PrettyPrintBody:[{ return fmt.Sprintf(`Index %d is out of range.`, err) }]}
{Id:2 FileId:102 StartLine:25 StartColumn:1 EndLine:27 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc00113ea20 Body:{
	return `No entries in this tree.`
} PrettyPrintBody:[{ return `No entries in this tree.` }]}
{Id:4 FileId:102 StartLine:35 StartColumn:1 EndLine:40 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc00113ea60 Body:{
	return fmt.Sprintf(`Provided dimension: %d is 
		greater than max dimension: %d`,
		oode.provided, oode.max,
	)
} PrettyPrintBody:[{ return fmt.Sprintf(`Provided dimension: %d is greater than max dimension: %d`, oode.provided, oode.max, ) }]}
{Id:1 FileId:93 StartLine:21 StartColumn:1 EndLine:29 EndColumn:2 Name:Compare Params:[{Name:other Type:Item}] Results:[{Name: Type:int}] Receiver:0xc00129b9a0 Body:{
	omi := other.(mockItem)
	if mi > omi {
		return 1
	} else if mi == omi {
		return 0
	}
	return -1
} PrettyPrintBody:[{ omi := other.(mockItem) if mi > omi { return 1 } else if mi == omi { return 0 } return -1 }]}
{Id:2 FileId:43 StartLine:26 StartColumn:1 EndLine:32 EndColumn:2 Name:split Params:[{Name:numParts Type:int}] Results:[{Name: Type:[]items}] Receiver:0xc0013089c0 Body:{
	parts := make([]items, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = its[i*int64(len(its))/int64(numParts) : (i+1)*int64(len(its))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]items, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = its[i*int64(len(its))/int64(numParts) : (i+1)*int64(len(its))/int64(numParts)] } return parts }]}
{Id:1 FileId:106 StartLine:24 StartColumn:1 EndLine:26 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00111ec60 Body:{
	return me.id
} PrettyPrintBody:[{ return me.id }]}
{Id:2 FileId:106 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:ValueAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00111ecc0 Body:{
	return me.dimensions[dimension-1]
} PrettyPrintBody:[{ return me.dimensions[dimension-1] }]}
{Id:3 FileId:106 StartLine:32 StartColumn:1 EndLine:37 EndColumn:2 Name:constructMockEntry Params:[{Name:id Type:uint64} {Name:values Type:...int64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{
		id:		id,
		dimensions:	values,
	}
} PrettyPrintBody:[{ return &mockEntry{ id:		id, dimensions:	values, } }]}
{Id:6 FileId:106 StartLine:47 StartColumn:1 EndLine:49 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000e8df80 Body:{
	return mi.dimensions[dimension-1].low
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].low }]}
{Id:7 FileId:106 StartLine:51 StartColumn:1 EndLine:53 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000e8dfe0 Body:{
	return mi.dimensions[dimension-1].high
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].high }]}
{Id:8 FileId:106 StartLine:55 StartColumn:1 EndLine:59 EndColumn:2 Name:constructMockInterval Params:[{Name:dimensions Type:...dimension}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{
		dimensions: dimensions,
	}
} PrettyPrintBody:[{ return &mockInterval{ dimensions: dimensions, } }]}
{Id:1 FileId:129 StartLine:25 StartColumn:1 EndLine:57 EndColumn:2 Name:TestIterate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	e1 := newMockEntry(1)
	n1 := newNode(e1, 8)
	iter := &iterator{
		n:	n1,
		first:	true,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e2 := newMockEntry(2)
	n2 := newNode(e2, 8)
	n1.forward[0] = n2

	iter = &iterator{
		n:	n1,
		first:	true,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.True(t, iter.Next())
	assert.Equal(t, e2, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	iter = nilIterator()
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())
} PrettyPrintBody:[{ e1 := newMockEntry(1) n1 := newNode(e1, 8) iter := &iterator{ n:	n1, first:	true, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e2 := newMockEntry(2) n2 := newNode(e2, 8) n1.forward[0] = n2 iter = &iterator{ n:	n1, first:	true, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.True(t, iter.Next()) assert.Equal(t, e2, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) iter = nilIterator() assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) }]}
{Id:1 FileId:101 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:TestDisposeEntries Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := NewEntries()
	entries = append(entries, constructMockEntry(0, 0))

	entries.Dispose()

	assert.Len(t, entries, 0)
} PrettyPrintBody:[{ entries := NewEntries() entries = append(entries, constructMockEntry(0, 0)) entries.Dispose() assert.Len(t, entries, 0) }]}
{Id:2 FileId:54 StartLine:22 StartColumn:1 EndLine:34 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc0010323c0 Body:{
	otherKey := other.(mockKey)

	if mk == otherKey {
		return 0
	}

	if mk > otherKey {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherKey := other.(mockKey) if mk == otherKey { return 0 } if mk > otherKey { return 1 } return -1 }]}
{Id:1 FileId:53 StartLine:21 StartColumn:1 EndLine:28 EndColumn:2 Name:reverseKeys Params:[{Name:cmps Type:common.Comparators}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	reversed := make(common.Comparators, len(cmps))
	for i := len(cmps) - 1; i >= 0; i-- {
		reversed[len(cmps)-1-i] = cmps[i]
	}

	return reversed
} PrettyPrintBody:[{ reversed := make(common.Comparators, len(cmps)) for i := len(cmps) - 1; i >= 0; i-- { reversed[len(cmps)-1-i] = cmps[i] } return reversed }]}
{Id:2 FileId:53 StartLine:30 StartColumn:1 EndLine:36 EndColumn:2 Name:chunkKeys Params:[{Name:keys Type:common.Comparators} {Name:numParts Type:int64}] Results:[{Name: Type:[]common.Comparators}] Receiver:<nil> Body:{
	parts := make([]common.Comparators, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]common.Comparators, numParts) for i := int64(0); i < numParts; i++ { parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts] } return parts }]}
{Id:2 FileId:139 StartLine:36 StartColumn:1 EndLine:41 EndColumn:2 Name:Set Params:[{Name:err Type:error}] Results:[] Receiver:0xc0014093c0 Body:{
	e.lock.Lock()
	defer e.lock.Unlock()

	e.err = err
} PrettyPrintBody:[{ e.lock.Lock() defer e.lock.Unlock() e.err = err }]}
{Id:3 FileId:139 StartLine:44 StartColumn:1 EndLine:49 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:error}] Receiver:0xc001308d00 Body:{
	e.lock.RLock()
	defer e.lock.RUnlock()

	return e.err
} PrettyPrintBody:[{ e.lock.RLock() defer e.lock.RUnlock() return e.err }]}
{Id:4 FileId:139 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:New Params:[] Results:[{Name: Type:*Error}] Receiver:<nil> Body:{
	return &Error{}
} PrettyPrintBody:[{ return &Error{} }]}
{Id:4 FileId:131 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc0009f8a60 Body:{
	return n.entry.Compare(e)
} PrettyPrintBody:[{ return n.entry.Compare(e) }]}
{Id:5 FileId:131 StartLine:44 StartColumn:1 EndLine:50 EndColumn:2 Name:newNode Params:[{Name:cmp Type:common.Comparator} {Name:maxLevels Type:uint8}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		entry:		cmp,
		forward:	make(nodes, maxLevels),
		widths:		make(widths, maxLevels),
	}
} PrettyPrintBody:[{ return &node{ entry:		cmp, forward:	make(nodes, maxLevels), widths:		make(widths, maxLevels), } }]}
{Id:2 FileId:152 StartLine:30 StartColumn:1 EndLine:38 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001602040 Body:{
	if iter.first {
		iter.first = false
		return iter.n != nil
	}

	iter.n = iter.n.children[1]
	return iter.n != nil
} PrettyPrintBody:[{ if iter.first { iter.first = false return iter.n != nil } iter.n = iter.n.children[1] return iter.n != nil }]}
{Id:3 FileId:152 StartLine:43 StartColumn:1 EndLine:49 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001308880 Body:{
	if iter.n == nil {
		return nil
	}

	return iter.n.entry
} PrettyPrintBody:[{ if iter.n == nil { return nil } return iter.n.entry }]}
{Id:4 FileId:152 StartLine:53 StartColumn:1 EndLine:60 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:Entries}] Receiver:0xc0010bc360 Body:{
	entries := make(Entries, 0, 100)
	for it := iter; it.Next(); {
		entries = append(entries, it.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, 100) for it := iter; it.Next(); { entries = append(entries, it.Value()) } return entries }]}
{Id:1 FileId:144 StartLine:21 StartColumn:1 EndLine:32 EndColumn:2 Name:Compare Params:[{Name:other Type:Entry}] Results:[{Name: Type:int}] Receiver:0xc001291560 Body:{
	otherMe := other.(mockEntry)
	if me > otherMe {
		return 1
	}

	if me < otherMe {
		return -1
	}

	return 0
} PrettyPrintBody:[{ otherMe := other.(mockEntry) if me > otherMe { return 1 } if me < otherMe { return -1 } return 0 }]}
{Id:3 FileId:4 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc00095ab20 Body:{
	for i := 0; i < len(*ivs); i++ {
		(*ivs)[i] = nil
	}

	*ivs = (*ivs)[:0]
	intervalsPool.Put(*ivs)
} PrettyPrintBody:[{ for i := 0; i < len(*ivs); i++ { (*ivs)[i] = nil } *ivs = (*ivs)[:0] intervalsPool.Put(*ivs) }]}
{Id:2 FileId:154 StartLine:25 StartColumn:1 EndLine:28 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0009f94a0 Body:{
	args := me.Called()
	return args.Get(0).(uint64)
} PrettyPrintBody:[{ args := me.Called() return args.Get(0).(uint64) }]}
{Id:3 FileId:154 StartLine:30 StartColumn:1 EndLine:34 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	me := new(mockEntry)
	me.On(`Key`).Return(key)
	return me
} PrettyPrintBody:[{ me := new(mockEntry) me.On(`Key`).Return(key) return me }]}
{Id:1 FileId:126 StartLine:25 StartColumn:1 EndLine:30 EndColumn:2 Name:TestSort Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{3, 6, 1, 0, -1}
	s.Sort()

	assert.Equal(t, Int64Slice{-1, 0, 1, 3, 6}, s)
} PrettyPrintBody:[{ s := Int64Slice{3, 6, 1, 0, -1} s.Sort() assert.Equal(t, Int64Slice{-1, 0, 1, 3, 6}, s) }]}
{Id:2 FileId:126 StartLine:32 StartColumn:1 EndLine:38 EndColumn:2 Name:TestSearch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}

	assert.Equal(t, 1, s.Search(3))
	assert.Equal(t, 1, s.Search(2))
	assert.Equal(t, 3, s.Search(7))
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} assert.Equal(t, 1, s.Search(3)) assert.Equal(t, 1, s.Search(2)) assert.Equal(t, 3, s.Search(7)) }]}
{Id:3 FileId:126 StartLine:40 StartColumn:1 EndLine:45 EndColumn:2 Name:TestExists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}

	assert.True(t, s.Exists(3))
	assert.False(t, s.Exists(4))
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} assert.True(t, s.Exists(3)) assert.False(t, s.Exists(4)) }]}
{Id:4 FileId:126 StartLine:47 StartColumn:1 EndLine:54 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}
	s = s.Insert(2)
	assert.Equal(t, Int64Slice{1, 2, 3, 6}, s)

	s = s.Insert(7)
	assert.Equal(t, Int64Slice{1, 2, 3, 6, 7}, s)
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} s = s.Insert(2) assert.Equal(t, Int64Slice{1, 2, 3, 6}, s) s = s.Insert(7) assert.Equal(t, Int64Slice{1, 2, 3, 6, 7}, s) }]}
{Id:1 FileId:5 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:TestIntervalsDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	intervals := intervalsPool.Get().(Intervals)
	intervals = append(intervals, constructSingleDimensionInterval(0, 1, 0))

	intervals.Dispose()

	assert.Len(t, intervals, 0)
} PrettyPrintBody:[{ intervals := intervalsPool.Get().(Intervals) intervals = append(intervals, constructSingleDimensionInterval(0, 1, 0)) intervals.Dispose() assert.Len(t, intervals, 0) }]}
{Id:0 FileId:79 StartLine:6 StartColumn:1 EndLine:13 EndColumn:2 Name:hash Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	key ^= key >> 33
	key *= 0xff51afd7ed558ccd
	key ^= key >> 33
	key *= 0xc4ceb9fe1a85ec53
	key ^= key >> 33
	return key
} PrettyPrintBody:[{ key ^= key >> 33 key *= 0xff51afd7ed558ccd key ^= key >> 33 key *= 0xc4ceb9fe1a85ec53 key ^= key >> 33 return key }]}
{Id:4 FileId:16 StartLine:38 StartColumn:1 EndLine:44 EndColumn:2 Name:toNums Params:[{Name:offset Type:uint64} {Name:nums Type:*[]uint64}] Results:[] Receiver:0xc000d604e0 Body:{
	for i := uint64(0); i < s; i++ {
		if b&block(1<<i) > 0 {
			*nums = append(*nums, i+offset)
		}
	}
} PrettyPrintBody:[{ for i := uint64(0); i < s; i++ { if b&block(1<<i) > 0 { *nums = append(*nums, i+offset) } } }]}
{Id:5 FileId:16 StartLine:46 StartColumn:1 EndLine:55 EndColumn:2 Name:findLeftPosition Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000e8cba0 Body:{
	for i := s - 1; i < s; i-- {
		test := block(1 << i)
		if b&test == test {
			return i
		}
	}

	return s
} PrettyPrintBody:[{ for i := s - 1; i < s; i-- { test := block(1 << i) if b&test == test { return i } } return s }]}
{Id:6 FileId:16 StartLine:57 StartColumn:1 EndLine:66 EndColumn:2 Name:findRightPosition Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001290180 Body:{
	for i := uint64(0); i < s; i++ {
		test := block(1 << i)
		if b&test == test {
			return i
		}
	}

	return s
} PrettyPrintBody:[{ for i := uint64(0); i < s; i++ { test := block(1 << i) if b&test == test { return i } } return s }]}
{Id:7 FileId:16 StartLine:68 StartColumn:1 EndLine:70 EndColumn:2 Name:insert Params:[{Name:position Type:uint64}] Results:[{Name: Type:block}] Receiver:0xc0012267a0 Body:{
	return b | block(1<<position)
} PrettyPrintBody:[{ return b | block(1<<position) }]}
{Id:8 FileId:16 StartLine:72 StartColumn:1 EndLine:74 EndColumn:2 Name:remove Params:[{Name:position Type:uint64}] Results:[{Name: Type:block}] Receiver:0xc0012909c0 Body:{
	return b & ^block(1<<position)
} PrettyPrintBody:[{ return b & ^block(1<<position) }]}
{Id:9 FileId:16 StartLine:76 StartColumn:1 EndLine:78 EndColumn:2 Name:or Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc0014093a0 Body:{
	return b | other
} PrettyPrintBody:[{ return b | other }]}
{Id:10 FileId:16 StartLine:80 StartColumn:1 EndLine:82 EndColumn:2 Name:and Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc001239240 Body:{
	return b & other
} PrettyPrintBody:[{ return b & other }]}
{Id:11 FileId:16 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:nand Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc0012278e0 Body:{
	return b &^ other
} PrettyPrintBody:[{ return b &^ other }]}
{Id:12 FileId:16 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:get Params:[{Name:position Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000e7ff60 Body:{
	return b&block(1<<position) != 0
} PrettyPrintBody:[{ return b&block(1<<position) != 0 }]}
{Id:13 FileId:16 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:equals Params:[{Name:other Type:block}] Results:[{Name: Type:bool}] Receiver:0xc001032ec0 Body:{
	return b == other
} PrettyPrintBody:[{ return b == other }]}
{Id:14 FileId:16 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:intersects Params:[{Name:other Type:block}] Results:[{Name: Type:bool}] Receiver:0xc001032f20 Body:{
	return b&other == other
} PrettyPrintBody:[{ return b&other == other }]}
{Id:15 FileId:16 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00095a020 Body:{
	return fmt.Sprintf(fmt.Sprintf("%%0%db", s), uint64(b))
} PrettyPrintBody:[{ return fmt.Sprintf(fmt.Sprintf("%%0%db", s), uint64(b)) }]}
{Id:3 FileId:128 StartLine:33 StartColumn:1 EndLine:45 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001013040 Body:{
	if iter.first {
		iter.first = false
		return iter.n != nil
	}

	if iter.n == nil {
		return false
	}

	iter.n = iter.n.forward[0]
	return iter.n != nil
} PrettyPrintBody:[{ if iter.first { iter.first = false return iter.n != nil } if iter.n == nil { return false } iter.n = iter.n.forward[0] return iter.n != nil }]}
{Id:4 FileId:128 StartLine:49 StartColumn:1 EndLine:55 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc001032d00 Body:{
	if iter.n == nil {
		return nil
	}

	return iter.n.entry
} PrettyPrintBody:[{ if iter.n == nil { return nil } return iter.n.entry }]}
{Id:5 FileId:128 StartLine:59 StartColumn:1 EndLine:66 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc000e57400 Body:{
	entries := make(common.Comparators, 0, 10)
	for i := iter; i.Next(); {
		entries = append(entries, i.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, 10) for i := iter; i.Next(); { entries = append(entries, i.Value()) } return entries }]}
{Id:6 FileId:128 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*iterator}] Receiver:<nil> Body:{
	return &iterator{}
} PrettyPrintBody:[{ return &iterator{} }]}
{Id:3 FileId:100 StartLine:33 StartColumn:1 EndLine:40 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0011550e0 Body:{
	for i := 0; i < len(*entries); i++ {
		(*entries)[i] = nil
	}

	*entries = (*entries)[:0]
	entriesPool.Put(*entries)
} PrettyPrintBody:[{ for i := 0; i < len(*entries); i++ { (*entries)[i] = nil } *entries = (*entries)[:0] entriesPool.Put(*entries) }]}
{Id:4 FileId:100 StartLine:43 StartColumn:1 EndLine:45 EndColumn:2 Name:NewEntries Params:[] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	return entriesPool.Get().(Entries)
} PrettyPrintBody:[{ return entriesPool.Get().(Entries) }]}
{Id:1 FileId:134 StartLine:8 StartColumn:1 EndLine:10 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0003d21a0 Body:{
	return c[i].Compare(c[j]) < 0
} PrettyPrintBody:[{ return c[i].Compare(c[j]) < 0 }]}
{Id:2 FileId:134 StartLine:14 StartColumn:1 EndLine:16 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a0a0 Body:{
	return len(c)
} PrettyPrintBody:[{ return len(c) }]}
{Id:3 FileId:134 StartLine:19 StartColumn:1 EndLine:21 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001309060 Body:{
	c[j], c[i] = c[i], c[j]
} PrettyPrintBody:[{ c[j], c[i] = c[i], c[j] }]}
{Id:3 FileId:6 StartLine:30 StartColumn:1 EndLine:34 EndColumn:2 Name:checkDimension Params:[{Name:dimension Type:uint64}] Results:[] Receiver:0xc00019eea0 Body:{
	if dimension > uint64(len(mi.dimensions)) {
		panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension))
	}
} PrettyPrintBody:[{ if dimension > uint64(len(mi.dimensions)) { panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension)) } }]}
{Id:4 FileId:6 StartLine:36 StartColumn:1 EndLine:38 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00019ef00 Body:{
	return mi.dimensions[dimension-1].low
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].low }]}
{Id:5 FileId:6 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00019ef60 Body:{
	return mi.dimensions[dimension-1].high
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].high }]}
{Id:6 FileId:6 StartLine:44 StartColumn:1 EndLine:47 EndColumn:2 Name:OverlapsAtDimension Params:[{Name:iv Type:Interval} {Name:dimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000fa6e20 Body:{
	return mi.HighAtDimension(dimension) > iv.LowAtDimension(dimension) &&
		mi.LowAtDimension(dimension) < iv.HighAtDimension(dimension)
} PrettyPrintBody:[{ return mi.HighAtDimension(dimension) > iv.LowAtDimension(dimension) && mi.LowAtDimension(dimension) < iv.HighAtDimension(dimension) }]}
{Id:7 FileId:6 StartLine:49 StartColumn:1 EndLine:51 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0010bc900 Body:{
	return mi.id
} PrettyPrintBody:[{ return mi.id }]}
{Id:8 FileId:6 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:constructSingleDimensionInterval Params:[{Name:low Type:int64} {Name:id Type:uint64}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{[]*dimension{&dimension{low: low, high: high}}, id}
} PrettyPrintBody:[{ return &mockInterval{[]*dimension{&dimension{low: low, high: high}}, id} }]}
{Id:9 FileId:6 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:constructMultiDimensionInterval Params:[{Name:id Type:uint64} {Name:dimensions Type:...*dimension}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{dimensions: dimensions, id: id}
} PrettyPrintBody:[{ return &mockInterval{dimensions: dimensions, id: id} }]}
{Id:1 FileId:31 StartLine:21 StartColumn:1 EndLine:25 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0009f8940 Body:{
	return sort.Search(len(keys), func(i int) bool {
		return keys[i].Compare(key) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(keys), func(i int) bool { return keys[i].Compare(key) >= 0 }) }]}
{Id:2 FileId:31 StartLine:27 StartColumn:1 EndLine:30 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc0011b3cc0 Body:{
	i := keys.search(key)
	return keys.insertAt(key, i)
} PrettyPrintBody:[{ i := keys.search(key) return keys.insertAt(key, i) }]}
{Id:3 FileId:31 StartLine:32 StartColumn:1 EndLine:48 EndColumn:2 Name:insertAt Params:[{Name:key Type:Key} {Name:i Type:int}] Results:[{Name: Type:Key}] Receiver:0xc000e600c0 Body:{
	if i == len(*keys) {
		*keys = append(*keys, key)
		return nil
	}

	if (*keys)[i].Compare(key) == 0 {
		oldKey := (*keys)[i]
		(*keys)[i] = key
		return oldKey
	}

	*keys = append(*keys, nil)
	copy((*keys)[i+1:], (*keys)[i:])
	(*keys)[i] = key
	return nil
} PrettyPrintBody:[{ if i == len(*keys) { *keys = append(*keys, key) return nil } if (*keys)[i].Compare(key) == 0 { oldKey := (*keys)[i] (*keys)[i] = key return oldKey } *keys = append(*keys, nil) copy((*keys)[i+1:], (*keys)[i:]) (*keys)[i] = key return nil }]}
{Id:4 FileId:31 StartLine:50 StartColumn:1 EndLine:56 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:Keys} {Name: Type:Keys}] Receiver:0xc000e60120 Body:{
	i := (len(*keys) / 2) - 1
	middle := (*keys)[i]

	left, right := keys.splitAt(i)
	return middle, left, right
} PrettyPrintBody:[{ i := (len(*keys) / 2) - 1 middle := (*keys)[i] left, right := keys.splitAt(i) return middle, left, right }]}
{Id:5 FileId:31 StartLine:58 StartColumn:1 EndLine:67 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:Keys} {Name: Type:Keys}] Receiver:0xc000e604c0 Body:{
	right := make(Keys, len(*keys)-i-1, cap(*keys))
	copy(right, (*keys)[i+1:])
	for j := i + 1; j < len(*keys); j++ {
		(*keys)[j] = nil
	}
	*keys = (*keys)[:i+1]

	return *keys, right
} PrettyPrintBody:[{ right := make(Keys, len(*keys)-i-1, cap(*keys)) copy(right, (*keys)[i+1:]) for j := i + 1; j < len(*keys); j++ { (*keys)[j] = nil } *keys = (*keys)[:i+1] return *keys, right }]}
{Id:6 FileId:31 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:last Params:[] Results:[{Name: Type:Key}] Receiver:0xc000e60600 Body:{
	return keys[len(keys)-1]
} PrettyPrintBody:[{ return keys[len(keys)-1] }]}
{Id:7 FileId:31 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:first Params:[] Results:[{Name: Type:Key}] Receiver:0xc000e60f60 Body:{
	return keys[0]
} PrettyPrintBody:[{ return keys[0] }]}
{Id:8 FileId:31 StartLine:77 StartColumn:1 EndLine:79 EndColumn:2 Name:needsSplit Params:[] Results:[{Name: Type:bool}] Receiver:0xc000e61460 Body:{
	return cap(keys) == len(keys)
} PrettyPrintBody:[{ return cap(keys) == len(keys) }]}
{Id:9 FileId:31 StartLine:81 StartColumn:1 EndLine:88 EndColumn:2 Name:reverse Params:[] Results:[{Name: Type:Keys}] Receiver:0xc000e615e0 Body:{
	reversed := make(Keys, len(keys))
	for i := len(keys) - 1; i >= 0; i-- {
		reversed[len(keys)-1-i] = keys[i]
	}

	return reversed
} PrettyPrintBody:[{ reversed := make(Keys, len(keys)) for i := len(keys) - 1; i >= 0; i-- { reversed[len(keys)-1-i] = keys[i] } return reversed }]}
{Id:10 FileId:31 StartLine:90 StartColumn:1 EndLine:96 EndColumn:2 Name:chunkKeys Params:[{Name:keys Type:Keys} {Name:numParts Type:int64}] Results:[{Name: Type:[]Keys}] Receiver:<nil> Body:{
	parts := make([]Keys, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Keys, numParts) for i := int64(0); i < numParts; i++ { parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts] } return parts }]}
{Id:1 FileId:135 StartLine:9 StartColumn:1 EndLine:11 EndColumn:2 Name:sortBucket Params:[{Name:comparators Type:Comparators}] Results:[] Receiver:<nil> Body:{
	sort.Sort(comparators)
} PrettyPrintBody:[{ sort.Sort(comparators) }]}
{Id:2 FileId:135 StartLine:13 StartColumn:1 EndLine:17 EndColumn:2 Name:copyChunk Params:[{Name:chunk Type:[]Comparators}] Results:[{Name: Type:[]Comparators}] Receiver:<nil> Body:{
	cp := make([]Comparators, len(chunk))
	copy(cp, chunk)
	return cp
} PrettyPrintBody:[{ cp := make([]Comparators, len(chunk)) copy(cp, chunk) return cp }]}
{Id:3 FileId:135 StartLine:23 StartColumn:1 EndLine:64 EndColumn:2 Name:MultithreadedSortComparators Params:[{Name:comparators Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	toBeSorted := make(Comparators, len(comparators))
	copy(toBeSorted, comparators)

	var wg sync.WaitGroup

	numCPU := int64(runtime.NumCPU())
	if numCPU%2 == 1 {
		numCPU++
	}

	chunks := chunk(toBeSorted, numCPU)
	wg.Add(len(chunks))
	for i := 0; i < len(chunks); i++ {
		go func(i int) {
			sortBucket(chunks[i])
			wg.Done()
		}(i)
	}

	wg.Wait()
	todo := make([]Comparators, len(chunks)/2)
	for {
		todo = todo[:len(chunks)/2]
		wg.Add(len(chunks) / 2)
		for i := 0; i < len(chunks); i += 2 {
			go func(i int) {
				todo[i/2] = SymMerge(chunks[i], chunks[i+1])
				wg.Done()
			}(i)
		}

		wg.Wait()

		chunks = copyChunk(todo)
		if len(chunks) == 1 {
			break
		}
	}

	return chunks[0]
} PrettyPrintBody:[{ toBeSorted := make(Comparators, len(comparators)) copy(toBeSorted, comparators) var wg sync.WaitGroup numCPU := int64(runtime.NumCPU()) if numCPU%2 == 1 { numCPU++ } chunks := chunk(toBeSorted, numCPU) wg.Add(len(chunks)) for i := 0; i < len(chunks); i++ { go func(i int) { sortBucket(chunks[i]) wg.Done() }(i) } wg.Wait() todo := make([]Comparators, len(chunks)/2) for { todo = todo[:len(chunks)/2] wg.Add(len(chunks) / 2) for i := 0; i < len(chunks); i += 2 { go func(i int) { todo[i/2] = SymMerge(chunks[i], chunks[i+1]) wg.Done() }(i) } wg.Wait() chunks = copyChunk(todo) if len(chunks) == 1 { break } } return chunks[0] }]}
{Id:4 FileId:135 StartLine:66 StartColumn:1 EndLine:72 EndColumn:2 Name:chunk Params:[{Name:comparators Type:Comparators} {Name:numParts Type:int64}] Results:[{Name: Type:[]Comparators}] Receiver:<nil> Body:{
	parts := make([]Comparators, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = comparators[i*int64(len(comparators))/numParts : (i+1)*int64(len(comparators))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Comparators, numParts) for i := int64(0); i < numParts; i++ { parts[i] = comparators[i*int64(len(comparators))/numParts : (i+1)*int64(len(comparators))/numParts] } return parts }]}
{Id:3 FileId:85 StartLine:32 StartColumn:1 EndLine:38 EndColumn:2 Name:Put Params:[{Name:items Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc00095aa40 Body:{
	args := m.Called(items)
	if m.PutChan != nil {
		m.PutChan <- true
	}
	return args.Error(0)
} PrettyPrintBody:[{ args := m.Called(items) if m.PutChan != nil { m.PutChan <- true } return args.Error(0) }]}
{Id:4 FileId:85 StartLine:40 StartColumn:1 EndLine:43 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc001580920 Body:{
	args := m.Called()
	return args.Get(0).([]interface{}), args.Error(1)
} PrettyPrintBody:[{ args := m.Called() return args.Get(0).([]interface{}), args.Error(1) }]}
{Id:5 FileId:85 StartLine:45 StartColumn:1 EndLine:48 EndColumn:2 Name:Flush Params:[] Results:[{Name: Type:error}] Receiver:0xc001238080 Body:{
	args := m.Called()
	return args.Error(0)
} PrettyPrintBody:[{ args := m.Called() return args.Error(0) }]}
{Id:6 FileId:85 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc000e5b200 Body:{
	m.Called()
} PrettyPrintBody:[{ m.Called() }]}
{Id:7 FileId:85 StartLine:54 StartColumn:1 EndLine:57 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc001032fe0 Body:{
	args := m.Called()
	return args.Bool(0)
} PrettyPrintBody:[{ args := m.Called() return args.Bool(0) }]}
{Id:1 FileId:112 StartLine:23 StartColumn:1 EndLine:25 EndColumn:2 Name:ValueAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000b76a00 Body:{
	return me.values[dimension]
} PrettyPrintBody:[{ return me.values[dimension] }]}
{Id:2 FileId:112 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:newMockEntry Params:[{Name:values Type:...int64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{values: values}
} PrettyPrintBody:[{ return &mockEntry{values: values} }]}
{Id:4 FileId:112 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc001291040 Body:{
	return mi.lows[dimension]
} PrettyPrintBody:[{ return mi.lows[dimension] }]}
{Id:5 FileId:112 StartLine:39 StartColumn:1 EndLine:41 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc001291620 Body:{
	return mi.highs[dimension]
} PrettyPrintBody:[{ return mi.highs[dimension] }]}
{Id:6 FileId:112 StartLine:43 StartColumn:1 EndLine:48 EndColumn:2 Name:newMockInterval Params:[{Name:lows Type:[]int64}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{
		lows:	lows,
		highs:	highs,
	}
} PrettyPrintBody:[{ return &mockInterval{ lows:	lows, highs:	highs, } }]}
{Id:1 FileId:39 StartLine:37 StartColumn:1 EndLine:43 EndColumn:2 Name:DefaultConfig Params:[{Name:persister Type:Persister} {Name:comparator Type:Comparator}] Results:[{Name: Type:Config}] Receiver:<nil> Body:{
	return Config{
		NodeWidth:	10000,
		Persister:	persister,
		Comparator:	comparator,
	}
} PrettyPrintBody:[{ return Config{ NodeWidth:	10000, Persister:	persister, Comparator:	comparator, } }]}
{Id:2 FileId:125 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc000fa7e40 Body:{
	return len(s)
} PrettyPrintBody:[{ return len(s) }]}
{Id:3 FileId:125 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000f52980 Body:{
	return s[i] < s[j]
} PrettyPrintBody:[{ return s[i] < s[j] }]}
{Id:4 FileId:125 StartLine:45 StartColumn:1 EndLine:49 EndColumn:2 Name:Search Params:[{Name:x Type:int64}] Results:[{Name: Type:int}] Receiver:0xc000dde000 Body:{
	return sort.Search(len(s), func(i int) bool {
		return s[i] >= x
	})
} PrettyPrintBody:[{ return sort.Search(len(s), func(i int) bool { return s[i] >= x }) }]}
{Id:5 FileId:125 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:Sort Params:[] Results:[] Receiver:0xc001309000 Body:{
	sort.Sort(s)
} PrettyPrintBody:[{ sort.Sort(s) }]}
{Id:6 FileId:125 StartLine:58 StartColumn:1 EndLine:60 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0010bc7c0 Body:{
	s[i], s[j] = s[j], s[i]
} PrettyPrintBody:[{ s[i], s[j] = s[j], s[i] }]}
{Id:7 FileId:125 StartLine:65 StartColumn:1 EndLine:72 EndColumn:2 Name:Exists Params:[{Name:x Type:int64}] Results:[{Name: Type:bool}] Receiver:0xc000e617e0 Body:{
	i := s.Search(x)
	if i == len(s) {
		return false
	}

	return s[i] == x
} PrettyPrintBody:[{ i := s.Search(x) if i == len(s) { return false } return s[i] == x }]}
{Id:8 FileId:125 StartLine:77 StartColumn:1 EndLine:91 EndColumn:2 Name:Insert Params:[{Name:x Type:int64}] Results:[{Name: Type:Int64Slice}] Receiver:0xc001309280 Body:{
	i := s.Search(x)
	if i == len(s) {
		return append(s, x)
	}

	if s[i] == x {
		return s
	}

	s = append(s, 0)
	copy(s[i+1:], s[i:])
	s[i] = x
	return s
} PrettyPrintBody:[{ i := s.Search(x) if i == len(s) { return append(s, x) } if s[i] == x { return s } s = append(s, 0) copy(s[i+1:], s[i:]) s[i] = x return s }]}
{Id:5 FileId:71 StartLine:14 StartColumn:1 EndLine:73 EndColumn:2 Name:Example Params:[] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	fmt.Println("Created heap 1.")
	nodeh1_1 := heap1.Enqueue(SomeLargerNumberAround15)
	fmt.Printf("Heap 1 insert: %v\n", nodeh1_1.Priority)

	heap2 := NewFloatFibHeap()
	fmt.Println("Created heap 2.")
	fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty())
	nodeh2_1 := heap2.Enqueue(SomeNumberAroundMinus1000)
	fmt.Printf("Heap 2 insert: %v\n", nodeh2_1.Priority)
	nodeh2_2 := heap2.Enqueue(SomeNumberAround0)
	fmt.Printf("Heap 2 insert: %v\n", nodeh2_2.Priority)
	fmt.Printf("Heap 1 size: %v\n", heap1.Size())
	fmt.Printf("Heap 2 size: %v\n", heap2.Size())
	fmt.Printf("Heap 1 is empty? %v\n", heap1.IsEmpty())
	fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty())

	fmt.Printf("\nMerge Heap 1 and Heap 2.\n")
	mergedHeap, _ := heap1.Merge(&heap2)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())
	fmt.Printf("Set node with priority %v to new priority %v\n", SomeNumberAroundMinus1000, SomeNumberAroundMinus1003)

	mergedHeap.DecreaseKey(nodeh2_1, SomeNumberAroundMinus1003)
	min, _ := mergedHeap.DequeueMin()
	fmt.Printf("Dequeue minimum of merged heap: %v\n", min.Priority)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())

	fmt.Printf("Delete from merged heap: %v\n", SomeNumberAround0)
	mergedHeap.Delete(nodeh2_2)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())

	min, _ = mergedHeap.DequeueMin()
	fmt.Printf("Extracting minimum of merged heap: %v\n", min.Priority)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())
	fmt.Printf("Merged heap is empty? %v\n", mergedHeap.IsEmpty())

} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() fmt.Println("Created heap 1.") nodeh1_1 := heap1.Enqueue(SomeLargerNumberAround15) fmt.Printf("Heap 1 insert: %v\n", nodeh1_1.Priority) heap2 := NewFloatFibHeap() fmt.Println("Created heap 2.") fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty()) nodeh2_1 := heap2.Enqueue(SomeNumberAroundMinus1000) fmt.Printf("Heap 2 insert: %v\n", nodeh2_1.Priority) nodeh2_2 := heap2.Enqueue(SomeNumberAround0) fmt.Printf("Heap 2 insert: %v\n", nodeh2_2.Priority) fmt.Printf("Heap 1 size: %v\n", heap1.Size()) fmt.Printf("Heap 2 size: %v\n", heap2.Size()) fmt.Printf("Heap 1 is empty? %v\n", heap1.IsEmpty()) fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty()) fmt.Printf("\nMerge Heap 1 and Heap 2.\n") mergedHeap, _ := heap1.Merge(&heap2) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Set node with priority %v to new priority %v\n", SomeNumberAroundMinus1000, SomeNumberAroundMinus1003) mergedHeap.DecreaseKey(nodeh2_1, SomeNumberAroundMinus1003) min, _ := mergedHeap.DequeueMin() fmt.Printf("Dequeue minimum of merged heap: %v\n", min.Priority) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Delete from merged heap: %v\n", SomeNumberAround0) mergedHeap.Delete(nodeh2_2) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) min, _ = mergedHeap.DequeueMin() fmt.Printf("Extracting minimum of merged heap: %v\n", min.Priority) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Merged heap is empty? %v\n", mergedHeap.IsEmpty()) }]}
{Id:1 FileId:151 StartLine:34 StartColumn:1 EndLine:36 EndColumn:2 Name:mask Params:[{Name:hash Type:uint32} {Name:level Type:uint8}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	return (hash >> (5 * level)) & 0x01f
} PrettyPrintBody:[{ return (hash >> (5 * level)) & 0x01f }]}
{Id:2 FileId:151 StartLine:38 StartColumn:1 EndLine:70 EndColumn:2 Name:defaultHasher Params:[{Name:value Type:interface{}}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	switch v := value.(type) {
	case uint8:
		return uint32(v)
	case uint16:
		return uint32(v)
	case uint32:
		return v
	case uint64:
		return uint32(v)
	case int8:
		return uint32(v)
	case int16:
		return uint32(v)
	case int32:
		return uint32(v)
	case int64:
		return uint32(v)
	case uint:
		return uint32(v)
	case int:
		return uint32(v)
	case uintptr:
		return uint32(v)
	case float32:
		return uint32(v)
	case float64:
		return uint32(v)
	}
	hasher := fnv.New32a()
	hasher.Write([]byte(fmt.Sprintf("%#v", value)))
	return hasher.Sum32()
} PrettyPrintBody:[{ switch v := value.(type) { case uint8: return uint32(v) case uint16: return uint32(v) case uint32: return v case uint64: return uint32(v) case int8: return uint32(v) case int16: return uint32(v) case int32: return uint32(v) case int64: return uint32(v) case uint: return uint32(v) case int: return uint32(v) case uintptr: return uint32(v) case float32: return uint32(v) case float64: return uint32(v) } hasher := fnv.New32a() hasher.Write([]byte(fmt.Sprintf("%#v", value))) return hasher.Sum32() }]}
{Id:2 FileId:130 StartLine:27 StartColumn:1 EndLine:38 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000dceb00 Body:{
	otherU := other.(mockEntry)
	if me == otherU {
		return 0
	}

	if me > otherU {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherU := other.(mockEntry) if me == otherU { return 0 } if me > otherU { return 1 } return -1 }]}
{Id:3 FileId:130 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:mockEntry}] Receiver:<nil> Body:{
	return mockEntry(key)
} PrettyPrintBody:[{ return mockEntry(key) }]}
{Id:5 FileId:130 StartLine:48 StartColumn:1 EndLine:51 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001238600 Body:{
	args := mi.Called()
	return args.Bool(0)
} PrettyPrintBody:[{ args := mi.Called() return args.Bool(0) }]}
{Id:6 FileId:130 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc0012388c0 Body:{
	args := mi.Called()
	result, ok := args.Get(0).(common.Comparator)
	if !ok {
		return nil
	}

	return result
} PrettyPrintBody:[{ args := mi.Called() result, ok := args.Get(0).(common.Comparator) if !ok { return nil } return result }]}
{Id:7 FileId:130 StartLine:63 StartColumn:1 EndLine:65 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001409580 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:2 FileId:61 StartLine:26 StartColumn:1 EndLine:42 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095ab40 Body:{
	if iter.index == iteratorExhausted {
		return false
	}

	iter.index++
	if iter.index >= len(iter.node.keys) {
		iter.node = iter.node.pointer
		if iter.node == nil {
			iter.index = iteratorExhausted
			return false
		}
		iter.index = 0
	}

	return true
} PrettyPrintBody:[{ if iter.index == iteratorExhausted { return false } iter.index++ if iter.index >= len(iter.node.keys) { iter.node = iter.node.pointer if iter.node == nil { iter.index = iteratorExhausted return false } iter.index = 0 } return true }]}
{Id:3 FileId:61 StartLine:44 StartColumn:1 EndLine:52 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Key}] Receiver:0xc001032dc0 Body:{
	if iter.index == iteratorExhausted ||
		iter.index < 0 || iter.index >= len(iter.node.keys) {

		return nil
	}

	return iter.node.keys[iter.index]
} PrettyPrintBody:[{ if iter.index == iteratorExhausted || iter.index < 0 || iter.index >= len(iter.node.keys) { return nil } return iter.node.keys[iter.index] }]}
{Id:4 FileId:61 StartLine:55 StartColumn:1 EndLine:62 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:keys}] Receiver:0xc000e7eea0 Body:{
	keys := make(keys, 0, 10)
	for iter := iter; iter.Next(); {
		keys = append(keys, iter.Value())
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, 10) for iter := iter; iter.Next(); { keys = append(keys, iter.Value()) } return keys }]}
{Id:5 FileId:61 StartLine:64 StartColumn:1 EndLine:68 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*iterator}] Receiver:<nil> Body:{
	return &iterator{
		index: iteratorExhausted,
	}
} PrettyPrintBody:[{ return &iterator{ index: iteratorExhausted, } }]}
{Id:2 FileId:46 StartLine:39 StartColumn:1 EndLine:48 EndColumn:2 Name:append Params:[{Name:pb Type:*pathBundle}] Results:[] Receiver:0xc001602020 Body:{
	if p.head == nil {
		p.head = pb
		p.tail = pb
		return
	}

	pb.prev = p.tail
	p.tail = pb
} PrettyPrintBody:[{ if p.head == nil { p.head = pb p.tail = pb return } pb.prev = p.tail p.tail = pb }]}
{Id:3 FileId:46 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:*pathBundle}] Receiver:0xc000e7e140 Body:{
	if pb := p.tail; pb != nil {
		p.tail = pb.prev
		pb.prev = nil
		return pb
	}

	return nil
} PrettyPrintBody:[{ if pb := p.tail; pb != nil { p.tail = pb.prev pb.prev = nil return pb } return nil }]}
{Id:4 FileId:46 StartLine:63 StartColumn:1 EndLine:65 EndColumn:2 Name:peek Params:[] Results:[{Name: Type:*pathBundle}] Receiver:0xc0012469c0 Body:{
	return p.tail
} PrettyPrintBody:[{ return p.tail }]}
{Id:1 FileId:117 StartLine:23 StartColumn:1 EndLine:25 EndColumn:2 Name:LowerLeft Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc001000700 Body:{
	return mr.xlow, mr.ylow
} PrettyPrintBody:[{ return mr.xlow, mr.ylow }]}
{Id:2 FileId:117 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:UpperRight Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc00095ac00 Body:{
	return mr.xhigh, mr.yhigh
} PrettyPrintBody:[{ return mr.xhigh, mr.yhigh }]}
{Id:3 FileId:117 StartLine:31 StartColumn:1 EndLine:38 EndColumn:2 Name:newMockRectangle Params:[{Name:xlow Type:int32}] Results:[{Name: Type:*mockRectangle}] Receiver:<nil> Body:{
	return &mockRectangle{
		xlow:	xlow,
		ylow:	ylow,
		xhigh:	xhigh,
		yhigh:	yhigh,
	}
} PrettyPrintBody:[{ return &mockRectangle{ xlow:	xlow, ylow:	ylow, xhigh:	xhigh, yhigh:	yhigh, } }]}
{Id:1 FileId:17 StartLine:25 StartColumn:1 EndLine:36 EndColumn:2 Name:TestBlockToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := block(0)

	b = b.insert(s - 2)
	b = b.insert(s - 6)

	expected := []uint64{s - 6, s - 2}

	result := make([]uint64, 0, 0)
	b.toNums(0, &result)
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ b := block(0) b = b.insert(s - 2) b = b.insert(s - 6) expected := []uint64{s - 6, s - 2} result := make([]uint64, 0, 0) b.toNums(0, &result) assert.Equal(t, expected, result) }]}
{Id:2 FileId:17 StartLine:38 StartColumn:1 EndLine:50 EndColumn:2 Name:BenchmarkBlockToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	block := block(0)
	for i := uint64(0); i < s; i++ {
		block = block.insert(i)
	}

	nums := make([]uint64, 0, 0)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		block.toNums(0, &nums)
	}
} PrettyPrintBody:[{ block := block(0) for i := uint64(0); i < s; i++ { block = block.insert(i) } nums := make([]uint64, 0, 0) b.ResetTimer() for i := 0; i < b.N; i++ { block.toNums(0, &nums) } }]}
{Id:0 FileId:23 StartLine:19 StartColumn:1 EndLine:84 EndColumn:2 Name:nandSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	max := len(sba.indices)
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	var resultBlock block

	for {
		if selfIndex == len(sba.indices) {

			break
		} else if otherIndex == len(other.indices) {

			indices = append(indices, sba.indices[selfIndex])
			blocks = append(blocks, sba.blocks[selfIndex])
			selfIndex++
			continue
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch {
		case otherValue < selfValue:

			otherIndex++

		case otherValue > selfValue:

			indices = append(indices, selfValue)
			blocks = append(blocks, sba.blocks[selfIndex])

			selfIndex++

		default:

			resultBlock = sba.blocks[selfIndex].nand(other.blocks[otherIndex])
			if resultBlock > 0 {
				indices = append(indices, selfValue)
				blocks = append(blocks, resultBlock)
			}
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ max := len(sba.indices) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 var resultBlock block for { if selfIndex == len(sba.indices) { break } else if otherIndex == len(other.indices) { indices = append(indices, sba.indices[selfIndex]) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ continue } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch { case otherValue < selfValue: otherIndex++ case otherValue > selfValue: indices = append(indices, selfValue) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ default: resultBlock = sba.blocks[selfIndex].nand(other.blocks[otherIndex]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]}
{Id:1 FileId:23 StartLine:86 StartColumn:1 EndLine:116 EndColumn:2 Name:nandSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	indices := make(uintSlice, 0, len(sba.indices))
	blocks := make(blocks, 0, len(sba.indices))

	var resultBlock block

	for selfIndex, selfValue := range sba.indices {
		if selfValue >= uint64(len(other.blocks)) {

			resultBlock = sba.blocks[selfIndex]
			indices = append(indices, selfValue)
			blocks = append(blocks, resultBlock)
			continue
		}

		resultBlock = sba.blocks[selfIndex].nand(other.blocks[selfValue])
		if resultBlock > 0 {
			indices = append(indices, selfValue)
			blocks = append(blocks, resultBlock)
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ indices := make(uintSlice, 0, len(sba.indices)) blocks := make(blocks, 0, len(sba.indices)) var resultBlock block for selfIndex, selfValue := range sba.indices { if selfValue >= uint64(len(other.blocks)) { resultBlock = sba.blocks[selfIndex] indices = append(indices, selfValue) blocks = append(blocks, resultBlock) continue } resultBlock = sba.blocks[selfIndex].nand(other.blocks[selfValue]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]}
{Id:2 FileId:23 StartLine:118 StartColumn:1 EndLine:137 EndColumn:2 Name:nandDenseWithSparseBitArray Params:[{Name:sba Type:*bitArray} {Name:other Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	tmp := sba.copy()
	ret := tmp.(*bitArray)

	for otherIndex, otherValue := range other.indices {
		if otherValue >= uint64(len(ret.blocks)) {
			break
		}

		ret.blocks[otherValue] = sba.blocks[otherValue].nand(other.blocks[otherIndex])
	}

	ret.setLowest()
	ret.setHighest()

	return ret
} PrettyPrintBody:[{ tmp := sba.copy() ret := tmp.(*bitArray) for otherIndex, otherValue := range other.indices { if otherValue >= uint64(len(ret.blocks)) { break } ret.blocks[otherValue] = sba.blocks[otherValue].nand(other.blocks[otherIndex]) } ret.setLowest() ret.setHighest() return ret }]}
{Id:3 FileId:23 StartLine:139 StartColumn:1 EndLine:152 EndColumn:2 Name:nandDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	min := uint64(len(dba.blocks))

	ba := newBitArray(min * s)

	for i := uint64(0); i < min; i++ {
		ba.blocks[i] = dba.blocks[i].nand(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ min := uint64(len(dba.blocks)) ba := newBitArray(min * s) for i := uint64(0); i < min; i++ { ba.blocks[i] = dba.blocks[i].nand(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]}
{Id:2 FileId:148 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc0009f9f60 Body:{
	return e.hash
} PrettyPrintBody:[{ return e.hash }]}
{Id:3 FileId:148 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0009f9fa0 Body:{
	return e.key
} PrettyPrintBody:[{ return e.key }]}
{Id:4 FileId:148 StartLine:56 StartColumn:1 EndLine:58 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000fbd4e0 Body:{
	return e.value
} PrettyPrintBody:[{ return e.value }]}
{Id:5 FileId:148 StartLine:62 StartColumn:1 EndLine:70 EndColumn:2 Name:New Params:[{Name:hasher Type:func(v interface{}) uint32}] Results:[{Name: Type:*Dtrie}] Receiver:<nil> Body:{
	if hasher == nil {
		hasher = defaultHasher
	}
	return &Dtrie{
		root:	emptyNode(0, 32),
		hasher:	hasher,
	}
} PrettyPrintBody:[{ if hasher == nil { hasher = defaultHasher } return &Dtrie{ root:	emptyNode(0, 32), hasher:	hasher, } }]}
{Id:6 FileId:148 StartLine:73 StartColumn:1 EndLine:78 EndColumn:2 Name:Size Params:[] Results:[{Name:size Type:int}] Receiver:0xc001580a40 Body:{
	for _ = range iterate(d.root, nil) {
		size++
	}
	return size
} PrettyPrintBody:[{ for _ = range iterate(d.root, nil) { size++ } return size }]}
{Id:7 FileId:148 StartLine:82 StartColumn:1 EndLine:88 EndColumn:2 Name:Get Params:[{Name:key Type:interface{}}] Results:[{Name: Type:interface{}}] Receiver:0xc001409680 Body:{
	node := get(d.root, d.hasher(key), key)
	if node != nil {
		return node.Value()
	}
	return nil
} PrettyPrintBody:[{ node := get(d.root, d.hasher(key), key) if node != nil { return node.Value() } return nil }]}
{Id:8 FileId:148 StartLine:92 StartColumn:1 EndLine:95 EndColumn:2 Name:Insert Params:[{Name:key Type:interface{}}] Results:[{Name: Type:*Dtrie}] Receiver:0xc0010335a0 Body:{
	root := insert(d.root, &entry{d.hasher(key), key, value})
	return &Dtrie{root, d.hasher}
} PrettyPrintBody:[{ root := insert(d.root, &entry{d.hasher(key), key, value}) return &Dtrie{root, d.hasher} }]}
{Id:9 FileId:148 StartLine:99 StartColumn:1 EndLine:102 EndColumn:2 Name:Remove Params:[{Name:key Type:interface{}}] Results:[{Name: Type:*Dtrie}] Receiver:0xc0014096e0 Body:{
	root := remove(d.root, d.hasher(key), key)
	return &Dtrie{root, d.hasher}
} PrettyPrintBody:[{ root := remove(d.root, d.hasher(key), key) return &Dtrie{root, d.hasher} }]}
{Id:10 FileId:148 StartLine:108 StartColumn:1 EndLine:110 EndColumn:2 Name:Iterator Params:[{Name:stop Type:<-chan struct{}}] Results:[{Name: Type:<-chan Entry}] Receiver:0xc00095a160 Body:{
	return iterate(d.root, stop)
} PrettyPrintBody:[{ return iterate(d.root, stop) }]}
{Id:2 FileId:119 StartLine:25 StartColumn:1 EndLine:42 EndColumn:2 Name:adjust Params:[{Name:rect Type:rtree.Rectangle}] Results:[] Receiver:0xc001098260 Body:{
	x, y := rect.LowerLeft()
	if x < r.xlow {
		r.xlow = x
	}
	if y < r.ylow {
		r.ylow = y
	}

	x, y = rect.UpperRight()
	if x > r.xhigh {
		r.xhigh = x
	}

	if y > r.yhigh {
		r.yhigh = y
	}
} PrettyPrintBody:[{ x, y := rect.LowerLeft() if x < r.xlow { r.xlow = x } if y < r.ylow { r.ylow = y } x, y = rect.UpperRight() if x > r.xhigh { r.xhigh = x } if y > r.yhigh { r.yhigh = y } }]}
{Id:3 FileId:119 StartLine:44 StartColumn:1 EndLine:52 EndColumn:2 Name:equal Params:[{Name:r1 Type:rtree.Rectangle}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	xlow1, ylow1 := r1.LowerLeft()
	xhigh2, yhigh2 := r2.UpperRight()

	xhigh1, yhigh1 := r1.UpperRight()
	xlow2, ylow2 := r2.LowerLeft()

	return xlow1 == xlow2 && xhigh1 == xhigh2 && ylow1 == ylow2 && yhigh1 == yhigh2
} PrettyPrintBody:[{ xlow1, ylow1 := r1.LowerLeft() xhigh2, yhigh2 := r2.UpperRight() xhigh1, yhigh1 := r1.UpperRight() xlow2, ylow2 := r2.LowerLeft() return xlow1 == xlow2 && xhigh1 == xhigh2 && ylow1 == ylow2 && yhigh1 == yhigh2 }]}
{Id:4 FileId:119 StartLine:54 StartColumn:1 EndLine:59 EndColumn:2 Name:intersect Params:[{Name:rect1 Type:*rectangle} {Name:rect2 Type:rtree.Rectangle}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	xhigh2, yhigh2 := rect2.UpperRight()
	xlow2, ylow2 := rect2.LowerLeft()

	return xhigh2 >= rect1.xlow && xlow2 <= rect1.xhigh && yhigh2 >= rect1.ylow && ylow2 <= rect1.yhigh
} PrettyPrintBody:[{ xhigh2, yhigh2 := rect2.UpperRight() xlow2, ylow2 := rect2.LowerLeft() return xhigh2 >= rect1.xlow && xlow2 <= rect1.xhigh && yhigh2 >= rect1.ylow && ylow2 <= rect1.yhigh }]}
{Id:5 FileId:119 StartLine:61 StartColumn:1 EndLine:72 EndColumn:2 Name:newRectangeFromRect Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:*rectangle}] Receiver:<nil> Body:{
	r := &rectangle{}
	x, y := rect.LowerLeft()
	r.xlow = x
	r.ylow = y

	x, y = rect.UpperRight()
	r.xhigh = x
	r.yhigh = y

	return r
} PrettyPrintBody:[{ r := &rectangle{} x, y := rect.LowerLeft() r.xlow = x r.ylow = y x, y = rect.UpperRight() r.xhigh = x r.yhigh = y return r }]}
{Id:6 FileId:119 StartLine:74 StartColumn:1 EndLine:93 EndColumn:2 Name:newRectangleFromRects Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*rectangle}] Receiver:<nil> Body:{
	if len(rects) == 0 {
		panic(`Cannot construct rectangle with no dimensions.`)
	}

	xlow, ylow := rects[0].LowerLeft()
	xhigh, yhigh := rects[0].UpperRight()
	r := &rectangle{
		xlow:	xlow,
		xhigh:	xhigh,
		ylow:	ylow,
		yhigh:	yhigh,
	}

	for i := 1; i < len(rects); i++ {
		r.adjust(rects[i])
	}

	return r
} PrettyPrintBody:[{ if len(rects) == 0 { panic(`Cannot construct rectangle with no dimensions.`) } xlow, ylow := rects[0].LowerLeft() xhigh, yhigh := rects[0].UpperRight() r := &rectangle{ xlow:	xlow, xhigh:	xhigh, ylow:	ylow, yhigh:	yhigh, } for i := 1; i < len(rects); i++ { r.adjust(rects[i]) } return r }]}
{Id:1 FileId:80 StartLine:13 StartColumn:1 EndLine:18 EndColumn:2 Name:TestHash Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	key := uint64(5)
	h := hash(key)

	assert.NotEqual(t, key, h)
} PrettyPrintBody:[{ key := uint64(5) h := hash(key) assert.NotEqual(t, key, h) }]}
{Id:2 FileId:80 StartLine:20 StartColumn:1 EndLine:36 EndColumn:2 Name:BenchmarkHash Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, numItems)
	for i := 0; i < numItems; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hash(key)
		}
	}
} PrettyPrintBody:[{ numItems := 1000 r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, numItems) for i := 0; i < numItems; i++ { key := uint64(r.Int63()) keys = append(keys, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hash(key) } } }]}
{Id:3 FileId:80 StartLine:38 StartColumn:1 EndLine:56 EndColumn:2 Name:BenchmarkFnvHash Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, numItems)
	for i := 0; i < numItems; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hasher := fnv.New64()
			binary.Write(hasher, binary.LittleEndian, key)
			hasher.Sum64()
		}
	}
} PrettyPrintBody:[{ numItems := 1000 r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, numItems) for i := 0; i < numItems; i++ { key := uint64(r.Int63()) keys = append(keys, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hasher := fnv.New64() binary.Write(hasher, binary.LittleEndian, key) hasher.Sum64() } } }]}
{Id:0 FileId:58 StartLine:36 StartColumn:1 EndLine:51 EndColumn:2 Name:keySearch Params:[{Name:keys Type:keys} {Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	low, high := 0, len(keys)-1
	var mid int
	for low <= high {
		mid = (high + low) / 2
		switch keys[mid].Compare(key) {
		case 1:
			low = mid + 1
		case -1:
			high = mid - 1
		case 0:
			return mid
		}
	}
	return low
} PrettyPrintBody:[{ low, high := 0, len(keys)-1 var mid int for low <= high { mid = (high + low) / 2 switch keys[mid].Compare(key) { case 1: low = mid + 1 case -1: high = mid - 1 case 0: return mid } } return low }]}
{Id:2 FileId:58 StartLine:58 StartColumn:1 EndLine:74 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[] Receiver:0xc0016022c0 Body:{
	if tree.root == nil {
		n := newLeafNode(tree.nodeSize)
		n.insert(tree, key)
		tree.number = 1
		return
	}

	result := tree.root.insert(tree, key)
	if result {
		tree.number++
	}

	if tree.root.needsSplit(tree.nodeSize) {
		tree.root = split(tree, nil, tree.root)
	}
} PrettyPrintBody:[{ if tree.root == nil { n := newLeafNode(tree.nodeSize) n.insert(tree, key) tree.number = 1 return } result := tree.root.insert(tree, key) if result { tree.number++ } if tree.root.needsSplit(tree.nodeSize) { tree.root = split(tree, nil, tree.root) } }]}
{Id:3 FileId:58 StartLine:79 StartColumn:1 EndLine:83 EndColumn:2 Name:Insert Params:[{Name:keys Type:...Key}] Results:[] Receiver:0xc001240b80 Body:{
	for _, key := range keys {
		tree.insert(key)
	}
} PrettyPrintBody:[{ for _, key := range keys { tree.insert(key) } }]}
{Id:4 FileId:58 StartLine:87 StartColumn:1 EndLine:93 EndColumn:2 Name:Iter Params:[{Name:key Type:Key}] Results:[{Name: Type:Iterator}] Receiver:0xc001240fe0 Body:{
	if tree.root == nil {
		return nilIterator()
	}

	return tree.root.find(key)
} PrettyPrintBody:[{ if tree.root == nil { return nilIterator() } return tree.root.find(key) }]}
{Id:5 FileId:58 StartLine:95 StartColumn:1 EndLine:106 EndColumn:2 Name:get Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc0013091c0 Body:{
	iter := tree.root.find(key)
	if !iter.Next() {
		return nil
	}

	if iter.Value().Compare(key) == 0 {
		return iter.Value()
	}

	return nil
} PrettyPrintBody:[{ iter := tree.root.find(key) if !iter.Next() { return nil } if iter.Value().Compare(key) == 0 { return iter.Value() } return nil }]}
{Id:6 FileId:58 StartLine:111 StartColumn:1 EndLine:118 EndColumn:2 Name:Get Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc001033280 Body:{
	results := make(Keys, 0, len(keys))
	for _, k := range keys {
		results = append(results, tree.get(k))
	}

	return results
} PrettyPrintBody:[{ results := make(Keys, 0, len(keys)) for _, k := range keys { results = append(results, tree.get(k)) } return results }]}
{Id:7 FileId:58 StartLine:121 StartColumn:1 EndLine:123 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409800 Body:{
	return tree.number
} PrettyPrintBody:[{ return tree.number }]}
{Id:8 FileId:58 StartLine:125 StartColumn:1 EndLine:130 EndColumn:2 Name:newBTree Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:*btree}] Receiver:<nil> Body:{
	return &btree{
		nodeSize:	nodeSize,
		root:		newLeafNode(nodeSize),
	}
} PrettyPrintBody:[{ return &btree{ nodeSize:	nodeSize, root:		newLeafNode(nodeSize), } }]}
{Id:1 FileId:87 StartLine:39 StartColumn:1 EndLine:45 EndColumn:2 Name:boolToInt Params:[{Name:value Type:bool}] Results:[{Name: Type:int32}] Receiver:<nil> Body:{
	if value {
		return int32(1)
	}

	return int32(0)
} PrettyPrintBody:[{ if value { return int32(1) } return int32(0) }]}
{Id:2 FileId:87 StartLine:47 StartColumn:1 EndLine:58 EndColumn:2 Name:rotate Params:[{Name:n Type:int32} {Name:x Type:*int32}] Results:[] Receiver:<nil> Body:{
	if ry == 0 {
		if rx == 1 {
			*x = n - 1 - *x
			*y = n - 1 - *y
		}

		t := *x
		*x = *y
		*y = t
	}
} PrettyPrintBody:[{ if ry == 0 { if rx == 1 { *x = n - 1 - *x *y = n - 1 - *y } t := *x *x = *y *y = t } }]}
{Id:3 FileId:87 StartLine:62 StartColumn:1 EndLine:73 EndColumn:2 Name:Encode Params:[{Name:x Type:int32}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	var rx, ry int32
	var d int64
	for s := int32(n / 2); s > 0; s /= 2 {
		rx = boolToInt(x&s > 0)
		ry = boolToInt(y&s > 0)
		d += int64(int64(s) * int64(s) * int64(((3 * rx) ^ ry)))
		rotate(s, rx, ry, &x, &y)
	}

	return d
} PrettyPrintBody:[{ var rx, ry int32 var d int64 for s := int32(n / 2); s > 0; s /= 2 { rx = boolToInt(x&s > 0) ry = boolToInt(y&s > 0) d += int64(int64(s) * int64(s) * int64(((3 * rx) ^ ry))) rotate(s, rx, ry, &x, &y) } return d }]}
{Id:4 FileId:87 StartLine:77 StartColumn:1 EndLine:92 EndColumn:2 Name:Decode Params:[{Name:h Type:int64}] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:<nil> Body:{
	var ry, rx int64
	var x, y int32
	t := h

	for s := int64(1); s < int64(n); s *= 2 {
		rx = 1 & (t / 2)
		ry = 1 & (t ^ rx)
		rotate(int32(s), int32(rx), int32(ry), &x, &y)
		x += int32(s * rx)
		y += int32(s * ry)
		t /= 4
	}

	return x, y
} PrettyPrintBody:[{ var ry, rx int64 var x, y int32 t := h for s := int64(1); s < int64(n); s *= 2 { rx = 1 & (t / 2) ry = 1 & (t ^ rx) rotate(int32(s), int32(rx), int32(ry), &x, &y) x += int32(s * rx) y += int32(s * ry) t /= 4 } return x, y }]}
{Id:3 FileId:73 StartLine:52 StartColumn:1 EndLine:62 EndColumn:2 Name:GetResult Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001032400 Body:{
	f.lock.Lock()
	if f.triggered {
		f.lock.Unlock()
		return f.item, f.err
	}
	f.lock.Unlock()

	f.wg.Wait()
	return f.item, f.err
} PrettyPrintBody:[{ f.lock.Lock() if f.triggered { f.lock.Unlock() return f.item, f.err } f.lock.Unlock() f.wg.Wait() return f.item, f.err }]}
{Id:4 FileId:73 StartLine:65 StartColumn:1 EndLine:70 EndColumn:2 Name:HasResult Params:[] Results:[{Name: Type:bool}] Receiver:0xc0010019c0 Body:{
	f.lock.Lock()
	hasResult := f.triggered
	f.lock.Unlock()
	return hasResult
} PrettyPrintBody:[{ f.lock.Lock() hasResult := f.triggered f.lock.Unlock() return hasResult }]}
{Id:5 FileId:73 StartLine:72 StartColumn:1 EndLine:79 EndColumn:2 Name:setItem Params:[{Name:item Type:interface{}} {Name:err Type:error}] Results:[] Receiver:0xc00095ac60 Body:{
	f.lock.Lock()
	f.triggered = true
	f.item = item
	f.err = err
	f.lock.Unlock()
	f.wg.Done()
} PrettyPrintBody:[{ f.lock.Lock() f.triggered = true f.item = item f.err = err f.lock.Unlock() f.wg.Done() }]}
{Id:6 FileId:73 StartLine:81 StartColumn:1 EndLine:91 EndColumn:2 Name:listenForResult Params:[{Name:f Type:*Future} {Name:ch Type:Completer} {Name:timeout Type:time.Duration} {Name:wg Type:*sync.WaitGroup}] Results:[] Receiver:<nil> Body:{
	wg.Done()
	t := time.NewTimer(timeout)
	select {
	case item := <-ch:
		f.setItem(item, nil)
		t.Stop()
	case <-t.C:
		f.setItem(nil, fmt.Errorf(`timeout after %f seconds`, timeout.Seconds()))
	}
} PrettyPrintBody:[{ wg.Done() t := time.NewTimer(timeout) select { case item := <-ch: f.setItem(item, nil) t.Stop() case <-t.C: f.setItem(nil, fmt.Errorf(`timeout after %f seconds`, timeout.Seconds())) } }]}
{Id:7 FileId:73 StartLine:97 StartColumn:1 EndLine:105 EndColumn:2 Name:New Params:[{Name:completer Type:Completer} {Name:timeout Type:time.Duration}] Results:[{Name: Type:*Future}] Receiver:<nil> Body:{
	f := &Future{}
	f.wg.Add(1)
	var wg sync.WaitGroup
	wg.Add(1)
	go listenForResult(f, completer, timeout, &wg)
	wg.Wait()
	return f
} PrettyPrintBody:[{ f := &Future{} f.wg.Add(1) var wg sync.WaitGroup wg.Add(1) go listenForResult(f, completer, timeout, &wg) wg.Wait() return f }]}
{Id:2 FileId:160 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:iterExhausted Params:[{Name:iter Type:*Iterator}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return iter.index == iteratorExhausted
} PrettyPrintBody:[{ return iter.index == iteratorExhausted }]}
{Id:4 FileId:160 StartLine:40 StartColumn:1 EndLine:61 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000dde040 Body:{
	if iterExhausted(iter) {
		return false
	}
	iter.index++
	if iter.index >= len(iter.entries.entries) {
		next := iter.xfastIterator.Next()
		if !next {
			iter.index = iteratorExhausted
			return false
		}
		var ok bool
		iter.entries, ok = iter.xfastIterator.Value().(*entriesWrapper)
		if !ok {
			iter.index = iteratorExhausted
			return false
		}
		iter.index = 0
	}

	return true
} PrettyPrintBody:[{ if iterExhausted(iter) { return false } iter.index++ if iter.index >= len(iter.entries.entries) { next := iter.xfastIterator.Next() if !next { iter.index = iteratorExhausted return false } var ok bool iter.entries, ok = iter.xfastIterator.Value().(*entriesWrapper) if !ok { iter.index = iteratorExhausted return false } iter.index = 0 } return true }]}
{Id:5 FileId:160 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Entry}] Receiver:0xc000e7fe00 Body:{
	if iterExhausted(iter) {
		return nil
	}

	if iter.entries == nil || iter.index < 0 || iter.index >= len(iter.entries.entries) {
		return nil
	}

	return iter.entries.entries[iter.index]
} PrettyPrintBody:[{ if iterExhausted(iter) { return nil } if iter.entries == nil || iter.index < 0 || iter.index >= len(iter.entries.entries) { return nil } return iter.entries.entries[iter.index] }]}
{Id:6 FileId:160 StartLine:80 StartColumn:1 EndLine:87 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:Entries}] Receiver:0xc000e7ffa0 Body:{
	entries := make(Entries, 0, 100)
	for it := iter; it.Next(); {
		entries = append(entries, it.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, 100) for it := iter; it.Next(); { entries = append(entries, it.Value()) } return entries }]}
{Id:7 FileId:160 StartLine:91 StartColumn:1 EndLine:95 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*Iterator}] Receiver:<nil> Body:{
	return &Iterator{
		index: iteratorExhausted,
	}
} PrettyPrintBody:[{ return &Iterator{ index: iteratorExhausted, } }]}
{Id:0 FileId:29 StartLine:20 StartColumn:1 EndLine:29 EndColumn:2 Name:maxInt64 Params:[{Name:ints Type:...int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	maxInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] > maxInt {
			maxInt = ints[i]
		}
	}

	return maxInt
} PrettyPrintBody:[{ maxInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] > maxInt { maxInt = ints[i] } } return maxInt }]}
{Id:1 FileId:29 StartLine:32 StartColumn:1 EndLine:41 EndColumn:2 Name:maxUint64 Params:[{Name:ints Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	maxInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] > maxInt {
			maxInt = ints[i]
		}
	}

	return maxInt
} PrettyPrintBody:[{ maxInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] > maxInt { maxInt = ints[i] } } return maxInt }]}
{Id:2 FileId:29 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:minUint64 Params:[{Name:ints Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	minInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] < minInt {
			minInt = ints[i]
		}
	}

	return minInt
} PrettyPrintBody:[{ minInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] < minInt { minInt = ints[i] } } return minInt }]}
{Id:1 FileId:145 StartLine:21 StartColumn:1 EndLine:25 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001291580 Body:{
	for i := range ns {
		ns[i] = nil
	}
} PrettyPrintBody:[{ for i := range ns { ns[i] = nil } }]}
{Id:3 FileId:145 StartLine:35 StartColumn:1 EndLine:41 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*node}] Receiver:0xc000c499e0 Body:{
	return &node{
		balance:	n.balance,
		children:	[2]*node{n.children[0], n.children[1]},
		entry:		n.entry,
	}
} PrettyPrintBody:[{ return &node{ balance:	n.balance, children:	[2]*node{n.children[0], n.children[1]}, entry:		n.entry, } }]}
{Id:4 FileId:145 StartLine:45 StartColumn:1 EndLine:50 EndColumn:2 Name:newNode Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		entry:		entry,
		children:	[2]*node{},
	}
} PrettyPrintBody:[{ return &node{ entry:		entry, children:	[2]*node{}, } }]}
{Id:1 FileId:74 StartLine:27 StartColumn:1 EndLine:50 EndColumn:2 Name:TestWaitOnGetResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(30*time.Minute))
	var result interface{}
	var err error
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		result, err = f.GetResult()
		wg.Done()
	}()

	completer <- `test`
	wg.Wait()

	assert.Nil(t, err)
	assert.Equal(t, `test`, result)

	result, err = f.GetResult()

	assert.Equal(t, `test`, result)
	assert.Nil(t, err)
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(30*time.Minute)) var result interface{} var err error var wg sync.WaitGroup wg.Add(1) go func() { result, err = f.GetResult() wg.Done() }() completer <- `test` wg.Wait() assert.Nil(t, err) assert.Equal(t, `test`, result) result, err = f.GetResult() assert.Equal(t, `test`, result) assert.Nil(t, err) }]}
{Id:2 FileId:74 StartLine:52 StartColumn:1 EndLine:69 EndColumn:2 Name:TestHasResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(30*time.Minute))

	assert.False(t, f.HasResult())

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		f.GetResult()
		wg.Done()
	}()

	completer <- `test`
	wg.Wait()

	assert.True(t, f.HasResult())
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(30*time.Minute)) assert.False(t, f.HasResult()) var wg sync.WaitGroup wg.Add(1) go func() { f.GetResult() wg.Done() }() completer <- `test` wg.Wait() assert.True(t, f.HasResult()) }]}
{Id:3 FileId:74 StartLine:71 StartColumn:1 EndLine:79 EndColumn:2 Name:TestTimeout Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(0))

	result, err := f.GetResult()

	assert.Nil(t, result)
	assert.NotNil(t, err)
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(0)) result, err := f.GetResult() assert.Nil(t, result) assert.NotNil(t, err) }]}
{Id:4 FileId:74 StartLine:81 StartColumn:1 EndLine:99 EndColumn:2 Name:BenchmarkFuture Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	timeout := time.Duration(30 * time.Minute)
	var wg sync.WaitGroup

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(1)
		f := New(completer, timeout)
		go func() {
			f.GetResult()
			wg.Done()
		}()

		completer <- `test`
		wg.Wait()
	}
} PrettyPrintBody:[{ completer := make(chan interface{}) timeout := time.Duration(30 * time.Minute) var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(1) f := New(completer, timeout) go func() { f.GetResult() wg.Done() }() completer <- `test` wg.Wait() } }]}
{Id:1 FileId:22 StartLine:26 StartColumn:1 EndLine:29 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000c56020 Body:{
	iter.index++
	return iter.index < int64(len(iter.sba.indices))
} PrettyPrintBody:[{ iter.index++ return iter.index < int64(len(iter.sba.indices)) }]}
{Id:2 FileId:22 StartLine:32 StartColumn:1 EndLine:34 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:uint64} {Name: Type:block}] Receiver:0xc001308b60 Body:{
	return iter.sba.indices[iter.index], iter.sba.blocks[iter.index]
} PrettyPrintBody:[{ return iter.sba.indices[iter.index], iter.sba.blocks[iter.index] }]}
{Id:3 FileId:22 StartLine:36 StartColumn:1 EndLine:41 EndColumn:2 Name:newCompressedBitArrayIterator Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:*sparseBitArrayIterator}] Receiver:<nil> Body:{
	return &sparseBitArrayIterator{
		sba:	sba,
		index:	-1,
	}
} PrettyPrintBody:[{ return &sparseBitArrayIterator{ sba:	sba, index:	-1, } }]}
{Id:5 FileId:22 StartLine:51 StartColumn:1 EndLine:54 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000942680 Body:{
	iter.index++
	return uint64(iter.index) <= iter.stopIndex
} PrettyPrintBody:[{ iter.index++ return uint64(iter.index) <= iter.stopIndex }]}
{Id:6 FileId:22 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:uint64} {Name: Type:block}] Receiver:0xc0013095c0 Body:{
	return uint64(iter.index), iter.ba.blocks[iter.index]
} PrettyPrintBody:[{ return uint64(iter.index), iter.ba.blocks[iter.index] }]}
{Id:7 FileId:22 StartLine:61 StartColumn:1 EndLine:69 EndColumn:2 Name:newBitArrayIterator Params:[{Name:ba Type:*bitArray}] Results:[{Name: Type:*bitArrayIterator}] Receiver:<nil> Body:{
	stop, _ := getIndexAndRemainder(ba.highest)
	start, _ := getIndexAndRemainder(ba.lowest)
	return &bitArrayIterator{
		ba:		ba,
		index:		int64(start) - 1,
		stopIndex:	stop,
	}
} PrettyPrintBody:[{ stop, _ := getIndexAndRemainder(ba.highest) start, _ := getIndexAndRemainder(ba.lowest) return &bitArrayIterator{ ba:		ba, index:		int64(start) - 1, stopIndex:	stop, } }]}
{Id:3 FileId:86 StartLine:15 StartColumn:1 EndLine:23 EndColumn:2 Name:Add Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc000e8d1a0 Body:{
	args := m.Called(entries)
	ifc := args.Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(entries) ifc := args.Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]}
{Id:4 FileId:86 StartLine:25 StartColumn:1 EndLine:27 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000f52e60 Body:{
	return m.Called().Get(0).(uint64)
} PrettyPrintBody:[{ return m.Called().Get(0).(uint64) }]}
{Id:5 FileId:86 StartLine:29 StartColumn:1 EndLine:31 EndColumn:2 Name:Delete Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0016024a0 Body:{
	return m.Called(entries).Get(0).(rangetree.Entries)
} PrettyPrintBody:[{ return m.Called(entries).Get(0).(rangetree.Entries) }]}
{Id:6 FileId:86 StartLine:33 StartColumn:1 EndLine:41 EndColumn:2 Name:Query Params:[{Name:interval Type:rangetree.Interval}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0011d6240 Body:{
	args := m.Called(interval)
	ifc := args.Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(interval) ifc := args.Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]}
{Id:7 FileId:86 StartLine:43 StartColumn:1 EndLine:48 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:rangetree.Entries} {Name: Type:rangetree.Entries}] Receiver:0xc0011d6360 Body:{

	args := m.Called(dimension, index, number)
	return args.Get(0).(rangetree.Entries), args.Get(1).(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(dimension, index, number) return args.Get(0).(rangetree.Entries), args.Get(1).(rangetree.Entries) }]}
{Id:8 FileId:86 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:Apply Params:[{Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[] Receiver:0xc0011d63a0 Body:{
	m.Called(interval, fn)
} PrettyPrintBody:[{ m.Called(interval, fn) }]}
{Id:9 FileId:86 StartLine:54 StartColumn:1 EndLine:61 EndColumn:2 Name:Get Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0011d6580 Body:{
	ifc := m.Called(entries).Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ ifc := m.Called(entries).Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]}
{Id:3 FileId:75 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:NewSelectable Params:[] Results:[{Name: Type:*Selectable}] Receiver:<nil> Body:{
	return &Selectable{}
} PrettyPrintBody:[{ return &Selectable{} }]}
{Id:4 FileId:75 StartLine:49 StartColumn:1 EndLine:57 EndColumn:2 Name:wchan Params:[] Results:[{Name: Type:<-chan struct{}}] Receiver:0xc000aeb200 Body:{
	f.m.Lock()
	if f.wait == nil {
		f.wait = make(chan struct{})
	}
	ch := f.wait
	f.m.Unlock()
	return ch
} PrettyPrintBody:[{ f.m.Lock() if f.wait == nil { f.wait = make(chan struct{}) } ch := f.wait f.m.Unlock() return ch }]}
{Id:5 FileId:75 StartLine:60 StartColumn:1 EndLine:65 EndColumn:2 Name:WaitChan Params:[] Results:[{Name: Type:<-chan struct{}}] Receiver:0xc001239f20 Body:{
	if atomic.LoadUint32(&f.filled) == 1 {
		return closed
	}
	return f.wchan()
} PrettyPrintBody:[{ if atomic.LoadUint32(&f.filled) == 1 { return closed } return f.wchan() }]}
{Id:6 FileId:75 StartLine:69 StartColumn:1 EndLine:74 EndColumn:2 Name:GetResult Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc0010331c0 Body:{
	if atomic.LoadUint32(&f.filled) == 0 {
		<-f.wchan()
	}
	return f.val, f.err
} PrettyPrintBody:[{ if atomic.LoadUint32(&f.filled) == 0 { <-f.wchan() } return f.val, f.err }]}
{Id:7 FileId:75 StartLine:78 StartColumn:1 EndLine:92 EndColumn:2 Name:Fill Params:[{Name:v Type:interface{}} {Name:e Type:error}] Results:[{Name: Type:error}] Receiver:0xc001033200 Body:{
	f.m.Lock()
	if f.filled == 0 {
		f.val = v
		f.err = e
		atomic.StoreUint32(&f.filled, 1)
		w := f.wait
		f.wait = closed
		if w != nil {
			close(w)
		}
	}
	f.m.Unlock()
	return f.err
} PrettyPrintBody:[{ f.m.Lock() if f.filled == 0 { f.val = v f.err = e atomic.StoreUint32(&f.filled, 1) w := f.wait f.wait = closed if w != nil { close(w) } } f.m.Unlock() return f.err }]}
{Id:8 FileId:75 StartLine:95 StartColumn:1 EndLine:97 EndColumn:2 Name:SetValue Params:[{Name:v Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc001309440 Body:{
	return f.Fill(v, nil)
} PrettyPrintBody:[{ return f.Fill(v, nil) }]}
{Id:9 FileId:75 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:SetError Params:[{Name:e Type:error}] Results:[] Receiver:0xc001033520 Body:{
	f.Fill(nil, e)
} PrettyPrintBody:[{ f.Fill(nil, e) }]}
{Id:10 FileId:75 StartLine:105 StartColumn:1 EndLine:107 EndColumn:2 Name:Cancel Params:[] Results:[] Receiver:0xc0013094c0 Body:{
	f.SetError(ErrFutureCanceled)
} PrettyPrintBody:[{ f.SetError(ErrFutureCanceled) }]}
{Id:12 FileId:75 StartLine:111 StartColumn:1 EndLine:113 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	close(closed)
} PrettyPrintBody:[{ close(closed) }]}
{Id:1 FileId:34 StartLine:25 StartColumn:1 EndLine:31 EndColumn:2 Name:newTestNode Params:[{Name:isLeaf Type:bool} {Name:ary Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	make(Keys, 0, ary),
		nodes:	make(nodes, 0, ary+1),
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	make(Keys, 0, ary), nodes:	make(nodes, 0, ary+1), } }]}
{Id:2 FileId:34 StartLine:33 StartColumn:1 EndLine:39 EndColumn:2 Name:checkTree Params:[{Name:t Type:testing.TB} {Name:tree Type:*blink}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if tree.root == nil {
		return true
	}

	return checkNode(t, tree.root)
} PrettyPrintBody:[{ if tree.root == nil { return true } return checkNode(t, tree.root) }]}
{Id:3 FileId:34 StartLine:41 StartColumn:1 EndLine:77 EndColumn:2 Name:checkNode Params:[{Name:t Type:testing.TB} {Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if len(n.keys) == 0 {
		assert.Len(t, n.nodes, 0)
		return false
	}

	if n.isLeaf {
		assert.Len(t, n.nodes, 0)
		return false
	}

	if !assert.Len(t, n.nodes, len(n.keys)+1) {
		return false
	}

	for i := 0; i < len(n.keys); i++ {
		if !assert.True(t, n.keys[i].Compare(n.nodes[i].key()) >= 0) {
			t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, n.keys[i], n.nodes[i])
			return false
		}
	}

	if !assert.True(t, n.nodes[len(n.nodes)-1].key().Compare(n.keys.last()) > 0) {
		t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, n.nodes[len(n.nodes)-1].key(), n.keys.last())
		return false
	}
	for _, child := range n.nodes {
		if !assert.NotNil(t, child) {
			return false
		}
		if !checkNode(t, child) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if len(n.keys) == 0 { assert.Len(t, n.nodes, 0) return false } if n.isLeaf { assert.Len(t, n.nodes, 0) return false } if !assert.Len(t, n.nodes, len(n.keys)+1) { return false } for i := 0; i < len(n.keys); i++ { if !assert.True(t, n.keys[i].Compare(n.nodes[i].key()) >= 0) { t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, n.keys[i], n.nodes[i]) return false } } if !assert.True(t, n.nodes[len(n.nodes)-1].key().Compare(n.keys.last()) > 0) { t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, n.nodes[len(n.nodes)-1].key(), n.keys.last()) return false } for _, child := range n.nodes { if !assert.NotNil(t, child) { return false } if !checkNode(t, child) { return false } } return true }]}
{Id:4 FileId:34 StartLine:79 StartColumn:1 EndLine:103 EndColumn:2 Name:TestSplitInternalNodeOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(false, 3)
	n1 := newTestNode(true, 3)
	n1.keys.insert(mockKey(1))
	n2 := newTestNode(true, 3)
	n2.keys.insert(mockKey(5))
	n3 := newTestNode(true, 3)
	n3.keys.insert(mockKey(10))
	n4 := newTestNode(true, 3)
	n4.keys.insert(mockKey(15))

	parent.nodes = nodes{n1, n2, n3, n4}
	parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15)}

	key, l, r := parent.split()
	assert.Equal(t, mockKey(10), key)
	assert.Equal(t, Keys{mockKey(5)}, l.keys)
	assert.Equal(t, Keys{mockKey(15)}, r.keys)

	assert.Equal(t, nodes{n1, n2}, l.nodes)
	assert.Equal(t, nodes{n3, n4}, r.nodes)
	assert.Equal(t, l.right, r)
	assert.False(t, l.isLeaf)
	assert.False(t, r.isLeaf)
} PrettyPrintBody:[{ parent := newTestNode(false, 3) n1 := newTestNode(true, 3) n1.keys.insert(mockKey(1)) n2 := newTestNode(true, 3) n2.keys.insert(mockKey(5)) n3 := newTestNode(true, 3) n3.keys.insert(mockKey(10)) n4 := newTestNode(true, 3) n4.keys.insert(mockKey(15)) parent.nodes = nodes{n1, n2, n3, n4} parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15)} key, l, r := parent.split() assert.Equal(t, mockKey(10), key) assert.Equal(t, Keys{mockKey(5)}, l.keys) assert.Equal(t, Keys{mockKey(15)}, r.keys) assert.Equal(t, nodes{n1, n2}, l.nodes) assert.Equal(t, nodes{n3, n4}, r.nodes) assert.Equal(t, l.right, r) assert.False(t, l.isLeaf) assert.False(t, r.isLeaf) }]}
{Id:5 FileId:34 StartLine:105 StartColumn:1 EndLine:131 EndColumn:2 Name:TestSplitInternalNodeEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(false, 4)
	n1 := newTestNode(true, 4)
	n1.keys.insert(mockKey(1))
	n2 := newTestNode(true, 4)
	n2.keys.insert(mockKey(5))
	n3 := newTestNode(true, 4)
	n3.keys.insert(mockKey(10))
	n4 := newTestNode(true, 4)
	n4.keys.insert(mockKey(15))
	n5 := newTestNode(true, 4)
	n5.keys.insert(mockKey(20))

	parent.nodes = nodes{n1, n2, n3, n4, n5}
	parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15), mockKey(20)}

	key, l, r := parent.split()
	assert.Equal(t, mockKey(15), key)
	assert.Equal(t, Keys{mockKey(5), mockKey(10)}, l.keys)
	assert.Equal(t, Keys{mockKey(20)}, r.keys)

	assert.Equal(t, nodes{n1, n2, n3}, l.nodes)
	assert.Equal(t, nodes{n4, n5}, r.nodes)
	assert.Equal(t, l.right, r)
	assert.False(t, l.isLeaf)
	assert.False(t, r.isLeaf)
} PrettyPrintBody:[{ parent := newTestNode(false, 4) n1 := newTestNode(true, 4) n1.keys.insert(mockKey(1)) n2 := newTestNode(true, 4) n2.keys.insert(mockKey(5)) n3 := newTestNode(true, 4) n3.keys.insert(mockKey(10)) n4 := newTestNode(true, 4) n4.keys.insert(mockKey(15)) n5 := newTestNode(true, 4) n5.keys.insert(mockKey(20)) parent.nodes = nodes{n1, n2, n3, n4, n5} parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15), mockKey(20)} key, l, r := parent.split() assert.Equal(t, mockKey(15), key) assert.Equal(t, Keys{mockKey(5), mockKey(10)}, l.keys) assert.Equal(t, Keys{mockKey(20)}, r.keys) assert.Equal(t, nodes{n1, n2, n3}, l.nodes) assert.Equal(t, nodes{n4, n5}, r.nodes) assert.Equal(t, l.right, r) assert.False(t, l.isLeaf) assert.False(t, r.isLeaf) }]}
{Id:6 FileId:34 StartLine:133 StartColumn:1 EndLine:147 EndColumn:2 Name:TestSplitLeafNodeOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(true, 3)
	k1 := mockKey(5)
	k2 := mockKey(15)
	k3 := mockKey(20)

	parent.keys = Keys{k1, k2, k3}
	key, l, r := parent.split()
	assert.Equal(t, k2, key)
	assert.Equal(t, Keys{k1, k2}, l.keys)
	assert.Equal(t, Keys{k3}, r.keys)
	assert.True(t, l.isLeaf)
	assert.True(t, r.isLeaf)
	assert.Equal(t, r, l.right)
} PrettyPrintBody:[{ parent := newTestNode(true, 3) k1 := mockKey(5) k2 := mockKey(15) k3 := mockKey(20) parent.keys = Keys{k1, k2, k3} key, l, r := parent.split() assert.Equal(t, k2, key) assert.Equal(t, Keys{k1, k2}, l.keys) assert.Equal(t, Keys{k3}, r.keys) assert.True(t, l.isLeaf) assert.True(t, r.isLeaf) assert.Equal(t, r, l.right) }]}
{Id:7 FileId:34 StartLine:149 StartColumn:1 EndLine:164 EndColumn:2 Name:TestSplitLeafNodeEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(true, 4)
	k1 := mockKey(5)
	k2 := mockKey(15)
	k3 := mockKey(20)
	k4 := mockKey(25)

	parent.keys = Keys{k1, k2, k3, k4}
	key, l, r := parent.split()
	assert.Equal(t, k3, key)
	assert.Equal(t, Keys{k1, k2, k3}, l.keys)
	assert.Equal(t, Keys{k4}, r.keys)
	assert.True(t, l.isLeaf)
	assert.True(t, r.isLeaf)
	assert.Equal(t, r, l.right)
} PrettyPrintBody:[{ parent := newTestNode(true, 4) k1 := mockKey(5) k2 := mockKey(15) k3 := mockKey(20) k4 := mockKey(25) parent.keys = Keys{k1, k2, k3, k4} key, l, r := parent.split() assert.Equal(t, k3, key) assert.Equal(t, Keys{k1, k2, k3}, l.keys) assert.Equal(t, Keys{k4}, r.keys) assert.True(t, l.isLeaf) assert.True(t, r.isLeaf) assert.Equal(t, r, l.right) }]}
{Id:1 FileId:81 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:roundUp Params:[{Name:v Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	v--
	v |= v >> 1
	v |= v >> 2
	v |= v >> 4
	v |= v >> 8
	v |= v >> 16
	v |= v >> 32
	v++
	return v
} PrettyPrintBody:[{ v-- v |= v >> 1 v |= v >> 2 v |= v >> 4 v |= v >> 8 v |= v >> 16 v |= v >> 32 v++ return v }]}
{Id:4 FileId:81 StartLine:45 StartColumn:1 EndLine:53 EndColumn:2 Name:find Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:0xc000e8dee0 Body:{
	h := hash(key)
	i := h & (uint64(len(packets)) - 1)
	for packets[i] != nil && packets[i].key != key {
		i = (i + 1) & (uint64(len(packets)) - 1)
	}

	return i
} PrettyPrintBody:[{ h := hash(key) i := h & (uint64(len(packets)) - 1) for packets[i] != nil && packets[i].key != key { i = (i + 1) & (uint64(len(packets)) - 1) } return i }]}
{Id:5 FileId:81 StartLine:55 StartColumn:1 EndLine:63 EndColumn:2 Name:set Params:[{Name:packet Type:*packet}] Results:[] Receiver:0xc0012272a0 Body:{
	i := packets.find(packet.key)
	if packets[i] == nil {
		packets[i] = packet
		return
	}

	packets[i].value = packet.value
} PrettyPrintBody:[{ i := packets.find(packet.key) if packets[i] == nil { packets[i] = packet return } packets[i].value = packet.value }]}
{Id:6 FileId:81 StartLine:65 StartColumn:1 EndLine:72 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc001580980 Body:{
	i := packets.find(key)
	if packets[i] == nil {
		return 0, false
	}

	return packets[i].value, true
} PrettyPrintBody:[{ i := packets.find(key) if packets[i] == nil { return 0, false } return packets[i].value, true }]}
{Id:7 FileId:81 StartLine:74 StartColumn:1 EndLine:88 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001308dc0 Body:{
	i := packets.find(key)
	if packets[i] == nil {
		return false
	}
	packets[i] = nil
	i = (i + 1) & (uint64(len(packets)) - 1)
	for packets[i] != nil {
		p := packets[i]
		packets[i] = nil
		packets.set(p)
		i = (i + 1) & (uint64(len(packets)) - 1)
	}
	return true
} PrettyPrintBody:[{ i := packets.find(key) if packets[i] == nil { return false } packets[i] = nil i = (i + 1) & (uint64(len(packets)) - 1) for packets[i] != nil { p := packets[i] packets[i] = nil packets.set(p) i = (i + 1) & (uint64(len(packets)) - 1) } return true }]}
{Id:8 FileId:81 StartLine:90 StartColumn:1 EndLine:93 EndColumn:2 Name:exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000c577e0 Body:{
	i := packets.find(key)
	return packets[i] != nil
} PrettyPrintBody:[{ i := packets.find(key) return packets[i] != nil }]}
{Id:10 FileId:81 StartLine:109 StartColumn:1 EndLine:119 EndColumn:2 Name:rebuild Params:[] Results:[] Receiver:0xc000118740 Body:{
	packets := make(packets, roundUp(uint64(len(fi.packets))+1))
	for _, packet := range fi.packets {
		if packet == nil {
			continue
		}

		packets.set(packet)
	}
	fi.packets = packets
} PrettyPrintBody:[{ packets := make(packets, roundUp(uint64(len(fi.packets))+1)) for _, packet := range fi.packets { if packet == nil { continue } packets.set(packet) } fi.packets = packets }]}
{Id:11 FileId:81 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc00095a3c0 Body:{
	return fi.packets.get(key)
} PrettyPrintBody:[{ return fi.packets.get(key) }]}
{Id:12 FileId:81 StartLine:128 StartColumn:1 EndLine:135 EndColumn:2 Name:Set Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc000a23800 Body:{
	if float64(fi.count+1)/float64(len(fi.packets)) > ratio {
		fi.rebuild()
	}

	fi.packets.set(&packet{key: key, value: value})
	fi.count++
} PrettyPrintBody:[{ if float64(fi.count+1)/float64(len(fi.packets)) > ratio { fi.rebuild() } fi.packets.set(&packet{key: key, value: value}) fi.count++ }]}
{Id:13 FileId:81 StartLine:139 StartColumn:1 EndLine:141 EndColumn:2 Name:Exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001500fc0 Body:{
	return fi.packets.exists(key)
} PrettyPrintBody:[{ return fi.packets.exists(key) }]}
{Id:14 FileId:81 StartLine:145 StartColumn:1 EndLine:149 EndColumn:2 Name:Delete Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc0010de4a0 Body:{
	if fi.packets.delete(key) {
		fi.count--
	}
} PrettyPrintBody:[{ if fi.packets.delete(key) { fi.count-- } }]}
{Id:15 FileId:81 StartLine:152 StartColumn:1 EndLine:154 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001501cc0 Body:{
	return fi.count
} PrettyPrintBody:[{ return fi.count }]}
{Id:16 FileId:81 StartLine:157 StartColumn:1 EndLine:159 EndColumn:2 Name:Cap Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602560 Body:{
	return uint64(len(fi.packets))
} PrettyPrintBody:[{ return uint64(len(fi.packets)) }]}
{Id:17 FileId:81 StartLine:163 StartColumn:1 EndLine:173 EndColumn:2 Name:New Params:[{Name:hint Type:uint64}] Results:[{Name: Type:*FastIntegerHashMap}] Receiver:<nil> Body:{
	if hint == 0 {
		hint = 16
	}

	hint = roundUp(hint)
	return &FastIntegerHashMap{
		count:		0,
		packets:	make(packets, hint),
	}
} PrettyPrintBody:[{ if hint == 0 { hint = 16 } hint = roundUp(hint) return &FastIntegerHashMap{ count:		0, packets:	make(packets, hint), } }]}
{Id:1 FileId:49 StartLine:12 StartColumn:1 EndLine:34 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000e7fd80 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x84, 0xa1, 0x75)
	o, err = z.UUID.MarshalMsg(o)
	if err != nil {
		return
	}

	o = append(o, 0xa1, 0x63)
	o = msgp.AppendInt(o, z.Count)

	o = append(o, 0xa1, 0x72)
	o, err = z.Root.MarshalMsg(o)
	if err != nil {
		return
	}

	o = append(o, 0xa2, 0x6e, 0x77)
	o = msgp.AppendInt(o, z.NodeWidth)
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x84, 0xa1, 0x75) o, err = z.UUID.MarshalMsg(o) if err != nil { return } o = append(o, 0xa1, 0x63) o = msgp.AppendInt(o, z.Count) o = append(o, 0xa1, 0x72) o, err = z.Root.MarshalMsg(o) if err != nil { return } o = append(o, 0xa2, 0x6e, 0x77) o = msgp.AppendInt(o, z.NodeWidth) return }]}
{Id:2 FileId:49 StartLine:37 StartColumn:1 EndLine:81 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc0001187e0 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			bts, err = z.UUID.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "c":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "r":
			bts, err = z.Root.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "nw":
			z.NodeWidth, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "u": bts, err = z.UUID.UnmarshalMsg(bts) if err != nil { return } case "c": z.Count, bts, err = msgp.ReadIntBytes(bts) if err != nil { return } case "r": bts, err = z.Root.UnmarshalMsg(bts) if err != nil { return } case "nw": z.NodeWidth, bts, err = msgp.ReadIntBytes(bts) if err != nil { return } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]}
{Id:3 FileId:49 StartLine:83 StartColumn:1 EndLine:86 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc00095a4a0 Body:{
	s = 1 + 2 + z.UUID.Msgsize() + 2 + msgp.IntSize + 2 + z.Root.Msgsize() + 3 + msgp.IntSize
	return
} PrettyPrintBody:[{ s = 1 + 2 + z.UUID.Msgsize() + 2 + msgp.IntSize + 2 + z.Root.Msgsize() + 3 + msgp.IntSize return }]}
{Id:1 FileId:15 StartLine:35 StartColumn:1 EndLine:46 EndColumn:2 Name:TestBitmap32_PopCount Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := []uint32{
		uint32(0x55555555),
		uint32(0x33333333),
		uint32(0x0F0F0F0F),
		uint32(0x00FF00FF),
		uint32(0x0000FFFF),
	}
	for _, x := range b {
		assert.Equal(t, 16, Bitmap32(x).PopCount())
	}
} PrettyPrintBody:[{ b := []uint32{ uint32(0x55555555), uint32(0x33333333), uint32(0x0F0F0F0F), uint32(0x00FF00FF), uint32(0x0000FFFF), } for _, x := range b { assert.Equal(t, 16, Bitmap32(x).PopCount()) } }]}
{Id:2 FileId:15 StartLine:48 StartColumn:1 EndLine:59 EndColumn:2 Name:TestBitmap64_PopCount Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := []uint64{
		uint64(0x5555555555555555),
		uint64(0x3333333333333333),
		uint64(0x0F0F0F0F0F0F0F0F),
		uint64(0x00FF00FF00FF00FF),
		uint64(0x0000FFFF0000FFFF),
	}
	for _, x := range b {
		assert.Equal(t, 32, Bitmap64(x).PopCount())
	}
} PrettyPrintBody:[{ b := []uint64{ uint64(0x5555555555555555), uint64(0x3333333333333333), uint64(0x0F0F0F0F0F0F0F0F), uint64(0x00FF00FF00FF00FF), uint64(0x0000FFFF0000FFFF), } for _, x := range b { assert.Equal(t, 32, Bitmap64(x).PopCount()) } }]}
{Id:3 FileId:15 StartLine:61 StartColumn:1 EndLine:64 EndColumn:2 Name:TestBitmap32_SetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0)
	assert.Equal(t, Bitmap32(0x4), m.SetBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0) assert.Equal(t, Bitmap32(0x4), m.SetBit(2)) }]}
{Id:4 FileId:15 StartLine:66 StartColumn:1 EndLine:69 EndColumn:2 Name:TestBitmap32_ClearBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x4)
	assert.Equal(t, Bitmap32(0), m.ClearBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0x4) assert.Equal(t, Bitmap32(0), m.ClearBit(2)) }]}
{Id:5 FileId:15 StartLine:71 StartColumn:1 EndLine:74 EndColumn:2 Name:TestBitmap32_zGetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x55555555)
	assert.Equal(t, true, m.GetBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0x55555555) assert.Equal(t, true, m.GetBit(2)) }]}
{Id:6 FileId:15 StartLine:76 StartColumn:1 EndLine:79 EndColumn:2 Name:TestBitmap64_SetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0)
	assert.Equal(t, Bitmap64(0x4), m.SetBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0) assert.Equal(t, Bitmap64(0x4), m.SetBit(2)) }]}
{Id:7 FileId:15 StartLine:81 StartColumn:1 EndLine:84 EndColumn:2 Name:TestBitmap64_ClearBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x4)
	assert.Equal(t, Bitmap64(0), m.ClearBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0x4) assert.Equal(t, Bitmap64(0), m.ClearBit(2)) }]}
{Id:8 FileId:15 StartLine:86 StartColumn:1 EndLine:89 EndColumn:2 Name:TestBitmap64_GetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x55555555)
	assert.Equal(t, true, m.GetBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0x55555555) assert.Equal(t, true, m.GetBit(2)) }]}
{Id:9 FileId:15 StartLine:91 StartColumn:1 EndLine:97 EndColumn:2 Name:BenchmarkBitmap32_PopCount Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x33333333)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		m.PopCount()
	}
} PrettyPrintBody:[{ m := Bitmap32(0x33333333) b.ResetTimer() for i := b.N; i > 0; i-- { m.PopCount() } }]}
{Id:10 FileId:15 StartLine:99 StartColumn:1 EndLine:105 EndColumn:2 Name:BenchmarkBitmap64_PopCount Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x3333333333333333)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		m.PopCount()
	}
} PrettyPrintBody:[{ m := Bitmap64(0x3333333333333333) b.ResetTimer() for i := b.N; i > 0; i-- { m.PopCount() } }]}
{Id:0 FileId:62 StartLine:19 StartColumn:1 EndLine:25 EndColumn:2 Name:chunkKeys Params:[{Name:ks Type:keys} {Name:numParts Type:int64}] Results:[{Name: Type:[]keys}] Receiver:<nil> Body:{
	parts := make([]keys, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = ks[i*int64(len(ks))/numParts : (i+1)*int64(len(ks))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]keys, numParts) for i := int64(0); i < numParts; i++ { parts[i] = ks[i*int64(len(ks))/numParts : (i+1)*int64(len(ks))/numParts] } return parts }]}
{Id:2 FileId:62 StartLine:31 StartColumn:1 EndLine:41 EndColumn:2 Name:Compare Params:[{Name:other Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0010336a0 Body:{
	key := other.(*mockKey)
	if key.value == mk.value {
		return 0
	}
	if key.value > mk.value {
		return 1
	}

	return -1
} PrettyPrintBody:[{ key := other.(*mockKey) if key.value == mk.value { return 0 } if key.value > mk.value { return 1 } return -1 }]}
{Id:3 FileId:62 StartLine:43 StartColumn:1 EndLine:45 EndColumn:2 Name:newMockKey Params:[{Name:value Type:int}] Results:[{Name: Type:*mockKey}] Receiver:<nil> Body:{
	return &mockKey{value}
} PrettyPrintBody:[{ return &mockKey{value} }]}
{Id:3 FileId:35 StartLine:57 StartColumn:1 EndLine:77 EndColumn:2 Name:insert Params:[{Name:key Type:Key} {Name:stack Type:*nodes}] Results:[{Name: Type:Key}] Receiver:0xc00095a120 Body:{
	var parent *node
	blink.lock.Lock()
	if blink.root == nil {
		blink.root = newNode(
			true, make(Keys, 0, blink.ary), make(nodes, 0, blink.ary+1),
		)
		blink.root.keys = make(Keys, 0, blink.ary)
		blink.root.isLeaf = true
	}
	parent = blink.root
	blink.lock.Unlock()

	result := insert(blink, parent, stack, key)
	if result == nil {
		atomic.AddUint64(&blink.number, 1)
		return nil
	}

	return result
} PrettyPrintBody:[{ var parent *node blink.lock.Lock() if blink.root == nil { blink.root = newNode( true, make(Keys, 0, blink.ary), make(nodes, 0, blink.ary+1), ) blink.root.keys = make(Keys, 0, blink.ary) blink.root.isLeaf = true } parent = blink.root blink.lock.Unlock() result := insert(blink, parent, stack, key) if result == nil { atomic.AddUint64(&blink.number, 1) return nil } return result }]}
{Id:4 FileId:35 StartLine:79 StartColumn:1 EndLine:103 EndColumn:2 Name:multithreadedInsert Params:[{Name:keys Type:Keys}] Results:[{Name: Type:Keys}] Receiver:0xc001308fa0 Body:{
	chunks := chunkKeys(keys, int64(blink.numRoutines))
	overwritten := make(Keys, len(keys))
	var offset uint64
	var wg sync.WaitGroup
	wg.Add(len(chunks))

	for _, chunk := range chunks {
		go func(chunk Keys, offset uint64) {
			defer wg.Done()
			stack := make(nodes, 0, blink.ary)

			for i := 0; i < len(chunk); i++ {
				result := blink.insert(chunk[i], &stack)
				stack.reset()
				overwritten[offset+uint64(i)] = result
			}
		}(chunk, offset)
		offset += uint64(len(chunk))
	}

	wg.Wait()

	return overwritten
} PrettyPrintBody:[{ chunks := chunkKeys(keys, int64(blink.numRoutines)) overwritten := make(Keys, len(keys)) var offset uint64 var wg sync.WaitGroup wg.Add(len(chunks)) for _, chunk := range chunks { go func(chunk Keys, offset uint64) { defer wg.Done() stack := make(nodes, 0, blink.ary) for i := 0; i < len(chunk); i++ { result := blink.insert(chunk[i], &stack) stack.reset() overwritten[offset+uint64(i)] = result } }(chunk, offset) offset += uint64(len(chunk)) } wg.Wait() return overwritten }]}
{Id:5 FileId:35 StartLine:108 StartColumn:1 EndLine:120 EndColumn:2 Name:Insert Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc000a8a1e0 Body:{
	if len(keys) > numberOfItemsBeforeMultithread {
		return blink.multithreadedInsert(keys)
	}
	overwritten := make(Keys, 0, len(keys))
	stack := make(nodes, 0, blink.ary)
	for _, k := range keys {
		overwritten = append(overwritten, blink.insert(k, &stack))
		stack.reset()
	}

	return overwritten
} PrettyPrintBody:[{ if len(keys) > numberOfItemsBeforeMultithread { return blink.multithreadedInsert(keys) } overwritten := make(Keys, 0, len(keys)) stack := make(nodes, 0, blink.ary) for _, k := range keys { overwritten = append(overwritten, blink.insert(k, &stack)) stack.reset() } return overwritten }]}
{Id:6 FileId:35 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409bc0 Body:{
	return atomic.LoadUint64(&blink.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&blink.number) }]}
{Id:7 FileId:35 StartLine:127 StartColumn:1 EndLine:142 EndColumn:2 Name:get Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc001409c20 Body:{
	var parent *node
	blink.lock.RLock()
	parent = blink.root
	blink.lock.RUnlock()
	k := search(parent, key)
	if k == nil {
		return nil
	}

	if k.Compare(key) == 0 {
		return k
	}

	return nil
} PrettyPrintBody:[{ var parent *node blink.lock.RLock() parent = blink.root blink.lock.RUnlock() k := search(parent, key) if k == nil { return nil } if k.Compare(key) == 0 { return k } return nil }]}
{Id:8 FileId:35 StartLine:147 StartColumn:1 EndLine:154 EndColumn:2 Name:Get Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc001409ca0 Body:{
	found := make(Keys, 0, len(keys))
	for _, k := range keys {
		found = append(found, blink.get(k))
	}

	return found
} PrettyPrintBody:[{ found := make(Keys, 0, len(keys)) for _, k := range keys { found = append(found, blink.get(k)) } return found }]}
{Id:9 FileId:35 StartLine:156 StartColumn:1 EndLine:163 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc001309920 Body:{
	output.Println(`PRINTING B-LINK`)
	if blink.root == nil {
		return
	}

	blink.root.print(output)
} PrettyPrintBody:[{ output.Println(`PRINTING B-LINK`) if blink.root == nil { return } blink.root.print(output) }]}
{Id:10 FileId:35 StartLine:165 StartColumn:1 EndLine:167 EndColumn:2 Name:newTree Params:[{Name:ary Type:uint64}] Results:[{Name: Type:*blink}] Receiver:<nil> Body:{
	return &blink{ary: ary, numRoutines: numRoutines}
} PrettyPrintBody:[{ return &blink{ary: ary, numRoutines: numRoutines} }]}
{Id:4 FileId:70 StartLine:13 StartColumn:1 EndLine:20 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Enqueue Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	node := heap.Enqueue(SomeNumber)
	fmt.Println(node.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) fmt.Println(node.Priority) }]}
{Id:5 FileId:70 StartLine:22 StartColumn:1 EndLine:29 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Min Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(SomeNumber)
	heap.Enqueue(SomeLargerNumber)
	min, _ := heap.Min()
	fmt.Println(min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(SomeNumber) heap.Enqueue(SomeLargerNumber) min, _ := heap.Min() fmt.Println(min.Priority) }]}
{Id:6 FileId:70 StartLine:31 StartColumn:1 EndLine:39 EndColumn:2 Name:ExampleFloatingFibonacciHeap_IsEmpty Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	fmt.Printf("Empty before insert? %v\n", heap.IsEmpty())
	heap.Enqueue(SomeNumber)
	fmt.Printf("Empty after insert? %v\n", heap.IsEmpty())

} PrettyPrintBody:[{ heap := NewFloatFibHeap() fmt.Printf("Empty before insert? %v\n", heap.IsEmpty()) heap.Enqueue(SomeNumber) fmt.Printf("Empty after insert? %v\n", heap.IsEmpty()) }]}
{Id:7 FileId:70 StartLine:41 StartColumn:1 EndLine:49 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Size Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	fmt.Printf("Size before insert: %v\n", heap.Size())
	heap.Enqueue(SomeNumber)
	fmt.Printf("Size after insert: %v\n", heap.Size())

} PrettyPrintBody:[{ heap := NewFloatFibHeap() fmt.Printf("Size before insert: %v\n", heap.Size()) heap.Enqueue(SomeNumber) fmt.Printf("Size after insert: %v\n", heap.Size()) }]}
{Id:8 FileId:70 StartLine:51 StartColumn:1 EndLine:58 EndColumn:2 Name:ExampleFloatingFibonacciHeap_DequeueMin Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(SomeNumber)
	node, _ := heap.DequeueMin()
	fmt.Printf("Dequeueing minimal element: %v\n", node.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(SomeNumber) node, _ := heap.DequeueMin() fmt.Printf("Dequeueing minimal element: %v\n", node.Priority) }]}
{Id:9 FileId:70 StartLine:60 StartColumn:1 EndLine:71 EndColumn:2 Name:ExampleFloatingFibonacciHeap_DecreaseKey Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(SomeNumber)
	min, _ := heap.Min()
	fmt.Printf("Minimal element before decreasing key: %v\n", min.Priority)
	heap.DecreaseKey(node, SomeSmallerNumber)
	min, _ = heap.Min()
	fmt.Printf("Minimal element after decreasing key: %v\n", min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) min, _ := heap.Min() fmt.Printf("Minimal element before decreasing key: %v\n", min.Priority) heap.DecreaseKey(node, SomeSmallerNumber) min, _ = heap.Min() fmt.Printf("Minimal element after decreasing key: %v\n", min.Priority) }]}
{Id:10 FileId:70 StartLine:73 StartColumn:1 EndLine:85 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Delete Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(SomeNumber)
	heap.Enqueue(SomeLargerNumber)
	min, _ := heap.Min()
	fmt.Printf("Minimal element before deletion: %v\n", min.Priority)
	heap.Delete(node)
	min, _ = heap.Min()
	fmt.Printf("Minimal element after deletion: %v\n", min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) heap.Enqueue(SomeLargerNumber) min, _ := heap.Min() fmt.Printf("Minimal element before deletion: %v\n", min.Priority) heap.Delete(node) min, _ = heap.Min() fmt.Printf("Minimal element after deletion: %v\n", min.Priority) }]}
{Id:11 FileId:70 StartLine:87 StartColumn:1 EndLine:104 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Merge Params:[] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	heap2 := NewFloatFibHeap()
	heap1.Enqueue(SomeNumber)
	heap1.Enqueue(SomeLargerNumber)
	heap2.Enqueue(SomeSmallerNumber)
	min, _ := heap1.Min()
	fmt.Printf("Minimal element of heap 1: %v\n", min.Priority)
	min, _ = heap2.Min()
	fmt.Printf("Minimal element of heap 2: %v\n", min.Priority)
	heap, _ := heap1.Merge(&heap2)
	min, _ = heap.Min()
	fmt.Printf("Minimal element of merged heap: %v\n", min.Priority)

} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() heap2 := NewFloatFibHeap() heap1.Enqueue(SomeNumber) heap1.Enqueue(SomeLargerNumber) heap2.Enqueue(SomeSmallerNumber) min, _ := heap1.Min() fmt.Printf("Minimal element of heap 1: %v\n", min.Priority) min, _ = heap2.Min() fmt.Printf("Minimal element of heap 2: %v\n", min.Priority) heap, _ := heap1.Merge(&heap2) min, _ = heap.Min() fmt.Printf("Minimal element of merged heap: %v\n", min.Priority) }]}
{Id:4 FileId:65 StartLine:37 StartColumn:1 EndLine:41 EndColumn:2 Name:setElementIfNotNil Params:[{Name:element Type:*list.Element}] Results:[] Receiver:0xc0009f89c0 Body:{
	if element != nil {
		c.element = element
	}
} PrettyPrintBody:[{ if element != nil { c.element = element } }]}
{Id:9 FileId:65 StartLine:69 StartColumn:1 EndLine:80 EndColumn:2 Name:EvictionPolicy Params:[{Name:policy Type:Policy}] Results:[{Name: Type:CacheOption}] Receiver:<nil> Body:{
	return func(c *cache) {
		switch policy {
		case LeastRecentlyAdded:
			c.recordAccess = c.noop
			c.recordAdd = c.record
		case LeastRecentlyUsed:
			c.recordAccess = c.record
			c.recordAdd = c.noop
		}
	}
} PrettyPrintBody:[{ return func(c *cache) { switch policy { case LeastRecentlyAdded: c.recordAccess = c.noop c.recordAdd = c.record case LeastRecentlyUsed: c.recordAccess = c.record c.recordAdd = c.noop } } }]}
{Id:10 FileId:65 StartLine:85 StartColumn:1 EndLine:99 EndColumn:2 Name:New Params:[{Name:capacity Type:uint64} {Name:options Type:...CacheOption}] Results:[{Name: Type:Cache}] Receiver:<nil> Body:{
	c := &cache{
		cap:		capacity,
		keyList:	list.New(),
		items:		map[string]*cached{},
	}

	EvictionPolicy(LeastRecentlyUsed)(c)

	for _, option := range options {
		option(c)
	}

	return c
} PrettyPrintBody:[{ c := &cache{ cap:		capacity, keyList:	list.New(), items:		map[string]*cached{}, } EvictionPolicy(LeastRecentlyUsed)(c) for _, option := range options { option(c) } return c }]}
{Id:11 FileId:65 StartLine:101 StartColumn:1 EndLine:117 EndColumn:2 Name:Get Params:[{Name:keys Type:...string}] Results:[{Name: Type:[]Item}] Receiver:0xc0014092a0 Body:{
	c.Lock()
	defer c.Unlock()

	items := make([]Item, len(keys))
	for i, key := range keys {
		cached := c.items[key]
		if cached == nil {
			items[i] = nil
		} else {
			c.recordAccess(key)
			items[i] = cached.item
		}
	}

	return items
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() items := make([]Item, len(keys)) for i, key := range keys { cached := c.items[key] if cached == nil { items[i] = nil } else { c.recordAccess(key) items[i] = cached.item } } return items }]}
{Id:12 FileId:65 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:Put Params:[{Name:key Type:string} {Name:item Type:Item}] Results:[] Receiver:0xc001309200 Body:{
	c.Lock()
	defer c.Unlock()

	c.remove(key)

	c.ensureCapacity(item.Size())

	cached := &cached{item: item}
	cached.setElementIfNotNil(c.recordAdd(key))
	cached.setElementIfNotNil(c.recordAccess(key))
	c.items[key] = cached
	c.size += item.Size()
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() c.remove(key) c.ensureCapacity(item.Size()) cached := &cached{item: item} cached.setElementIfNotNil(c.recordAdd(key)) cached.setElementIfNotNil(c.recordAccess(key)) c.items[key] = cached c.size += item.Size() }]}
{Id:13 FileId:65 StartLine:137 StartColumn:1 EndLine:144 EndColumn:2 Name:Remove Params:[{Name:keys Type:...string}] Results:[] Receiver:0xc000a8b7c0 Body:{
	c.Lock()
	defer c.Unlock()

	for _, key := range keys {
		c.remove(key)
	}
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() for _, key := range keys { c.remove(key) } }]}
{Id:14 FileId:65 StartLine:146 StartColumn:1 EndLine:151 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0012cf1c0 Body:{
	c.Lock()
	defer c.Unlock()

	return c.size
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() return c.size }]}
{Id:15 FileId:65 StartLine:156 StartColumn:1 EndLine:163 EndColumn:2 Name:ensureCapacity Params:[{Name:toAdd Type:uint64}] Results:[] Receiver:0xc001580d80 Body:{
	mustRemove := int64(c.size+toAdd) - int64(c.cap)
	for mustRemove > 0 {
		key := c.keyList.Back().Value.(string)
		mustRemove -= int64(c.items[key].item.Size())
		c.remove(key)
	}
} PrettyPrintBody:[{ mustRemove := int64(c.size+toAdd) - int64(c.cap) for mustRemove > 0 { key := c.keyList.Back().Value.(string) mustRemove -= int64(c.items[key].item.Size()) c.remove(key) } }]}
{Id:16 FileId:65 StartLine:167 StartColumn:1 EndLine:173 EndColumn:2 Name:remove Params:[{Name:key Type:string}] Results:[] Receiver:0xc000df6f40 Body:{
	if cached, ok := c.items[key]; ok {
		delete(c.items, key)
		c.size -= cached.item.Size()
		c.keyList.Remove(cached.element)
	}
} PrettyPrintBody:[{ if cached, ok := c.items[key]; ok { delete(c.items, key) c.size -= cached.item.Size() c.keyList.Remove(cached.element) } }]}
{Id:17 FileId:65 StartLine:176 StartColumn:1 EndLine:176 EndColumn:58 Name:noop Params:[{Name: Type:string}] Results:[{Name: Type:*list.Element}] Receiver:0xc001309a40 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:18 FileId:65 StartLine:179 StartColumn:1 EndLine:185 EndColumn:2 Name:record Params:[{Name:key Type:string}] Results:[{Name: Type:*list.Element}] Receiver:0xc000df7e40 Body:{
	if item, ok := c.items[key]; ok {
		c.keyList.MoveToFront(item.element)
		return item.element
	}
	return c.keyList.PushFront(key)
} PrettyPrintBody:[{ if item, ok := c.items[key]; ok { c.keyList.MoveToFront(item.element) return item.element } return c.keyList.PushFront(key) }]}
{Id:1 FileId:14 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:SetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap32}] Receiver:0xc0010982e0 Body:{
	return b | (1 << pos)
} PrettyPrintBody:[{ return b | (1 << pos) }]}
{Id:2 FileId:14 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:ClearBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap32}] Receiver:0xc000ced1e0 Body:{
	return b & ^(1 << pos)
} PrettyPrintBody:[{ return b & ^(1 << pos) }]}
{Id:3 FileId:14 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:GetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:bool}] Receiver:0xc000ced280 Body:{
	return (b & (1 << pos)) != 0
} PrettyPrintBody:[{ return (b & (1 << pos)) != 0 }]}
{Id:4 FileId:14 StartLine:50 StartColumn:1 EndLine:58 EndColumn:2 Name:PopCount Params:[] Results:[{Name: Type:int}] Receiver:0xc0013081e0 Body:{

	b -= (b >> 1) & 0x55555555
	b = (b>>2)&0x33333333 + b&0x33333333
	b += b >> 4
	b &= 0x0f0f0f0f
	b *= 0x01010101
	return int(byte(b >> 24))
} PrettyPrintBody:[{ b -= (b >> 1) & 0x55555555 b = (b>>2)&0x33333333 + b&0x33333333 b += b >> 4 b &= 0x0f0f0f0f b *= 0x01010101 return int(byte(b >> 24)) }]}
{Id:6 FileId:14 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:SetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap64}] Receiver:0xc001247c60 Body:{
	return b | (1 << pos)
} PrettyPrintBody:[{ return b | (1 << pos) }]}
{Id:7 FileId:14 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:ClearBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap64}] Receiver:0xc000942640 Body:{
	return b & ^(1 << pos)
} PrettyPrintBody:[{ return b & ^(1 << pos) }]}
{Id:8 FileId:14 StartLine:74 StartColumn:1 EndLine:76 EndColumn:2 Name:GetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:bool}] Receiver:0xc000a23620 Body:{
	return (b & (1 << pos)) != 0
} PrettyPrintBody:[{ return (b & (1 << pos)) != 0 }]}
{Id:9 FileId:14 StartLine:79 StartColumn:1 EndLine:87 EndColumn:2 Name:PopCount Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a2c0 Body:{

	b -= (b >> 1) & 0x5555555555555555
	b = (b>>2)&0x3333333333333333 + b&0x3333333333333333
	b += b >> 4
	b &= 0x0f0f0f0f0f0f0f0f
	b *= 0x0101010101010101
	return int(byte(b >> 56))
} PrettyPrintBody:[{ b -= (b >> 1) & 0x5555555555555555 b = (b>>2)&0x3333333333333333 + b&0x3333333333333333 b += b >> 4 b &= 0x0f0f0f0f0f0f0f0f b *= 0x0101010101010101 return int(byte(b >> 56)) }]}
{Id:1 FileId:76 StartLine:29 StartColumn:1 EndLine:51 EndColumn:2 Name:TestSelectableGetResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	f := NewSelectable()
	var result interface{}
	var err error
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		result, err = f.GetResult()
		wg.Done()
	}()

	f.SetValue(`test`)
	wg.Wait()

	assert.Nil(t, err)
	assert.Equal(t, `test`, result)

	result, err = f.GetResult()

	assert.Equal(t, `test`, result)
	assert.Nil(t, err)
} PrettyPrintBody:[{ f := NewSelectable() var result interface{} var err error var wg sync.WaitGroup wg.Add(1) go func() { result, err = f.GetResult() wg.Done() }() f.SetValue(`test`) wg.Wait() assert.Nil(t, err) assert.Equal(t, `test`, result) result, err = f.GetResult() assert.Equal(t, `test`, result) assert.Nil(t, err) }]}
{Id:2 FileId:76 StartLine:53 StartColumn:1 EndLine:65 EndColumn:2 Name:TestSelectableSetError Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	f := NewSelectable()
	select {
	case <-f.WaitChan():
	case <-time.After(0):
		f.SetError(fmt.Errorf("timeout"))
	}

	result, err := f.GetResult()

	assert.Nil(t, result)
	assert.NotNil(t, err)
} PrettyPrintBody:[{ f := NewSelectable() select { case <-f.WaitChan(): case <-time.After(0): f.SetError(fmt.Errorf("timeout")) } result, err := f.GetResult() assert.Nil(t, result) assert.NotNil(t, err) }]}
{Id:3 FileId:76 StartLine:67 StartColumn:1 EndLine:88 EndColumn:2 Name:BenchmarkSelectable Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	timeout := time.After(30 * time.Minute)
	var wg sync.WaitGroup

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(1)
		f := NewSelectable()
		go func() {
			select {
			case <-f.WaitChan():
			case <-timeout:
				f.SetError(fmt.Errorf("timeout"))
			}
			wg.Done()
		}()

		f.SetValue(`test`)
		wg.Wait()
	}
} PrettyPrintBody:[{ timeout := time.After(30 * time.Minute) var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(1) f := NewSelectable() go func() { select { case <-f.WaitChan(): case <-timeout: f.SetError(fmt.Errorf("timeout")) } wg.Done() }() f.SetValue(`test`) wg.Wait() } }]}
{Id:1 FileId:116 StartLine:27 StartColumn:1 EndLine:32 EndColumn:2 Name:getCenter Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:<nil> Body:{
	xlow, ylow := rect.LowerLeft()
	xhigh, yhigh := rect.UpperRight()

	return (xhigh + xlow) / 2, (yhigh + ylow) / 2
} PrettyPrintBody:[{ xlow, ylow := rect.LowerLeft() xhigh, yhigh := rect.UpperRight() return (xhigh + xlow) / 2, (yhigh + ylow) / 2 }]}
{Id:3 FileId:116 StartLine:39 StartColumn:1 EndLine:70 EndColumn:2 Name:bundlesFromRects Params:[{Name:rects Type:...rtree.Rectangle}] Results:[{Name: Type:[]*hilbertBundle}] Receiver:<nil> Body:{
	chunks := chunkRectangles(rects, int64(runtime.NumCPU()))
	bundleChunks := make([][]*hilbertBundle, len(chunks))
	var wg sync.WaitGroup
	wg.Add(len(chunks))

	for i := 0; i < runtime.NumCPU(); i++ {
		if len(chunks[i]) == 0 {
			bundleChunks[i] = []*hilbertBundle{}
			wg.Done()
			continue
		}
		go func(i int) {
			bundles := make([]*hilbertBundle, 0, len(chunks[i]))
			for _, r := range chunks[i] {
				h := h.Encode(getCenter(r))
				bundles = append(bundles, &hilbertBundle{hilbert(h), r})
			}
			bundleChunks[i] = bundles
			wg.Done()
		}(i)
	}

	wg.Wait()

	bundles := make([]*hilbertBundle, 0, len(rects))
	for _, bc := range bundleChunks {
		bundles = append(bundles, bc...)
	}

	return bundles
} PrettyPrintBody:[{ chunks := chunkRectangles(rects, int64(runtime.NumCPU())) bundleChunks := make([][]*hilbertBundle, len(chunks)) var wg sync.WaitGroup wg.Add(len(chunks)) for i := 0; i < runtime.NumCPU(); i++ { if len(chunks[i]) == 0 { bundleChunks[i] = []*hilbertBundle{} wg.Done() continue } go func(i int) { bundles := make([]*hilbertBundle, 0, len(chunks[i])) for _, r := range chunks[i] { h := h.Encode(getCenter(r)) bundles = append(bundles, &hilbertBundle{hilbert(h), r}) } bundleChunks[i] = bundles wg.Done() }(i) } wg.Wait() bundles := make([]*hilbertBundle, 0, len(rects)) for _, bc := range bundleChunks { bundles = append(bundles, bc...) } return bundles }]}
{Id:4 FileId:116 StartLine:73 StartColumn:1 EndLine:79 EndColumn:2 Name:chunkRectangles Params:[{Name:slice Type:rtree.Rectangles} {Name:numParts Type:int64}] Results:[{Name: Type:[]rtree.Rectangles}] Receiver:<nil> Body:{
	parts := make([]rtree.Rectangles, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = slice[i*int64(len(slice))/numParts : (i+1)*int64(len(slice))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]rtree.Rectangles, numParts) for i := int64(0); i < numParts; i++ { parts[i] = slice[i*int64(len(slice))/numParts : (i+1)*int64(len(slice))/numParts] } return parts }]}
{Id:0 FileId:10 StartLine:19 StartColumn:1 EndLine:71 EndColumn:2 Name:andSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	max := maxInt64(int64(len(sba.indices)), int64(len(other.indices)))
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	var resultBlock block

	for {
		if selfIndex == len(sba.indices) || otherIndex == len(other.indices) {

			break
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch {
		case otherValue < selfValue:

			otherIndex++

		case otherValue > selfValue:

			selfIndex++

		default:

			resultBlock = sba.blocks[selfIndex].and(other.blocks[otherIndex])
			if resultBlock > 0 {
				indices = append(indices, selfValue)
				blocks = append(blocks, resultBlock)
			}
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ max := maxInt64(int64(len(sba.indices)), int64(len(other.indices))) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 var resultBlock block for { if selfIndex == len(sba.indices) || otherIndex == len(other.indices) { break } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch { case otherValue < selfValue: otherIndex++ case otherValue > selfValue: selfIndex++ default: resultBlock = sba.blocks[selfIndex].and(other.blocks[otherIndex]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]}
{Id:1 FileId:10 StartLine:73 StartColumn:1 EndLine:119 EndColumn:2 Name:andSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if other.IsEmpty() {
		return newSparseBitArray()
	}

	ba := sba.copy()

	for selfIndex, selfValue := range ba.indices {

		if selfValue >= uint64(len(other.blocks)) {

			ba.blocks = ba.blocks[:selfIndex-1]
			ba.indices = ba.indices[:selfIndex-1]

			break
		}
		ba.blocks[selfIndex] = ba.blocks[selfIndex].and(
			other.blocks[selfValue])

	}

	for i := 0; i < len(ba.blocks); i++ {
		if ba.blocks[i] == 0 {
			ba.blocks.deleteAtIndex(int64(i))
			ba.indices.deleteAtIndex(int64(i))
			i--
		}
	}

	return ba
} PrettyPrintBody:[{ if other.IsEmpty() { return newSparseBitArray() } ba := sba.copy() for selfIndex, selfValue := range ba.indices { if selfValue >= uint64(len(other.blocks)) { ba.blocks = ba.blocks[:selfIndex-1] ba.indices = ba.indices[:selfIndex-1] break } ba.blocks[selfIndex] = ba.blocks[selfIndex].and( other.blocks[selfValue]) } for i := 0; i < len(ba.blocks); i++ { if ba.blocks[i] == 0 { ba.blocks.deleteAtIndex(int64(i)) ba.indices.deleteAtIndex(int64(i)) i-- } } return ba }]}
{Id:2 FileId:10 StartLine:121 StartColumn:1 EndLine:134 EndColumn:2 Name:andDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	min := minUint64(uint64(len(dba.blocks)), uint64(len(other.blocks)))

	ba := newBitArray(min * s)

	for i := uint64(0); i < min; i++ {
		ba.blocks[i] = dba.blocks[i].and(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ min := minUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))) ba := newBitArray(min * s) for i := uint64(0); i < min; i++ { ba.blocks[i] = dba.blocks[i].and(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]}
{Id:2 FileId:38 StartLine:38 StartColumn:1 EndLine:51 EndColumn:2 Name:asyncLoadNode Params:[{Name:t Type:*Tr} {Name:key Type:ID} {Name:completer Type:chan interface{}}] Results:[] Receiver:0xc001226fe0 Body:{
	n, err := c.loadNode(t, key)
	if err != nil {
		completer <- err
		return
	}

	if n == nil {
		completer <- ErrNodeNotFound
		return
	}

	completer <- n
} PrettyPrintBody:[{ n, err := c.loadNode(t, key) if err != nil { completer <- err return } if n == nil { completer <- ErrNodeNotFound return } completer <- n }]}
{Id:3 FileId:38 StartLine:54 StartColumn:1 EndLine:59 EndColumn:2 Name:clear Params:[] Results:[] Receiver:0xc000c56320 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()

	c.cache = make(map[string]*futures.Future, 10)
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() c.cache = make(map[string]*futures.Future, 10) }]}
{Id:4 FileId:38 StartLine:63 StartColumn:1 EndLine:68 EndColumn:2 Name:deleteFromCache Params:[{Name:id Type:ID}] Results:[] Receiver:0xc001308e00 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()

	delete(c.cache, string(id))
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() delete(c.cache, string(id)) }]}
{Id:5 FileId:38 StartLine:70 StartColumn:1 EndLine:82 EndColumn:2 Name:loadNode Params:[{Name:t Type:*Tr} {Name:key Type:ID}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc001032d80 Body:{
	items, err := c.persister.Load(key)
	if err != nil {
		return nil, err
	}

	n, err := nodeFromBytes(t, items[0].Payload)
	if err != nil {
		return nil, err
	}

	return n, nil
} PrettyPrintBody:[{ items, err := c.persister.Load(key) if err != nil { return nil, err } n, err := nodeFromBytes(t, items[0].Payload) if err != nil { return nil, err } return n, nil }]}
{Id:6 FileId:38 StartLine:88 StartColumn:1 EndLine:124 EndColumn:2 Name:getNode Params:[{Name:t Type:*Tr} {Name:key Type:ID} {Name:useCache Type:bool}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc0015810c0 Body:{
	if !useCache {
		return c.loadNode(t, key)
	}

	c.lock.Lock()
	future, ok := c.cache[string(key)]
	if ok {
		c.lock.Unlock()
		ifc, err := future.GetResult()
		if err != nil {
			return nil, err
		}

		return ifc.(*Node), nil
	}

	completer := make(chan interface{}, 1)
	future = futures.New(completer, 30*time.Second)
	c.cache[string(key)] = future
	c.lock.Unlock()

	go c.asyncLoadNode(t, key, completer)

	ifc, err := future.GetResult()
	if err != nil {
		c.deleteFromCache(key)
		return nil, err
	}

	if err, ok := ifc.(error); ok {
		c.deleteFromCache(key)
		return nil, err
	}

	return ifc.(*Node), nil
} PrettyPrintBody:[{ if !useCache { return c.loadNode(t, key) } c.lock.Lock() future, ok := c.cache[string(key)] if ok { c.lock.Unlock() ifc, err := future.GetResult() if err != nil { return nil, err } return ifc.(*Node), nil } completer := make(chan interface{}, 1) future = futures.New(completer, 30*time.Second) c.cache[string(key)] = future c.lock.Unlock() go c.asyncLoadNode(t, key, completer) ifc, err := future.GetResult() if err != nil { c.deleteFromCache(key) return nil, err } if err, ok := ifc.(error); ok { c.deleteFromCache(key) return nil, err } return ifc.(*Node), nil }]}
{Id:7 FileId:38 StartLine:128 StartColumn:1 EndLine:133 EndColumn:2 Name:newCacher Params:[{Name:persister Type:Persister}] Results:[{Name: Type:*cacher}] Receiver:<nil> Body:{
	return &cacher{
		persister:	persister,
		cache:		make(map[string]*futures.Future, 10),
	}
} PrettyPrintBody:[{ return &cacher{ persister:	persister, cache:		make(map[string]*futures.Future, 10), } }]}
{Id:3 FileId:77 StartLine:52 StartColumn:1 EndLine:57 EndColumn:2 Name:V Params:[] Results:[{Name: Type:int}] Receiver:0xc001308820 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	return g.v
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() return g.v }]}
{Id:4 FileId:77 StartLine:60 StartColumn:1 EndLine:65 EndColumn:2 Name:E Params:[] Results:[{Name: Type:int}] Receiver:0xc000e57ca0 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	return g.e
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() return g.e }]}
{Id:5 FileId:77 StartLine:68 StartColumn:1 EndLine:87 EndColumn:2 Name:AddEdge Params:[{Name:v Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc001032e20 Body:{
	g.mutex.Lock()
	defer g.mutex.Unlock()

	if v == w {
		return ErrSelfLoop
	}

	g.addVertex(v)
	g.addVertex(w)

	if _, ok := g.adjacencyList[v][w]; ok {
		return ErrParallelEdge
	}

	g.adjacencyList[v][w] = struct{}{}
	g.adjacencyList[w][v] = struct{}{}
	g.e++
	return nil
} PrettyPrintBody:[{ g.mutex.Lock() defer g.mutex.Unlock() if v == w { return ErrSelfLoop } g.addVertex(v) g.addVertex(w) if _, ok := g.adjacencyList[v][w]; ok { return ErrParallelEdge } g.adjacencyList[v][w] = struct{}{} g.adjacencyList[w][v] = struct{}{} g.e++ return nil }]}
{Id:6 FileId:77 StartLine:90 StartColumn:1 EndLine:106 EndColumn:2 Name:Adj Params:[{Name:v Type:interface{}}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc000bb7580 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	deg, err := g.Degree(v)
	if err != nil {
		return nil, ErrVertexNotFound
	}

	adj := make([]interface{}, deg)
	i := 0
	for key := range g.adjacencyList[v] {
		adj[i] = key
		i++
	}
	return adj, nil
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() deg, err := g.Degree(v) if err != nil { return nil, ErrVertexNotFound } adj := make([]interface{}, deg) i := 0 for key := range g.adjacencyList[v] { adj[i] = key i++ } return adj, nil }]}
{Id:7 FileId:77 StartLine:109 StartColumn:1 EndLine:118 EndColumn:2 Name:Degree Params:[{Name:v Type:interface{}}] Results:[{Name: Type:int} {Name: Type:error}] Receiver:0xc000f53420 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	val, ok := g.adjacencyList[v]
	if !ok {
		return 0, ErrVertexNotFound
	}
	return len(val), nil
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() val, ok := g.adjacencyList[v] if !ok { return 0, ErrVertexNotFound } return len(val), nil }]}
{Id:8 FileId:77 StartLine:120 StartColumn:1 EndLine:127 EndColumn:2 Name:addVertex Params:[{Name:v Type:interface{}}] Results:[] Receiver:0xc000f536e0 Body:{
	mm, ok := g.adjacencyList[v]
	if !ok {
		mm = make(map[interface{}]struct{})
		g.adjacencyList[v] = mm
		g.v++
	}
} PrettyPrintBody:[{ mm, ok := g.adjacencyList[v] if !ok { mm = make(map[interface{}]struct{}) g.adjacencyList[v] = mm g.v++ } }]}
{Id:9 FileId:77 StartLine:130 StartColumn:1 EndLine:136 EndColumn:2 Name:NewSimpleGraph Params:[] Results:[{Name: Type:*SimpleGraph}] Receiver:<nil> Body:{
	return &SimpleGraph{
		adjacencyList:	make(map[interface{}]map[interface{}]struct{}),
		v:		0,
		e:		0,
	}
} PrettyPrintBody:[{ return &SimpleGraph{ adjacencyList:	make(map[interface{}]map[interface{}]struct{}), v:		0, e:		0, } }]}
{Id:1 FileId:136 StartLine:9 StartColumn:1 EndLine:17 EndColumn:2 Name:TestMultiThreadedSortEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(10)
	comparators = reverseComparators(comparators)

	result := MultithreadedSortComparators(comparators)
	comparators = reverseComparators(comparators)

	assert.Equal(t, comparators, result)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(10) comparators = reverseComparators(comparators) result := MultithreadedSortComparators(comparators) comparators = reverseComparators(comparators) assert.Equal(t, comparators, result) }]}
{Id:2 FileId:136 StartLine:19 StartColumn:1 EndLine:27 EndColumn:2 Name:TestMultiThreadedSortOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(9)
	comparators = reverseComparators(comparators)

	result := MultithreadedSortComparators(comparators)
	comparators = reverseComparators(comparators)

	assert.Equal(t, comparators, result)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(9) comparators = reverseComparators(comparators) result := MultithreadedSortComparators(comparators) comparators = reverseComparators(comparators) assert.Equal(t, comparators, result) }]}
{Id:3 FileId:136 StartLine:29 StartColumn:1 EndLine:39 EndColumn:2 Name:BenchmarkMultiThreadedSort Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numCells := 100000

	comparators := constructOrderedMockComparators(numCells)
	comparators = reverseComparators(comparators)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		MultithreadedSortComparators(comparators)
	}
} PrettyPrintBody:[{ numCells := 100000 comparators := constructOrderedMockComparators(numCells) comparators = reverseComparators(comparators) b.ResetTimer() for i := 0; i < b.N; i++ { MultithreadedSortComparators(comparators) } }]}
{Id:0 FileId:25 StartLine:19 StartColumn:1 EndLine:74 EndColumn:2 Name:orSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	if len(other.indices) == 0 {
		return sba.copy()
	}

	if len(sba.indices) == 0 {
		return other.copy()
	}

	max := maxInt64(int64(len(sba.indices)), int64(len(other.indices)))
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	for {

		if selfIndex == len(sba.indices) && otherIndex == len(other.indices) {
			break
		} else if selfIndex == len(sba.indices) {
			indices = append(indices, other.indices[otherIndex:]...)
			blocks = append(blocks, other.blocks[otherIndex:]...)
			break
		} else if otherIndex == len(other.indices) {
			indices = append(indices, sba.indices[selfIndex:]...)
			blocks = append(blocks, sba.blocks[selfIndex:]...)
			break
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch diff := int(otherValue) - int(selfValue); {
		case diff > 0:
			indices = append(indices, selfValue)
			blocks = append(blocks, sba.blocks[selfIndex])
			selfIndex++
		case diff < 0:
			indices = append(indices, otherValue)
			blocks = append(blocks, other.blocks[otherIndex])
			otherIndex++
		default:
			indices = append(indices, otherValue)
			blocks = append(blocks, sba.blocks[selfIndex].or(other.blocks[otherIndex]))
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ if len(other.indices) == 0 { return sba.copy() } if len(sba.indices) == 0 { return other.copy() } max := maxInt64(int64(len(sba.indices)), int64(len(other.indices))) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 for { if selfIndex == len(sba.indices) && otherIndex == len(other.indices) { break } else if selfIndex == len(sba.indices) { indices = append(indices, other.indices[otherIndex:]...) blocks = append(blocks, other.blocks[otherIndex:]...) break } else if otherIndex == len(other.indices) { indices = append(indices, sba.indices[selfIndex:]...) blocks = append(blocks, sba.blocks[selfIndex:]...) break } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch diff := int(otherValue) - int(selfValue); { case diff > 0: indices = append(indices, selfValue) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ case diff < 0: indices = append(indices, otherValue) blocks = append(blocks, other.blocks[otherIndex]) otherIndex++ default: indices = append(indices, otherValue) blocks = append(blocks, sba.blocks[selfIndex].or(other.blocks[otherIndex])) selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]}
{Id:1 FileId:25 StartLine:76 StartColumn:1 EndLine:119 EndColumn:2 Name:orSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if other.Capacity() == 0 || !other.anyset {
		return sba.copy()
	}

	if sba.Capacity() == 0 {
		return other.copy()
	}

	max := maxUint64(uint64(sba.Capacity()), uint64(other.Capacity()))

	ba := newBitArray(max * s)
	selfIndex := 0
	otherIndex := 0
	for {
		if selfIndex == len(sba.indices) && otherIndex == len(other.blocks) {
			break
		} else if selfIndex == len(sba.indices) {
			copy(ba.blocks[otherIndex:], other.blocks[otherIndex:])
			break
		} else if otherIndex == len(other.blocks) {
			for i, value := range sba.indices[selfIndex:] {
				ba.blocks[value] = sba.blocks[i+selfIndex]
			}
			break
		}

		selfValue := sba.indices[selfIndex]
		if selfValue == uint64(otherIndex) {
			ba.blocks[otherIndex] = sba.blocks[selfIndex].or(other.blocks[otherIndex])
			selfIndex++
			otherIndex++
			continue
		}

		ba.blocks[otherIndex] = other.blocks[otherIndex]
		otherIndex++
	}

	ba.setHighest()
	ba.setLowest()

	return ba
} PrettyPrintBody:[{ if other.Capacity() == 0 || !other.anyset { return sba.copy() } if sba.Capacity() == 0 { return other.copy() } max := maxUint64(uint64(sba.Capacity()), uint64(other.Capacity())) ba := newBitArray(max * s) selfIndex := 0 otherIndex := 0 for { if selfIndex == len(sba.indices) && otherIndex == len(other.blocks) { break } else if selfIndex == len(sba.indices) { copy(ba.blocks[otherIndex:], other.blocks[otherIndex:]) break } else if otherIndex == len(other.blocks) { for i, value := range sba.indices[selfIndex:] { ba.blocks[value] = sba.blocks[i+selfIndex] } break } selfValue := sba.indices[selfIndex] if selfValue == uint64(otherIndex) { ba.blocks[otherIndex] = sba.blocks[selfIndex].or(other.blocks[otherIndex]) selfIndex++ otherIndex++ continue } ba.blocks[otherIndex] = other.blocks[otherIndex] otherIndex++ } ba.setHighest() ba.setLowest() return ba }]}
{Id:2 FileId:25 StartLine:121 StartColumn:1 EndLine:152 EndColumn:2 Name:orDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if dba.Capacity() == 0 || !dba.anyset {
		return other.copy()
	}

	if other.Capacity() == 0 || !other.anyset {
		return dba.copy()
	}

	max := maxUint64(uint64(len(dba.blocks)), uint64(len(other.blocks)))

	ba := newBitArray(max * s)

	for i := uint64(0); i < max; i++ {
		if i == uint64(len(dba.blocks)) {
			copy(ba.blocks[i:], other.blocks[i:])
			break
		}

		if i == uint64(len(other.blocks)) {
			copy(ba.blocks[i:], dba.blocks[i:])
			break
		}

		ba.blocks[i] = dba.blocks[i].or(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ if dba.Capacity() == 0 || !dba.anyset { return other.copy() } if other.Capacity() == 0 || !other.anyset { return dba.copy() } max := maxUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))) ba := newBitArray(max * s) for i := uint64(0); i < max; i++ { if i == uint64(len(dba.blocks)) { copy(ba.blocks[i:], other.blocks[i:]) break } if i == uint64(len(other.blocks)) { copy(ba.blocks[i:], dba.blocks[i:]) break } ba.blocks[i] = dba.blocks[i].or(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]}
{Id:2 FileId:157 StartLine:29 StartColumn:1 EndLine:31 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0009f9fe0 Body:{
	return ew.key
} PrettyPrintBody:[{ return ew.key }]}
{Id:4 FileId:157 StartLine:43 StartColumn:1 EndLine:47 EndColumn:2 Name:search Params:[{Name:key Type:uint64}] Results:[{Name: Type:int}] Receiver:0xc000f2c040 Body:{
	return sort.Search(len(entries), func(i int) bool {
		return entries[i].Key() >= key
	})
} PrettyPrintBody:[{ return sort.Search(len(entries), func(i int) bool { return entries[i].Key() >= key }) }]}
{Id:5 FileId:157 StartLine:53 StartColumn:1 EndLine:71 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc0010323e0 Body:{
	i := entries.search(entry.Key())

	if i == len(*entries) {
		*entries = append(*entries, entry)
		return nil
	}

	if (*entries)[i].Key() == entry.Key() {
		oldEntry := (*entries)[i]
		(*entries)[i] = entry
		return oldEntry
	}

	(*entries) = append(*entries, nil)
	copy((*entries)[i+1:], (*entries)[i:])
	(*entries)[i] = entry
	return nil
} PrettyPrintBody:[{ i := entries.search(entry.Key()) if i == len(*entries) { *entries = append(*entries, entry) return nil } if (*entries)[i].Key() == entry.Key() { oldEntry := (*entries)[i] (*entries)[i] = entry return oldEntry } (*entries) = append(*entries, nil) copy((*entries)[i+1:], (*entries)[i:]) (*entries)[i] = entry return nil }]}
{Id:6 FileId:157 StartLine:76 StartColumn:1 EndLine:91 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc000f52200 Body:{
	i := entries.search(key)
	if i == len(*entries) {
		return nil
	}

	if (*entries)[i].Key() != key {
		return nil
	}

	oldEntry := (*entries)[i]
	copy((*entries)[i:], (*entries)[i+1:])
	(*entries)[len(*entries)-1] = nil
	*entries = (*entries)[:len(*entries)-1]
	return oldEntry
} PrettyPrintBody:[{ i := entries.search(key) if i == len(*entries) { return nil } if (*entries)[i].Key() != key { return nil } oldEntry := (*entries)[i] copy((*entries)[i:], (*entries)[i+1:]) (*entries)[len(*entries)-1] = nil *entries = (*entries)[:len(*entries)-1] return oldEntry }]}
{Id:7 FileId:157 StartLine:96 StartColumn:1 EndLine:102 EndColumn:2 Name:max Params:[] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc00095a2e0 Body:{
	if len(entries) == 0 {
		return 0, false
	}

	return entries[len(entries)-1].Key(), true
} PrettyPrintBody:[{ if len(entries) == 0 { return 0, false } return entries[len(entries)-1].Key(), true }]}
{Id:8 FileId:157 StartLine:107 StartColumn:1 EndLine:118 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc001409940 Body:{
	i := entries.search(key)
	if i == len(entries) {
		return nil
	}

	if entries[i].Key() == key {
		return entries[i]
	}

	return nil
} PrettyPrintBody:[{ i := entries.search(key) if i == len(entries) { return nil } if entries[i].Key() == key { return entries[i] } return nil }]}
{Id:9 FileId:157 StartLine:124 StartColumn:1 EndLine:131 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry} {Name: Type:int}] Receiver:0xc001580dc0 Body:{
	i := entries.search(key)
	if i == len(entries) {
		return nil, -1
	}

	return entries[i], i
} PrettyPrintBody:[{ i := entries.search(key) if i == len(entries) { return nil, -1 } return entries[i], i }]}
{Id:10 FileId:157 StartLine:137 StartColumn:1 EndLine:158 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry} {Name: Type:int}] Receiver:0xc0010de700 Body:{
	if len(entries) == 0 {
		return nil, -1
	}

	i := entries.search(key)
	if i == len(entries) {
		return entries[i-1], i - 1
	}

	if entries[i].Key() == key {
		return entries[i], i
	}

	i--

	if i < 0 {
		return nil, -1
	}

	return entries[i], i
} PrettyPrintBody:[{ if len(entries) == 0 { return nil, -1 } i := entries.search(key) if i == len(entries) { return entries[i-1], i - 1 } if entries[i].Key() == key { return entries[i], i } i-- if i < 0 { return nil, -1 } return entries[i], i }]}
{Id:1 FileId:98 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:roundUp Params:[{Name:v Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	v--
	v |= v >> 1
	v |= v >> 2
	v |= v >> 4
	v |= v >> 8
	v |= v >> 16
	v |= v >> 32
	v++
	return v
} PrettyPrintBody:[{ v-- v |= v >> 1 v |= v >> 2 v |= v >> 4 v |= v >> 8 v |= v >> 16 v |= v >> 32 v++ return v }]}
{Id:5 FileId:98 StartLine:63 StartColumn:1 EndLine:70 EndColumn:2 Name:init Params:[{Name:size Type:uint64}] Results:[] Receiver:0xc001033220 Body:{
	size = roundUp(size)
	rb.nodes = make(nodes, size)
	for i := uint64(0); i < size; i++ {
		rb.nodes[i] = node{position: i}
	}
	rb.mask = size - 1
} PrettyPrintBody:[{ size = roundUp(size) rb.nodes = make(nodes, size) for i := uint64(0); i < size; i++ { rb.nodes[i] = node{position: i} } rb.mask = size - 1 }]}
{Id:6 FileId:98 StartLine:75 StartColumn:1 EndLine:78 EndColumn:2 Name:Put Params:[{Name:item Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc0014095c0 Body:{
	_, err := rb.put(item, false)
	return err
} PrettyPrintBody:[{ _, err := rb.put(item, false) return err }]}
{Id:7 FileId:98 StartLine:83 StartColumn:1 EndLine:85 EndColumn:2 Name:Offer Params:[{Name:item Type:interface{}}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001247740 Body:{
	return rb.put(item, true)
} PrettyPrintBody:[{ return rb.put(item, true) }]}
{Id:8 FileId:98 StartLine:87 StartColumn:1 EndLine:119 EndColumn:2 Name:put Params:[{Name:item Type:interface{}} {Name:offer Type:bool}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001309520 Body:{
	var n *node
	pos := atomic.LoadUint64(&rb.queue)
L:
	for {
		if atomic.LoadUint64(&rb.disposed) == 1 {
			return false, ErrDisposed
		}

		n = &rb.nodes[pos&rb.mask]
		seq := atomic.LoadUint64(&n.position)
		switch dif := seq - pos; {
		case dif == 0:
			if atomic.CompareAndSwapUint64(&rb.queue, pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in a compromised state during a put operation.`)
		default:
			pos = atomic.LoadUint64(&rb.queue)
		}

		if offer {
			return false, nil
		}

		runtime.Gosched()
	}

	n.data = item
	atomic.StoreUint64(&n.position, pos+1)
	return true, nil
} PrettyPrintBody:[{ var n *node pos := atomic.LoadUint64(&rb.queue) L: for { if atomic.LoadUint64(&rb.disposed) == 1 { return false, ErrDisposed } n = &rb.nodes[pos&rb.mask] seq := atomic.LoadUint64(&n.position) switch dif := seq - pos; { case dif == 0: if atomic.CompareAndSwapUint64(&rb.queue, pos, pos+1) { break L } case dif < 0: panic(`Ring buffer in a compromised state during a put operation.`) default: pos = atomic.LoadUint64(&rb.queue) } if offer { return false, nil } runtime.Gosched() } n.data = item atomic.StoreUint64(&n.position, pos+1) return true, nil }]}
{Id:9 FileId:98 StartLine:125 StartColumn:1 EndLine:127 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001309660 Body:{
	return rb.Poll(0)
} PrettyPrintBody:[{ return rb.Poll(0) }]}
{Id:10 FileId:98 StartLine:134 StartColumn:1 EndLine:172 EndColumn:2 Name:Poll Params:[{Name:timeout Type:time.Duration}] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001602620 Body:{
	var (
		n	*node
		pos	= atomic.LoadUint64(&rb.dequeue)
		start	time.Time
	)
	if timeout > 0 {
		start = time.Now()
	}
L:
	for {
		if atomic.LoadUint64(&rb.disposed) == 1 {
			return nil, ErrDisposed
		}

		n = &rb.nodes[pos&rb.mask]
		seq := atomic.LoadUint64(&n.position)
		switch dif := seq - (pos + 1); {
		case dif == 0:
			if atomic.CompareAndSwapUint64(&rb.dequeue, pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in compromised state during a get operation.`)
		default:
			pos = atomic.LoadUint64(&rb.dequeue)
		}

		if timeout > 0 && time.Since(start) >= timeout {
			return nil, ErrTimeout
		}

		runtime.Gosched()
	}
	data := n.data
	n.data = nil
	atomic.StoreUint64(&n.position, pos+rb.mask+1)
	return data, nil
} PrettyPrintBody:[{ var ( n	*node pos	= atomic.LoadUint64(&rb.dequeue) start	time.Time ) if timeout > 0 { start = time.Now() } L: for { if atomic.LoadUint64(&rb.disposed) == 1 { return nil, ErrDisposed } n = &rb.nodes[pos&rb.mask] seq := atomic.LoadUint64(&n.position) switch dif := seq - (pos + 1); { case dif == 0: if atomic.CompareAndSwapUint64(&rb.dequeue, pos, pos+1) { break L } case dif < 0: panic(`Ring buffer in compromised state during a get operation.`) default: pos = atomic.LoadUint64(&rb.dequeue) } if timeout > 0 && time.Since(start) >= timeout { return nil, ErrTimeout } runtime.Gosched() } data := n.data n.data = nil atomic.StoreUint64(&n.position, pos+rb.mask+1) return data, nil }]}
{Id:11 FileId:98 StartLine:175 StartColumn:1 EndLine:177 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001309e80 Body:{
	return atomic.LoadUint64(&rb.queue) - atomic.LoadUint64(&rb.dequeue)
} PrettyPrintBody:[{ return atomic.LoadUint64(&rb.queue) - atomic.LoadUint64(&rb.dequeue) }]}
{Id:12 FileId:98 StartLine:180 StartColumn:1 EndLine:182 EndColumn:2 Name:Cap Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0011d7380 Body:{
	return uint64(len(rb.nodes))
} PrettyPrintBody:[{ return uint64(len(rb.nodes)) }]}
{Id:13 FileId:98 StartLine:187 StartColumn:1 EndLine:189 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc000a8a600 Body:{
	atomic.CompareAndSwapUint64(&rb.disposed, 0, 1)
} PrettyPrintBody:[{ atomic.CompareAndSwapUint64(&rb.disposed, 0, 1) }]}
{Id:14 FileId:98 StartLine:193 StartColumn:1 EndLine:195 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000a8a640 Body:{
	return atomic.LoadUint64(&rb.disposed) == 1
} PrettyPrintBody:[{ return atomic.LoadUint64(&rb.disposed) == 1 }]}
{Id:15 FileId:98 StartLine:199 StartColumn:1 EndLine:203 EndColumn:2 Name:NewRingBuffer Params:[{Name:size Type:uint64}] Results:[{Name: Type:*RingBuffer}] Receiver:<nil> Body:{
	rb := &RingBuffer{}
	rb.init(size)
	return rb
} PrettyPrintBody:[{ rb := &RingBuffer{} rb.init(size) return rb }]}
{Id:1 FileId:19 StartLine:25 StartColumn:1 EndLine:47 EndColumn:2 Name:TestSparseBitArraySerialization Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outBytes, err := input.Serialize()
	assert.Equal(t, err, nil)

	assert.Equal(t, len(outBytes), 337)
	assert.True(t, outBytes[0] == 'S')
	expected := []byte{83, 20, 0, 0, 0, 0, 0, 0, 0, 73}
	assert.Equal(t, expected, outBytes[:10])

	output := newSparseBitArray()
	err = output.Deserialize(outBytes)
	assert.Equal(t, err, nil)
	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newSparseBitArray() for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outBytes, err := input.Serialize() assert.Equal(t, err, nil) assert.Equal(t, len(outBytes), 337) assert.True(t, outBytes[0] == 'S') expected := []byte{83, 20, 0, 0, 0, 0, 0, 0, 0, 73} assert.Equal(t, expected, outBytes[:10]) output := newSparseBitArray() err = output.Deserialize(outBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]}
{Id:2 FileId:19 StartLine:49 StartColumn:1 EndLine:73 EndColumn:2 Name:TestBitArraySerialization Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outBytes, err := input.Serialize()
	assert.Equal(t, err, nil)

	assert.Equal(t, len(outBytes), 178)

	expected := []byte{66, 0, 0, 0, 0, 0, 0, 0, 0, 254}
	assert.Equal(t, expected, outBytes[:10])

	output := newBitArray(0)
	err = output.Deserialize(outBytes)
	assert.Equal(t, err, nil)
	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outBytes, err := input.Serialize() assert.Equal(t, err, nil) assert.Equal(t, len(outBytes), 178) expected := []byte{66, 0, 0, 0, 0, 0, 0, 0, 0, 254} assert.Equal(t, expected, outBytes[:10]) output := newBitArray(0) err = output.Deserialize(outBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]}
{Id:3 FileId:19 StartLine:75 StartColumn:1 EndLine:94 EndColumn:2 Name:TestBitArrayMarshalUnmarshal Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)
	assert.Equal(t, err, nil)
	assert.Equal(t, outputBytes[0], byte('B'))
	assert.Equal(t, len(outputBytes), 178)

	output, err := Unmarshal(outputBytes)
	assert.Equal(t, err, nil)

	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) assert.Equal(t, err, nil) assert.Equal(t, outputBytes[0], byte('B')) assert.Equal(t, len(outputBytes), 178) output, err := Unmarshal(outputBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]}
{Id:4 FileId:19 StartLine:96 StartColumn:1 EndLine:115 EndColumn:2 Name:TestSparseBitArrayMarshalUnmarshal Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)
	assert.Equal(t, err, nil)
	assert.Equal(t, outputBytes[0], byte('S'))
	assert.Equal(t, len(outputBytes), 337)

	output, err := Unmarshal(outputBytes)
	assert.Equal(t, err, nil)

	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newSparseBitArray() for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) assert.Equal(t, err, nil) assert.Equal(t, outputBytes[0], byte('S')) assert.Equal(t, len(outputBytes), 337) output, err := Unmarshal(outputBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]}
{Id:5 FileId:19 StartLine:117 StartColumn:1 EndLine:138 EndColumn:2 Name:TestUnmarshalErrors Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)

	outputBytes[0] = 'C'

	output, err := Unmarshal(outputBytes)
	assert.Error(t, err)
	assert.Equal(t, output, nil)

	output, err = Unmarshal(nil)
	assert.Error(t, err)
	assert.Equal(t, output, nil)
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) outputBytes[0] = 'C' output, err := Unmarshal(outputBytes) assert.Error(t, err) assert.Equal(t, output, nil) output, err = Unmarshal(nil) assert.Error(t, err) assert.Equal(t, output, nil) }]}
{Id:1 FileId:153 StartLine:25 StartColumn:1 EndLine:59 EndColumn:2 Name:TestIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	iter := &Iterator{
		first: true,
	}

	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e1 := newMockEntry(5)
	n1 := newNode(nil, e1)
	iter = &Iterator{
		first:	true,
		n:	n1,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e2 := newMockEntry(10)
	n2 := newNode(nil, e2)
	n1.children[1] = n2

	iter = &Iterator{
		first:	true,
		n:	n1,
	}

	assert.True(t, iter.Next())
	assert.True(t, iter.Next())
	assert.Equal(t, e2, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())
} PrettyPrintBody:[{ iter := &Iterator{ first: true, } assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e1 := newMockEntry(5) n1 := newNode(nil, e1) iter = &Iterator{ first:	true, n:	n1, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e2 := newMockEntry(10) n2 := newNode(nil, e2) n1.children[1] = n2 iter = &Iterator{ first:	true, n:	n1, } assert.True(t, iter.Next()) assert.True(t, iter.Next()) assert.Equal(t, e2, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) }]}
{Id:4 FileId:51 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc000fa7f20 Body:{
	ga.completer.Done()
} PrettyPrintBody:[{ ga.completer.Done() }]}
{Id:5 FileId:51 StartLine:46 StartColumn:1 EndLine:48 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc00095ac40 Body:{
	return get
} PrettyPrintBody:[{ return get }]}
{Id:6 FileId:51 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001308f00 Body:{
	return ga.result
} PrettyPrintBody:[{ return ga.result }]}
{Id:7 FileId:51 StartLine:54 StartColumn:1 EndLine:56 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc000e5bb80 Body:{
	return
} PrettyPrintBody:[{ return }]}
{Id:8 FileId:51 StartLine:58 StartColumn:1 EndLine:60 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001308f40 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:9 FileId:51 StartLine:62 StartColumn:1 EndLine:71 EndColumn:2 Name:newGetAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*getAction}] Receiver:<nil> Body:{
	result := make(common.Comparators, len(keys))
	copy(result, keys)
	ga := &getAction{
		result:		result,
		completer:	new(sync.WaitGroup),
	}
	ga.completer.Add(1)
	return ga
} PrettyPrintBody:[{ result := make(common.Comparators, len(keys)) copy(result, keys) ga := &getAction{ result:		result, completer:	new(sync.WaitGroup), } ga.completer.Add(1) return ga }]}
{Id:11 FileId:51 StartLine:79 StartColumn:1 EndLine:81 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc001409600 Body:{
	ia.completer.Done()
} PrettyPrintBody:[{ ia.completer.Done() }]}
{Id:12 FileId:51 StartLine:83 StartColumn:1 EndLine:85 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc001409720 Body:{
	return add
} PrettyPrintBody:[{ return add }]}
{Id:13 FileId:51 StartLine:87 StartColumn:1 EndLine:89 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001409760 Body:{
	return ia.result
} PrettyPrintBody:[{ return ia.result }]}
{Id:14 FileId:51 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001309680 Body:{
	ia.ns[i] = n
} PrettyPrintBody:[{ ia.ns[i] = n }]}
{Id:15 FileId:51 StartLine:95 StartColumn:1 EndLine:97 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc0013096e0 Body:{
	return ia.ns
} PrettyPrintBody:[{ return ia.ns }]}
{Id:16 FileId:51 StartLine:99 StartColumn:1 EndLine:109 EndColumn:2 Name:newInsertAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*insertAction}] Receiver:<nil> Body:{
	result := make(common.Comparators, len(keys))
	copy(result, keys)
	ia := &insertAction{
		result:		result,
		completer:	new(sync.WaitGroup),
		ns:		make([]*node, len(keys)),
	}
	ia.completer.Add(1)
	return ia
} PrettyPrintBody:[{ result := make(common.Comparators, len(keys)) copy(result, keys) ia := &insertAction{ result:		result, completer:	new(sync.WaitGroup), ns:		make([]*node, len(keys)), } ia.completer.Add(1) return ia }]}
{Id:18 FileId:51 StartLine:115 StartColumn:1 EndLine:117 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc001409d60 Body:{
	return remove
} PrettyPrintBody:[{ return remove }]}
{Id:19 FileId:51 StartLine:119 StartColumn:1 EndLine:123 EndColumn:2 Name:newRemoveAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*removeAction}] Receiver:<nil> Body:{
	return &removeAction{
		newInsertAction(keys),
	}
} PrettyPrintBody:[{ return &removeAction{ newInsertAction(keys), } }]}
{Id:21 FileId:51 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0010df320 Body:{
	return apply
} PrettyPrintBody:[{ return apply }]}
{Id:22 FileId:51 StartLine:135 StartColumn:1 EndLine:137 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001033bc0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:23 FileId:51 StartLine:139 StartColumn:1 EndLine:139 EndColumn:52 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001602860 Body:{
} PrettyPrintBody:[{ }]}
{Id:24 FileId:51 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc0016028e0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:25 FileId:51 StartLine:145 StartColumn:1 EndLine:147 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc001309e20 Body:{
	aa.completer.Done()
} PrettyPrintBody:[{ aa.completer.Done() }]}
{Id:26 FileId:51 StartLine:149 StartColumn:1 EndLine:158 EndColumn:2 Name:newApplyAction Params:[{Name:fn Type:func(common.Comparator) bool} {Name:start Type:common.Comparator}] Results:[{Name: Type:*applyAction}] Receiver:<nil> Body:{
	aa := &applyAction{
		fn:		fn,
		start:		start,
		stop:		stop,
		completer:	new(sync.WaitGroup),
	}
	aa.completer.Add(1)
	return aa
} PrettyPrintBody:[{ aa := &applyAction{ fn:		fn, start:		start, stop:		stop, completer:	new(sync.WaitGroup), } aa.completer.Add(1) return aa }]}
{Id:27 FileId:51 StartLine:160 StartColumn:1 EndLine:169 EndColumn:2 Name:minUint64 Params:[{Name:choices Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	min := choices[0]
	for i := 1; i < len(choices); i++ {
		if choices[i] < min {
			min = choices[i]
		}
	}

	return min
} PrettyPrintBody:[{ min := choices[0] for i := 1; i < len(choices); i++ { if choices[i] < min { min = choices[i] } } return min }]}
{Id:29 FileId:51 StartLine:173 StartColumn:1 EndLine:205 EndColumn:2 Name:executeInterfacesInParallel Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	done := int64(-1)
	numCPU := uint64(runtime.NumCPU())
	if numCPU > 1 {
		numCPU--
	}

	numCPU = minUint64(numCPU, uint64(len(ifs)))

	var wg sync.WaitGroup
	wg.Add(int(numCPU))

	for i := uint64(0); i < numCPU; i++ {
		go func() {
			defer wg.Done()

			for {
				i := atomic.AddInt64(&done, 1)
				if i >= int64(len(ifs)) {
					return
				}

				fn(ifs[i])
			}
		}()
	}

	wg.Wait()
} PrettyPrintBody:[{ if len(ifs) == 0 { return } done := int64(-1) numCPU := uint64(runtime.NumCPU()) if numCPU > 1 { numCPU-- } numCPU = minUint64(numCPU, uint64(len(ifs))) var wg sync.WaitGroup wg.Add(int(numCPU)) for i := uint64(0); i < numCPU; i++ { go func() { defer wg.Done() for { i := atomic.AddInt64(&done, 1) if i >= int64(len(ifs)) { return } fn(ifs[i]) } }() } wg.Wait() }]}
{Id:30 FileId:51 StartLine:207 StartColumn:1 EndLine:215 EndColumn:2 Name:executeInterfacesInSerial Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	for _, ifc := range ifs {
		fn(ifc)
	}
} PrettyPrintBody:[{ if len(ifs) == 0 { return } for _, ifc := range ifs { fn(ifc) } }]}
{Id:4 FileId:115 StartLine:44 StartColumn:1 EndLine:46 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc000aeb220 Body:{
	ga.completer.Done()
} PrettyPrintBody:[{ ga.completer.Done() }]}
{Id:5 FileId:115 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc000aeb280 Body:{
	return get
} PrettyPrintBody:[{ return get }]}
{Id:6 FileId:115 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:hilberts}] Receiver:0xc00123cbe0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:7 FileId:115 StartLine:56 StartColumn:1 EndLine:58 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001580320 Body:{
	return
} PrettyPrintBody:[{ return }]}
{Id:8 FileId:115 StartLine:60 StartColumn:1 EndLine:62 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001580ac0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:9 FileId:115 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:rects Params:[] Results:[{Name: Type:[]*hilbertBundle}] Receiver:0xc001580b00 Body:{
	return []*hilbertBundle{&hilbertBundle{}}
} PrettyPrintBody:[{ return []*hilbertBundle{&hilbertBundle{}} }]}
{Id:10 FileId:115 StartLine:68 StartColumn:1 EndLine:76 EndColumn:2 Name:newGetAction Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:*getAction}] Receiver:<nil> Body:{
	r := newRectangeFromRect(rect)
	ga := &getAction{
		completer:	new(sync.WaitGroup),
		lookup:		r,
	}
	ga.completer.Add(1)
	return ga
} PrettyPrintBody:[{ r := newRectangeFromRect(rect) ga := &getAction{ completer:	new(sync.WaitGroup), lookup:		r, } ga.completer.Add(1) return ga }]}
{Id:12 FileId:115 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc0012ce0c0 Body:{
	ia.completer.Done()
} PrettyPrintBody:[{ ia.completer.Done() }]}
{Id:13 FileId:115 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0012ce760 Body:{
	return add
} PrettyPrintBody:[{ return add }]}
{Id:14 FileId:115 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:hilberts}] Receiver:0xc001409a60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:15 FileId:115 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc000a8a000 Body:{
	ia.ns[i] = n
} PrettyPrintBody:[{ ia.ns[i] = n }]}
{Id:16 FileId:115 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc000a8a040 Body:{
	return ia.ns
} PrettyPrintBody:[{ return ia.ns }]}
{Id:17 FileId:115 StartLine:104 StartColumn:1 EndLine:106 EndColumn:2 Name:rects Params:[] Results:[{Name: Type:[]*hilbertBundle}] Receiver:0xc000a8a080 Body:{
	return ia.rs
} PrettyPrintBody:[{ return ia.rs }]}
{Id:18 FileId:115 StartLine:108 StartColumn:1 EndLine:116 EndColumn:2 Name:newInsertAction Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*insertAction}] Receiver:<nil> Body:{
	ia := &insertAction{
		rs:		bundlesFromRects(rects...),
		completer:	new(sync.WaitGroup),
		ns:		make([]*node, len(rects)),
	}
	ia.completer.Add(1)
	return ia
} PrettyPrintBody:[{ ia := &insertAction{ rs:		bundlesFromRects(rects...), completer:	new(sync.WaitGroup), ns:		make([]*node, len(rects)), } ia.completer.Add(1) return ia }]}
{Id:20 FileId:115 StartLine:122 StartColumn:1 EndLine:124 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0013098e0 Body:{
	return remove
} PrettyPrintBody:[{ return remove }]}
{Id:21 FileId:115 StartLine:126 StartColumn:1 EndLine:130 EndColumn:2 Name:newRemoveAction Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*removeAction}] Receiver:<nil> Body:{
	return &removeAction{
		newInsertAction(rects),
	}
} PrettyPrintBody:[{ return &removeAction{ newInsertAction(rects), } }]}
{Id:22 FileId:115 StartLine:132 StartColumn:1 EndLine:141 EndColumn:2 Name:minUint64 Params:[{Name:choices Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	min := choices[0]
	for i := 1; i < len(choices); i++ {
		if choices[i] < min {
			min = choices[i]
		}
	}

	return min
} PrettyPrintBody:[{ min := choices[0] for i := 1; i < len(choices); i++ { if choices[i] < min { min = choices[i] } } return min }]}
{Id:24 FileId:115 StartLine:145 StartColumn:1 EndLine:177 EndColumn:2 Name:executeInterfacesInParallel Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	done := int64(-1)
	numCPU := uint64(runtime.NumCPU())
	if numCPU > 1 {
		numCPU--
	}

	numCPU = minUint64(numCPU, uint64(len(ifs)))

	var wg sync.WaitGroup
	wg.Add(int(numCPU))

	for i := uint64(0); i < numCPU; i++ {
		go func() {
			defer wg.Done()

			for {
				i := atomic.AddInt64(&done, 1)
				if i >= int64(len(ifs)) {
					return
				}

				fn(ifs[i])
			}
		}()
	}

	wg.Wait()
} PrettyPrintBody:[{ if len(ifs) == 0 { return } done := int64(-1) numCPU := uint64(runtime.NumCPU()) if numCPU > 1 { numCPU-- } numCPU = minUint64(numCPU, uint64(len(ifs))) var wg sync.WaitGroup wg.Add(int(numCPU)) for i := uint64(0); i < numCPU; i++ { go func() { defer wg.Done() for { i := atomic.AddInt64(&done, 1) if i >= int64(len(ifs)) { return } fn(ifs[i]) } }() } wg.Wait() }]}
{Id:25 FileId:115 StartLine:179 StartColumn:1 EndLine:187 EndColumn:2 Name:executeInterfacesInSerial Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	for _, ifc := range ifs {
		fn(ifc)
	}
} PrettyPrintBody:[{ if len(ifs) == 0 { return } for _, ifc := range ifs { fn(ifc) } }]}
{Id:1 FileId:149 StartLine:35 StartColumn:1 EndLine:40 EndColumn:2 Name:TestDefaultHasher Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert.Equal(t,
		defaultHasher(map[int]string{11234: "foo"}),
		defaultHasher(map[int]string{11234: "foo"}))
	assert.NotEqual(t, defaultHasher("foo"), defaultHasher("bar"))
} PrettyPrintBody:[{ assert.Equal(t, defaultHasher(map[int]string{11234: "foo"}), defaultHasher(map[int]string{11234: "foo"})) assert.NotEqual(t, defaultHasher("foo"), defaultHasher("bar")) }]}
{Id:2 FileId:149 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:collisionHash Params:[{Name:key Type:interface{}}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	return uint32(0xffffffff)
} PrettyPrintBody:[{ return uint32(0xffffffff) }]}
{Id:3 FileId:149 StartLine:46 StartColumn:1 EndLine:49 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	insertTest(t, defaultHasher, 10000)
	insertTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ insertTest(t, defaultHasher, 10000) insertTest(t, collisionHash, 1000) }]}
{Id:4 FileId:149 StartLine:51 StartColumn:1 EndLine:57 EndColumn:2 Name:insertTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := emptyNode(0, 32)
	for i := 0; i < count; i++ {
		n = insert(n, &entry{hashfunc(i), i, i})
	}
	return n
} PrettyPrintBody:[{ n := emptyNode(0, 32) for i := 0; i < count; i++ { n = insert(n, &entry{hashfunc(i), i, i}) } return n }]}
{Id:5 FileId:149 StartLine:59 StartColumn:1 EndLine:62 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	getTest(t, defaultHasher, 10000)
	getTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ getTest(t, defaultHasher, 10000) getTest(t, collisionHash, 1000) }]}
{Id:6 FileId:149 StartLine:64 StartColumn:1 EndLine:70 EndColumn:2 Name:getTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		x := get(n, hashfunc(i), i)
		assert.Equal(t, i, x.Value())
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { x := get(n, hashfunc(i), i) assert.Equal(t, i, x.Value()) } }]}
{Id:7 FileId:149 StartLine:72 StartColumn:1 EndLine:75 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	removeTest(t, defaultHasher, 10000)
	removeTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ removeTest(t, defaultHasher, 10000) removeTest(t, collisionHash, 1000) }]}
{Id:8 FileId:149 StartLine:77 StartColumn:1 EndLine:87 EndColumn:2 Name:removeTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		n = remove(n, hashfunc(i), i)
	}
	for _, e := range n.entries {
		if e != nil {
			t.Fatal("final node is not empty")
		}
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { n = remove(n, hashfunc(i), i) } for _, e := range n.entries { if e != nil { t.Fatal("final node is not empty") } } }]}
{Id:9 FileId:149 StartLine:89 StartColumn:1 EndLine:92 EndColumn:2 Name:TestUpdate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	updateTest(t, defaultHasher, 10000)
	updateTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ updateTest(t, defaultHasher, 10000) updateTest(t, collisionHash, 1000) }]}
{Id:10 FileId:149 StartLine:94 StartColumn:1 EndLine:99 EndColumn:2 Name:updateTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		n = insert(n, &entry{hashfunc(i), i, -i})
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { n = insert(n, &entry{hashfunc(i), i, -i}) } }]}
{Id:11 FileId:149 StartLine:101 StartColumn:1 EndLine:129 EndColumn:2 Name:TestIterate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, defaultHasher, 10000)
	echan := iterate(n, nil)
	c := 0
	for _ = range echan {
		c++
	}
	assert.Equal(t, 10000, c)

	c = 0
	stop := make(chan struct{})
	echan = iterate(n, stop)
	for _ = range echan {
		c++
		if c == 100 {
			close(stop)
			break
		}
	}
	assert.True(t, c == 100)

	n = insertTest(t, collisionHash, 1000)
	c = 0
	echan = iterate(n, nil)
	for _ = range echan {
		c++
	}
	assert.Equal(t, 1000, c)
} PrettyPrintBody:[{ n := insertTest(t, defaultHasher, 10000) echan := iterate(n, nil) c := 0 for _ = range echan { c++ } assert.Equal(t, 10000, c) c = 0 stop := make(chan struct{}) echan = iterate(n, stop) for _ = range echan { c++ if c == 100 { close(stop) break } } assert.True(t, c == 100) n = insertTest(t, collisionHash, 1000) c = 0 echan = iterate(n, nil) for _ = range echan { c++ } assert.Equal(t, 1000, c) }]}
{Id:12 FileId:149 StartLine:131 StartColumn:1 EndLine:135 EndColumn:2 Name:TestSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, defaultHasher, 10000)
	d := &Dtrie{n, defaultHasher}
	assert.Equal(t, 10000, d.Size())
} PrettyPrintBody:[{ n := insertTest(t, defaultHasher, 10000) d := &Dtrie{n, defaultHasher} assert.Equal(t, 10000, d.Size()) }]}
{Id:13 FileId:149 StartLine:137 StartColumn:1 EndLine:144 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := emptyNode(0, 32)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = insert(n, &entry{defaultHasher(i), i, i})
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := emptyNode(0, 32) b.ResetTimer() for i := b.N; i > 0; i-- { n = insert(n, &entry{defaultHasher(i), i, i}) } }]}
{Id:14 FileId:149 StartLine:146 StartColumn:1 EndLine:153 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		get(n, defaultHasher(i), i)
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { get(n, defaultHasher(i), i) } }]}
{Id:15 FileId:149 StartLine:155 StartColumn:1 EndLine:162 EndColumn:2 Name:BenchmarkRemove Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = remove(n, defaultHasher(i), i)
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { n = remove(n, defaultHasher(i), i) } }]}
{Id:16 FileId:149 StartLine:164 StartColumn:1 EndLine:171 EndColumn:2 Name:BenchmarkUpdate Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = insert(n, &entry{defaultHasher(i), i, -i})
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { n = insert(n, &entry{defaultHasher(i), i, -i}) } }]}
{Id:1 FileId:158 StartLine:25 StartColumn:1 EndLine:40 EndColumn:2 Name:TestEntriesInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)

	es.insert(e1)
	es.insert(e2)

	assert.Equal(t, Entries{e2, e1}, es)

	e3 := newMockEntry(3)
	es.insert(e3)

	assert.Equal(t, Entries{e2, e3, e1}, es)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) assert.Equal(t, Entries{e2, e1}, es) e3 := newMockEntry(3) es.insert(e3) assert.Equal(t, Entries{e2, e3, e1}, es) }]}
{Id:2 FileId:158 StartLine:42 StartColumn:1 EndLine:55 EndColumn:2 Name:TestEntriesDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	es.delete(5)
	assert.Equal(t, Entries{e2}, es)

	es.delete(1)
	assert.Equal(t, Entries{}, es)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) es.delete(5) assert.Equal(t, Entries{e2}, es) es.delete(1) assert.Equal(t, Entries{}, es) }]}
{Id:3 FileId:158 StartLine:57 StartColumn:1 EndLine:74 EndColumn:2 Name:TestEntriesMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}
	max, ok := es.max()
	assert.Equal(t, uint64(0), max)
	assert.False(t, ok)

	e2 := newMockEntry(1)
	es.insert(e2)
	max, ok = es.max()
	assert.Equal(t, uint64(1), max)
	assert.True(t, ok)

	e1 := newMockEntry(5)
	es.insert(e1)
	max, ok = es.max()
	assert.Equal(t, uint64(5), max)
	assert.True(t, ok)
} PrettyPrintBody:[{ es := Entries{} max, ok := es.max() assert.Equal(t, uint64(0), max) assert.False(t, ok) e2 := newMockEntry(1) es.insert(e2) max, ok = es.max() assert.Equal(t, uint64(1), max) assert.True(t, ok) e1 := newMockEntry(5) es.insert(e1) max, ok = es.max() assert.Equal(t, uint64(5), max) assert.True(t, ok) }]}
{Id:4 FileId:158 StartLine:76 StartColumn:1 EndLine:92 EndColumn:2 Name:TestEntriesGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	result := es.get(5)
	assert.Equal(t, e1, result)

	result = es.get(1)
	assert.Equal(t, e2, result)

	result = es.get(10)
	assert.Nil(t, result)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) result := es.get(5) assert.Equal(t, e1, result) result = es.get(1) assert.Equal(t, e2, result) result = es.get(10) assert.Nil(t, result) }]}
{Id:5 FileId:158 StartLine:94 StartColumn:1 EndLine:121 EndColumn:2 Name:TestEntriesSuccessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	successor, i := es.successor(5)
	assert.Equal(t, -1, i)
	assert.Nil(t, successor)

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	successor, i = es.successor(0)
	assert.Equal(t, 0, i)
	assert.Equal(t, e2, successor)

	successor, i = es.successor(2)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, successor)

	successor, i = es.successor(5)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, successor)

	successor, i = es.successor(10)
	assert.Equal(t, -1, i)
	assert.Nil(t, successor)
} PrettyPrintBody:[{ es := Entries{} successor, i := es.successor(5) assert.Equal(t, -1, i) assert.Nil(t, successor) e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) successor, i = es.successor(0) assert.Equal(t, 0, i) assert.Equal(t, e2, successor) successor, i = es.successor(2) assert.Equal(t, 1, i) assert.Equal(t, e1, successor) successor, i = es.successor(5) assert.Equal(t, 1, i) assert.Equal(t, e1, successor) successor, i = es.successor(10) assert.Equal(t, -1, i) assert.Nil(t, successor) }]}
{Id:6 FileId:158 StartLine:123 StartColumn:1 EndLine:150 EndColumn:2 Name:TestEntriesPredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	predecessor, i := es.predecessor(5)
	assert.Equal(t, -1, i)
	assert.Nil(t, predecessor)

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	predecessor, i = es.predecessor(0)
	assert.Equal(t, -1, i)
	assert.Nil(t, predecessor)

	predecessor, i = es.predecessor(2)
	assert.Equal(t, 0, i)
	assert.Equal(t, e2, predecessor)

	predecessor, i = es.predecessor(5)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, predecessor)

	predecessor, i = es.predecessor(10)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, predecessor)
} PrettyPrintBody:[{ es := Entries{} predecessor, i := es.predecessor(5) assert.Equal(t, -1, i) assert.Nil(t, predecessor) e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) predecessor, i = es.predecessor(0) assert.Equal(t, -1, i) assert.Nil(t, predecessor) predecessor, i = es.predecessor(2) assert.Equal(t, 0, i) assert.Equal(t, e2, predecessor) predecessor, i = es.predecessor(5) assert.Equal(t, 1, i) assert.Equal(t, e1, predecessor) predecessor, i = es.predecessor(10) assert.Equal(t, 1, i) assert.Equal(t, e1, predecessor) }]}
{Id:3 FileId:123 StartLine:42 StartColumn:1 EndLine:50 EndColumn:2 Name:Add Params:[{Name:items Type:...interface{}}] Results:[] Receiver:0xc000d60520 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	set.flattened = nil
	for _, item := range items {
		set.items[item] = struct{}{}
	}
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() set.flattened = nil for _, item := range items { set.items[item] = struct{}{} } }]}
{Id:4 FileId:123 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:Remove Params:[{Name:items Type:...interface{}}] Results:[] Receiver:0xc001409480 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	set.flattened = nil
	for _, item := range items {
		delete(set.items, item)
	}
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() set.flattened = nil for _, item := range items { delete(set.items, item) } }]}
{Id:5 FileId:123 StartLine:64 StartColumn:1 EndLine:72 EndColumn:2 Name:Exists Params:[{Name:item Type:interface{}}] Results:[{Name: Type:bool}] Receiver:0xc000f52a60 Body:{
	set.lock.RLock()

	_, ok := set.items[item]

	set.lock.RUnlock()

	return ok
} PrettyPrintBody:[{ set.lock.RLock() _, ok := set.items[item] set.lock.RUnlock() return ok }]}
{Id:6 FileId:123 StartLine:75 StartColumn:1 EndLine:88 EndColumn:2 Name:Flatten Params:[] Results:[{Name: Type:[]interface{}}] Receiver:0xc0013093a0 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	if set.flattened != nil {
		return set.flattened
	}

	set.flattened = make([]interface{}, 0, len(set.items))
	for item := range set.items {
		set.flattened = append(set.flattened, item)
	}
	return set.flattened
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() if set.flattened != nil { return set.flattened } set.flattened = make([]interface{}, 0, len(set.items)) for item := range set.items { set.flattened = append(set.flattened, item) } return set.flattened }]}
{Id:7 FileId:123 StartLine:91 StartColumn:1 EndLine:99 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc001033620 Body:{
	set.lock.RLock()

	size := int64(len(set.items))

	set.lock.RUnlock()

	return size
} PrettyPrintBody:[{ set.lock.RLock() size := int64(len(set.items)) set.lock.RUnlock() return size }]}
{Id:8 FileId:123 StartLine:102 StartColumn:1 EndLine:108 EndColumn:2 Name:Clear Params:[] Results:[] Receiver:0xc001033640 Body:{
	set.lock.Lock()

	set.items = map[interface{}]struct{}{}

	set.lock.Unlock()
} PrettyPrintBody:[{ set.lock.Lock() set.items = map[interface{}]struct{}{} set.lock.Unlock() }]}
{Id:9 FileId:123 StartLine:111 StartColumn:1 EndLine:122 EndColumn:2 Name:All Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:bool}] Receiver:0xc00095a440 Body:{
	set.lock.RLock()
	defer set.lock.RUnlock()

	for _, item := range items {
		if _, ok := set.items[item]; !ok {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ set.lock.RLock() defer set.lock.RUnlock() for _, item := range items { if _, ok := set.items[item]; !ok { return false } } return true }]}
{Id:10 FileId:123 StartLine:125 StartColumn:1 EndLine:140 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc001309640 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	for k := range set.items {
		delete(set.items, k)
	}

	for i := 0; i < len(set.flattened); i++ {
		set.flattened[i] = nil
	}

	set.flattened = set.flattened[:0]
	pool.Put(set)
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() for k := range set.items { delete(set.items, k) } for i := 0; i < len(set.flattened); i++ { set.flattened[i] = nil } set.flattened = set.flattened[:0] pool.Put(set) }]}
{Id:11 FileId:123 StartLine:144 StartColumn:1 EndLine:155 EndColumn:2 Name:New Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:*Set}] Receiver:<nil> Body:{
	set := pool.Get().(*Set)
	for _, item := range items {
		set.items[item] = struct{}{}
	}

	if len(items) > 0 {
		set.flattened = nil
	}

	return set
} PrettyPrintBody:[{ set := pool.Get().(*Set) for _, item := range items { set.items[item] = struct{}{} } if len(items) > 0 { set.flattened = nil } return set }]}
{Id:12 FileId:123 StartLine:157 StartColumn:1 EndLine:163 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	pool.New = func() interface{} {
		return &Set{
			items: make(map[interface{}]struct{}, 10),
		}
	}
} PrettyPrintBody:[{ pool.New = func() interface{} { return &Set{ items: make(map[interface{}]struct{}, 10), } } }]}
{Id:2 FileId:8 StartLine:33 StartColumn:1 EndLine:35 EndColumn:2 Name:newMutex Params:[] Results:[{Name: Type:*mutex}] Receiver:<nil> Body:{
	return &mutex{lock: make(chan struct{}, 1)}
} PrettyPrintBody:[{ return &mutex{lock: make(chan struct{}, 1)} }]}
{Id:3 FileId:8 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Lock Params:[] Results:[] Receiver:0xc001580c40 Body:{
	m.lock <- struct{}{}
} PrettyPrintBody:[{ m.lock <- struct{}{} }]}
{Id:4 FileId:8 StartLine:41 StartColumn:1 EndLine:43 EndColumn:2 Name:Unlock Params:[] Results:[] Receiver:0xc001580c60 Body:{
	<-m.lock
} PrettyPrintBody:[{ <-m.lock }]}
{Id:5 FileId:8 StartLine:45 StartColumn:1 EndLine:52 EndColumn:2 Name:TryLock Params:[] Results:[{Name: Type:bool}] Receiver:0xc000bb68c0 Body:{
	select {
	case m.lock <- struct{}{}:
		return true
	default:
		return false
	}
} PrettyPrintBody:[{ select { case m.lock <- struct{}{}: return true default: return false } }]}
{Id:10 FileId:8 StartLine:104 StartColumn:1 EndLine:118 EndColumn:2 Name:New Params:[{Name:maxTime Type:time.Duration} {Name:maxItems Type:uint} {Name:calculate Type:CalculateBytes}] Results:[{Name: Type:Batcher} {Name: Type:error}] Receiver:<nil> Body:{
	if maxBytes > 0 && calculate == nil {
		return nil, errors.New("batcher: must provide CalculateBytes function")
	}

	return &basicBatcher{
		maxTime:	maxTime,
		maxItems:	maxItems,
		maxBytes:	maxBytes,
		calculateBytes:	calculate,
		items:		make([]interface{}, 0, maxItems),
		batchChan:	make(chan []interface{}, queueLen),
		lock:		newMutex(),
	}, nil
} PrettyPrintBody:[{ if maxBytes > 0 && calculate == nil { return nil, errors.New("batcher: must provide CalculateBytes function") } return &basicBatcher{ maxTime:	maxTime, maxItems:	maxItems, maxBytes:	maxBytes, calculateBytes:	calculate, items:		make([]interface{}, 0, maxItems), batchChan:	make(chan []interface{}, queueLen), lock:		newMutex(), }, nil }]}
{Id:11 FileId:8 StartLine:121 StartColumn:1 EndLine:142 EndColumn:2 Name:Put Params:[{Name:item Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc0014098e0 Body:{
	b.lock.Lock()
	if b.disposed {
		b.lock.Unlock()
		return ErrDisposed
	}

	b.items = append(b.items, item)
	if b.calculateBytes != nil {
		b.availableBytes += b.calculateBytes(item)
	}
	if b.ready() {

		b.flush()
	}

	b.lock.Unlock()
	return nil
} PrettyPrintBody:[{ b.lock.Lock() if b.disposed { b.lock.Unlock() return ErrDisposed } b.items = append(b.items, item) if b.calculateBytes != nil { b.availableBytes += b.calculateBytes(item) } if b.ready() { b.flush() } b.lock.Unlock() return nil }]}
{Id:12 FileId:8 StartLine:146 StartColumn:1 EndLine:210 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc001409900 Body:{

	var timeout <-chan time.Time
	if b.maxTime > 0 {
		timeout = time.After(b.maxTime)
	}

	select {
	case items, ok := <-b.batchChan:

		if !ok {
			return nil, ErrDisposed
		}
		return items, nil
	case <-timeout:

		for {
			if b.lock.TryLock() {

				select {
				case items, ok := <-b.batchChan:
					b.lock.Unlock()
					if !ok {
						return nil, ErrDisposed
					}
					return items, nil
				default:
				}

				items := b.items
				b.items = make([]interface{}, 0, b.maxItems)
				b.availableBytes = 0
				b.lock.Unlock()
				return items, nil
			} else {

				select {
				case items, ok := <-b.batchChan:
					if !ok {
						return nil, ErrDisposed
					}
					return items, nil
				default:
				}
			}
		}
	}
} PrettyPrintBody:[{ var timeout <-chan time.Time if b.maxTime > 0 { timeout = time.After(b.maxTime) } select { case items, ok := <-b.batchChan: if !ok { return nil, ErrDisposed } return items, nil case <-timeout: for { if b.lock.TryLock() { select { case items, ok := <-b.batchChan: b.lock.Unlock() if !ok { return nil, ErrDisposed } return items, nil default: } items := b.items b.items = make([]interface{}, 0, b.maxItems) b.availableBytes = 0 b.lock.Unlock() return items, nil } else { select { case items, ok := <-b.batchChan: if !ok { return nil, ErrDisposed } return items, nil default: } } } } }]}
{Id:13 FileId:8 StartLine:213 StartColumn:1 EndLine:223 EndColumn:2 Name:Flush Params:[] Results:[{Name: Type:error}] Receiver:0xc000992060 Body:{

	b.lock.Lock()
	if b.disposed {
		b.lock.Unlock()
		return ErrDisposed
	}
	b.flush()
	b.lock.Unlock()
	return nil
} PrettyPrintBody:[{ b.lock.Lock() if b.disposed { b.lock.Unlock() return ErrDisposed } b.flush() b.lock.Unlock() return nil }]}
{Id:14 FileId:8 StartLine:229 StartColumn:1 EndLine:254 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0011d74a0 Body:{
	for {
		if b.lock.TryLock() {

			if b.disposed {
				b.lock.Unlock()
				return
			}

			b.disposed = true
			b.items = nil
			b.drainBatchChan()
			close(b.batchChan)
			b.lock.Unlock()
		} else {

			b.drainBatchChan()
		}

	}
} PrettyPrintBody:[{ for { if b.lock.TryLock() { if b.disposed { b.lock.Unlock() return } b.disposed = true b.items = nil b.drainBatchChan() close(b.batchChan) b.lock.Unlock() } else { b.drainBatchChan() } } }]}
{Id:15 FileId:8 StartLine:257 StartColumn:1 EndLine:262 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000992960 Body:{
	b.lock.Lock()
	disposed := b.disposed
	b.lock.Unlock()
	return disposed
} PrettyPrintBody:[{ b.lock.Lock() disposed := b.disposed b.lock.Unlock() return disposed }]}
{Id:16 FileId:8 StartLine:266 StartColumn:1 EndLine:270 EndColumn:2 Name:flush Params:[] Results:[] Receiver:0xc001033c20 Body:{
	b.batchChan <- b.items
	b.items = make([]interface{}, 0, b.maxItems)
	b.availableBytes = 0
} PrettyPrintBody:[{ b.batchChan <- b.items b.items = make([]interface{}, 0, b.maxItems) b.availableBytes = 0 }]}
{Id:17 FileId:8 StartLine:272 StartColumn:1 EndLine:280 EndColumn:2 Name:ready Params:[] Results:[{Name: Type:bool}] Receiver:0xc001033d60 Body:{
	if b.maxItems != 0 && uint(len(b.items)) >= b.maxItems {
		return true
	}
	if b.maxBytes != 0 && b.availableBytes >= b.maxBytes {
		return true
	}
	return false
} PrettyPrintBody:[{ if b.maxItems != 0 && uint(len(b.items)) >= b.maxItems { return true } if b.maxBytes != 0 && b.availableBytes >= b.maxBytes { return true } return false }]}
{Id:18 FileId:8 StartLine:282 StartColumn:1 EndLine:290 EndColumn:2 Name:drainBatchChan Params:[] Results:[] Receiver:0xc001033d80 Body:{
	for {
		select {
		case <-b.batchChan:
		default:
			return
		}
	}
} PrettyPrintBody:[{ for { select { case <-b.batchChan: default: return } } }]}
{Id:1 FileId:11 StartLine:26 StartColumn:1 EndLine:35 EndColumn:2 Name:checkBit Params:[{Name:t Type:*testing.T} {Name:ba Type:BitArray} {Name:position Type:uint64} {Name:expected Type:bool}] Results:[] Receiver:<nil> Body:{
	ok, err := ba.GetBit(position)
	if assert.NoError(t, err) {
		if expected {
			assert.True(t, ok, "Bitarray at position %d should be set", position)
		} else {
			assert.False(t, ok, "Bitarray at position %d should be unset", position)
		}
	}
} PrettyPrintBody:[{ ok, err := ba.GetBit(position) if assert.NoError(t, err) { if expected { assert.True(t, ok, "Bitarray at position %d should be set", position) } else { assert.False(t, ok, "Bitarray at position %d should be unset", position) } } }]}
{Id:2 FileId:11 StartLine:37 StartColumn:1 EndLine:76 EndColumn:2 Name:TestAndSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(3)
	sba.SetBit(280)
	other.SetBit(9)
	other.SetBit(100)
	sba.SetBit(1000)
	other.SetBit(1001)

	sba.SetBit(1)
	other.SetBit(1)
	sba.SetBit(2680)
	other.SetBit(2680)
	sba.SetBit(30)
	other.SetBit(30)

	ba := andSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 30, true)
	checkBit(t, ba, 2680, true)

	checkBit(t, ba, 3, false)
	checkBit(t, ba, 280, false)
	checkBit(t, ba, 1000, false)

	checkBit(t, ba, 9, false)
	checkBit(t, ba, 100, false)
	checkBit(t, ba, 2, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{1, 30, 2680}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(3) sba.SetBit(280) other.SetBit(9) other.SetBit(100) sba.SetBit(1000) other.SetBit(1001) sba.SetBit(1) other.SetBit(1) sba.SetBit(2680) other.SetBit(2680) sba.SetBit(30) other.SetBit(30) ba := andSparseWithSparseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 30, true) checkBit(t, ba, 2680, true) checkBit(t, ba, 3, false) checkBit(t, ba, 280, false) checkBit(t, ba, 1000, false) checkBit(t, ba, 9, false) checkBit(t, ba, 100, false) checkBit(t, ba, 2, false) nums := ba.ToNums() assert.Equal(t, []uint64{1, 30, 2680}, nums) }]}
{Id:3 FileId:11 StartLine:78 StartColumn:1 EndLine:104 EndColumn:2 Name:TestAndSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(300)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := andSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 150, true)
	checkBit(t, ba, 300, true)

	checkBit(t, ba, 155, false)

	checkBit(t, ba, 156, false)

} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(300) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 150, true) checkBit(t, ba, 300, true) checkBit(t, ba, 155, false) checkBit(t, ba, 156, false) }]}
{Id:4 FileId:11 StartLine:108 StartColumn:1 EndLine:137 EndColumn:2 Name:TestAndSparseWithSmallerDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(512)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	sba.SetBit(500)

	other.SetBit(128)
	sba.SetBit(1500)
	sba.SetBit(1200)

	ba := andSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 150, true)

	checkBit(t, ba, 155, false)
	checkBit(t, ba, 500, false)
	checkBit(t, ba, 1200, false)
	checkBit(t, ba, 1500, false)

	checkBit(t, ba, 128, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(512) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) sba.SetBit(500) other.SetBit(128) sba.SetBit(1500) sba.SetBit(1200) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 150, true) checkBit(t, ba, 155, false) checkBit(t, ba, 500, false) checkBit(t, ba, 1200, false) checkBit(t, ba, 1500, false) checkBit(t, ba, 128, false) }]}
{Id:5 FileId:11 StartLine:139 StartColumn:1 EndLine:163 EndColumn:2 Name:TestAndDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	dba.SetBit(1)
	other.SetBit(18)
	dba.SetBit(222)
	other.SetBit(222)
	other.SetBit(1501)

	ba := andDenseWithDenseBitArray(dba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 1, false)
	checkBit(t, ba, 3, false)
	checkBit(t, ba, 18, false)
	checkBit(t, ba, 222, true)

	_, err := ba.GetBit(1500)
	assert.Equal(t, OutOfRangeError(1500), err)
	_, err = ba.GetBit(1501)
	assert.Equal(t, OutOfRangeError(1501), err)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) dba.SetBit(1) other.SetBit(18) dba.SetBit(222) other.SetBit(222) other.SetBit(1501) ba := andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 1, false) checkBit(t, ba, 3, false) checkBit(t, ba, 18, false) checkBit(t, ba, 222, true) _, err := ba.GetBit(1500) assert.Equal(t, OutOfRangeError(1500), err) _, err = ba.GetBit(1501) assert.Equal(t, OutOfRangeError(1501), err) }]}
{Id:6 FileId:11 StartLine:165 StartColumn:1 EndLine:176 EndColumn:2 Name:TestAndSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	ba := andSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 5, false)
	checkBit(t, ba, 100, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) ba := andSparseWithSparseBitArray(sba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 5, false) checkBit(t, ba, 100, false) }]}
{Id:7 FileId:11 StartLine:178 StartColumn:1 EndLine:191 EndColumn:2 Name:TestAndSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	ba := andSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)

	sba.Reset()
	other.SetBit(5)

	ba = andSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) sba.Reset() other.SetBit(5) ba = andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) }]}
{Id:8 FileId:11 StartLine:193 StartColumn:1 EndLine:205 EndColumn:2 Name:TestAndDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	ba := andDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)

	dba.Reset()
	other.SetBit(5)
	ba = andDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) ba := andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) dba.Reset() other.SetBit(5) ba = andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) }]}
{Id:1 FileId:88 StartLine:25 StartColumn:1 EndLine:49 EndColumn:2 Name:TestHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	h := Encode(0, 0)
	x, y := Decode(h)
	assert.Equal(t, int64(0), h)
	assert.Equal(t, int32(0), x)
	assert.Equal(t, int32(0), y)

	h = Encode(1, 0)
	x, y = Decode(h)
	assert.Equal(t, int64(3), h)
	assert.Equal(t, int32(1), x)
	assert.Equal(t, int32(0), y)

	h = Encode(1, 1)
	x, y = Decode(h)
	assert.Equal(t, int64(2), h)
	assert.Equal(t, int32(1), x)
	assert.Equal(t, int32(1), y)

	h = Encode(0, 1)
	x, y = Decode(h)
	assert.Equal(t, int64(1), h)
	assert.Equal(t, int32(0), x)
	assert.Equal(t, int32(1), y)
} PrettyPrintBody:[{ h := Encode(0, 0) x, y := Decode(h) assert.Equal(t, int64(0), h) assert.Equal(t, int32(0), x) assert.Equal(t, int32(0), y) h = Encode(1, 0) x, y = Decode(h) assert.Equal(t, int64(3), h) assert.Equal(t, int32(1), x) assert.Equal(t, int32(0), y) h = Encode(1, 1) x, y = Decode(h) assert.Equal(t, int64(2), h) assert.Equal(t, int32(1), x) assert.Equal(t, int32(1), y) h = Encode(0, 1) x, y = Decode(h) assert.Equal(t, int64(1), h) assert.Equal(t, int32(0), x) assert.Equal(t, int32(1), y) }]}
{Id:2 FileId:88 StartLine:51 StartColumn:1 EndLine:57 EndColumn:2 Name:TestHilbertAtMaxRange Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	x, y := int32(math.MaxInt32), int32(math.MaxInt32)
	h := Encode(x, y)
	resultx, resulty := Decode(h)
	assert.Equal(t, x, resultx)
	assert.Equal(t, y, resulty)
} PrettyPrintBody:[{ x, y := int32(math.MaxInt32), int32(math.MaxInt32) h := Encode(x, y) resultx, resulty := Decode(h) assert.Equal(t, x, resultx) assert.Equal(t, y, resulty) }]}
{Id:3 FileId:88 StartLine:59 StartColumn:1 EndLine:63 EndColumn:2 Name:BenchmarkEncode Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		Encode(int32(i), int32(i))
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { Encode(int32(i), int32(i)) } }]}
{Id:4 FileId:88 StartLine:65 StartColumn:1 EndLine:69 EndColumn:2 Name:BenchmarkDecode Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		Decode(int64(i))
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { Decode(int64(i)) } }]}
{Id:1 FileId:137 StartLine:11 StartColumn:1 EndLine:23 EndColumn:2 Name:symSearch Params:[{Name:u Type:Comparators}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	start, stop, p := 0, len(u), len(w)-1
	for start < stop {
		mid := (start + stop) / 2
		if u[mid].Compare(w[p-mid]) <= 0 {
			start = mid + 1
		} else {
			stop = mid
		}
	}

	return start
} PrettyPrintBody:[{ start, stop, p := 0, len(u), len(w)-1 for start < stop { mid := (start + stop) / 2 if u[mid].Compare(w[p-mid]) <= 0 { start = mid + 1 } else { stop = mid } } return start }]}
{Id:2 FileId:137 StartLine:28 StartColumn:1 EndLine:32 EndColumn:2 Name:swap Params:[{Name:u Type:Comparators} {Name:index Type:int}] Results:[] Receiver:<nil> Body:{
	for i := index; i < len(u); i++ {
		u[i], w[i-index] = w[i-index], u[i]
	}
} PrettyPrintBody:[{ for i := index; i < len(u); i++ { u[i], w[i-index] = w[i-index], u[i] } }]}
{Id:3 FileId:137 StartLine:38 StartColumn:1 EndLine:51 EndColumn:2 Name:decomposeForSymMerge Params:[{Name:length Type:int} {Name:comparators Type:Comparators}] Results:[{Name:v1 Type:Comparators} {Name:w Type:Comparators} {Name:v2 Type:Comparators}] Receiver:<nil> Body:{

	if length >= len(comparators) {
		panic(`INCORRECT PARAMS FOR SYM MERGE.`)
	}

	overhang := (len(comparators) - length) / 2
	v1 = comparators[:overhang]
	w = comparators[overhang : overhang+length]
	v2 = comparators[overhang+length:]
	return
} PrettyPrintBody:[{ if length >= len(comparators) { panic(`INCORRECT PARAMS FOR SYM MERGE.`) } overhang := (len(comparators) - length) / 2 v1 = comparators[:overhang] w = comparators[overhang : overhang+length] v2 = comparators[overhang+length:] return }]}
{Id:4 FileId:137 StartLine:55 StartColumn:1 EndLine:66 EndColumn:2 Name:symBinarySearch Params:[{Name:u Type:Comparators} {Name:start Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	for start < stop {
		mid := (start + stop) / 2
		if u[mid].Compare(u[total-mid]) <= 0 {
			start = mid + 1
		} else {
			stop = mid
		}
	}

	return start
} PrettyPrintBody:[{ for start < stop { mid := (start + stop) / 2 if u[mid].Compare(u[total-mid]) <= 0 { start = mid + 1 } else { stop = mid } } return start }]}
{Id:5 FileId:137 StartLine:71 StartColumn:1 EndLine:75 EndColumn:2 Name:symSwap Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < end; i++ {
		u[start1+i], u[start2+i] = u[start2+i], u[start1+i]
	}
} PrettyPrintBody:[{ for i := 0; i < end; i++ { u[start1+i], u[start2+i] = u[start2+i], u[start1+i] } }]}
{Id:6 FileId:137 StartLine:79 StartColumn:1 EndLine:106 EndColumn:2 Name:symRotate Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	i := start2 - start1
	if i == 0 {
		return
	}

	j := end - start2
	if j == 0 {
		return
	}

	if i == j {
		symSwap(u, start1, start2, i)
		return
	}

	p := start1 + i
	for i != j {
		if i > j {
			symSwap(u, p-i, p, j)
			i -= j
		} else {
			symSwap(u, p-i, p+j-i, i)
			j -= i
		}
	}
	symSwap(u, p-i, p, i)
} PrettyPrintBody:[{ i := start2 - start1 if i == 0 { return } j := end - start2 if j == 0 { return } if i == j { symSwap(u, start1, start2, i) return } p := start1 + i for i != j { if i > j { symSwap(u, p-i, p, j) i -= j } else { symSwap(u, p-i, p+j-i, i) j -= i } } symSwap(u, p-i, p, i) }]}
{Id:7 FileId:137 StartLine:109 StartColumn:1 EndLine:125 EndColumn:2 Name:symMerge Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	if start1 < start2 && start2 < last {
		mid := (start1 + last) / 2
		n := mid + start2
		var start int
		if start2 > mid {
			start = symBinarySearch(u, n-last, mid, n-1)
		} else {
			start = symBinarySearch(u, start1, start2, n-1)
		}
		end := n - start

		symRotate(u, start, start2, end)
		symMerge(u, start1, start, mid)
		symMerge(u, mid, end, last)
	}
} PrettyPrintBody:[{ if start1 < start2 && start2 < last { mid := (start1 + last) / 2 n := mid + start2 var start int if start2 > mid { start = symBinarySearch(u, n-last, mid, n-1) } else { start = symBinarySearch(u, start1, start2, n-1) } end := n - start symRotate(u, start, start2, end) symMerge(u, start1, start, mid) symMerge(u, mid, end, last) } }]}
{Id:8 FileId:137 StartLine:133 StartColumn:1 EndLine:170 EndColumn:2 Name:SymMerge Params:[{Name:u Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	lenU, lenW := len(u), len(w)
	if lenU == 0 {
		return w
	}

	if lenW == 0 {
		return u
	}

	diff := lenU - lenW
	if math.Abs(float64(diff)) > 1 {
		u1, w1, u2, w2 := prepareForSymMerge(u, w)

		lenU1 := len(u1)
		lenU2 := len(u2)
		u = append(u1, w1...)
		w = append(u2, w2...)
		var wg sync.WaitGroup
		wg.Add(2)
		go func() {
			symMerge(u, 0, lenU1, len(u))
			wg.Done()
		}()
		go func() {
			symMerge(w, 0, lenU2, len(w))
			wg.Done()
		}()

		wg.Wait()
		u = append(u, w...)
		return u
	}

	u = append(u, w...)
	symMerge(u, 0, lenU, len(u))
	return u
} PrettyPrintBody:[{ lenU, lenW := len(u), len(w) if lenU == 0 { return w } if lenW == 0 { return u } diff := lenU - lenW if math.Abs(float64(diff)) > 1 { u1, w1, u2, w2 := prepareForSymMerge(u, w) lenU1 := len(u1) lenU2 := len(u2) u = append(u1, w1...) w = append(u2, w2...) var wg sync.WaitGroup wg.Add(2) go func() { symMerge(u, 0, lenU1, len(u)) wg.Done() }() go func() { symMerge(w, 0, lenU2, len(w)) wg.Done() }() wg.Wait() u = append(u, w...) return u } u = append(u, w...) symMerge(u, 0, lenU, len(u)) return u }]}
{Id:9 FileId:137 StartLine:179 StartColumn:1 EndLine:196 EndColumn:2 Name:prepareForSymMerge Params:[{Name:u Type:Comparators}] Results:[{Name:u1 Type:Comparators}] Receiver:<nil> Body:{
	if u.Len() > w.Len() {
		u, w = w, u
	}
	v1, w, v2 := decomposeForSymMerge(len(u), w)

	i := symSearch(u, w)

	u1 = make(Comparators, i)
	copy(u1, u[:i])
	w1 = append(v1, w[:len(w)-i]...)

	u2 = make(Comparators, len(u)-i)
	copy(u2, u[i:])

	w2 = append(w[len(w)-i:], v2...)
	return
} PrettyPrintBody:[{ if u.Len() > w.Len() { u, w = w, u } v1, w, v2 := decomposeForSymMerge(len(u), w) i := symSearch(u, w) u1 = make(Comparators, i) copy(u1, u[:i]) w1 = append(v1, w[:len(w)-i]...) u2 = make(Comparators, len(u)-i) copy(u2, u[i:]) w2 = append(w[len(w)-i:], v2...) return }]}
{Id:4 FileId:83 StartLine:82 StartColumn:1 EndLine:84 EndColumn:2 Name:Head Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000eee560 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]}
{Id:5 FileId:83 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:Tail Params:[] Results:[{Name: Type:PersistentList} {Name: Type:bool}] Receiver:0xc001602120 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]}
{Id:6 FileId:83 StartLine:93 StartColumn:1 EndLine:95 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001602160 Body:{
	return true
} PrettyPrintBody:[{ return true }]}
{Id:7 FileId:83 StartLine:98 StartColumn:1 EndLine:100 EndColumn:2 Name:Length Params:[] Results:[{Name: Type:uint}] Receiver:0xc001308a00 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:8 FileId:83 StartLine:103 StartColumn:1 EndLine:105 EndColumn:2 Name:Add Params:[{Name:head Type:interface{}}] Results:[{Name: Type:PersistentList}] Receiver:0xc001308a60 Body:{
	return &list{head, e}
} PrettyPrintBody:[{ return &list{head, e} }]}
{Id:9 FileId:83 StartLine:109 StartColumn:1 EndLine:114 EndColumn:2 Name:Insert Params:[{Name:val Type:interface{}} {Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc001580940 Body:{
	if pos == 0 {
		return e.Add(val), nil
	}
	return nil, ErrEmptyList
} PrettyPrintBody:[{ if pos == 0 { return e.Add(val), nil } return nil, ErrEmptyList }]}
{Id:10 FileId:83 StartLine:118 StartColumn:1 EndLine:120 EndColumn:2 Name:Get Params:[{Name:pos Type:uint}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc001308ea0 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]}
{Id:11 FileId:83 StartLine:124 StartColumn:1 EndLine:126 EndColumn:2 Name:Remove Params:[{Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc00095a040 Body:{
	return nil, ErrEmptyList
} PrettyPrintBody:[{ return nil, ErrEmptyList }]}
{Id:12 FileId:83 StartLine:130 StartColumn:1 EndLine:132 EndColumn:2 Name:Find Params:[{Name: Type:func(interface{}) bool}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0012471c0 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]}
{Id:13 FileId:83 StartLine:136 StartColumn:1 EndLine:138 EndColumn:2 Name:FindIndex Params:[{Name: Type:func(interface{}) bool}] Results:[{Name: Type:int}] Receiver:0xc001033320 Body:{
	return -1
} PrettyPrintBody:[{ return -1 }]}
{Id:14 FileId:83 StartLine:142 StartColumn:1 EndLine:144 EndColumn:2 Name:Map Params:[{Name: Type:func(interface{}) interface{}}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001580d60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:16 FileId:83 StartLine:153 StartColumn:1 EndLine:155 EndColumn:2 Name:Head Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000118800 Body:{
	return l.head, true
} PrettyPrintBody:[{ return l.head, true }]}
{Id:17 FileId:83 StartLine:159 StartColumn:1 EndLine:161 EndColumn:2 Name:Tail Params:[] Results:[{Name: Type:PersistentList} {Name: Type:bool}] Receiver:0xc000118820 Body:{
	return l.tail, true
} PrettyPrintBody:[{ return l.tail, true }]}
{Id:18 FileId:83 StartLine:164 StartColumn:1 EndLine:166 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc000118860 Body:{
	return false
} PrettyPrintBody:[{ return false }]}
{Id:19 FileId:83 StartLine:169 StartColumn:1 EndLine:180 EndColumn:2 Name:Length Params:[] Results:[{Name: Type:uint}] Receiver:0xc0001188c0 Body:{
	curr := l
	length := uint(0)
	for {
		length += 1
		tail, _ := curr.Tail()
		if tail.IsEmpty() {
			return length
		}
		curr = tail.(*list)
	}
} PrettyPrintBody:[{ curr := l length := uint(0) for { length += 1 tail, _ := curr.Tail() if tail.IsEmpty() { return length } curr = tail.(*list) } }]}
{Id:20 FileId:83 StartLine:183 StartColumn:1 EndLine:185 EndColumn:2 Name:Add Params:[{Name:head Type:interface{}}] Results:[{Name: Type:PersistentList}] Receiver:0xc001602600 Body:{
	return &list{head, l}
} PrettyPrintBody:[{ return &list{head, l} }]}
{Id:21 FileId:83 StartLine:189 StartColumn:1 EndLine:198 EndColumn:2 Name:Insert Params:[{Name:val Type:interface{}} {Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc0010dee60 Body:{
	if pos == 0 {
		return l.Add(val), nil
	}
	nl, err := l.tail.Insert(val, pos-1)
	if err != nil {
		return nil, err
	}
	return nl.Add(l.head), nil
} PrettyPrintBody:[{ if pos == 0 { return l.Add(val), nil } nl, err := l.tail.Insert(val, pos-1) if err != nil { return nil, err } return nl.Add(l.head), nil }]}
{Id:22 FileId:83 StartLine:202 StartColumn:1 EndLine:207 EndColumn:2 Name:Get Params:[{Name:pos Type:uint}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0003e4ee0 Body:{
	if pos == 0 {
		return l.head, true
	}
	return l.tail.Get(pos - 1)
} PrettyPrintBody:[{ if pos == 0 { return l.head, true } return l.tail.Get(pos - 1) }]}
{Id:23 FileId:83 StartLine:211 StartColumn:1 EndLine:222 EndColumn:2 Name:Remove Params:[{Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc0001e60a0 Body:{
	if pos == 0 {
		nl, _ := l.Tail()
		return nl, nil
	}

	nl, err := l.tail.Remove(pos - 1)
	if err != nil {
		return nil, err
	}
	return &list{l.head, nl}, nil
} PrettyPrintBody:[{ if pos == 0 { nl, _ := l.Tail() return nl, nil } nl, err := l.tail.Remove(pos - 1) if err != nil { return nil, err } return &list{l.head, nl}, nil }]}
{Id:24 FileId:83 StartLine:226 StartColumn:1 EndLine:231 EndColumn:2 Name:Find Params:[{Name:pred Type:func(interface{}) bool}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc001581580 Body:{
	if pred(l.head) {
		return l.head, true
	}
	return l.tail.Find(pred)
} PrettyPrintBody:[{ if pred(l.head) { return l.head, true } return l.tail.Find(pred) }]}
{Id:25 FileId:83 StartLine:235 StartColumn:1 EndLine:249 EndColumn:2 Name:FindIndex Params:[{Name:pred Type:func(interface{}) bool}] Results:[{Name: Type:int}] Receiver:0xc000993bc0 Body:{
	curr := l
	idx := 0
	for {
		if pred(curr.head) {
			return idx
		}
		tail, _ := curr.Tail()
		if tail.IsEmpty() {
			return -1
		}
		curr = tail.(*list)
		idx += 1
	}
} PrettyPrintBody:[{ curr := l idx := 0 for { if pred(curr.head) { return idx } tail, _ := curr.Tail() if tail.IsEmpty() { return -1 } curr = tail.(*list) idx += 1 } }]}
{Id:26 FileId:83 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:Map Params:[{Name:f Type:func(interface{}) interface{}}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001602ea0 Body:{
	return append(l.tail.Map(f), f(l.head))
} PrettyPrintBody:[{ return append(l.tail.Map(f), f(l.head)) }]}
{Id:2 FileId:162 StartLine:51 StartColumn:1 EndLine:67 EndColumn:2 Name:init Params:[{Name:intType Type:interface{}}] Results:[] Receiver:0xc001155120 Body:{
	switch intType.(type) {
	case uint8:
		yfast.bits = 8
	case uint16:
		yfast.bits = 16
	case uint32:
		yfast.bits = 32
	case uint, uint64:
		yfast.bits = 64
	default:

		panic(`Invalid universe size provided.`)
	}

	yfast.xfast = xfast.New(intType)
} PrettyPrintBody:[{ switch intType.(type) { case uint8: yfast.bits = 8 case uint16: yfast.bits = 16 case uint32: yfast.bits = 32 case uint, uint64: yfast.bits = 64 default: panic(`Invalid universe size provided.`) } yfast.xfast = xfast.New(intType) }]}
{Id:3 FileId:162 StartLine:71 StartColumn:1 EndLine:74 EndColumn:2 Name:getBucketKey Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:0xc001033040 Body:{
	i := key/uint64(yfast.bits) + 1
	return uint64(yfast.bits)*i - 1
} PrettyPrintBody:[{ i := key/uint64(yfast.bits) + 1 return uint64(yfast.bits)*i - 1 }]}
{Id:4 FileId:162 StartLine:76 StartColumn:1 EndLine:103 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001033160 Body:{

	bundleKey := yfast.getBucketKey(entry.Key())
	bundle := yfast.xfast.Get(bundleKey)

	if bundle != nil {
		overwritten := bundle.(*entriesWrapper).entries.insert(entry)
		if overwritten == nil {
			yfast.num++
			return nil
		}

		return overwritten
	}

	yfast.num++
	entries := make(Entries, 0, yfast.bits)
	entries.insert(entry)

	ew := &entriesWrapper{
		key:		bundleKey,
		entries:	entries,
	}

	yfast.xfast.Insert(ew)
	return nil
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(entry.Key()) bundle := yfast.xfast.Get(bundleKey) if bundle != nil { overwritten := bundle.(*entriesWrapper).entries.insert(entry) if overwritten == nil { yfast.num++ return nil } return overwritten } yfast.num++ entries := make(Entries, 0, yfast.bits) entries.insert(entry) ew := &entriesWrapper{ key:		bundleKey, entries:	entries, } yfast.xfast.Insert(ew) return nil }]}
{Id:5 FileId:162 StartLine:107 StartColumn:1 EndLine:114 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0013099e0 Body:{
	overwritten := make(Entries, 0, len(entries))
	for _, e := range entries {
		overwritten = append(overwritten, yfast.insert(e))
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(Entries, 0, len(entries)) for _, e := range entries { overwritten = append(overwritten, yfast.insert(e)) } return overwritten }]}
{Id:6 FileId:162 StartLine:116 StartColumn:1 EndLine:137 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0015810a0 Body:{
	bundleKey := yfast.getBucketKey(key)

	bundle := yfast.xfast.Get(bundleKey)
	if bundle == nil {
		return nil
	}

	ew := bundle.(*entriesWrapper)
	entry := ew.entries.delete(key)
	if entry == nil {
		return nil
	}

	yfast.num--

	if len(ew.entries) == 0 {
		yfast.xfast.Delete(bundleKey)
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Get(bundleKey) if bundle == nil { return nil } ew := bundle.(*entriesWrapper) entry := ew.entries.delete(key) if entry == nil { return nil } yfast.num-- if len(ew.entries) == 0 { yfast.xfast.Delete(bundleKey) } return entry }]}
{Id:7 FileId:162 StartLine:141 StartColumn:1 EndLine:148 EndColumn:2 Name:Delete Params:[{Name:keys Type:...uint64}] Results:[{Name: Type:Entries}] Receiver:0xc001309c00 Body:{
	entries := make(Entries, 0, len(keys))
	for _, key := range keys {
		entries = append(entries, yfast.delete(key))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, len(keys)) for _, key := range keys { entries = append(entries, yfast.delete(key)) } return entries }]}
{Id:8 FileId:162 StartLine:150 StartColumn:1 EndLine:163 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0016027c0 Body:{
	bundleKey := yfast.getBucketKey(key)
	bundle := yfast.xfast.Get(bundleKey)
	if bundle == nil {
		return nil
	}

	entry := bundle.(*entriesWrapper).entries.get(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Get(bundleKey) if bundle == nil { return nil } entry := bundle.(*entriesWrapper).entries.get(key) if entry == nil { return nil } return entry }]}
{Id:9 FileId:162 StartLine:168 StartColumn:1 EndLine:175 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc001309e00 Body:{
	entry := yfast.get(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.get(key) if entry == nil { return nil } return entry }]}
{Id:10 FileId:162 StartLine:178 StartColumn:1 EndLine:180 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00095a580 Body:{
	return yfast.num
} PrettyPrintBody:[{ return yfast.num }]}
{Id:11 FileId:162 StartLine:182 StartColumn:1 EndLine:194 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0001e6160 Body:{
	bundle := yfast.xfast.Successor(key)
	if bundle == nil {
		return nil
	}

	entry, _ := bundle.(*entriesWrapper).entries.successor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundle := yfast.xfast.Successor(key) if bundle == nil { return nil } entry, _ := bundle.(*entriesWrapper).entries.successor(key) if entry == nil { return nil } return entry }]}
{Id:12 FileId:162 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:Successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc00095a700 Body:{
	entry := yfast.successor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.successor(key) if entry == nil { return nil } return entry }]}
{Id:13 FileId:162 StartLine:208 StartColumn:1 EndLine:237 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0003e5080 Body:{

	bundleKey := yfast.getBucketKey(key)
	bundle := yfast.xfast.Predecessor(bundleKey)
	if bundle == nil {
		return nil
	}

	ew := bundle.(*entriesWrapper)
	entry, _ := ew.entries.predecessor(key)
	if entry != nil {
		return entry
	}

	bundle = yfast.xfast.Predecessor(bundleKey - 1)
	if bundle == nil {
		return nil
	}

	ew = bundle.(*entriesWrapper)

	entry, _ = ew.entries.predecessor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Predecessor(bundleKey) if bundle == nil { return nil } ew := bundle.(*entriesWrapper) entry, _ := ew.entries.predecessor(key) if entry != nil { return entry } bundle = yfast.xfast.Predecessor(bundleKey - 1) if bundle == nil { return nil } ew = bundle.(*entriesWrapper) entry, _ = ew.entries.predecessor(key) if entry == nil { return nil } return entry }]}
{Id:14 FileId:162 StartLine:242 StartColumn:1 EndLine:249 EndColumn:2 Name:Predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc000993840 Body:{
	entry := yfast.predecessor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.predecessor(key) if entry == nil { return nil } return entry }]}
{Id:15 FileId:162 StartLine:251 StartColumn:1 EndLine:265 EndColumn:2 Name:iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc001602d20 Body:{
	xfastIter := yfast.xfast.Iter(key)
	xfastIter.Next()
	bundle := xfastIter.Value()
	if bundle == nil {
		return nilIterator()
	}

	i := bundle.(*entriesWrapper).entries.search(key)
	return &Iterator{
		index:		i - 1,
		xfastIterator:	xfastIter,
		entries:	bundle.(*entriesWrapper),
	}
} PrettyPrintBody:[{ xfastIter := yfast.xfast.Iter(key) xfastIter.Next() bundle := xfastIter.Value() if bundle == nil { return nilIterator() } i := bundle.(*entriesWrapper).entries.search(key) return &Iterator{ index:		i - 1, xfastIterator:	xfastIter, entries:	bundle.(*entriesWrapper), } }]}
{Id:16 FileId:162 StartLine:270 StartColumn:1 EndLine:272 EndColumn:2 Name:Iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc001033fe0 Body:{
	return yfast.iter(key)
} PrettyPrintBody:[{ return yfast.iter(key) }]}
{Id:17 FileId:162 StartLine:278 StartColumn:1 EndLine:282 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*YFastTrie}] Receiver:<nil> Body:{
	yfast := &YFastTrie{}
	yfast.init(ifc)
	return yfast
} PrettyPrintBody:[{ yfast := &YFastTrie{} yfast.init(ifc) return yfast }]}
{Id:1 FileId:124 StartLine:25 StartColumn:1 EndLine:33 EndColumn:2 Name:TestAddDuplicateItem Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Add(`test`)

	if !reflect.DeepEqual([]interface{}{`test`}, set.Flatten()) {
		t.Errorf(`Incorrect result returned: %+v`, set.Flatten())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Add(`test`) if !reflect.DeepEqual([]interface{}{`test`}, set.Flatten()) { t.Errorf(`Incorrect result returned: %+v`, set.Flatten()) } }]}
{Id:2 FileId:124 StartLine:35 StartColumn:1 EndLine:54 EndColumn:2 Name:TestAddItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Add(`test1`)

	firstSeen := false
	secondSeen := false

	for _, item := range set.Flatten() {
		if item.(string) == `test` {
			firstSeen = true
		} else if item.(string) == `test1` {
			secondSeen = true
		}
	}

	if !firstSeen || !secondSeen {
		t.Errorf(`Not all items seen in set.`)
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Add(`test1`) firstSeen := false secondSeen := false for _, item := range set.Flatten() { if item.(string) == `test` { firstSeen = true } else if item.(string) == `test1` { secondSeen = true } } if !firstSeen || !secondSeen { t.Errorf(`Not all items seen in set.`) } }]}
{Id:3 FileId:124 StartLine:56 StartColumn:1 EndLine:64 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Remove(`test`)

	if !reflect.DeepEqual([]interface{}{}, set.Flatten()) {
		t.Errorf(`Incorrect result returned: %+v`, set.Flatten())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Remove(`test`) if !reflect.DeepEqual([]interface{}{}, set.Flatten()) { t.Errorf(`Incorrect result returned: %+v`, set.Flatten()) } }]}
{Id:4 FileId:124 StartLine:66 StartColumn:1 EndLine:77 EndColumn:2 Name:TestExists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	if !set.Exists(`test`) {
		t.Errorf(`Correct existence not determined`)
	}

	if set.Exists(`test1`) {
		t.Errorf(`Correct nonexistence not determined.`)
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) if !set.Exists(`test`) { t.Errorf(`Correct existence not determined`) } if set.Exists(`test1`) { t.Errorf(`Correct nonexistence not determined.`) } }]}
{Id:5 FileId:124 StartLine:79 StartColumn:1 EndLine:93 EndColumn:2 Name:TestExists_WithNewItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New(`test`, `test1`)

	if !set.Exists(`test`) {
		t.Errorf(`Correct existence not determined`)
	}

	if !set.Exists(`test1`) {
		t.Errorf(`Correct existence not determined`)
	}

	if set.Exists(`test2`) {
		t.Errorf(`Correct nonexistence not determined.`)
	}
} PrettyPrintBody:[{ set := New(`test`, `test1`) if !set.Exists(`test`) { t.Errorf(`Correct existence not determined`) } if !set.Exists(`test1`) { t.Errorf(`Correct existence not determined`) } if set.Exists(`test2`) { t.Errorf(`Correct nonexistence not determined.`) } }]}
{Id:6 FileId:124 StartLine:95 StartColumn:1 EndLine:107 EndColumn:2 Name:TestLen Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	if set.Len() != 1 {
		t.Errorf(`Expected len: %d, received: %d`, 1, set.Len())
	}

	set.Add(`test1`)
	if set.Len() != 2 {
		t.Errorf(`Expected len: %d, received: %d`, 2, set.Len())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) if set.Len() != 1 { t.Errorf(`Expected len: %d, received: %d`, 1, set.Len()) } set.Add(`test1`) if set.Len() != 2 { t.Errorf(`Expected len: %d, received: %d`, 2, set.Len()) } }]}
{Id:7 FileId:124 StartLine:109 StartColumn:1 EndLine:119 EndColumn:2 Name:TestFlattenCaches Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	set.Flatten()

	if len(set.flattened) != 1 {
		t.Errorf(`Expected len: %d, received: %d`, 1, len(set.flattened))
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() if len(set.flattened) != 1 { t.Errorf(`Expected len: %d, received: %d`, 1, len(set.flattened)) } }]}
{Id:8 FileId:124 StartLine:121 StartColumn:1 EndLine:132 EndColumn:2 Name:TestFlattenCaches_CacheReturn Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	flatten1 := set.Flatten()
	flatten2 := set.Flatten()

	if !reflect.DeepEqual(flatten1, flatten2) {
		t.Errorf(`Flatten cache is not the same as original result. Got %+v, expected %+v`, flatten2, flatten1)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) flatten1 := set.Flatten() flatten2 := set.Flatten() if !reflect.DeepEqual(flatten1, flatten2) { t.Errorf(`Flatten cache is not the same as original result. Got %+v, expected %+v`, flatten2, flatten1) } }]}
{Id:9 FileId:124 StartLine:134 StartColumn:1 EndLine:152 EndColumn:2 Name:TestAddClearsCache Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)
	set.Flatten()

	set.Add(item)

	if len(set.flattened) != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, len(set.flattened))
	}

	item = `test2`
	set.Add(item)

	if set.flattened != nil {
		t.Errorf(`Cache not cleared.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() set.Add(item) if len(set.flattened) != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, len(set.flattened)) } item = `test2` set.Add(item) if set.flattened != nil { t.Errorf(`Cache not cleared.`) } }]}
{Id:10 FileId:124 StartLine:154 StartColumn:1 EndLine:165 EndColumn:2 Name:TestDeleteClearsCache Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)
	set.Flatten()

	set.Remove(item)

	if set.flattened != nil {
		t.Errorf(`Cache not cleared.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() set.Remove(item) if set.flattened != nil { t.Errorf(`Cache not cleared.`) } }]}
{Id:11 FileId:124 StartLine:167 StartColumn:1 EndLine:183 EndColumn:2 Name:TestAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	result := set.All(item)
	if !result {
		t.Errorf(`Expected true.`)
	}

	itemTwo := `test1`

	result = set.All(item, itemTwo)
	if result {
		t.Errorf(`Expected false.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) result := set.All(item) if !result { t.Errorf(`Expected true.`) } itemTwo := `test1` result = set.All(item, itemTwo) if result { t.Errorf(`Expected false.`) } }]}
{Id:12 FileId:124 StartLine:185 StartColumn:1 EndLine:194 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	set.Clear()

	if set.Len() != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, set.Len())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Clear() if set.Len() != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, set.Len()) } }]}
{Id:13 FileId:124 StartLine:196 StartColumn:1 EndLine:207 EndColumn:2 Name:BenchmarkFlatten Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < 50; i++ {
		item := strconv.Itoa(i)
		set.Add(item)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Flatten()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < 50; i++ { item := strconv.Itoa(i) set.Add(item) } b.ResetTimer() for i := 0; i < b.N; i++ { set.Flatten() } }]}
{Id:14 FileId:124 StartLine:209 StartColumn:1 EndLine:220 EndColumn:2 Name:BenchmarkLen Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < 50; i++ {
		item := strconv.Itoa(i)
		set.Add(item)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Len()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < 50; i++ { item := strconv.Itoa(i) set.Add(item) } b.ResetTimer() for i := 0; i < b.N; i++ { set.Len() } }]}
{Id:15 FileId:124 StartLine:222 StartColumn:1 EndLine:230 EndColumn:2 Name:BenchmarkExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(1)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Exists(1)
	}
} PrettyPrintBody:[{ set := New() set.Add(1) b.ResetTimer() for i := 0; i < b.N; i++ { set.Exists(1) } }]}
{Id:16 FileId:124 StartLine:232 StartColumn:1 EndLine:237 EndColumn:2 Name:BenchmarkClear Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < b.N; i++ {
		set.Clear()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < b.N; i++ { set.Clear() } }]}
{Id:1 FileId:33 StartLine:24 StartColumn:1 EndLine:36 EndColumn:2 Name:search Params:[{Name:parent Type:*node} {Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:<nil> Body:{
	parent = getParent(parent, nil, key)
	parent.lock.RLock()
	parent = moveRight(parent, key, false)
	defer parent.lock.RUnlock()

	i := parent.search(key)
	if i == len(parent.keys) {
		return nil
	}

	return parent.keys[i]
} PrettyPrintBody:[{ parent = getParent(parent, nil, key) parent.lock.RLock() parent = moveRight(parent, key, false) defer parent.lock.RUnlock() i := parent.search(key) if i == len(parent.keys) { return nil } return parent.keys[i] }]}
{Id:2 FileId:33 StartLine:38 StartColumn:1 EndLine:53 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:stack Type:*nodes} {Name:key Type:Key}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		parent.lock.RLock()
		parent = moveRight(parent, key, false)
		n = parent.searchNode(key)
		if stack != nil {
			stack.push(parent)
		}

		parent.lock.RUnlock()
		parent = n
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { parent.lock.RLock() parent = moveRight(parent, key, false) n = parent.searchNode(key) if stack != nil { stack.push(parent) } parent.lock.RUnlock() parent = n } return parent }]}
{Id:3 FileId:33 StartLine:55 StartColumn:1 EndLine:75 EndColumn:2 Name:insert Params:[{Name:tree Type:*blink} {Name:parent Type:*node} {Name:stack Type:*nodes} {Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:<nil> Body:{
	parent = getParent(parent, stack, key)

	parent.lock.Lock()
	parent = moveRight(parent, key, true)

	result := parent.insert(key)
	if result != nil {
		parent.lock.Unlock()
		return result
	}

	if !parent.needsSplit() {
		parent.lock.Unlock()
		return nil
	}

	split(tree, parent, stack)

	return nil
} PrettyPrintBody:[{ parent = getParent(parent, stack, key) parent.lock.Lock() parent = moveRight(parent, key, true) result := parent.insert(key) if result != nil { parent.lock.Unlock() return result } if !parent.needsSplit() { parent.lock.Unlock() return nil } split(tree, parent, stack) return nil }]}
{Id:4 FileId:33 StartLine:77 StartColumn:1 EndLine:114 EndColumn:2 Name:split Params:[{Name:tree Type:*blink} {Name:n Type:*node} {Name:stack Type:*nodes}] Results:[] Receiver:<nil> Body:{
	var l, r *node
	var k Key
	var parent *node
	for n.needsSplit() {
		k, l, r = n.split()
		parent = stack.pop()
		if parent == nil {
			tree.lock.Lock()
			if tree.root == nil || tree.root == n {
				parent = newNode(false, make(Keys, 0, tree.ary), make(nodes, 0, tree.ary+1))
				parent.maxSeen = r.max()
				parent.keys.insert(k)
				parent.nodes.push(l)
				parent.nodes.push(r)
				tree.root = parent
				n.lock.Unlock()
				tree.lock.Unlock()
				return
			}

			parent = tree.root
			tree.lock.Unlock()
		}

		parent.lock.Lock()
		parent = moveRight(parent, r.key(), true)
		i := parent.search(k)
		parent.keys.insertAt(k, i)
		parent.nodes[i] = l
		parent.nodes.insertAt(r, i+1)

		n.lock.Unlock()
		n = parent
	}

	n.lock.Unlock()
} PrettyPrintBody:[{ var l, r *node var k Key var parent *node for n.needsSplit() { k, l, r = n.split() parent = stack.pop() if parent == nil { tree.lock.Lock() if tree.root == nil || tree.root == n { parent = newNode(false, make(Keys, 0, tree.ary), make(nodes, 0, tree.ary+1)) parent.maxSeen = r.max() parent.keys.insert(k) parent.nodes.push(l) parent.nodes.push(r) tree.root = parent n.lock.Unlock() tree.lock.Unlock() return } parent = tree.root tree.lock.Unlock() } parent.lock.Lock() parent = moveRight(parent, r.key(), true) i := parent.search(k) parent.keys.insertAt(k, i) parent.nodes[i] = l parent.nodes.insertAt(r, i+1) n.lock.Unlock() n = parent } n.lock.Unlock() }]}
{Id:5 FileId:33 StartLine:116 StartColumn:1 EndLine:137 EndColumn:2 Name:moveRight Params:[{Name:n Type:*node} {Name:key Type:Key} {Name:getLock Type:bool}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var right *node
	for {
		if len(n.keys) == 0 || n.right == nil {
			return n
		}
		if key.Compare(n.max()) < 1 {
			return n
		}

		if getLock {
			n.right.lock.Lock()
			right = n.right
			n.lock.Unlock()
		} else {
			n.right.lock.RLock()
			right = n.right
			n.lock.RUnlock()
		}
		n = right
	}
} PrettyPrintBody:[{ var right *node for { if len(n.keys) == 0 || n.right == nil { return n } if key.Compare(n.max()) < 1 { return n } if getLock { n.right.lock.Lock() right = n.right n.lock.Unlock() } else { n.right.lock.RLock() right = n.right n.lock.RUnlock() } n = right } }]}
{Id:7 FileId:33 StartLine:141 StartColumn:1 EndLine:147 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001602580 Body:{
	for i := range *ns {
		(*ns)[i] = nil
	}

	*ns = (*ns)[:0]
} PrettyPrintBody:[{ for i := range *ns { (*ns)[i] = nil } *ns = (*ns)[:0] }]}
{Id:8 FileId:33 StartLine:149 StartColumn:1 EndLine:151 EndColumn:2 Name:push Params:[{Name:n Type:*node}] Results:[] Receiver:0xc0010337c0 Body:{
	*ns = append(*ns, n)
} PrettyPrintBody:[{ *ns = append(*ns, n) }]}
{Id:9 FileId:33 StartLine:153 StartColumn:1 EndLine:162 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:*node}] Receiver:0xc001033800 Body:{
	if len(*ns) == 0 {
		return nil
	}

	n := (*ns)[len(*ns)-1]
	(*ns)[len(*ns)-1] = nil
	*ns = (*ns)[:len(*ns)-1]
	return n
} PrettyPrintBody:[{ if len(*ns) == 0 { return nil } n := (*ns)[len(*ns)-1] (*ns)[len(*ns)-1] = nil *ns = (*ns)[:len(*ns)-1] return n }]}
{Id:10 FileId:33 StartLine:164 StartColumn:1 EndLine:173 EndColumn:2 Name:insertAt Params:[{Name:n Type:*node} {Name:i Type:int}] Results:[] Receiver:0xc000a22080 Body:{
	if i == len(*ns) {
		*ns = append(*ns, n)
		return
	}

	*ns = append(*ns, nil)
	copy((*ns)[i+1:], (*ns)[i:])
	(*ns)[i] = n
} PrettyPrintBody:[{ if i == len(*ns) { *ns = append(*ns, n) return } *ns = append(*ns, nil) copy((*ns)[i+1:], (*ns)[i:]) (*ns)[i] = n }]}
{Id:11 FileId:33 StartLine:175 StartColumn:1 EndLine:184 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:nodes} {Name: Type:nodes}] Receiver:0xc001033a40 Body:{
	length := len(*ns) - i
	right := make(nodes, length, cap(*ns))
	copy(right, (*ns)[i+1:])
	for j := i + 1; j < len(*ns); j++ {
		(*ns)[j] = nil
	}
	*ns = (*ns)[:i+1]
	return *ns, right
} PrettyPrintBody:[{ length := len(*ns) - i right := make(nodes, length, cap(*ns)) copy(right, (*ns)[i+1:]) for j := i + 1; j < len(*ns); j++ { (*ns)[j] = nil } *ns = (*ns)[:i+1] return *ns, right }]}
{Id:13 FileId:33 StartLine:195 StartColumn:1 EndLine:197 EndColumn:2 Name:key Params:[] Results:[{Name: Type:Key}] Receiver:0xc0015813a0 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]}
{Id:14 FileId:33 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc001581420 Body:{
	if !n.isLeaf {
		panic(`Can't only insert key in an internal node.`)
	}

	overwritten := n.keys.insert(key)
	return overwritten
} PrettyPrintBody:[{ if !n.isLeaf { panic(`Can't only insert key in an internal node.`) } overwritten := n.keys.insert(key) return overwritten }]}
{Id:15 FileId:33 StartLine:208 StartColumn:1 EndLine:213 EndColumn:2 Name:insertNode Params:[{Name:other Type:*node}] Results:[] Receiver:0xc001581460 Body:{
	key := other.key()
	i := n.keys.search(key)
	n.keys.insertAt(key, i)
	n.nodes.insertAt(other, i)
} PrettyPrintBody:[{ key := other.key() i := n.keys.search(key) n.keys.insertAt(key, i) n.nodes.insertAt(other, i) }]}
{Id:16 FileId:33 StartLine:215 StartColumn:1 EndLine:217 EndColumn:2 Name:needsSplit Params:[] Results:[{Name: Type:bool}] Receiver:0xc001309cc0 Body:{
	return n.keys.needsSplit()
} PrettyPrintBody:[{ return n.keys.needsSplit() }]}
{Id:17 FileId:33 StartLine:219 StartColumn:1 EndLine:225 EndColumn:2 Name:max Params:[] Results:[{Name: Type:Key}] Receiver:0xc0015814c0 Body:{
	if n.isLeaf {
		return n.keys.last()
	}

	return n.maxSeen
} PrettyPrintBody:[{ if n.isLeaf { return n.keys.last() } return n.maxSeen }]}
{Id:18 FileId:33 StartLine:227 StartColumn:1 EndLine:238 EndColumn:2 Name:splitLeaf Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095a540 Body:{
	i := (len(n.keys) / 2)
	key := n.keys[i]
	_, rightKeys := n.keys.splitAt(i)
	nn := &node{
		keys:	rightKeys,
		right:	n.right,
		isLeaf:	true,
	}
	n.right = nn
	return key, n, nn
} PrettyPrintBody:[{ i := (len(n.keys) / 2) key := n.keys[i] _, rightKeys := n.keys.splitAt(i) nn := &node{ keys:	rightKeys, right:	n.right, isLeaf:	true, } n.right = nn return key, n, nn }]}
{Id:19 FileId:33 StartLine:240 StartColumn:1 EndLine:267 EndColumn:2 Name:splitInternal Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095a720 Body:{
	i := (len(n.keys) / 2)
	key := n.keys[i]

	rightKeys := make(Keys, len(n.keys)-1-i, cap(n.keys))
	rightNodes := make(nodes, len(rightKeys)+1, cap(n.nodes))

	copy(rightKeys, n.keys[i+1:])
	copy(rightNodes, n.nodes[i+1:])

	for j := i + 1; j < len(n.nodes); j++ {
		if j != len(n.keys) {
			n.keys[j] = nil
		}
		n.nodes[j] = nil
	}

	nn := newNode(false, rightKeys, rightNodes)
	nn.maxSeen = n.max()

	n.maxSeen = key
	n.keys = n.keys[:i]
	n.nodes = n.nodes[:i+1]
	n.right = nn

	return key, n, nn
} PrettyPrintBody:[{ i := (len(n.keys) / 2) key := n.keys[i] rightKeys := make(Keys, len(n.keys)-1-i, cap(n.keys)) rightNodes := make(nodes, len(rightKeys)+1, cap(n.nodes)) copy(rightKeys, n.keys[i+1:]) copy(rightNodes, n.nodes[i+1:]) for j := i + 1; j < len(n.nodes); j++ { if j != len(n.keys) { n.keys[j] = nil } n.nodes[j] = nil } nn := newNode(false, rightKeys, rightNodes) nn.maxSeen = n.max() n.maxSeen = key n.keys = n.keys[:i] n.nodes = n.nodes[:i+1] n.right = nn return key, n, nn }]}
{Id:20 FileId:33 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc0003e5240 Body:{
	if n.isLeaf {
		return n.splitLeaf()
	}

	return n.splitInternal()
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf() } return n.splitInternal() }]}
{Id:21 FileId:33 StartLine:277 StartColumn:1 EndLine:279 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000993a00 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]}
{Id:22 FileId:33 StartLine:281 StartColumn:1 EndLine:285 EndColumn:2 Name:searchNode Params:[{Name:key Type:Key}] Results:[{Name: Type:*node}] Receiver:0xc000993aa0 Body:{
	i := n.search(key)

	return n.nodes[i]
} PrettyPrintBody:[{ i := n.search(key) return n.nodes[i] }]}
{Id:23 FileId:33 StartLine:287 StartColumn:1 EndLine:298 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc000993d80 Body:{
	output.Printf(`NODE: %+v, %p`, n, n)
	if !n.isLeaf {
		for _, n := range n.nodes {
			if n == nil {
				output.Println(`NIL NODE`)
				continue
			}
			n.print(output)
		}
	}
} PrettyPrintBody:[{ output.Printf(`NODE: %+v, %p`, n, n) if !n.isLeaf { for _, n := range n.nodes { if n == nil { output.Println(`NIL NODE`) continue } n.print(output) } } }]}
{Id:24 FileId:33 StartLine:300 StartColumn:1 EndLine:306 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:Keys} {Name:ns Type:nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]}
{Id:1 FileId:18 StartLine:28 StartColumn:1 EndLine:36 EndColumn:2 Name:Marshal Params:[{Name:ba Type:BitArray}] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:<nil> Body:{
	if eba, ok := ba.(*bitArray); ok {
		return eba.Serialize()
	} else if sba, ok := ba.(*sparseBitArray); ok {
		return sba.Serialize()
	} else {
		return nil, errors.New("not a valid BitArray")
	}
} PrettyPrintBody:[{ if eba, ok := ba.(*bitArray); ok { return eba.Serialize() } else if sba, ok := ba.(*sparseBitArray); ok { return sba.Serialize() } else { return nil, errors.New("not a valid BitArray") } }]}
{Id:2 FileId:18 StartLine:40 StartColumn:1 EndLine:61 EndColumn:2 Name:Unmarshal Params:[{Name:input Type:[]byte}] Results:[{Name: Type:BitArray} {Name: Type:error}] Receiver:<nil> Body:{
	if len(input) == 0 {
		return nil, errors.New("no data in input")
	}
	if input[0] == 'B' {
		ret := newBitArray(0)
		err := ret.Deserialize(input)
		if err != nil {
			return nil, err
		}
		return ret, nil
	} else if input[0] == 'S' {
		ret := newSparseBitArray()
		err := ret.Deserialize(input)
		if err != nil {
			return nil, err
		}
		return ret, nil
	} else {
		return nil, errors.New("unrecognized encoding")
	}
} PrettyPrintBody:[{ if len(input) == 0 { return nil, errors.New("no data in input") } if input[0] == 'B' { ret := newBitArray(0) err := ret.Deserialize(input) if err != nil { return nil, err } return ret, nil } else if input[0] == 'S' { ret := newSparseBitArray() err := ret.Deserialize(input) if err != nil { return nil, err } return ret, nil } else { return nil, errors.New("unrecognized encoding") } }]}
{Id:3 FileId:18 StartLine:64 StartColumn:1 EndLine:96 EndColumn:2 Name:Serialize Params:[] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:0xc001226a60 Body:{
	w := new(bytes.Buffer)

	var identifier uint8 = 'S'
	err := binary.Write(w, binary.LittleEndian, identifier)
	if err != nil {
		return nil, err
	}

	blocksLen := uint64(len(ba.blocks))
	indexLen := uint64(len(ba.indices))

	err = binary.Write(w, binary.LittleEndian, blocksLen)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.blocks)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, indexLen)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.indices)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), nil
} PrettyPrintBody:[{ w := new(bytes.Buffer) var identifier uint8 = 'S' err := binary.Write(w, binary.LittleEndian, identifier) if err != nil { return nil, err } blocksLen := uint64(len(ba.blocks)) indexLen := uint64(len(ba.indices)) err = binary.Write(w, binary.LittleEndian, blocksLen) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.blocks) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, indexLen) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.indices) if err != nil { return nil, err } return w.Bytes(), nil }]}
{Id:4 FileId:18 StartLine:102 StartColumn:1 EndLine:110 EndColumn:2 Name:Uint64FromBytes Params:[{Name:b Type:[]byte}] Results:[{Name: Type:uint64} {Name: Type:int}] Receiver:<nil> Body:{
	if len(b) < 8 {
		return 0, -1
	}

	val := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
	return val, 8
} PrettyPrintBody:[{ if len(b) < 8 { return 0, -1 } val := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 return val, 8 }]}
{Id:5 FileId:18 StartLine:117 StartColumn:1 EndLine:157 EndColumn:2 Name:Deserialize Params:[{Name:incoming Type:[]byte}] Results:[{Name: Type:error}] Receiver:0xc001032fa0 Body:{
	var intsize = uint64(s / 8)
	var curLoc = uint64(1)

	var intsToRead uint64
	var bytesRead int
	intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
	if bytesRead < 0 {
		return errors.New("Invalid data for BitArray")
	}
	curLoc += intsize

	var nextblock uint64
	ret.blocks = make([]block, intsToRead)
	for i := uint64(0); i < intsToRead; i++ {
		nextblock, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
		if bytesRead < 0 {
			return errors.New("Invalid data for BitArray")
		}
		ret.blocks[i] = block(nextblock)
		curLoc += intsize
	}

	intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
	if bytesRead < 0 {
		return errors.New("Invalid data for BitArray")
	}
	curLoc += intsize

	var nextuint uint64
	ret.indices = make(uintSlice, intsToRead)
	for i := uint64(0); i < intsToRead; i++ {
		nextuint, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
		if bytesRead < 0 {
			return errors.New("Invalid data for BitArray")
		}
		ret.indices[i] = nextuint
		curLoc += intsize
	}
	return nil
} PrettyPrintBody:[{ var intsize = uint64(s / 8) var curLoc = uint64(1) var intsToRead uint64 var bytesRead int intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } curLoc += intsize var nextblock uint64 ret.blocks = make([]block, intsToRead) for i := uint64(0); i < intsToRead; i++ { nextblock, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } ret.blocks[i] = block(nextblock) curLoc += intsize } intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } curLoc += intsize var nextuint uint64 ret.indices = make(uintSlice, intsToRead) for i := uint64(0); i < intsToRead; i++ { nextuint, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } ret.indices[i] = nextuint curLoc += intsize } return nil }]}
{Id:6 FileId:18 StartLine:160 StartColumn:1 EndLine:194 EndColumn:2 Name:Serialize Params:[] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:0xc000a8a180 Body:{
	w := new(bytes.Buffer)

	var identifier uint8 = 'B'
	err := binary.Write(w, binary.LittleEndian, identifier)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.lowest)
	if err != nil {
		return nil, err
	}
	err = binary.Write(w, binary.LittleEndian, ba.highest)
	if err != nil {
		return nil, err
	}

	var encodedanyset uint8
	if ba.anyset {
		encodedanyset = 1
	} else {
		encodedanyset = 0
	}
	err = binary.Write(w, binary.LittleEndian, encodedanyset)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.blocks)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), nil
} PrettyPrintBody:[{ w := new(bytes.Buffer) var identifier uint8 = 'B' err := binary.Write(w, binary.LittleEndian, identifier) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.lowest) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.highest) if err != nil { return nil, err } var encodedanyset uint8 if ba.anyset { encodedanyset = 1 } else { encodedanyset = 0 } err = binary.Write(w, binary.LittleEndian, encodedanyset) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.blocks) if err != nil { return nil, err } return w.Bytes(), nil }]}
{Id:7 FileId:18 StartLine:200 StartColumn:1 EndLine:234 EndColumn:2 Name:Deserialize Params:[{Name:incoming Type:[]byte}] Results:[{Name: Type:error}] Receiver:0xc001033e60 Body:{
	r := bytes.NewReader(incoming[1:])

	err := binary.Read(r, binary.LittleEndian, &ret.lowest)
	if err != nil {
		return err
	}

	err = binary.Read(r, binary.LittleEndian, &ret.highest)
	if err != nil {
		return err
	}

	var encodedanyset uint8
	err = binary.Read(r, binary.LittleEndian, &encodedanyset)
	if err != nil {
		return err
	}

	if encodedanyset == 1 {
		ret.anyset = true
	}

	var nextblock block
	err = binary.Read(r, binary.LittleEndian, &nextblock)
	for err == nil {
		ret.blocks = append(ret.blocks, nextblock)
		err = binary.Read(r, binary.LittleEndian, &nextblock)
	}
	if err != io.EOF {
		return err
	}
	return nil
} PrettyPrintBody:[{ r := bytes.NewReader(incoming[1:]) err := binary.Read(r, binary.LittleEndian, &ret.lowest) if err != nil { return err } err = binary.Read(r, binary.LittleEndian, &ret.highest) if err != nil { return err } var encodedanyset uint8 err = binary.Read(r, binary.LittleEndian, &encodedanyset) if err != nil { return err } if encodedanyset == 1 { ret.anyset = true } var nextblock block err = binary.Read(r, binary.LittleEndian, &nextblock) for err == nil { ret.blocks = append(ret.blocks, nextblock) err = binary.Read(r, binary.LittleEndian, &nextblock) } if err != io.EOF { return err } return nil }]}
{Id:1 FileId:78 StartLine:25 StartColumn:1 EndLine:50 EndColumn:2 Name:TestV Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()
	assert.Equal(0, sgraph.V())

	sgraph.AddEdge("A", "B")
	assert.Equal(2, sgraph.V())

	sgraph.AddEdge("B", "C")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.V())
	sgraph.AddEdge("C", "A")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("C", "C")
	assert.Equal(3, sgraph.V())
	sgraph.AddEdge("D", "D")
	assert.Equal(3, sgraph.V())
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() assert.Equal(0, sgraph.V()) sgraph.AddEdge("A", "B") assert.Equal(2, sgraph.V()) sgraph.AddEdge("B", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("C", "A") assert.Equal(3, sgraph.V()) sgraph.AddEdge("C", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("D", "D") assert.Equal(3, sgraph.V()) }]}
{Id:2 FileId:78 StartLine:52 StartColumn:1 EndLine:78 EndColumn:2 Name:TestE Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	assert.Equal(0, sgraph.E())

	sgraph.AddEdge("A", "B")
	assert.Equal(1, sgraph.E())

	sgraph.AddEdge("B", "C")
	assert.Equal(2, sgraph.E())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.E())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.E())
	sgraph.AddEdge("C", "A")
	assert.Equal(3, sgraph.E())

	sgraph.AddEdge("C", "C")
	assert.Equal(3, sgraph.E())
	sgraph.AddEdge("D", "D")
	assert.Equal(3, sgraph.E())
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() assert.Equal(0, sgraph.E()) sgraph.AddEdge("A", "B") assert.Equal(1, sgraph.E()) sgraph.AddEdge("B", "C") assert.Equal(2, sgraph.E()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("C", "A") assert.Equal(3, sgraph.E()) sgraph.AddEdge("C", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("D", "D") assert.Equal(3, sgraph.E()) }]}
{Id:3 FileId:78 StartLine:80 StartColumn:1 EndLine:144 EndColumn:2 Name:TestDegree Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	v, err := sgraph.Degree("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("A", "A")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)
	sgraph.AddEdge("B", "A")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("B")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("C", "D")
	sgraph.AddEdge("A", "C")
	sgraph.AddEdge("E", "F")
	sgraph.AddEdge("E", "G")
	sgraph.AddEdge("H", "G")

	v, err = sgraph.Degree("A")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("B")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("C")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("D")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("E")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("G")
	assert.Equal(2, v)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() v, err := sgraph.Degree("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "B") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("A", "A") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("A", "B") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("B", "A") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("B") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("C", "D") sgraph.AddEdge("A", "C") sgraph.AddEdge("E", "F") sgraph.AddEdge("E", "G") sgraph.AddEdge("H", "G") v, err = sgraph.Degree("A") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("B") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("C") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("D") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("E") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("G") assert.Equal(2, v) assert.Nil(err) }]}
{Id:4 FileId:78 StartLine:146 StartColumn:1 EndLine:168 EndColumn:2 Name:TestAddEdge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	err := sgraph.AddEdge("A", "B")
	assert.Nil(err)

	err = sgraph.AddEdge("A", "B")
	assert.Error(err)

	err = sgraph.AddEdge("B", "A")
	assert.Error(err)

	err = sgraph.AddEdge("A", "A")
	assert.Error(err)

	err = sgraph.AddEdge("C", "C")
	assert.Error(err)

	err = sgraph.AddEdge("B", "C")
	assert.Nil(err)

} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() err := sgraph.AddEdge("A", "B") assert.Nil(err) err = sgraph.AddEdge("A", "B") assert.Error(err) err = sgraph.AddEdge("B", "A") assert.Error(err) err = sgraph.AddEdge("A", "A") assert.Error(err) err = sgraph.AddEdge("C", "C") assert.Error(err) err = sgraph.AddEdge("B", "C") assert.Nil(err) }]}
{Id:5 FileId:78 StartLine:170 StartColumn:1 EndLine:246 EndColumn:2 Name:TestAdj Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	v, err := sgraph.Adj("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "A")
	v, err = sgraph.Adj("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Adj("A")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("B", v[0])

	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("A", v[0])

	sgraph.AddEdge("A", "B")
	sgraph.AddEdge("B", "A")
	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("A", v[0])

	sgraph.AddEdge("C", "D")
	sgraph.AddEdge("A", "C")
	sgraph.AddEdge("E", "F")
	sgraph.AddEdge("E", "G")
	sgraph.AddEdge("H", "G")

	v, err = sgraph.Adj("A")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "B")
	assert.Contains(v, "C")
	assert.NotContains(v, "A")
	assert.NotContains(v, "D")

	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Contains(v, "A")
	assert.NotContains(v, "B")
	assert.NotContains(v, "C")
	assert.NotContains(v, "D")

	v, err = sgraph.Adj("C")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "A")
	assert.Contains(v, "D")
	assert.NotContains(v, "B")
	assert.NotContains(v, "C")

	v, err = sgraph.Adj("E")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "F")
	assert.Contains(v, "G")
	assert.NotContains(v, "A")

	v, err = sgraph.Adj("G")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "E")
	assert.Contains(v, "H")
	assert.NotContains(v, "A")
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() v, err := sgraph.Adj("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "A") v, err = sgraph.Adj("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "B") v, err = sgraph.Adj("A") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("B", v[0]) v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("A", v[0]) sgraph.AddEdge("A", "B") sgraph.AddEdge("B", "A") v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("A", v[0]) sgraph.AddEdge("C", "D") sgraph.AddEdge("A", "C") sgraph.AddEdge("E", "F") sgraph.AddEdge("E", "G") sgraph.AddEdge("H", "G") v, err = sgraph.Adj("A") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "B") assert.Contains(v, "C") assert.NotContains(v, "A") assert.NotContains(v, "D") v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Contains(v, "A") assert.NotContains(v, "B") assert.NotContains(v, "C") assert.NotContains(v, "D") v, err = sgraph.Adj("C") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "A") assert.Contains(v, "D") assert.NotContains(v, "B") assert.NotContains(v, "C") v, err = sgraph.Adj("E") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "F") assert.Contains(v, "G") assert.NotContains(v, "A") v, err = sgraph.Adj("G") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "E") assert.Contains(v, "H") assert.NotContains(v, "A") }]}
{Id:2 FileId:108 StartLine:25 StartColumn:1 EndLine:30 EndColumn:2 Name:search Params:[{Name:value Type:int64}] Results:[{Name: Type:int}] Receiver:0xc001602180 Body:{
	return sort.Search(
		len(nodes),
		func(i int) bool { return nodes[i].value >= value },
	)
} PrettyPrintBody:[{ return sort.Search( len(nodes), func(i int) bool { return nodes[i].value >= value }, ) }]}
{Id:3 FileId:108 StartLine:34 StartColumn:1 EndLine:52 EndColumn:2 Name:addAt Params:[{Name:i Type:int} {Name:node Type:*node}] Results:[{Name: Type:*node}] Receiver:0xc0011d6780 Body:{
	if i == len(*nodes) {
		*nodes = append(*nodes, node)
		return nil
	}

	if (*nodes)[i].value == node.value {
		overwritten := (*nodes)[i]

		(*nodes)[i] = node
		return overwritten
	}

	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
	return nil
} PrettyPrintBody:[{ if i == len(*nodes) { *nodes = append(*nodes, node) return nil } if (*nodes)[i].value == node.value { overwritten := (*nodes)[i] (*nodes)[i] = node return overwritten } *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node return nil }]}
{Id:4 FileId:108 StartLine:54 StartColumn:1 EndLine:57 EndColumn:2 Name:add Params:[{Name:node Type:*node}] Results:[{Name: Type:*node}] Receiver:0xc0011d6ce0 Body:{
	i := nodes.search(node.value)
	return nodes.addAt(i, node)
} PrettyPrintBody:[{ i := nodes.search(node.value) return nodes.addAt(i, node) }]}
{Id:5 FileId:108 StartLine:59 StartColumn:1 EndLine:69 EndColumn:2 Name:deleteAt Params:[{Name:i Type:int}] Results:[{Name: Type:*node}] Receiver:0xc0011d6f60 Body:{
	if i >= len(*nodes) {
		return nil
	}

	deleted := (*nodes)[i]
	copy((*nodes)[i:], (*nodes)[i+1:])
	(*nodes)[len(*nodes)-1] = nil
	*nodes = (*nodes)[:len(*nodes)-1]
	return deleted
} PrettyPrintBody:[{ if i >= len(*nodes) { return nil } deleted := (*nodes)[i] copy((*nodes)[i:], (*nodes)[i+1:]) (*nodes)[len(*nodes)-1] = nil *nodes = (*nodes)[:len(*nodes)-1] return deleted }]}
{Id:6 FileId:108 StartLine:71 StartColumn:1 EndLine:79 EndColumn:2 Name:delete Params:[{Name:value Type:int64}] Results:[{Name: Type:*node}] Receiver:0xc000df65a0 Body:{
	i := nodes.search(value)

	if (*nodes)[i].value != value || i == len(*nodes) {
		return nil
	}

	return nodes.deleteAt(i)
} PrettyPrintBody:[{ i := nodes.search(value) if (*nodes)[i].value != value || i == len(*nodes) { return nil } return nodes.deleteAt(i) }]}
{Id:7 FileId:108 StartLine:81 StartColumn:1 EndLine:98 EndColumn:2 Name:apply Params:[{Name:low Type:int64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc000df7060 Body:{
	index := nodes.search(low)
	if index == len(nodes) {
		return true
	}

	for ; index < len(nodes); index++ {
		if nodes[index].value > high {
			break
		}

		if !fn(nodes[index]) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ index := nodes.search(low) if index == len(nodes) { return true } for ; index < len(nodes); index++ { if nodes[index].value > high { break } if !fn(nodes[index]) { return false } } return true }]}
{Id:8 FileId:108 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:get Params:[{Name:value Type:int64}] Results:[{Name: Type:*node} {Name: Type:int}] Receiver:0xc001033880 Body:{
	i := nodes.search(value)
	if i == len(nodes) {
		return nil, i
	}

	if nodes[i].value == value {
		return nodes[i], i
	}

	return nil, i
} PrettyPrintBody:[{ i := nodes.search(value) if i == len(nodes) { return nil, i } if nodes[i].value == value { return nodes[i], i } return nil, i }]}
{Id:9 FileId:108 StartLine:113 StartColumn:1 EndLine:135 EndColumn:2 Name:getOrAdd Params:[{Name:entry Type:Entry} {Name:dimension Type:uint64}] Results:[{Name: Type:*node} {Name: Type:bool}] Receiver:0xc000a8a3c0 Body:{

	isLastDimension := isLastDimension(lastDimension, dimension)
	value := entry.ValueAtDimension(dimension)

	i := nodes.search(value)
	if i == len(*nodes) {
		node := newNode(value, entry, !isLastDimension)
		*nodes = append(*nodes, node)
		return node, true
	}

	if (*nodes)[i].value == value {
		return (*nodes)[i], false
	}

	node := newNode(value, entry, !isLastDimension)
	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
	return node, true
} PrettyPrintBody:[{ isLastDimension := isLastDimension(lastDimension, dimension) value := entry.ValueAtDimension(dimension) i := nodes.search(value) if i == len(*nodes) { node := newNode(value, entry, !isLastDimension) *nodes = append(*nodes, node) return node, true } if (*nodes)[i].value == value { return (*nodes)[i], false } node := newNode(value, entry, !isLastDimension) *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node return node, true }]}
{Id:10 FileId:108 StartLine:137 StartColumn:1 EndLine:145 EndColumn:2 Name:flatten Params:[{Name:entries Type:*Entries}] Results:[] Receiver:0xc0015813e0 Body:{
	for _, node := range nodes {
		if node.orderedNodes != nil {
			node.orderedNodes.flatten(entries)
		} else {
			*entries = append(*entries, node.entry)
		}
	}
} PrettyPrintBody:[{ for _, node := range nodes { if node.orderedNodes != nil { node.orderedNodes.flatten(entries) } else { *entries = append(*entries, node.entry) } } }]}
{Id:11 FileId:108 StartLine:147 StartColumn:1 EndLine:187 EndColumn:2 Name:insert Params:[{Name:insertDimension Type:uint64} {Name:index Type:int64} {Name:modified Type:*Entries}] Results:[] Receiver:0xc000a239a0 Body:{

	lastDimension := isLastDimension(maxDimension, dimension)

	if insertDimension == dimension {
		i := nodes.search(index)
		var toDelete []int

		for j := i; j < len(*nodes); j++ {
			(*nodes)[j].value += number
			if (*nodes)[j].value < index {
				toDelete = append(toDelete, j)
				if lastDimension {
					*deleted = append(*deleted, (*nodes)[j].entry)
				} else {
					(*nodes)[j].orderedNodes.flatten(deleted)
				}
				continue
			}
			if lastDimension {
				*modified = append(*modified, (*nodes)[j].entry)
			} else {
				(*nodes)[j].orderedNodes.flatten(modified)
			}
		}

		for i, index := range toDelete {
			nodes.deleteAt(index - i)
		}

		return
	}

	for _, node := range *nodes {
		node.orderedNodes.insert(
			insertDimension, dimension+1, maxDimension,
			index, number, modified, deleted,
		)
	}
} PrettyPrintBody:[{ lastDimension := isLastDimension(maxDimension, dimension) if insertDimension == dimension { i := nodes.search(index) var toDelete []int for j := i; j < len(*nodes); j++ { (*nodes)[j].value += number if (*nodes)[j].value < index { toDelete = append(toDelete, j) if lastDimension { *deleted = append(*deleted, (*nodes)[j].entry) } else { (*nodes)[j].orderedNodes.flatten(deleted) } continue } if lastDimension { *modified = append(*modified, (*nodes)[j].entry) } else { (*nodes)[j].orderedNodes.flatten(modified) } } for i, index := range toDelete { nodes.deleteAt(index - i) } return } for _, node := range *nodes { node.orderedNodes.insert( insertDimension, dimension+1, maxDimension, index, number, modified, deleted, ) } }]}
{Id:12 FileId:108 StartLine:189 StartColumn:1 EndLine:241 EndColumn:2 Name:immutableInsert Params:[{Name:insertDimension Type:uint64} {Name:index Type:int64} {Name:modified Type:*Entries}] Results:[{Name: Type:orderedNodes}] Receiver:0xc001033cc0 Body:{

	lastDimension := isLastDimension(maxDimension, dimension)

	cp := make(orderedNodes, len(nodes))
	copy(cp, nodes)

	if insertDimension == dimension {
		i := cp.search(index)
		var toDelete []int

		for j := i; j < len(cp); j++ {
			nn := newNode(cp[j].value+number, cp[j].entry, !lastDimension)
			nn.orderedNodes = cp[j].orderedNodes
			cp[j] = nn
			if cp[j].value < index {
				toDelete = append(toDelete, j)
				if lastDimension {
					*deleted = append(*deleted, cp[j].entry)
				} else {
					cp[j].orderedNodes.flatten(deleted)
				}
				continue
			}
			if lastDimension {
				*modified = append(*modified, cp[j].entry)
			} else {
				cp[j].orderedNodes.flatten(modified)
			}
		}

		for _, index := range toDelete {
			cp.deleteAt(index)
		}

		return cp
	}

	for i := 0; i < len(cp); i++ {
		oldNode := nodes[i]
		nn := newNode(oldNode.value, oldNode.entry, !lastDimension)
		nn.orderedNodes = oldNode.orderedNodes.immutableInsert(
			insertDimension, dimension+1,
			maxDimension,
			index, number,
			modified, deleted,
		)
		cp[i] = nn
	}

	return cp
} PrettyPrintBody:[{ lastDimension := isLastDimension(maxDimension, dimension) cp := make(orderedNodes, len(nodes)) copy(cp, nodes) if insertDimension == dimension { i := cp.search(index) var toDelete []int for j := i; j < len(cp); j++ { nn := newNode(cp[j].value+number, cp[j].entry, !lastDimension) nn.orderedNodes = cp[j].orderedNodes cp[j] = nn if cp[j].value < index { toDelete = append(toDelete, j) if lastDimension { *deleted = append(*deleted, cp[j].entry) } else { cp[j].orderedNodes.flatten(deleted) } continue } if lastDimension { *modified = append(*modified, cp[j].entry) } else { cp[j].orderedNodes.flatten(modified) } } for _, index := range toDelete { cp.deleteAt(index) } return cp } for i := 0; i < len(cp); i++ { oldNode := nodes[i] nn := newNode(oldNode.value, oldNode.entry, !lastDimension) nn.orderedNodes = oldNode.orderedNodes.immutableInsert( insertDimension, dimension+1, maxDimension, index, number, modified, deleted, ) cp[i] = nn } return cp }]}
{Id:2 FileId:27 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc000956040 Body:{
	return int64(len(u))
} PrettyPrintBody:[{ return int64(len(u)) }]}
{Id:3 FileId:27 StartLine:32 StartColumn:1 EndLine:34 EndColumn:2 Name:Swap Params:[{Name:i Type:int64}] Results:[] Receiver:0xc000956080 Body:{
	u[i], u[j] = u[j], u[i]
} PrettyPrintBody:[{ u[i], u[j] = u[j], u[i] }]}
{Id:4 FileId:27 StartLine:38 StartColumn:1 EndLine:40 EndColumn:2 Name:Less Params:[{Name:i Type:int64}] Results:[{Name: Type:bool}] Receiver:0xc00129ba20 Body:{
	return u[i] < u[j]
} PrettyPrintBody:[{ return u[i] < u[j] }]}
{Id:5 FileId:27 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:search Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00129ba80 Body:{
	return int64(sort.Search(len(u), func(i int) bool { return uint64(u[i]) >= x }))
} PrettyPrintBody:[{ return int64(sort.Search(len(u), func(i int) bool { return uint64(u[i]) >= x })) }]}
{Id:6 FileId:27 StartLine:46 StartColumn:1 EndLine:62 EndColumn:2 Name:insert Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64} {Name: Type:bool}] Receiver:0xc000e7e480 Body:{
	i := u.search(x)

	if i == int64(len(*u)) {
		*u = append(*u, x)
		return i, true
	}

	if (*u)[i] == x {
		return i, false
	}

	*u = append(*u, 0)
	copy((*u)[i+1:], (*u)[i:])
	(*u)[i] = x
	return i, true
} PrettyPrintBody:[{ i := u.search(x) if i == int64(len(*u)) { *u = append(*u, x) return i, true } if (*u)[i] == x { return i, false } *u = append(*u, 0) copy((*u)[i+1:], (*u)[i:]) (*u)[i] = x return i, true }]}
{Id:7 FileId:27 StartLine:64 StartColumn:1 EndLine:68 EndColumn:2 Name:deleteAtIndex Params:[{Name:i Type:int64}] Results:[] Receiver:0xc001033100 Body:{
	copy((*u)[i:], (*u)[i+1:])
	(*u)[len(*u)-1] = 0
	*u = (*u)[:len(*u)-1]
} PrettyPrintBody:[{ copy((*u)[i:], (*u)[i+1:]) (*u)[len(*u)-1] = 0 *u = (*u)[:len(*u)-1] }]}
{Id:8 FileId:27 StartLine:70 StartColumn:1 EndLine:81 EndColumn:2 Name:get Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc0010de920 Body:{
	i := u.search(x)
	if i == int64(len(u)) {
		return -1
	}

	if u[i] == x {
		return i
	}

	return -1
} PrettyPrintBody:[{ i := u.search(x) if i == int64(len(u)) { return -1 } if u[i] == x { return i } return -1 }]}
{Id:10 FileId:27 StartLine:85 StartColumn:1 EndLine:94 EndColumn:2 Name:insert Params:[{Name:index Type:int64}] Results:[] Receiver:0xc001309d40 Body:{
	if index == int64(len(*b)) {
		*b = append(*b, block(0))
		return
	}

	*b = append(*b, block(0))
	copy((*b)[index+1:], (*b)[index:])
	(*b)[index] = block(0)
} PrettyPrintBody:[{ if index == int64(len(*b)) { *b = append(*b, block(0)) return } *b = append(*b, block(0)) copy((*b)[index+1:], (*b)[index:]) (*b)[index] = block(0) }]}
{Id:11 FileId:27 StartLine:96 StartColumn:1 EndLine:100 EndColumn:2 Name:deleteAtIndex Params:[{Name:i Type:int64}] Results:[] Receiver:0xc001309d80 Body:{
	copy((*b)[i:], (*b)[i+1:])
	(*b)[len(*b)-1] = block(0)
	*b = (*b)[:len(*b)-1]
} PrettyPrintBody:[{ copy((*b)[i:], (*b)[i+1:]) (*b)[len(*b)-1] = block(0) *b = (*b)[:len(*b)-1] }]}
{Id:13 FileId:27 StartLine:108 StartColumn:1 EndLine:117 EndColumn:2 Name:SetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001309ee0 Body:{
	index, position := getIndexAndRemainder(k)
	i, inserted := sba.indices.insert(index)

	if inserted {
		sba.blocks.insert(i)
	}
	sba.blocks[i] = sba.blocks[i].insert(position)
	return nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i, inserted := sba.indices.insert(index) if inserted { sba.blocks.insert(i) } sba.blocks[i] = sba.blocks[i].insert(position) return nil }]}
{Id:14 FileId:27 StartLine:120 StartColumn:1 EndLine:128 EndColumn:2 Name:GetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc00026cb00 Body:{
	index, position := getIndexAndRemainder(k)
	i := sba.indices.get(index)
	if i == -1 {
		return false, nil
	}

	return sba.blocks[i].get(position), nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i := sba.indices.get(index) if i == -1 { return false, nil } return sba.blocks[i].get(position), nil }]}
{Id:15 FileId:27 StartLine:132 StartColumn:1 EndLine:145 EndColumn:2 Name:ToNums Params:[] Results:[{Name: Type:[]uint64}] Receiver:0xc000992e60 Body:{
	if len(sba.indices) == 0 {
		return nil
	}

	diff := uint64(len(sba.indices)) * s
	nums := make([]uint64, 0, diff/4)

	for i, offset := range sba.indices {
		sba.blocks[i].toNums(offset*s, &nums)
	}

	return nums
} PrettyPrintBody:[{ if len(sba.indices) == 0 { return nil } diff := uint64(len(sba.indices)) * s nums := make([]uint64, 0, diff/4) for i, offset := range sba.indices { sba.blocks[i].toNums(offset*s, &nums) } return nums }]}
{Id:16 FileId:27 StartLine:148 StartColumn:1 EndLine:162 EndColumn:2 Name:ClearBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001033d20 Body:{
	index, position := getIndexAndRemainder(k)
	i := sba.indices.get(index)
	if i == -1 {
		return nil
	}

	sba.blocks[i] = sba.blocks[i].remove(position)
	if sba.blocks[i] == 0 {
		sba.blocks.deleteAtIndex(i)
		sba.indices.deleteAtIndex(i)
	}

	return nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i := sba.indices.get(index) if i == -1 { return nil } sba.blocks[i] = sba.blocks[i].remove(position) if sba.blocks[i] == 0 { sba.blocks.deleteAtIndex(i) sba.indices.deleteAtIndex(i) } return nil }]}
{Id:17 FileId:27 StartLine:165 StartColumn:1 EndLine:168 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0003e5340 Body:{
	sba.blocks = sba.blocks[:0]
	sba.indices = sba.indices[:0]
} PrettyPrintBody:[{ sba.blocks = sba.blocks[:0] sba.indices = sba.indices[:0] }]}
{Id:18 FileId:27 StartLine:171 StartColumn:1 EndLine:173 EndColumn:2 Name:Blocks Params:[] Results:[{Name: Type:Iterator}] Receiver:0xc0003e53c0 Body:{
	return newCompressedBitArrayIterator(sba)
} PrettyPrintBody:[{ return newCompressedBitArrayIterator(sba) }]}
{Id:19 FileId:27 StartLine:177 StartColumn:1 EndLine:183 EndColumn:2 Name:Capacity Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0003e5400 Body:{
	if len(sba.indices) == 0 {
		return 0
	}

	return (sba.indices[len(sba.indices)-1] + 1) * s
} PrettyPrintBody:[{ if len(sba.indices) == 0 { return 0 } return (sba.indices[len(sba.indices)-1] + 1) * s }]}
{Id:20 FileId:27 StartLine:187 StartColumn:1 EndLine:226 EndColumn:2 Name:Equals Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc000993b00 Body:{
	if other.Capacity() == 0 && sba.Capacity() > 0 {
		return false
	}

	var selfIndex uint64
	for iter := other.Blocks(); iter.Next(); {
		otherIndex, otherBlock := iter.Value()
		if len(sba.indices) == 0 {
			if otherBlock > 0 {
				return false
			}

			continue
		}

		if selfIndex >= uint64(len(sba.indices)) {
			return false
		}

		if otherIndex < sba.indices[selfIndex] {
			if otherBlock > 0 {
				return false
			}
			continue
		}

		if otherIndex > sba.indices[selfIndex] {
			return false
		}

		if !sba.blocks[selfIndex].equals(otherBlock) {
			return false
		}

		selfIndex++
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 && sba.Capacity() > 0 { return false } var selfIndex uint64 for iter := other.Blocks(); iter.Next(); { otherIndex, otherBlock := iter.Value() if len(sba.indices) == 0 { if otherBlock > 0 { return false } continue } if selfIndex >= uint64(len(sba.indices)) { return false } if otherIndex < sba.indices[selfIndex] { if otherBlock > 0 { return false } continue } if otherIndex > sba.indices[selfIndex] { return false } if !sba.blocks[selfIndex].equals(otherBlock) { return false } selfIndex++ } return true }]}
{Id:21 FileId:27 StartLine:230 StartColumn:1 EndLine:236 EndColumn:2 Name:Or Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc001602f40 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return orSparseWithSparseBitArray(sba, ba)
	}

	return orSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return orSparseWithSparseBitArray(sba, ba) } return orSparseWithDenseBitArray(sba, other.(*bitArray)) }]}
{Id:22 FileId:27 StartLine:240 StartColumn:1 EndLine:246 EndColumn:2 Name:And Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc0003e5500 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return andSparseWithSparseBitArray(sba, ba)
	}

	return andSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return andSparseWithSparseBitArray(sba, ba) } return andSparseWithDenseBitArray(sba, other.(*bitArray)) }]}
{Id:23 FileId:27 StartLine:250 StartColumn:1 EndLine:256 EndColumn:2 Name:Nand Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc001409ee0 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return nandSparseWithSparseBitArray(sba, ba)
	}

	return nandSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return nandSparseWithSparseBitArray(sba, ba) } return nandSparseWithDenseBitArray(sba, other.(*bitArray)) }]}
{Id:24 FileId:27 StartLine:258 StartColumn:1 EndLine:262 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001409f80 Body:{

	return len(sba.indices) == 0
} PrettyPrintBody:[{ return len(sba.indices) == 0 }]}
{Id:25 FileId:27 StartLine:264 StartColumn:1 EndLine:273 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*sparseBitArray}] Receiver:0xc001603180 Body:{
	blocks := make(blocks, len(sba.blocks))
	copy(blocks, sba.blocks)
	indices := make(uintSlice, len(sba.indices))
	copy(indices, sba.indices)
	return &sparseBitArray{
		blocks:		blocks,
		indices:	indices,
	}
} PrettyPrintBody:[{ blocks := make(blocks, len(sba.blocks)) copy(blocks, sba.blocks) indices := make(uintSlice, len(sba.indices)) copy(indices, sba.indices) return &sparseBitArray{ blocks:		blocks, indices:	indices, } }]}
{Id:26 FileId:27 StartLine:277 StartColumn:1 EndLine:310 EndColumn:2 Name:Intersects Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc00019e4a0 Body:{
	if other.Capacity() == 0 {
		return true
	}

	var selfIndex int64
	for iter := other.Blocks(); iter.Next(); {
		otherI, otherBlock := iter.Value()
		if len(sba.indices) == 0 {
			if otherBlock > 0 {
				return false
			}
			continue
		}

		i := uintSlice(sba.indices[selfIndex:]).search(otherI)

		if i == int64(len(sba.indices)) {
			return false
		}

		if sba.indices[i] != otherI {
			return false
		}

		if !sba.blocks[i].intersects(otherBlock) {
			return false
		}

		selfIndex = i
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 { return true } var selfIndex int64 for iter := other.Blocks(); iter.Next(); { otherI, otherBlock := iter.Value() if len(sba.indices) == 0 { if otherBlock > 0 { return false } continue } i := uintSlice(sba.indices[selfIndex:]).search(otherI) if i == int64(len(sba.indices)) { return false } if sba.indices[i] != otherI { return false } if !sba.blocks[i].intersects(otherBlock) { return false } selfIndex = i } return true }]}
{Id:27 FileId:27 StartLine:312 StartColumn:1 EndLine:314 EndColumn:2 Name:IntersectsBetween Params:[{Name:other Type:BitArray} {Name:start Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000a8b400 Body:{
	return true
} PrettyPrintBody:[{ return true }]}
{Id:28 FileId:27 StartLine:316 StartColumn:1 EndLine:318 EndColumn:2 Name:newSparseBitArray Params:[] Results:[{Name: Type:*sparseBitArray}] Receiver:<nil> Body:{
	return &sparseBitArray{}
} PrettyPrintBody:[{ return &sparseBitArray{} }]}
{Id:29 FileId:27 StartLine:322 StartColumn:1 EndLine:324 EndColumn:2 Name:NewSparseBitArray Params:[] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	return newSparseBitArray()
} PrettyPrintBody:[{ return newSparseBitArray() }]}
{Id:1 FileId:47 StartLine:26 StartColumn:1 EndLine:86 EndColumn:2 Name:Apply Params:[{Name:fn Type:func(item *Item)} {Name:keys Type:...interface{}}] Results:[{Name: Type:error}] Receiver:0xc000879a80 Body:{
	if t.Root == nil || len(keys) == 0 {
		return nil
	}

	positions := make(map[interface{}]int, len(keys))
	for i, key := range keys {
		positions[key] = i
	}

	chunks := splitValues(keys, runtime.NumCPU())
	var wg sync.WaitGroup
	wg.Add(len(chunks))
	lerr := terr.New()
	result := make(Keys, len(keys))

	for i := 0; i < len(chunks); i++ {
		go func(i int) {
			defer wg.Done()

			chunk := chunks[i]
			if len(chunk) == 0 {
				return
			}

			for _, value := range chunk {
				n, _, err := t.iterativeFindWithoutPath(value, t.Root)
				if err != nil {
					lerr.Set(err)
					return
				}

				if n == nil {
					continue
				}

				k, _ := n.searchKey(t.config.Comparator, value)
				if k != nil && t.config.Comparator(k.Value, value) == 0 {
					result[positions[value]] = k
				}
			}
		}(i)
	}

	wg.Wait()

	if lerr.Get() != nil {
		return lerr.Get()
	}

	for _, k := range result {
		if k == nil {
			continue
		}

		item := k.ToItem()
		fn(item)
	}

	return nil
} PrettyPrintBody:[{ if t.Root == nil || len(keys) == 0 { return nil } positions := make(map[interface{}]int, len(keys)) for i, key := range keys { positions[key] = i } chunks := splitValues(keys, runtime.NumCPU()) var wg sync.WaitGroup wg.Add(len(chunks)) lerr := terr.New() result := make(Keys, len(keys)) for i := 0; i < len(chunks); i++ { go func(i int) { defer wg.Done() chunk := chunks[i] if len(chunk) == 0 { return } for _, value := range chunk { n, _, err := t.iterativeFindWithoutPath(value, t.Root) if err != nil { lerr.Set(err) return } if n == nil { continue } k, _ := n.searchKey(t.config.Comparator, value) if k != nil && t.config.Comparator(k.Value, value) == 0 { result[positions[value]] = k } } }(i) } wg.Wait() if lerr.Get() != nil { return lerr.Get() } for _, k := range result { if k == nil { continue } item := k.ToItem() fn(item) } return nil }]}
{Id:2 FileId:47 StartLine:92 StartColumn:1 EndLine:101 EndColumn:2 Name:filter Params:[{Name:start Type:interface{}} {Name:n Type:*Node} {Name:fn Type:func(key *Key) bool}] Results:[{Name: Type:bool}] Receiver:0xc001033460 Body:{
	for iter := n.iter(t.config.Comparator, start, stop); iter.next(); {
		id, _ := iter.value()
		if !fn(id) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for iter := n.iter(t.config.Comparator, start, stop); iter.next(); { id, _ := iter.value() if !fn(id) { return false } } return true }]}
{Id:3 FileId:47 StartLine:103 StartColumn:1 EndLine:133 EndColumn:2 Name:iter Params:[{Name:start Type:interface{}} {Name:fn Type:func(*Key) bool}] Results:[{Name: Type:error}] Receiver:0xc001309a80 Body:{
	if len(t.Root) == 0 {
		return nil
	}

	cur := start
	seen := make(map[string]struct{}, 10)

	for t.config.Comparator(stop, cur) > 0 {
		n, highestValue, err := t.iterativeFindWithoutPath(cur, t.Root)
		if err != nil {
			return err
		}

		if n == nil && highestValue == nil {
			break
		} else if n != nil {
			if _, ok := seen[string(n.ID)]; ok {
				break
			}
			if !t.filter(cur, stop, n, fn) {
				break
			}
		}

		cur = n.lastValue()
		seen[string(n.ID)] = struct{}{}
	}

	return nil
} PrettyPrintBody:[{ if len(t.Root) == 0 { return nil } cur := start seen := make(map[string]struct{}, 10) for t.config.Comparator(stop, cur) > 0 { n, highestValue, err := t.iterativeFindWithoutPath(cur, t.Root) if err != nil { return err } if n == nil && highestValue == nil { break } else if n != nil { if _, ok := seen[string(n.ID)]; ok { break } if !t.filter(cur, stop, n, fn) { break } } cur = n.lastValue() seen[string(n.ID)] = struct{}{} } return nil }]}
{Id:4 FileId:47 StartLine:138 StartColumn:1 EndLine:166 EndColumn:2 Name:iterativeFind Params:[{Name:value Type:interface{}} {Name:id Type:ID}] Results:[{Name: Type:*path} {Name: Type:error}] Receiver:0xc000a8a840 Body:{
	if len(id) == 0 {
		return nil, nil
	}

	path := &path{}
	var n *Node
	var err error
	var i int
	var key *Key

	for {
		n, err = t.contextOrCachedNode(id, t.mutable)
		if err != nil {
			return nil, err
		}

		key, i = n.searchKey(t.config.Comparator, value)

		pb := &pathBundle{i: i, n: n}
		path.append(pb)
		if n.IsLeaf {
			return path, nil
		}
		id = key.ID()
	}

	return path, nil
} PrettyPrintBody:[{ if len(id) == 0 { return nil, nil } path := &path{} var n *Node var err error var i int var key *Key for { n, err = t.contextOrCachedNode(id, t.mutable) if err != nil { return nil, err } key, i = n.searchKey(t.config.Comparator, value) pb := &pathBundle{i: i, n: n} path.append(pb) if n.IsLeaf { return path, nil } id = key.ID() } return path, nil }]}
{Id:5 FileId:47 StartLine:168 StartColumn:1 EndLine:197 EndColumn:2 Name:iterativeFindWithoutPath Params:[{Name:value Type:interface{}} {Name:id Type:ID}] Results:[{Name: Type:*Node} {Name: Type:interface{}} {Name: Type:error}] Receiver:0xc0001e6460 Body:{
	var n *Node
	var err error
	var i int
	var key *Key
	var highestValue interface{}

	for {
		n, err = t.contextOrCachedNode(id, t.mutable)
		if err != nil {
			return nil, highestValue, err
		}

		if n.IsLeaf {
			if t.config.Comparator(n.lastValue(), value) < 0 {
				return nil, highestValue, nil
			}
			highestValue = n.lastValue()
			return n, highestValue, nil
		}

		key, i = n.searchKey(t.config.Comparator, value)
		if i < n.lenValues() {
			highestValue = n.valueAt(i)
		}
		id = key.ID()
	}

	return n, highestValue, nil
} PrettyPrintBody:[{ var n *Node var err error var i int var key *Key var highestValue interface{} for { n, err = t.contextOrCachedNode(id, t.mutable) if err != nil { return nil, highestValue, err } if n.IsLeaf { if t.config.Comparator(n.lastValue(), value) < 0 { return nil, highestValue, nil } highestValue = n.lastValue() return n, highestValue, nil } key, i = n.searchKey(t.config.Comparator, value) if i < n.lenValues() { highestValue = n.valueAt(i) } id = key.ID() } return n, highestValue, nil }]}
{Id:2 FileId:48 StartLine:33 StartColumn:1 EndLine:38 EndColumn:2 Name:nodeExists Params:[{Name:id Type:ID}] Results:[{Name: Type:bool}] Receiver:0xc001032cc0 Body:{
	c.lock.RLock()
	defer c.lock.RUnlock()
	_, ok := c.seenNodes[string(id)]
	return ok
} PrettyPrintBody:[{ c.lock.RLock() defer c.lock.RUnlock() _, ok := c.seenNodes[string(id)] return ok }]}
{Id:3 FileId:48 StartLine:40 StartColumn:1 EndLine:44 EndColumn:2 Name:addNode Params:[{Name:n Type:*Node}] Results:[] Receiver:0xc0016021e0 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()
	c.seenNodes[string(n.ID)] = n
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() c.seenNodes[string(n.ID)] = n }]}
{Id:4 FileId:48 StartLine:46 StartColumn:1 EndLine:50 EndColumn:2 Name:getNode Params:[{Name:id Type:ID}] Results:[{Name: Type:*Node}] Receiver:0xc001309160 Body:{
	c.lock.RLock()
	defer c.lock.RUnlock()
	return c.seenNodes[string(id)]
} PrettyPrintBody:[{ c.lock.RLock() defer c.lock.RUnlock() return c.seenNodes[string(id)] }]}
{Id:5 FileId:48 StartLine:52 StartColumn:1 EndLine:56 EndColumn:2 Name:newContext Params:[] Results:[{Name: Type:*context}] Receiver:<nil> Body:{
	return &context{
		seenNodes: make(map[string]*Node, 10),
	}
} PrettyPrintBody:[{ return &context{ seenNodes: make(map[string]*Node, 10), } }]}
{Id:7 FileId:48 StartLine:72 StartColumn:1 EndLine:76 EndColumn:2 Name:createRoot Params:[] Results:[{Name: Type:*Node}] Receiver:0xc0010334a0 Body:{
	n := newNode()
	n.IsLeaf = true
	return n
} PrettyPrintBody:[{ n := newNode() n.IsLeaf = true return n }]}
{Id:8 FileId:48 StartLine:80 StartColumn:1 EndLine:89 EndColumn:2 Name:contextOrCachedNode Params:[{Name:id Type:ID} {Name:cache Type:bool}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc000f53a80 Body:{
	if t.context != nil {
		n := t.context.getNode(id)
		if n != nil {
			return n, nil
		}
	}

	return t.cacher.getNode(t, id, cache)
} PrettyPrintBody:[{ if t.context != nil { n := t.context.getNode(id) if n != nil { return n, nil } } return t.cacher.getNode(t, id, cache) }]}
{Id:9 FileId:48 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:ID}] Receiver:0xc001580e00 Body:{
	return t.UUID
} PrettyPrintBody:[{ return t.UUID }]}
{Id:10 FileId:48 StartLine:97 StartColumn:1 EndLine:104 EndColumn:2 Name:toBytes Params:[] Results:[{Name: Type:[]byte}] Receiver:0xc001309ae0 Body:{
	buf, err := t.MarshalMsg(nil)
	if err != nil {
		panic(`unable to encode tree`)
	}

	return buf
} PrettyPrintBody:[{ buf, err := t.MarshalMsg(nil) if err != nil { panic(`unable to encode tree`) } return buf }]}
{Id:11 FileId:48 StartLine:107 StartColumn:1 EndLine:110 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc0016026c0 Body:{
	t.cacher.clear()
	t.context = nil
} PrettyPrintBody:[{ t.cacher.clear() t.context = nil }]}
{Id:12 FileId:48 StartLine:114 StartColumn:1 EndLine:129 EndColumn:2 Name:commit Params:[] Results:[{Name: Type:[]*Payload}] Receiver:0xc000a22ca0 Body:{
	items := make([]*Payload, 0, len(t.context.seenNodes))
	for _, n := range t.context.seenNodes {
		n.ChildValues, n.ChildKeys = n.flatten()
		buf, err := n.MarshalMsg(nil)
		if err != nil {
			panic(`unable to encode node`)
		}

		n.ChildValues, n.ChildKeys = nil, nil
		item := &Payload{n.ID, buf}
		items = append(items, item)
	}

	return items
} PrettyPrintBody:[{ items := make([]*Payload, 0, len(t.context.seenNodes)) for _, n := range t.context.seenNodes { n.ChildValues, n.ChildKeys = n.flatten() buf, err := n.MarshalMsg(nil) if err != nil { panic(`unable to encode node`) } n.ChildValues, n.ChildKeys = nil, nil item := &Payload{n.ID, buf} items = append(items, item) } return items }]}
{Id:13 FileId:48 StartLine:131 StartColumn:1 EndLine:139 EndColumn:2 Name:copyNode Params:[{Name:n Type:*Node}] Results:[{Name: Type:*Node}] Receiver:0xc00095a7a0 Body:{
	if t.context.nodeExists(n.ID) {
		return n
	}

	cp := n.copy()
	t.context.addNode(cp)
	return cp
} PrettyPrintBody:[{ if t.context.nodeExists(n.ID) { return n } cp := n.copy() t.context.addNode(cp) return cp }]}
{Id:14 FileId:48 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0003e51c0 Body:{
	return t.Count
} PrettyPrintBody:[{ return t.Count }]}
{Id:15 FileId:48 StartLine:145 StartColumn:1 EndLine:156 EndColumn:2 Name:AsMutable Params:[] Results:[{Name: Type:MutableTree}] Receiver:0xc0015815c0 Body:{
	return &Tr{
		Count:		t.Count,
		UUID:		newID(),
		Root:		t.Root,
		config:		t.config,
		cacher:		t.cacher,
		context:	newContext(),
		NodeWidth:	t.NodeWidth,
		mutable:	true,
	}
} PrettyPrintBody:[{ return &Tr{ Count:		t.Count, UUID:		newID(), Root:		t.Root, config:		t.config, cacher:		t.cacher, context:	newContext(), NodeWidth:	t.NodeWidth, mutable:	true, } }]}
{Id:16 FileId:48 StartLine:158 StartColumn:1 EndLine:174 EndColumn:2 Name:Commit Params:[] Results:[{Name: Type:ReadableTree} {Name: Type:error}] Receiver:0xc001033f40 Body:{
	t.NodeWidth = t.config.NodeWidth
	items := make([]*Payload, 0, len(t.context.seenNodes))
	items = append(items, t.commit()...)

	items = append(items, &Payload{t.ID(), t.toBytes()})

	err := t.config.Persister.Save(items...)
	if err != nil {
		return nil, err
	}

	t.reset()
	t.context = nil
	return t, nil
} PrettyPrintBody:[{ t.NodeWidth = t.config.NodeWidth items := make([]*Payload, 0, len(t.context.seenNodes)) items = append(items, t.commit()...) items = append(items, &Payload{t.ID(), t.toBytes()}) err := t.config.Persister.Save(items...) if err != nil { return nil, err } t.reset() t.context = nil return t, nil }]}
{Id:17 FileId:48 StartLine:176 StartColumn:1 EndLine:191 EndColumn:2 Name:treeFromBytes Params:[{Name:p Type:Persister} {Name:data Type:[]byte} {Name:comparator Type:Comparator}] Results:[{Name: Type:*Tr} {Name: Type:error}] Receiver:<nil> Body:{
	t := &Tr{}
	_, err := t.UnmarshalMsg(data)
	if err != nil {
		return nil, err
	}

	cfg := DefaultConfig(p, comparator)
	if t.NodeWidth > 0 {
		cfg.NodeWidth = t.NodeWidth
	}
	t.config = cfg
	t.cacher = newCacher(cfg.Persister)

	return t, nil
} PrettyPrintBody:[{ t := &Tr{} _, err := t.UnmarshalMsg(data) if err != nil { return nil, err } cfg := DefaultConfig(p, comparator) if t.NodeWidth > 0 { cfg.NodeWidth = t.NodeWidth } t.config = cfg t.cacher = newCacher(cfg.Persister) return t, nil }]}
{Id:18 FileId:48 StartLine:193 StartColumn:1 EndLine:199 EndColumn:2 Name:newTree Params:[{Name:cfg Type:Config}] Results:[{Name: Type:*Tr}] Receiver:<nil> Body:{
	return &Tr{
		config:	cfg,
		UUID:	newID(),
		cacher:	newCacher(cfg.Persister),
	}
} PrettyPrintBody:[{ return &Tr{ config:	cfg, UUID:	newID(), cacher:	newCacher(cfg.Persister), } }]}
{Id:19 FileId:48 StartLine:202 StartColumn:1 EndLine:204 EndColumn:2 Name:New Params:[{Name:cfg Type:Config}] Results:[{Name: Type:ReadableTree}] Receiver:<nil> Body:{
	return newTree(cfg)
} PrettyPrintBody:[{ return newTree(cfg) }]}
{Id:20 FileId:48 StartLine:210 StartColumn:1 EndLine:226 EndColumn:2 Name:Load Params:[{Name:p Type:Persister} {Name:id Type:[]byte} {Name:comparator Type:Comparator}] Results:[{Name: Type:ReadableTree} {Name: Type:error}] Receiver:<nil> Body:{
	items, err := p.Load(id)
	if err != nil {
		return nil, err
	}

	if len(items) == 0 || items[0] == nil {
		return nil, ErrTreeNotFound
	}

	rt, err := treeFromBytes(p, items[0].Payload, comparator)
	if err != nil {
		return nil, err
	}

	return rt, nil
} PrettyPrintBody:[{ items, err := p.Load(id) if err != nil { return nil, err } if len(items) == 0 || items[0] == nil { return nil, ErrTreeNotFound } rt, err := treeFromBytes(p, items[0].Payload, comparator) if err != nil { return nil, err } return rt, nil }]}
{Id:2 FileId:96 StartLine:63 StartColumn:1 EndLine:73 EndColumn:2 Name:get Params:[] Results:[{Name: Type:*sema}] Receiver:0xc0012ce1a0 Body:{
	if len(*w) == 0 {
		return nil
	}

	sema := (*w)[0]
	copy((*w)[0:], (*w)[1:])
	(*w)[len(*w)-1] = nil
	*w = (*w)[:len(*w)-1]
	return sema
} PrettyPrintBody:[{ if len(*w) == 0 { return nil } sema := (*w)[0] copy((*w)[0:], (*w)[1:]) (*w)[len(*w)-1] = nil *w = (*w)[:len(*w)-1] return sema }]}
{Id:3 FileId:96 StartLine:75 StartColumn:1 EndLine:77 EndColumn:2 Name:put Params:[{Name:sema Type:*sema}] Results:[] Receiver:0xc00123c740 Body:{
	*w = append(*w, sema)
} PrettyPrintBody:[{ *w = append(*w, sema) }]}
{Id:4 FileId:96 StartLine:79 StartColumn:1 EndLine:92 EndColumn:2 Name:remove Params:[{Name:sema Type:*sema}] Results:[] Receiver:0xc00123c920 Body:{
	if len(*w) == 0 {
		return
	}

	ws := *w
	newWs := make(waiters, 0, len(*w))
	for i := range ws {
		if ws[i] != sema {
			newWs = append(newWs, ws[i])
		}
	}
	*w = newWs
} PrettyPrintBody:[{ if len(*w) == 0 { return } ws := *w newWs := make(waiters, 0, len(*w)) for i := range ws { if ws[i] != sema { newWs = append(newWs, ws[i]) } } *w = newWs }]}
{Id:6 FileId:96 StartLine:96 StartColumn:1 EndLine:111 EndColumn:2 Name:get Params:[{Name:number Type:int64}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001602500 Body:{
	returnItems := make([]interface{}, 0, number)
	index := int64(0)
	for i := int64(0); i < number; i++ {
		if i >= int64(len(*items)) {
			break
		}

		returnItems = append(returnItems, (*items)[i])
		(*items)[i] = nil
		index++
	}

	*items = (*items)[index:]
	return returnItems
} PrettyPrintBody:[{ returnItems := make([]interface{}, 0, number) index := int64(0) for i := int64(0); i < number; i++ { if i >= int64(len(*items)) { break } returnItems = append(returnItems, (*items)[i]) (*items)[i] = nil index++ } *items = (*items)[index:] return returnItems }]}
{Id:7 FileId:96 StartLine:113 StartColumn:1 EndLine:121 EndColumn:2 Name:peek Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000df6ca0 Body:{
	length := len(*items)

	if length == 0 {
		return nil, false
	}

	return (*items)[0], true
} PrettyPrintBody:[{ length := len(*items) if length == 0 { return nil, false } return (*items)[0], true }]}
{Id:8 FileId:96 StartLine:123 StartColumn:1 EndLine:146 EndColumn:2 Name:getUntil Params:[{Name:checker Type:func(item interface{}) bool}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001409b60 Body:{
	length := len(*items)

	if len(*items) == 0 {

		return []interface{}{}
	}

	returnItems := make([]interface{}, 0, length)
	index := -1
	for i, item := range *items {
		if !checker(item) {
			break
		}

		returnItems = append(returnItems, item)
		index = i
		(*items)[i] = nil
	}

	*items = (*items)[index+1:]
	return returnItems
} PrettyPrintBody:[{ length := len(*items) if len(*items) == 0 { return []interface{}{} } returnItems := make([]interface{}, 0, length) index := -1 for i, item := range *items { if !checker(item) { break } returnItems = append(returnItems, item) index = i (*items)[i] = nil } *items = (*items)[index+1:] return returnItems }]}
{Id:10 FileId:96 StartLine:153 StartColumn:1 EndLine:158 EndColumn:2 Name:newSema Params:[] Results:[{Name: Type:*sema}] Receiver:<nil> Body:{
	return &sema{
		ready:		make(chan bool, 1),
		response:	&sync.WaitGroup{},
	}
} PrettyPrintBody:[{ return &sema{ ready:		make(chan bool, 1), response:	&sync.WaitGroup{}, } }]}
{Id:12 FileId:96 StartLine:170 StartColumn:1 EndLine:202 EndColumn:2 Name:Put Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:error}] Receiver:0xc000a8a560 Body:{
	if len(items) == 0 {
		return nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return ErrDisposed
	}

	q.items = append(q.items, items...)
	for {
		sema := q.waiters.get()
		if sema == nil {
			break
		}
		sema.response.Add(1)
		select {
		case sema.ready <- true:
			sema.response.Wait()
		default:

		}
		if len(q.items) == 0 {
			break
		}
	}

	q.lock.Unlock()
	return nil
} PrettyPrintBody:[{ if len(items) == 0 { return nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return ErrDisposed } q.items = append(q.items, items...) for { sema := q.waiters.get() if sema == nil { break } sema.response.Add(1) select { case sema.ready <- true: sema.response.Wait() default: } if len(q.items) == 0 { break } } q.lock.Unlock() return nil }]}
{Id:13 FileId:96 StartLine:208 StartColumn:1 EndLine:210 EndColumn:2 Name:Get Params:[{Name:number Type:int64}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0001e60c0 Body:{
	return q.Poll(number, 0)
} PrettyPrintBody:[{ return q.Poll(number, 0) }]}
{Id:14 FileId:96 StartLine:217 StartColumn:1 EndLine:270 EndColumn:2 Name:Poll Params:[{Name:number Type:int64} {Name:timeout Type:time.Duration}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0003e4f40 Body:{
	if number < 1 {

		return []interface{}{}, nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return nil, ErrDisposed
	}

	var items []interface{}

	if len(q.items) == 0 {
		sema := newSema()
		q.waiters.put(sema)
		q.lock.Unlock()

		var timeoutC <-chan time.Time
		if timeout > 0 {
			timeoutC = time.After(timeout)
		}
		select {
		case <-sema.ready:

			if q.disposed {
				return nil, ErrDisposed
			}
			items = q.items.get(number)
			sema.response.Done()
			return items, nil
		case <-timeoutC:

			select {
			case sema.ready <- true:

				q.lock.Lock()
				q.waiters.remove(sema)
				q.lock.Unlock()
			default:

				sema.response.Done()
			}
			return nil, ErrTimeout
		}
	}

	items = q.items.get(number)
	q.lock.Unlock()
	return items, nil
} PrettyPrintBody:[{ if number < 1 { return []interface{}{}, nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return nil, ErrDisposed } var items []interface{} if len(q.items) == 0 { sema := newSema() q.waiters.put(sema) q.lock.Unlock() var timeoutC <-chan time.Time if timeout > 0 { timeoutC = time.After(timeout) } select { case <-sema.ready: if q.disposed { return nil, ErrDisposed } items = q.items.get(number) sema.response.Done() return items, nil case <-timeoutC: select { case sema.ready <- true: q.lock.Lock() q.waiters.remove(sema) q.lock.Unlock() default: sema.response.Done() } return nil, ErrTimeout } } items = q.items.get(number) q.lock.Unlock() return items, nil }]}
{Id:15 FileId:96 StartLine:274 StartColumn:1 EndLine:288 EndColumn:2 Name:Peek Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001033dc0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	if q.disposed {
		return nil, ErrDisposed
	}

	peekItem, ok := q.items.peek()
	if !ok {
		return nil, ErrEmptyQueue
	}

	return peekItem, nil
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() if q.disposed { return nil, ErrDisposed } peekItem, ok := q.items.peek() if !ok { return nil, ErrEmptyQueue } return peekItem, nil }]}
{Id:16 FileId:96 StartLine:293 StartColumn:1 EndLine:308 EndColumn:2 Name:TakeUntil Params:[{Name:checker Type:func(item interface{}) bool}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0015816c0 Body:{
	if checker == nil {
		return nil, nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return nil, ErrDisposed
	}

	result := q.items.getUntil(checker)
	q.lock.Unlock()
	return result, nil
} PrettyPrintBody:[{ if checker == nil { return nil, nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return nil, ErrDisposed } result := q.items.getUntil(checker) q.lock.Unlock() return result, nil }]}
{Id:17 FileId:96 StartLine:311 StartColumn:1 EndLine:316 EndColumn:2 Name:Empty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001409f20 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return len(q.items) == 0
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return len(q.items) == 0 }]}
{Id:18 FileId:96 StartLine:319 StartColumn:1 EndLine:324 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc000a8a9c0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return int64(len(q.items))
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return int64(len(q.items)) }]}
{Id:19 FileId:96 StartLine:328 StartColumn:1 EndLine:333 EndColumn:2 Name:Disposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000993ca0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return q.disposed
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return q.disposed }]}
{Id:20 FileId:96 StartLine:338 StartColumn:1 EndLine:359 EndColumn:2 Name:Dispose Params:[] Results:[{Name: Type:[]interface{}}] Receiver:0xc0001e6520 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	q.disposed = true
	for _, waiter := range q.waiters {
		waiter.response.Add(1)
		select {
		case waiter.ready <- true:

		default:

		}
	}

	disposedItems := q.items

	q.items = nil
	q.waiters = nil

	return disposedItems
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() q.disposed = true for _, waiter := range q.waiters { waiter.response.Add(1) select { case waiter.ready <- true: default: } } disposedItems := q.items q.items = nil q.waiters = nil return disposedItems }]}
{Id:21 FileId:96 StartLine:362 StartColumn:1 EndLine:366 EndColumn:2 Name:New Params:[{Name:hint Type:int64}] Results:[{Name: Type:*Queue}] Receiver:<nil> Body:{
	return &Queue{
		items: make([]interface{}, 0, hint),
	}
} PrettyPrintBody:[{ return &Queue{ items: make([]interface{}, 0, hint), } }]}
{Id:22 FileId:96 StartLine:372 StartColumn:1 EndLine:411 EndColumn:2 Name:ExecuteInParallel Params:[{Name:q Type:*Queue} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if q == nil {
		return
	}

	q.lock.Lock()

	todo, done := uint64(len(q.items)), int64(-1)

	if todo == 0 {
		return
	}

	numCPU := 1
	if runtime.NumCPU() > 1 {
		numCPU = runtime.NumCPU() - 1
	}

	var wg sync.WaitGroup
	wg.Add(numCPU)
	items := q.items

	for i := 0; i < numCPU; i++ {
		go func() {
			for {
				index := atomic.AddInt64(&done, 1)
				if index >= int64(todo) {
					wg.Done()
					break
				}

				fn(items[index])
				items[index] = 0
			}
		}()
	}
	wg.Wait()
	q.lock.Unlock()
	q.Dispose()
} PrettyPrintBody:[{ if q == nil { return } q.lock.Lock() todo, done := uint64(len(q.items)), int64(-1) if todo == 0 { return } numCPU := 1 if runtime.NumCPU() > 1 { numCPU = runtime.NumCPU() - 1 } var wg sync.WaitGroup wg.Add(numCPU) items := q.items for i := 0; i < numCPU; i++ { go func() { for { index := atomic.AddInt64(&done, 1) if index >= int64(todo) { wg.Done() break } fn(items[index]) items[index] = 0 } }() } wg.Wait() q.lock.Unlock() q.Dispose() }]}
{Id:2 FileId:103 StartLine:27 StartColumn:1 EndLine:33 EndColumn:2 Name:newCache Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:[]slice.Int64Slice}] Receiver:<nil> Body:{
	cache := make([]slice.Int64Slice, 0, dimensions-1)
	for i := uint64(0); i < dimensions; i++ {
		cache = append(cache, slice.Int64Slice{})
	}
	return cache
} PrettyPrintBody:[{ cache := make([]slice.Int64Slice, 0, dimensions-1) for i := uint64(0); i < dimensions; i++ { cache = append(cache, slice.Int64Slice{}) } return cache }]}
{Id:3 FileId:103 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:needNextDimension Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095abc0 Body:{
	return irt.dimensions > 1
} PrettyPrintBody:[{ return irt.dimensions > 1 }]}
{Id:4 FileId:103 StartLine:39 StartColumn:1 EndLine:74 EndColumn:2 Name:add Params:[{Name:nodes Type:*orderedNodes} {Name:cache Type:[]slice.Int64Slice} {Name:entry Type:Entry} {Name:added Type:*uint64}] Results:[] Receiver:0xc001602280 Body:{
	var node *node
	list := nodes

	for i := uint64(1); i <= irt.dimensions; i++ {
		if isLastDimension(irt.dimensions, i) {
			if i != 1 && !cache[i-1].Exists(node.value) {
				nodes := make(orderedNodes, len(*list))
				copy(nodes, *list)
				list = &nodes
				cache[i-1].Insert(node.value)
			}

			newNode := newNode(entry.ValueAtDimension(i), entry, false)
			overwritten := list.add(newNode)
			if overwritten == nil {
				*added++
			}
			if node != nil {
				node.orderedNodes = *list
			}
			break
		}

		if i != 1 && !cache[i-1].Exists(node.value) {
			nodes := make(orderedNodes, len(*list))
			copy(nodes, *list)
			list = &nodes
			cache[i-1].Insert(node.value)
			node.orderedNodes = *list
		}

		node, _ = list.getOrAdd(entry, i, irt.dimensions)
		list = &node.orderedNodes
	}
} PrettyPrintBody:[{ var node *node list := nodes for i := uint64(1); i <= irt.dimensions; i++ { if isLastDimension(irt.dimensions, i) { if i != 1 && !cache[i-1].Exists(node.value) { nodes := make(orderedNodes, len(*list)) copy(nodes, *list) list = &nodes cache[i-1].Insert(node.value) } newNode := newNode(entry.ValueAtDimension(i), entry, false) overwritten := list.add(newNode) if overwritten == nil { *added++ } if node != nil { node.orderedNodes = *list } break } if i != 1 && !cache[i-1].Exists(node.value) { nodes := make(orderedNodes, len(*list)) copy(nodes, *list) list = &nodes cache[i-1].Insert(node.value) node.orderedNodes = *list } node, _ = list.getOrAdd(entry, i, irt.dimensions) list = &node.orderedNodes } }]}
{Id:5 FileId:103 StartLine:78 StartColumn:1 EndLine:95 EndColumn:2 Name:Add Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*immutableRangeTree}] Receiver:0xc001409a40 Body:{
	if len(entries) == 0 {
		return irt
	}

	cache := newCache(irt.dimensions)
	top := make(orderedNodes, len(irt.top))
	copy(top, irt.top)
	added := uint64(0)
	for _, entry := range entries {
		irt.add(&top, cache, entry, &added)
	}

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = top
	tree.number = irt.number + added
	return tree
} PrettyPrintBody:[{ if len(entries) == 0 { return irt } cache := newCache(irt.dimensions) top := make(orderedNodes, len(irt.top)) copy(top, irt.top) added := uint64(0) for _, entry := range entries { irt.add(&top, cache, entry, &added) } tree := newImmutableRangeTree(irt.dimensions) tree.top = top tree.number = irt.number + added return tree }]}
{Id:6 FileId:103 StartLine:102 StartColumn:1 EndLine:120 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:*immutableRangeTree} {Name: Type:Entries} {Name: Type:Entries}] Receiver:0xc0010df120 Body:{

	if dimension > irt.dimensions || number == 0 {
		return irt, nil, nil
	}

	modified, deleted := make(Entries, 0, 100), make(Entries, 0, 100)

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = irt.top.immutableInsert(
		dimension, 1, irt.dimensions,
		index, number,
		&modified, &deleted,
	)
	tree.number = irt.number - uint64(len(deleted))

	return tree, modified, deleted
} PrettyPrintBody:[{ if dimension > irt.dimensions || number == 0 { return irt, nil, nil } modified, deleted := make(Entries, 0, 100), make(Entries, 0, 100) tree := newImmutableRangeTree(irt.dimensions) tree.top = irt.top.immutableInsert( dimension, 1, irt.dimensions, index, number, &modified, &deleted, ) tree.number = irt.number - uint64(len(deleted)) return tree, modified, deleted }]}
{Id:8 FileId:103 StartLine:129 StartColumn:1 EndLine:142 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*immutableRangeTree}] Receiver:0xc0010339e0 Body:{
	cache := newCache(irt.dimensions)
	top := make(orderedNodes, len(irt.top))
	copy(top, irt.top)
	deleted := uint64(0)
	for _, entry := range entries {
		irt.delete(&top, cache, entry, &deleted)
	}

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = top
	tree.number = irt.number - deleted
	return tree
} PrettyPrintBody:[{ cache := newCache(irt.dimensions) top := make(orderedNodes, len(irt.top)) copy(top, irt.top) deleted := uint64(0) for _, entry := range entries { irt.delete(&top, cache, entry, &deleted) } tree := newImmutableRangeTree(irt.dimensions) tree.top = top tree.number = irt.number - deleted return tree }]}
{Id:9 FileId:103 StartLine:144 StartColumn:1 EndLine:198 EndColumn:2 Name:delete Params:[{Name:top Type:*orderedNodes} {Name:cache Type:[]slice.Int64Slice} {Name:entry Type:Entry} {Name:deleted Type:*uint64}] Results:[] Receiver:0xc001581140 Body:{

	path := make([]*immutableNodeBundle, 0, 5)
	var index int
	var n *node
	var local *node
	list := top

	for i := uint64(1); i <= irt.dimensions; i++ {
		value := entry.ValueAtDimension(i)
		local, index = list.get(value)
		if local == nil {
			return
		}

		nb := &immutableNodeBundle{
			list:		list,
			index:		index,
			previousNode:	n,
		}
		path = append(path, nb)
		n = local
		list = &n.orderedNodes
	}

	*deleted++

	for i := len(path) - 1; i >= 0; i-- {
		nb := path[i]
		if nb.previousNode != nil {
			nodes := make(orderedNodes, len(*nb.list))
			copy(nodes, *nb.list)
			nb.list = &nodes
			if len(*nb.list) == 1 {
				continue
			}
			nn := newNode(
				nb.previousNode.value,
				nb.previousNode.entry,
				!isLastDimension(irt.dimensions, uint64(i)+1),
			)
			nn.orderedNodes = nodes
			path[i-1].newNode = nn
		}
	}

	for _, nb := range path {
		if nb.newNode == nil {
			nb.list.deleteAt(nb.index)
		} else {
			(*nb.list)[nb.index] = nb.newNode
		}
	}
} PrettyPrintBody:[{ path := make([]*immutableNodeBundle, 0, 5) var index int var n *node var local *node list := top for i := uint64(1); i <= irt.dimensions; i++ { value := entry.ValueAtDimension(i) local, index = list.get(value) if local == nil { return } nb := &immutableNodeBundle{ list:		list, index:		index, previousNode:	n, } path = append(path, nb) n = local list = &n.orderedNodes } *deleted++ for i := len(path) - 1; i >= 0; i-- { nb := path[i] if nb.previousNode != nil { nodes := make(orderedNodes, len(*nb.list)) copy(nodes, *nb.list) nb.list = &nodes if len(*nb.list) == 1 { continue } nn := newNode( nb.previousNode.value, nb.previousNode.entry, !isLastDimension(irt.dimensions, uint64(i)+1), ) nn.orderedNodes = nodes path[i-1].newNode = nn } } for _, nb := range path { if nb.newNode == nil { nb.list.deleteAt(nb.index) } else { (*nb.list)[nb.index] = nb.newNode } } }]}
{Id:10 FileId:103 StartLine:200 StartColumn:1 EndLine:222 EndColumn:2 Name:apply Params:[{Name:list Type:orderedNodes} {Name:interval Type:Interval} {Name:dimension Type:uint64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc000a8ab40 Body:{

	low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	if isLastDimension(irt.dimensions, dimension) {
		if !list.apply(low, high, fn) {
			return false
		}
	} else {
		if !list.apply(low, high, func(n *node) bool {
			if !irt.apply(n.orderedNodes, interval, dimension+1, fn) {
				return false
			}
			return true
		}) {
			return false
		}
		return true
	}

	return true
} PrettyPrintBody:[{ low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) if isLastDimension(irt.dimensions, dimension) { if !list.apply(low, high, fn) { return false } } else { if !list.apply(low, high, func(n *node) bool { if !irt.apply(n.orderedNodes, interval, dimension+1, fn) { return false } return true }) { return false } return true } return true }]}
{Id:11 FileId:103 StartLine:226 StartColumn:1 EndLine:235 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Entries}] Receiver:0xc0000ed620 Body:{
	entries := NewEntries()

	irt.apply(irt.top, interval, 1, func(n *node) bool {
		entries = append(entries, n.entry)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := NewEntries() irt.apply(irt.top, interval, 1, func(n *node) bool { entries = append(entries, n.entry) return true }) return entries }]}
{Id:12 FileId:103 StartLine:237 StartColumn:1 EndLine:251 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc00095ae00 Body:{
	on := irt.top
	for i := uint64(1); i <= irt.dimensions; i++ {
		n, _ := on.get(entry.ValueAtDimension(i))
		if n == nil {
			return nil
		}
		if i == irt.dimensions {
			return n.entry
		}
		on = n.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ on := irt.top for i := uint64(1); i <= irt.dimensions; i++ { n, _ := on.get(entry.ValueAtDimension(i)) if n == nil { return nil } if i == irt.dimensions { return n.entry } on = n.orderedNodes } return nil }]}
{Id:13 FileId:103 StartLine:257 StartColumn:1 EndLine:264 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0000ed740 Body:{
	result := make(Entries, 0, len(entries))
	for _, entry := range entries {
		result = append(result, irt.get(entry))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, entry := range entries { result = append(result, irt.get(entry)) } return result }]}
{Id:14 FileId:103 StartLine:267 StartColumn:1 EndLine:269 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0003e55a0 Body:{
	return irt.number
} PrettyPrintBody:[{ return irt.number }]}
{Id:15 FileId:103 StartLine:271 StartColumn:1 EndLine:275 EndColumn:2 Name:newImmutableRangeTree Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*immutableRangeTree}] Receiver:<nil> Body:{
	return &immutableRangeTree{
		dimensions: dimensions,
	}
} PrettyPrintBody:[{ return &immutableRangeTree{ dimensions: dimensions, } }]}
{Id:3 FileId:94 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0012915e0 Body:{
	(*items)[i], (*items)[j] = (*items)[j], (*items)[i]
} PrettyPrintBody:[{ (*items)[i], (*items)[j] = (*items)[j], (*items)[i] }]}
{Id:4 FileId:94 StartLine:46 StartColumn:1 EndLine:74 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:Item}] Receiver:0xc0011dba00 Body:{
	size := len(*items)

	items.swap(size-1, 0)
	item := (*items)[size-1]
	(*items)[size-1], *items = nil, (*items)[:size-1]

	index := 0
	childL, childR := 2*index+1, 2*index+2
	for len(*items) > childL {
		child := childL
		if len(*items) > childR && (*items)[childR].Compare((*items)[childL]) < 0 {
			child = childR
		}

		if (*items)[child].Compare((*items)[index]) < 0 {
			items.swap(index, child)

			index = child
			childL, childR = 2*index+1, 2*index+2
		} else {
			break
		}
	}

	return item
} PrettyPrintBody:[{ size := len(*items) items.swap(size-1, 0) item := (*items)[size-1] (*items)[size-1], *items = nil, (*items)[:size-1] index := 0 childL, childR := 2*index+1, 2*index+2 for len(*items) > childL { child := childL if len(*items) > childR && (*items)[childR].Compare((*items)[childL]) < 0 { child = childR } if (*items)[child].Compare((*items)[index]) < 0 { items.swap(index, child) index = child childL, childR = 2*index+1, 2*index+2 } else { break } } return item }]}
{Id:5 FileId:94 StartLine:76 StartColumn:1 EndLine:87 EndColumn:2 Name:get Params:[{Name:number Type:int}] Results:[{Name: Type:[]Item}] Receiver:0xc001409a80 Body:{
	returnItems := make([]Item, 0, number)
	for i := 0; i < number; i++ {
		if len(*items) == 0 {
			break
		}

		returnItems = append(returnItems, items.pop())
	}

	return returnItems
} PrettyPrintBody:[{ returnItems := make([]Item, 0, number) for i := 0; i < number; i++ { if len(*items) == 0 { break } returnItems = append(returnItems, items.pop()) } return returnItems }]}
{Id:6 FileId:94 StartLine:89 StartColumn:1 EndLine:102 EndColumn:2 Name:push Params:[{Name:item Type:Item}] Results:[] Receiver:0xc000a22ae0 Body:{

	*items = append(*items, item)

	index := len(*items) - 1
	parent := int((index - 1) / 2)
	for parent >= 0 && (*items)[parent].Compare(item) > 0 {
		items.swap(index, parent)

		index = parent
		parent = int((index - 1) / 2)
	}
} PrettyPrintBody:[{ *items = append(*items, item) index := len(*items) - 1 parent := int((index - 1) / 2) for parent >= 0 && (*items)[parent].Compare(item) > 0 { items.swap(index, parent) index = parent parent = int((index - 1) / 2) } }]}
{Id:8 FileId:94 StartLine:118 StartColumn:1 EndLine:154 EndColumn:2 Name:Put Params:[{Name:items Type:...Item}] Results:[{Name: Type:error}] Receiver:0xc001581320 Body:{
	if len(items) == 0 {
		return nil
	}

	pq.lock.Lock()
	defer pq.lock.Unlock()

	if pq.disposed {
		return ErrDisposed
	}

	for _, item := range items {
		if pq.allowDuplicates {
			pq.items.push(item)
		} else if _, ok := pq.itemMap[item]; !ok {
			pq.itemMap[item] = struct{}{}
			pq.items.push(item)
		}
	}

	for {
		sema := pq.waiters.get()
		if sema == nil {
			break
		}

		sema.response.Add(1)
		sema.ready <- true
		sema.response.Wait()
		if len(pq.items) == 0 {
			break
		}
	}

	return nil
} PrettyPrintBody:[{ if len(items) == 0 { return nil } pq.lock.Lock() defer pq.lock.Unlock() if pq.disposed { return ErrDisposed } for _, item := range items { if pq.allowDuplicates { pq.items.push(item) } else if _, ok := pq.itemMap[item]; !ok { pq.itemMap[item] = struct{}{} pq.items.push(item) } } for { sema := pq.waiters.get() if sema == nil { break } sema.response.Add(1) sema.ready <- true sema.response.Wait() if len(pq.items) == 0 { break } } return nil }]}
{Id:9 FileId:94 StartLine:159 StartColumn:1 EndLine:203 EndColumn:2 Name:Get Params:[{Name:number Type:int}] Results:[{Name: Type:[]Item} {Name: Type:error}] Receiver:0xc001309fe0 Body:{
	if number < 1 {
		return nil, nil
	}

	pq.lock.Lock()

	if pq.disposed {
		pq.lock.Unlock()
		return nil, ErrDisposed
	}

	var items []Item

	deleteItems := func(items []Item) {
		for _, item := range items {
			delete(pq.itemMap, item)
		}
	}

	if len(pq.items) == 0 {
		sema := newSema()
		pq.waiters.put(sema)
		pq.lock.Unlock()

		<-sema.ready

		if pq.Disposed() {
			return nil, ErrDisposed
		}

		items = pq.items.get(number)
		if !pq.allowDuplicates {
			deleteItems(items)
		}
		sema.response.Done()
		return items, nil
	}

	items = pq.items.get(number)
	deleteItems(items)
	pq.lock.Unlock()
	return items, nil
} PrettyPrintBody:[{ if number < 1 { return nil, nil } pq.lock.Lock() if pq.disposed { pq.lock.Unlock() return nil, ErrDisposed } var items []Item deleteItems := func(items []Item) { for _, item := range items { delete(pq.itemMap, item) } } if len(pq.items) == 0 { sema := newSema() pq.waiters.put(sema) pq.lock.Unlock() <-sema.ready if pq.Disposed() { return nil, ErrDisposed } items = pq.items.get(number) if !pq.allowDuplicates { deleteItems(items) } sema.response.Done() return items, nil } items = pq.items.get(number) deleteItems(items) pq.lock.Unlock() return items, nil }]}
{Id:10 FileId:94 StartLine:206 StartColumn:1 EndLine:213 EndColumn:2 Name:Peek Params:[] Results:[{Name: Type:Item}] Receiver:0xc00019e280 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()
	if len(pq.items) > 0 {
		return pq.items[0]
	}
	return nil
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() if len(pq.items) > 0 { return pq.items[0] } return nil }]}
{Id:11 FileId:94 StartLine:217 StartColumn:1 EndLine:222 EndColumn:2 Name:Empty Params:[] Results:[{Name: Type:bool}] Receiver:0xc000a8a900 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	return len(pq.items) == 0
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() return len(pq.items) == 0 }]}
{Id:12 FileId:94 StartLine:225 StartColumn:1 EndLine:230 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001602fe0 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	return len(pq.items)
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() return len(pq.items) }]}
{Id:13 FileId:94 StartLine:233 StartColumn:1 EndLine:238 EndColumn:2 Name:Disposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc001603000 Body:{
	pq.disposeLock.Lock()
	defer pq.disposeLock.Unlock()

	return pq.disposed
} PrettyPrintBody:[{ pq.disposeLock.Lock() defer pq.disposeLock.Unlock() return pq.disposed }]}
{Id:14 FileId:94 StartLine:242 StartColumn:1 EndLine:257 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0016033a0 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	pq.disposeLock.Lock()
	defer pq.disposeLock.Unlock()

	pq.disposed = true
	for _, waiter := range pq.waiters {
		waiter.response.Add(1)
		waiter.ready <- true
	}

	pq.items = nil
	pq.waiters = nil
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() pq.disposeLock.Lock() defer pq.disposeLock.Unlock() pq.disposed = true for _, waiter := range pq.waiters { waiter.response.Add(1) waiter.ready <- true } pq.items = nil pq.waiters = nil }]}
{Id:15 FileId:94 StartLine:260 StartColumn:1 EndLine:266 EndColumn:2 Name:NewPriorityQueue Params:[{Name:hint Type:int} {Name:allowDuplicates Type:bool}] Results:[{Name: Type:*PriorityQueue}] Receiver:<nil> Body:{
	return &PriorityQueue{
		items:			make(priorityItems, 0, hint),
		itemMap:		make(map[Item]struct{}, hint),
		allowDuplicates:	allowDuplicates,
	}
} PrettyPrintBody:[{ return &PriorityQueue{ items:			make(priorityItems, 0, hint), itemMap:		make(map[Item]struct{}, hint), allowDuplicates:	allowDuplicates, } }]}
{Id:1 FileId:109 StartLine:25 StartColumn:1 EndLine:45 EndColumn:2 Name:TestOrderedAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	overwritten := nodes.add(n1)
	assert.Nil(t, overwritten)

	overwritten = nodes.add(n2)
	assert.Nil(t, overwritten)

	assert.Equal(t, orderedNodes{n2, n1}, nodes)

	n3 := newNode(4, constructMockEntry(1, 4), false)

	overwritten = nodes.add(n3)

	assert.True(t, n1 == overwritten)
	assert.Equal(t, orderedNodes{n2, n3}, nodes)
} PrettyPrintBody:[{ nodes := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) overwritten := nodes.add(n1) assert.Nil(t, overwritten) overwritten = nodes.add(n2) assert.Nil(t, overwritten) assert.Equal(t, orderedNodes{n2, n1}, nodes) n3 := newNode(4, constructMockEntry(1, 4), false) overwritten = nodes.add(n3) assert.True(t, n1 == overwritten) assert.Equal(t, orderedNodes{n2, n3}, nodes) }]}
{Id:2 FileId:109 StartLine:47 StartColumn:1 EndLine:71 EndColumn:2 Name:TestOrderedDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	nodes.add(n1)
	nodes.add(n2)

	deleted := nodes.delete(n2.value)

	assert.Equal(t, orderedNodes{n1}, nodes)
	assert.Equal(t, n2, deleted)

	missingValue := int64(3)
	deleted = nodes.delete(missingValue)

	assert.Equal(t, orderedNodes{n1}, nodes)
	assert.Nil(t, deleted)

	deleted = nodes.delete(n1.value)

	assert.Empty(t, nodes)
	assert.Equal(t, n1, deleted)
} PrettyPrintBody:[{ nodes := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) nodes.add(n1) nodes.add(n2) deleted := nodes.delete(n2.value) assert.Equal(t, orderedNodes{n1}, nodes) assert.Equal(t, n2, deleted) missingValue := int64(3) deleted = nodes.delete(missingValue) assert.Equal(t, orderedNodes{n1}, nodes) assert.Nil(t, deleted) deleted = nodes.delete(n1.value) assert.Empty(t, nodes) assert.Equal(t, n1, deleted) }]}
{Id:3 FileId:109 StartLine:73 StartColumn:1 EndLine:139 EndColumn:2 Name:TestApply Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ns := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	ns.add(n1)
	ns.add(n2)

	results := make(nodes, 0, 2)

	ns.apply(1, 1, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n2}, results)

	results = results[:0]

	ns.apply(0, 0, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(2, 3, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(4, 5, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n1}, results)
	results = results[:0]

	ns.apply(0, 5, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n2, n1}, results)
	results = results[:0]

	ns.apply(5, 10, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(0, 100, func(n *node) bool {
		results = append(results, n)
		return false
	})

	assert.Equal(t, nodes{n2}, results)
} PrettyPrintBody:[{ ns := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) ns.add(n1) ns.add(n2) results := make(nodes, 0, 2) ns.apply(1, 1, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n2}, results) results = results[:0] ns.apply(0, 0, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(2, 3, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(4, 5, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n1}, results) results = results[:0] ns.apply(0, 5, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n2, n1}, results) results = results[:0] ns.apply(5, 10, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(0, 100, func(n *node) bool { results = append(results, n) return false }) assert.Equal(t, nodes{n2}, results) }]}
{Id:4 FileId:109 StartLine:141 StartColumn:1 EndLine:159 EndColumn:2 Name:TestInsertDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ns := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)
	n3 := newNode(2, constructMockEntry(3, 2), false)

	ns.add(n1)
	ns.add(n2)
	ns.add(n3)

	modified := make(Entries, 0, 1)
	deleted := make(Entries, 0, 1)

	ns.insert(2, 2, 2, 0, -5, &modified, &deleted)

	assert.Len(t, ns, 0)
	assert.Equal(t, Entries{n2.entry, n3.entry, n1.entry}, deleted)
} PrettyPrintBody:[{ ns := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) n3 := newNode(2, constructMockEntry(3, 2), false) ns.add(n1) ns.add(n2) ns.add(n3) modified := make(Entries, 0, 1) deleted := make(Entries, 0, 1) ns.insert(2, 2, 2, 0, -5, &modified, &deleted) assert.Len(t, ns, 0) assert.Equal(t, Entries{n2.entry, n3.entry, n1.entry}, deleted) }]}
{Id:5 FileId:109 StartLine:161 StartColumn:1 EndLine:174 EndColumn:2 Name:BenchmarkPrepend Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	ns := make(orderedNodes, 0, numItems)

	for i := b.N; i < b.N+numItems; i++ {
		ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false))
	}
} PrettyPrintBody:[{ numItems := 100000 ns := make(orderedNodes, 0, numItems) for i := b.N; i < b.N+numItems; i++ { ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false)) } b.ResetTimer() for i := 0; i < b.N; i++ { ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false)) } }]}
{Id:0 FileId:110 StartLine:18 StartColumn:1 EndLine:20 EndColumn:2 Name:isLastDimension Params:[{Name:value Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return test >= value
} PrettyPrintBody:[{ return test >= value }]}
{Id:3 FileId:110 StartLine:34 StartColumn:1 EndLine:36 EndColumn:2 Name:resetPath Params:[] Results:[] Receiver:0xc000ec6060 Body:{
	ot.path = ot.path[:0]
} PrettyPrintBody:[{ ot.path = ot.path[:0] }]}
{Id:4 FileId:110 StartLine:38 StartColumn:1 EndLine:40 EndColumn:2 Name:needNextDimension Params:[] Results:[{Name: Type:bool}] Receiver:0xc000e7fdc0 Body:{
	return ot.dimensions > 1
} PrettyPrintBody:[{ return ot.dimensions > 1 }]}
{Id:5 FileId:110 StartLine:44 StartColumn:1 EndLine:63 EndColumn:2 Name:add Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:0xc000e7f0c0 Body:{
	var node *node
	list := &ot.top

	for i := uint64(1); i <= ot.dimensions; i++ {
		if isLastDimension(ot.dimensions, i) {
			overwritten := list.add(
				newNode(entry.ValueAtDimension(i), entry, false),
			)
			if overwritten == nil {
				ot.number++
			}
			return overwritten
		}
		node, _ = list.getOrAdd(entry, i, ot.dimensions)
		list = &node.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ var node *node list := &ot.top for i := uint64(1); i <= ot.dimensions; i++ { if isLastDimension(ot.dimensions, i) { overwritten := list.add( newNode(entry.ValueAtDimension(i), entry, false), ) if overwritten == nil { ot.number++ } return overwritten } node, _ = list.getOrAdd(entry, i, ot.dimensions) list = &node.orderedNodes } return nil }]}
{Id:6 FileId:110 StartLine:70 StartColumn:1 EndLine:88 EndColumn:2 Name:Add Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0013092e0 Body:{
	if len(entries) == 0 {
		return nil
	}

	overwrittens := make(Entries, len(entries))
	for i, entry := range entries {
		if entry == nil {
			continue
		}

		overwritten := ot.add(entry)
		if overwritten != nil {
			overwrittens[i] = overwritten.entry
		}
	}

	return overwrittens
} PrettyPrintBody:[{ if len(entries) == 0 { return nil } overwrittens := make(Entries, len(entries)) for i, entry := range entries { if entry == nil { continue } overwritten := ot.add(entry) if overwritten != nil { overwrittens[i] = overwritten.entry } } return overwrittens }]}
{Id:7 FileId:110 StartLine:90 StartColumn:1 EndLine:120 EndColumn:2 Name:delete Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:0xc001409880 Body:{
	ot.resetPath()
	var index int
	var node *node
	list := &ot.top

	for i := uint64(1); i <= ot.dimensions; i++ {
		value := entry.ValueAtDimension(i)
		node, index = list.get(value)
		if node == nil {
			return nil
		}

		nb := &nodeBundle{list: list, index: index}
		ot.path = append(ot.path, nb)

		list = &node.orderedNodes
	}

	ot.number--

	for i := len(ot.path) - 1; i >= 0; i-- {
		nb := ot.path[i]
		nb.list.deleteAt(nb.index)
		if len(*nb.list) > 0 {
			break
		}
	}

	return node
} PrettyPrintBody:[{ ot.resetPath() var index int var node *node list := &ot.top for i := uint64(1); i <= ot.dimensions; i++ { value := entry.ValueAtDimension(i) node, index = list.get(value) if node == nil { return nil } nb := &nodeBundle{list: list, index: index} ot.path = append(ot.path, nb) list = &node.orderedNodes } ot.number-- for i := len(ot.path) - 1; i >= 0; i-- { nb := ot.path[i] nb.list.deleteAt(nb.index) if len(*nb.list) > 0 { break } } return node }]}
{Id:8 FileId:110 StartLine:122 StartColumn:1 EndLine:136 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001309720 Body:{
	on := ot.top
	for i := uint64(1); i <= ot.dimensions; i++ {
		n, _ := on.get(entry.ValueAtDimension(i))
		if n == nil {
			return nil
		}
		if i == ot.dimensions {
			return n.entry
		}
		on = n.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ on := ot.top for i := uint64(1); i <= ot.dimensions; i++ { n, _ := on.get(entry.ValueAtDimension(i)) if n == nil { return nil } if i == ot.dimensions { return n.entry } on = n.orderedNodes } return nil }]}
{Id:9 FileId:110 StartLine:142 StartColumn:1 EndLine:149 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc000a8a500 Body:{
	result := make(Entries, 0, len(entries))
	for _, entry := range entries {
		result = append(result, ot.get(entry))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, entry := range entries { result = append(result, ot.get(entry)) } return result }]}
{Id:10 FileId:110 StartLine:155 StartColumn:1 EndLine:173 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0001e6280 Body:{
	if len(entries) == 0 {
		return nil
	}

	deletedEntries := make(Entries, len(entries))
	for i, entry := range entries {
		if entry == nil {
			continue
		}

		deleted := ot.delete(entry)
		if deleted != nil {
			deletedEntries[i] = deleted.entry
		}
	}

	return deletedEntries
} PrettyPrintBody:[{ if len(entries) == 0 { return nil } deletedEntries := make(Entries, len(entries)) for i, entry := range entries { if entry == nil { continue } deleted := ot.delete(entry) if deleted != nil { deletedEntries[i] = deleted.entry } } return deletedEntries }]}
{Id:11 FileId:110 StartLine:176 StartColumn:1 EndLine:178 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602be0 Body:{
	return ot.number
} PrettyPrintBody:[{ return ot.number }]}
{Id:12 FileId:110 StartLine:180 StartColumn:1 EndLine:202 EndColumn:2 Name:apply Params:[{Name:list Type:orderedNodes} {Name:interval Type:Interval} {Name:dimension Type:uint64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc00095a900 Body:{

	low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	if isLastDimension(ot.dimensions, dimension) {
		if !list.apply(low, high, fn) {
			return false
		}
	} else {
		if !list.apply(low, high, func(n *node) bool {
			if !ot.apply(n.orderedNodes, interval, dimension+1, fn) {
				return false
			}
			return true
		}) {
			return false
		}
		return true
	}

	return true
} PrettyPrintBody:[{ low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) if isLastDimension(ot.dimensions, dimension) { if !list.apply(low, high, fn) { return false } } else { if !list.apply(low, high, func(n *node) bool { if !ot.apply(n.orderedNodes, interval, dimension+1, fn) { return false } return true }) { return false } return true } return true }]}
{Id:13 FileId:110 StartLine:208 StartColumn:1 EndLine:212 EndColumn:2 Name:Apply Params:[{Name:interval Type:Interval} {Name:fn Type:func(Entry) bool}] Results:[] Receiver:0xc001602ee0 Body:{
	ot.apply(ot.top, interval, 1, func(n *node) bool {
		return fn(n.entry)
	})
} PrettyPrintBody:[{ ot.apply(ot.top, interval, 1, func(n *node) bool { return fn(n.entry) }) }]}
{Id:14 FileId:110 StartLine:216 StartColumn:1 EndLine:225 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Entries}] Receiver:0xc000a8abc0 Body:{
	entries := NewEntries()

	ot.apply(ot.top, interval, 1, func(n *node) bool {
		entries = append(entries, n.entry)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := NewEntries() ot.apply(ot.top, interval, 1, func(n *node) bool { entries = append(entries, n.entry) return true }) return entries }]}
{Id:15 FileId:110 StartLine:232 StartColumn:1 EndLine:250 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:Entries} {Name: Type:Entries}] Receiver:0xc0001e65e0 Body:{

	if dimension > ot.dimensions || number == 0 {
		return nil, nil
	}

	modified := make(Entries, 0, 100)
	deleted := make(Entries, 0, 100)

	ot.top.insert(dimension, 1, ot.dimensions,
		index, number, &modified, &deleted,
	)

	ot.number -= uint64(len(deleted))

	return modified, deleted
} PrettyPrintBody:[{ if dimension > ot.dimensions || number == 0 { return nil, nil } modified := make(Entries, 0, 100) deleted := make(Entries, 0, 100) ot.top.insert(dimension, 1, ot.dimensions, index, number, &modified, &deleted, ) ot.number -= uint64(len(deleted)) return modified, deleted }]}
{Id:16 FileId:110 StartLine:252 StartColumn:1 EndLine:257 EndColumn:2 Name:newOrderedTree Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*orderedTree}] Receiver:<nil> Body:{
	return &orderedTree{
		dimensions:	dimensions,
		path:		make([]*nodeBundle, 0, dimensions),
	}
} PrettyPrintBody:[{ return &orderedTree{ dimensions:	dimensions, path:		make([]*nodeBundle, 0, dimensions), } }]}
{Id:17 FileId:110 StartLine:261 StartColumn:1 EndLine:263 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:RangeTree}] Receiver:<nil> Body:{
	return newOrderedTree(dimensions)
} PrettyPrintBody:[{ return newOrderedTree(dimensions) }]}
{Id:4 FileId:69 StartLine:102 StartColumn:1 EndLine:104 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc001032380 Body:{
	return string(e)
} PrettyPrintBody:[{ return string(e) }]}
{Id:6 FileId:69 StartLine:110 StartColumn:1 EndLine:112 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc001308a80 Body:{
	return string(e)
} PrettyPrintBody:[{ return string(e) }]}
{Id:7 FileId:69 StartLine:115 StartColumn:1 EndLine:115 EndColumn:86 Name:NewFloatFibHeap Params:[] Results:[{Name: Type:FloatingFibonacciHeap}] Receiver:<nil> Body:{
	return FloatingFibonacciHeap{nil, 0}
} PrettyPrintBody:[{ return FloatingFibonacciHeap{nil, 0} }]}
{Id:8 FileId:69 StartLine:118 StartColumn:1 EndLine:125 EndColumn:2 Name:Enqueue Params:[{Name:priority Type:float64}] Results:[{Name: Type:*Entry}] Receiver:0xc000e5ad20 Body:{
	singleton := newEntry(priority)

	heap.min = mergeLists(heap.min, singleton)
	heap.size++
	return singleton
} PrettyPrintBody:[{ singleton := newEntry(priority) heap.min = mergeLists(heap.min, singleton) heap.size++ return singleton }]}
{Id:9 FileId:69 StartLine:128 StartColumn:1 EndLine:133 EndColumn:2 Name:Min Params:[] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc001239940 Body:{
	if heap.IsEmpty() {
		return nil, EmptyHeapError("Trying to get minimum element of empty heap")
	}
	return heap.min, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Trying to get minimum element of empty heap") } return heap.min, nil }]}
{Id:10 FileId:69 StartLine:136 StartColumn:1 EndLine:138 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001239bc0 Body:{
	return heap.size == 0
} PrettyPrintBody:[{ return heap.size == 0 }]}
{Id:11 FileId:69 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint}] Receiver:0xc001308e60 Body:{
	return heap.size
} PrettyPrintBody:[{ return heap.size }]}
{Id:12 FileId:69 StartLine:147 StartColumn:1 EndLine:247 EndColumn:2 Name:DequeueMin Params:[] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc00123db40 Body:{
	if heap.IsEmpty() {
		return nil, EmptyHeapError("Cannot dequeue minimum of empty heap")
	}

	heap.size--

	min := heap.min

	if min.next == min {
		heap.min = nil
	} else {
		heap.min.prev.next = heap.min.next
		heap.min.next.prev = heap.min.prev
		heap.min = heap.min.next
	}

	if min.child != nil {

		curr := min.child
		for ok := true; ok; ok = (curr != min.child) {
			curr.parent = nil
			curr = curr.next
		}
	}

	heap.min = mergeLists(heap.min, min.child)

	if heap.min == nil {

		return min, nil
	}

	treeSlice := make([]*Entry, 0, heap.size)
	toVisit := make([]*Entry, 0, heap.size)

	for curr := heap.min; len(toVisit) == 0 || toVisit[0] != curr; curr = curr.next {
		toVisit = append(toVisit, curr)
	}

	for _, curr := range toVisit {
		for {
			for curr.degree >= len(treeSlice) {
				treeSlice = append(treeSlice, nil)
			}

			if treeSlice[curr.degree] == nil {
				treeSlice[curr.degree] = curr
				break
			}

			other := treeSlice[curr.degree]
			treeSlice[curr.degree] = nil

			var minT, maxT *Entry
			if other.Priority < curr.Priority {
				minT = other
				maxT = curr
			} else {
				minT = curr
				maxT = other
			}

			maxT.next.prev = maxT.prev
			maxT.prev.next = maxT.next

			maxT.prev = maxT
			maxT.next = maxT
			minT.child = mergeLists(minT.child, maxT)

			maxT.parent = minT

			maxT.marked = false

			minT.degree++

			curr = minT
		}

		if curr.Priority <= heap.min.Priority {
			heap.min = curr
		}
	}

	return min, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Cannot dequeue minimum of empty heap") } heap.size-- min := heap.min if min.next == min { heap.min = nil } else { heap.min.prev.next = heap.min.next heap.min.next.prev = heap.min.prev heap.min = heap.min.next } if min.child != nil { curr := min.child for ok := true; ok; ok = (curr != min.child) { curr.parent = nil curr = curr.next } } heap.min = mergeLists(heap.min, min.child) if heap.min == nil { return min, nil } treeSlice := make([]*Entry, 0, heap.size) toVisit := make([]*Entry, 0, heap.size) for curr := heap.min; len(toVisit) == 0 || toVisit[0] != curr; curr = curr.next { toVisit = append(toVisit, curr) } for _, curr := range toVisit { for { for curr.degree >= len(treeSlice) { treeSlice = append(treeSlice, nil) } if treeSlice[curr.degree] == nil { treeSlice[curr.degree] = curr break } other := treeSlice[curr.degree] treeSlice[curr.degree] = nil var minT, maxT *Entry if other.Priority < curr.Priority { minT = other maxT = curr } else { minT = curr maxT = other } maxT.next.prev = maxT.prev maxT.prev.next = maxT.next maxT.prev = maxT maxT.next = maxT minT.child = mergeLists(minT.child, maxT) maxT.parent = minT maxT.marked = false minT.degree++ curr = minT } if curr.Priority <= heap.min.Priority { heap.min = curr } } return min, nil }]}
{Id:13 FileId:69 StartLine:251 StartColumn:1 EndLine:268 EndColumn:2 Name:DecreaseKey Params:[{Name:node Type:*Entry} {Name:newPriority Type:float64}] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc0003e50a0 Body:{

	if heap.IsEmpty() {
		return nil, EmptyHeapError("Cannot decrease key in an empty heap")
	}

	if node == nil {
		return nil, NilError("Cannot decrease key: given node is nil")
	}

	if newPriority >= node.Priority {
		return nil, fmt.Errorf("The given new priority: %v, is larger than or equal to the old: %v",
			newPriority, node.Priority)
	}

	decreaseKeyUnchecked(heap, node, newPriority)
	return node, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Cannot decrease key in an empty heap") } if node == nil { return nil, NilError("Cannot decrease key: given node is nil") } if newPriority >= node.Priority { return nil, fmt.Errorf("The given new priority: %v, is larger than or equal to the old: %v", newPriority, node.Priority) } decreaseKeyUnchecked(heap, node, newPriority) return node, nil }]}
{Id:14 FileId:69 StartLine:271 StartColumn:1 EndLine:284 EndColumn:2 Name:Delete Params:[{Name:node Type:*Entry}] Results:[{Name: Type:error}] Receiver:0xc00095aca0 Body:{

	if heap.IsEmpty() {
		return EmptyHeapError("Cannot delete element from an empty heap")
	}

	if node == nil {
		return NilError("Cannot delete node: given node is nil")
	}

	decreaseKeyUnchecked(heap, node, -math.MaxFloat64)
	heap.DequeueMin()
	return nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return EmptyHeapError("Cannot delete element from an empty heap") } if node == nil { return NilError("Cannot delete node: given node is nil") } decreaseKeyUnchecked(heap, node, -math.MaxFloat64) heap.DequeueMin() return nil }]}
{Id:15 FileId:69 StartLine:291 StartColumn:1 EndLine:307 EndColumn:2 Name:Merge Params:[{Name:other Type:*FloatingFibonacciHeap}] Results:[{Name: Type:FloatingFibonacciHeap} {Name: Type:error}] Receiver:0xc001033f20 Body:{

	if heap == nil || other == nil {
		return FloatingFibonacciHeap{}, NilError("One of the heaps to merge is nil. Cannot merge")
	}

	resultSize := heap.size + other.size

	resultMin := mergeLists(heap.min, other.min)

	heap.min = nil
	other.min = nil
	heap.size = 0
	other.size = 0

	return FloatingFibonacciHeap{resultMin, resultSize}, nil
} PrettyPrintBody:[{ if heap == nil || other == nil { return FloatingFibonacciHeap{}, NilError("One of the heaps to merge is nil. Cannot merge") } resultSize := heap.size + other.size resultMin := mergeLists(heap.min, other.min) heap.min = nil other.min = nil heap.size = 0 other.size = 0 return FloatingFibonacciHeap{resultMin, resultSize}, nil }]}
{Id:16 FileId:69 StartLine:317 StartColumn:1 EndLine:327 EndColumn:2 Name:newEntry Params:[{Name:priority Type:float64}] Results:[{Name: Type:*Entry}] Receiver:<nil> Body:{
	result := new(Entry)
	result.degree = 0
	result.marked = false
	result.child = nil
	result.parent = nil
	result.next = result
	result.prev = result
	result.Priority = priority
	return result
} PrettyPrintBody:[{ result := new(Entry) result.degree = 0 result.marked = false result.child = nil result.parent = nil result.next = result result.prev = result result.Priority = priority return result }]}
{Id:17 FileId:69 StartLine:329 StartColumn:1 EndLine:349 EndColumn:2 Name:mergeLists Params:[{Name:one Type:*Entry}] Results:[{Name: Type:*Entry}] Receiver:<nil> Body:{
	if one == nil && two == nil {
		return nil
	} else if one != nil && two == nil {
		return one
	} else if one == nil && two != nil {
		return two
	}

	oneNext := one.next
	one.next = two.next
	one.next.prev = one
	two.next = oneNext
	two.next.prev = two

	if one.Priority < two.Priority {
		return one
	}
	return two

} PrettyPrintBody:[{ if one == nil && two == nil { return nil } else if one != nil && two == nil { return one } else if one == nil && two != nil { return two } oneNext := one.next one.next = two.next one.next.prev = one two.next = oneNext two.next.prev = two if one.Priority < two.Priority { return one } return two }]}
{Id:18 FileId:69 StartLine:351 StartColumn:1 EndLine:361 EndColumn:2 Name:decreaseKeyUnchecked Params:[{Name:heap Type:*FloatingFibonacciHeap} {Name:node Type:*Entry} {Name:priority Type:float64}] Results:[] Receiver:<nil> Body:{
	node.Priority = priority

	if node.parent != nil && node.Priority <= node.parent.Priority {
		cutNode(heap, node)
	}

	if node.Priority <= heap.min.Priority {
		heap.min = node
	}
} PrettyPrintBody:[{ node.Priority = priority if node.parent != nil && node.Priority <= node.parent.Priority { cutNode(heap, node) } if node.Priority <= heap.min.Priority { heap.min = node } }]}
{Id:19 FileId:69 StartLine:363 StartColumn:1 EndLine:399 EndColumn:2 Name:cutNode Params:[{Name:heap Type:*FloatingFibonacciHeap} {Name:node Type:*Entry}] Results:[] Receiver:<nil> Body:{
	node.marked = false

	if node.parent == nil {
		return
	}

	if node.next != node {
		node.next.prev = node.prev
		node.prev.next = node.next
	}

	if node.parent.child == node {
		if node.next != node {
			node.parent.child = node.next
		} else {
			node.parent.child = nil
		}
	}

	node.parent.degree--

	node.prev = node
	node.next = node
	heap.min = mergeLists(heap.min, node)

	if node.parent.marked {
		cutNode(heap, node.parent)
	} else {
		node.parent.marked = true
	}

	node.parent = nil
} PrettyPrintBody:[{ node.marked = false if node.parent == nil { return } if node.next != node { node.next.prev = node.prev node.prev.next = node.next } if node.parent.child == node { if node.next != node { node.parent.child = node.next } else { node.parent.child = nil } } node.parent.degree-- node.prev = node node.next = node heap.min = mergeLists(heap.min, node) if node.parent.marked { cutNode(heap, node.parent) } else { node.parent.marked = true } node.parent = nil }]}
{Id:3 FileId:89 StartLine:26 StartColumn:1 EndLine:31 EndColumn:2 Name:calculateVVP Params:[{Name:guess Type:*nmVertex} {Name:sigma Type:float64}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	distance := -guess.euclideanDistance(vertex)
	lhs := 1 / (math.Sqrt(2*math.Pi) * sigma)
	rhs := 1 - math.Exp(math.Pow(distance, 2)/(2*math.Pow(sigma, 2)))
	return rhs * lhs
} PrettyPrintBody:[{ distance := -guess.euclideanDistance(vertex) lhs := 1 / (math.Sqrt(2*math.Pi) * sigma) rhs := 1 - math.Exp(math.Pow(distance, 2)/(2*math.Pow(sigma, 2))) return rhs * lhs }]}
{Id:4 FileId:89 StartLine:39 StartColumn:1 EndLine:41 EndColumn:2 Name:calculateSigma Params:[{Name:dimensions Type:int}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	return math.Pow(3*math.Pow(float64(guesses), 1/float64(dimensions)), -1)
} PrettyPrintBody:[{ return math.Pow(3*math.Pow(float64(guesses), 1/float64(dimensions)), -1) }]}
{Id:5 FileId:89 StartLine:43 StartColumn:1 EndLine:47 EndColumn:2 Name:calculateProbabilities Params:[{Name:bestGuess Type:*nmVertex} {Name:sigma Type:float64}] Results:[] Receiver:0xc001033400 Body:{
	for _, v := range pbs {
		v.probability = calculateVVP(bestGuess, v.vertex, sigma)
	}
} PrettyPrintBody:[{ for _, v := range pbs { v.probability = calculateVVP(bestGuess, v.vertex, sigma) } }]}
{Id:6 FileId:89 StartLine:49 StartColumn:1 EndLine:51 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc000e7f6e0 Body:{
	sort.Sort(pbs)
} PrettyPrintBody:[{ sort.Sort(pbs) }]}
{Id:7 FileId:89 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000e7fc20 Body:{
	return pbs[i].probability < pbs[j].probability
} PrettyPrintBody:[{ return pbs[i].probability < pbs[j].probability }]}
{Id:8 FileId:89 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0010334e0 Body:{
	pbs[i], pbs[j] = pbs[j], pbs[i]
} PrettyPrintBody:[{ pbs[i], pbs[j] = pbs[j], pbs[i] }]}
{Id:9 FileId:89 StartLine:61 StartColumn:1 EndLine:63 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc000df73c0 Body:{
	return len(pbs)
} PrettyPrintBody:[{ return len(pbs) }]}
{Id:11 FileId:89 StartLine:79 StartColumn:1 EndLine:83 EndColumn:2 Name:search Params:[{Name:result Type:*nmVertex}] Results:[{Name: Type:int}] Receiver:0xc001309b60 Body:{
	return sort.Search(len(results.vertices), func(i int) bool {
		return !results.vertices[i].less(results.config, result)
	})
} PrettyPrintBody:[{ return sort.Search(len(results.vertices), func(i int) bool { return !results.vertices[i].less(results.config, result) }) }]}
{Id:12 FileId:89 StartLine:85 StartColumn:1 EndLine:102 EndColumn:2 Name:exists Params:[{Name:result Type:*nmVertex} {Name:hint Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000a8a3a0 Body:{
	if hint < 0 {
		hint = results.search(result)
	}

	if hint > 0 && results.vertices[hint-1].approximatelyEqualToVertex(result) {
		return true
	}

	if hint < len(results.vertices)-1 && results.vertices[hint].approximatelyEqualToVertex(result) {
		return true
	}

	return false
} PrettyPrintBody:[{ if hint < 0 { hint = results.search(result) } if hint > 0 && results.vertices[hint-1].approximatelyEqualToVertex(result) { return true } if hint < len(results.vertices)-1 && results.vertices[hint].approximatelyEqualToVertex(result) { return true } return false }]}
{Id:13 FileId:89 StartLine:104 StartColumn:1 EndLine:118 EndColumn:2 Name:insert Params:[{Name:vertex Type:*nmVertex}] Results:[] Receiver:0xc000a224a0 Body:{
	i := results.search(vertex)
	if results.exists(vertex, i) {
		return
	}

	if i == len(results.vertices) {
		results.vertices = append(results.vertices, vertex)
		return
	}

	results.vertices = append(results.vertices, nil)
	copy(results.vertices[i+1:], results.vertices[i:])
	results.vertices[i] = vertex
} PrettyPrintBody:[{ i := results.search(vertex) if results.exists(vertex, i) { return } if i == len(results.vertices) { results.vertices = append(results.vertices, vertex) return } results.vertices = append(results.vertices, nil) copy(results.vertices[i+1:], results.vertices[i:]) results.vertices[i] = vertex }]}
{Id:14 FileId:89 StartLine:120 StartColumn:1 EndLine:140 EndColumn:2 Name:grab Params:[{Name:num Type:int}] Results:[{Name: Type:vertices}] Receiver:0xc0011726c0 Body:{
	vs := make(vertices, 0, num)

	for i := 0; i < num; i++ {
		vs = append(vs, results.pbs[i].vertex)
	}

	copy(results.pbs, results.pbs[num:])
	length := len(results.pbs) - num

	for i := length; i < len(results.pbs); i++ {
		results.pbs[i] = nil
	}

	results.pbs = results.pbs[:length]
	return vs
} PrettyPrintBody:[{ vs := make(vertices, 0, num) for i := 0; i < num; i++ { vs = append(vs, results.pbs[i].vertex) } copy(results.pbs, results.pbs[num:]) length := len(results.pbs) - num for i := length; i < len(results.pbs); i++ { results.pbs[i] = nil } results.pbs = results.pbs[:length] return vs }]}
{Id:15 FileId:89 StartLine:145 StartColumn:1 EndLine:152 EndColumn:2 Name:reSort Params:[{Name:vertex Type:*nmVertex}] Results:[] Receiver:0xc00019e420 Body:{
	results.insert(vertex)

	bestGuess := results.vertices[0]
	sigma := calculateSigma(len(results.config.Vars), len(results.vertices))
	results.pbs.calculateProbabilities(bestGuess, sigma)
	results.pbs.sort()
} PrettyPrintBody:[{ results.insert(vertex) bestGuess := results.vertices[0] sigma := calculateSigma(len(results.config.Vars), len(results.vertices)) results.pbs.calculateProbabilities(bestGuess, sigma) results.pbs.sort() }]}
{Id:16 FileId:89 StartLine:154 StartColumn:1 EndLine:168 EndColumn:2 Name:newResults Params:[{Name:guess Type:*nmVertex} {Name:config Type:NelderMeadConfiguration} {Name:num Type:int}] Results:[{Name: Type:*results}] Receiver:<nil> Body:{
	vertices := make(vertices, 0, num+1)
	vertices = append(vertices, guess)
	vertices = append(vertices, generateRandomVerticesFromGuess(guess, num)...)

	bundles := make(pbs, 0, len(vertices))
	for _, v := range vertices {
		bundles = append(bundles, &vertexProbabilityBundle{vertex: v})
	}

	return &results{
		pbs:	bundles,
		config:	config,
	}
} PrettyPrintBody:[{ vertices := make(vertices, 0, num+1) vertices = append(vertices, guess) vertices = append(vertices, generateRandomVerticesFromGuess(guess, num)...) bundles := make(pbs, 0, len(vertices)) for _, v := range vertices { bundles = append(bundles, &vertexProbabilityBundle{vertex: v}) } return &results{ pbs:	bundles, config:	config, } }]}
{Id:1 FileId:40 StartLine:21 StartColumn:1 EndLine:47 EndColumn:2 Name:DeleteItems Params:[{Name:values Type:...interface{}}] Results:[{Name: Type:[]*Item} {Name: Type:error}] Receiver:0xc001032d60 Body:{
	if len(values) == 0 {
		return nil, nil
	}

	keys := make(Keys, 0, len(values))
	err := t.Apply(func(item *Item) {
		keys = append(keys, &Key{Value: item.Value, Payload: item.Payload})
	}, values...)

	if err != nil {
		return nil, err
	}

	keys = keys.sort(t.config.Comparator)

	err = t.delete(keys)
	if err != nil {
		return nil, err
	}

	t.Count -= len(keys)

	return keys.toItems(), nil
} PrettyPrintBody:[{ if len(values) == 0 { return nil, nil } keys := make(Keys, 0, len(values)) err := t.Apply(func(item *Item) { keys = append(keys, &Key{Value: item.Value, Payload: item.Payload}) }, values...) if err != nil { return nil, err } keys = keys.sort(t.config.Comparator) err = t.delete(keys) if err != nil { return nil, err } t.Count -= len(keys) return keys.toItems(), nil }]}
{Id:2 FileId:40 StartLine:49 StartColumn:1 EndLine:139 EndColumn:2 Name:delete Params:[{Name:keys Type:Keys}] Results:[{Name: Type:error}] Receiver:0xc0013099c0 Body:{
	if len(keys) == 0 {
		return nil
	}

	toDelete := make([]*Key, 0, len(keys))

	for i := 0; i < len(keys); {
		key := keys[i]
		mapping := make(map[string]*Node, 10)
		path, err := t.iterativeFind(key.Value, t.Root)
		if err != nil {
			return err
		}

		pb := path.peek()
		node := pb.n
		isRoot := bytes.Compare(node.ID, t.Root) == 0
		if !t.context.nodeExists(node.ID) {
			cp := node.copy()
			t.context.addNode(cp)
			mapping[string(node.ID)] = cp
			node = cp
		}
		base := node

		toDelete = append(toDelete, key)
		for j := i + 1; j <= len(keys); j++ {
			i = j
			if j == len(keys) {
				break
			}
			neighbor := keys[j]
			if t.config.Comparator(neighbor.Value, node.lastValue()) <= 0 {
				toDelete = append(toDelete, neighbor)
			} else {
				break
			}
		}

		if len(toDelete) > len(node.ChildValues)/4 {
			node.multiDelete(t.config.Comparator, toDelete...)
		} else {
			for _, k := range toDelete {
				node.delete(t.config.Comparator, k)
			}
		}

		toDelete = toDelete[:0]
		if isRoot {
			t.Root = node.ID
			continue
		}

		for pb.prev != nil {
			parentBundle := pb.prev
			parent := parentBundle.n
			isRoot := bytes.Compare(parent.ID, t.Root) == 0
			if !t.context.nodeExists(parent.ID) {
				cp := parent.copy()
				t.context.addNode(cp)
				mapping[string(parent.ID)] = cp
				parent = cp
			} else {
				mapping[string(parent.ID)] = parent
			}

			if isRoot {
				t.Root = parent.ID
			}

			i := pb.prev.i
			parent.replaceKeyAt(&Key{UUID: node.ID}, i)
			node = parent
			pb = pb.prev
		}

		path.pop()
		err = t.walkupDelete(key, base, path, mapping)
		if err != nil {
			return err
		}
	}

	n := t.context.getNode(t.Root)
	if n.lenValues() == 0 {
		t.Root = nil
	}

	return nil
} PrettyPrintBody:[{ if len(keys) == 0 { return nil } toDelete := make([]*Key, 0, len(keys)) for i := 0; i < len(keys); { key := keys[i] mapping := make(map[string]*Node, 10) path, err := t.iterativeFind(key.Value, t.Root) if err != nil { return err } pb := path.peek() node := pb.n isRoot := bytes.Compare(node.ID, t.Root) == 0 if !t.context.nodeExists(node.ID) { cp := node.copy() t.context.addNode(cp) mapping[string(node.ID)] = cp node = cp } base := node toDelete = append(toDelete, key) for j := i + 1; j <= len(keys); j++ { i = j if j == len(keys) { break } neighbor := keys[j] if t.config.Comparator(neighbor.Value, node.lastValue()) <= 0 { toDelete = append(toDelete, neighbor) } else { break } } if len(toDelete) > len(node.ChildValues)/4 { node.multiDelete(t.config.Comparator, toDelete...) } else { for _, k := range toDelete { node.delete(t.config.Comparator, k) } } toDelete = toDelete[:0] if isRoot { t.Root = node.ID continue } for pb.prev != nil { parentBundle := pb.prev parent := parentBundle.n isRoot := bytes.Compare(parent.ID, t.Root) == 0 if !t.context.nodeExists(parent.ID) { cp := parent.copy() t.context.addNode(cp) mapping[string(parent.ID)] = cp parent = cp } else { mapping[string(parent.ID)] = parent } if isRoot { t.Root = parent.ID } i := pb.prev.i parent.replaceKeyAt(&Key{UUID: node.ID}, i) node = parent pb = pb.prev } path.pop() err = t.walkupDelete(key, base, path, mapping) if err != nil { return err } } n := t.context.getNode(t.Root) if n.lenValues() == 0 { t.Root = nil } return nil }]}
{Id:3 FileId:40 StartLine:145 StartColumn:1 EndLine:279 EndColumn:2 Name:walkupDelete Params:[{Name:key Type:*Key} {Name:node Type:*Node} {Name:path Type:*path} {Name:mapping Type:map[string]*Node}] Results:[{Name: Type:error}] Receiver:0xc001603140 Body:{
	needsMerged := t.config.NodeWidth / 2
	if needsMerged < 1 {
		needsMerged = 1
	}
	if node.lenValues() >= needsMerged {
		return nil
	}

	if string(node.ID) == string(t.Root) {
		if node.lenKeys() == 1 {
			id := node.keyAt(0)
			t.Root = id.UUID
		}

		return nil
	}

	var getSibling = func(parent *Node, i int) (*Node, error) {
		key := parent.keyAt(i)
		n, err := t.contextOrCachedNode(key.UUID, true)
		if err != nil {
			return nil, err
		}

		if !t.context.nodeExists(n.ID) {
			cp := t.copyNode(n)
			mapping[string(n.ID)] = cp
			parent.replaceKeyAt(&Key{UUID: cp.ID}, i)
			n = cp
		}

		return n, nil
	}

	parentBundle := path.pop()
	parent := mapping[string(parentBundle.n.ID)]

	_, i := parent.searchKey(t.config.Comparator, key.Value)
	siblingPosition := i
	if i == parent.lenValues() {
		siblingPosition--
	} else {
		siblingPosition++
	}

	sibling, err := getSibling(parent, siblingPosition)
	if err != nil {
		return err
	}

	prepend := false

	if siblingPosition < i {
		node, sibling = sibling, node
		prepend = true
	}

	if (sibling.lenValues()+node.lenValues())/2 >= needsMerged {
		if i == parent.lenValues() {
			i--
		}

		var key *Key
		var value interface{}
		for node.lenValues() < needsMerged || sibling.lenValues() < needsMerged {
			if prepend {
				correctedValue, key := node.popValue(), node.popKey()
				if node.IsLeaf {
					sibling.prependValue(correctedValue)
					sibling.prependKey(key)
					parent.replaceValueAt(i, node.lastValue())
				} else {
					parentValue := parent.valueAt(i)
					sibling.prependKey(key)
					sibling.prependValue(parentValue)
					parent.replaceValueAt(i, correctedValue)
				}
			} else {
				value, key = sibling.popFirstValue(), sibling.popFirstKey()
				correctedValue := value
				if !node.IsLeaf {
					correctedValue = parent.valueAt(i)
				}
				node.appendValue(correctedValue)
				node.appendChild(key)
				parent.replaceValueAt(i, value)
			}
		}

		return nil
	}

	if node.IsLeaf {
		node.append(sibling)
		if prepend {
			parent.deleteKeyAt(i)
		} else {
			parent.deleteKeyAt(i + 1)
		}

		if i == parent.lenValues() {
			i--
		}

		parent.deleteValueAt(i)
		return t.walkupDelete(key, parent, path, mapping)
	}

	valueIndex := i
	if i == parent.lenValues() {
		valueIndex--
	}

	parentValue := parent.valueAt(valueIndex)
	node.appendValue(parentValue)
	node.append(sibling)
	parent.deleteKeyAt(i)
	parent.deleteValueAt(valueIndex)
	parent.replaceKeyAt(&Key{UUID: node.ID}, valueIndex)
	return t.walkupDelete(key, parent, path, mapping)
} PrettyPrintBody:[{ needsMerged := t.config.NodeWidth / 2 if needsMerged < 1 { needsMerged = 1 } if node.lenValues() >= needsMerged { return nil } if string(node.ID) == string(t.Root) { if node.lenKeys() == 1 { id := node.keyAt(0) t.Root = id.UUID } return nil } var getSibling = func(parent *Node, i int) (*Node, error) { key := parent.keyAt(i) n, err := t.contextOrCachedNode(key.UUID, true) if err != nil { return nil, err } if !t.context.nodeExists(n.ID) { cp := t.copyNode(n) mapping[string(n.ID)] = cp parent.replaceKeyAt(&Key{UUID: cp.ID}, i) n = cp } return n, nil } parentBundle := path.pop() parent := mapping[string(parentBundle.n.ID)] _, i := parent.searchKey(t.config.Comparator, key.Value) siblingPosition := i if i == parent.lenValues() { siblingPosition-- } else { siblingPosition++ } sibling, err := getSibling(parent, siblingPosition) if err != nil { return err } prepend := false if siblingPosition < i { node, sibling = sibling, node prepend = true } if (sibling.lenValues()+node.lenValues())/2 >= needsMerged { if i == parent.lenValues() { i-- } var key *Key var value interface{} for node.lenValues() < needsMerged || sibling.lenValues() < needsMerged { if prepend { correctedValue, key := node.popValue(), node.popKey() if node.IsLeaf { sibling.prependValue(correctedValue) sibling.prependKey(key) parent.replaceValueAt(i, node.lastValue()) } else { parentValue := parent.valueAt(i) sibling.prependKey(key) sibling.prependValue(parentValue) parent.replaceValueAt(i, correctedValue) } } else { value, key = sibling.popFirstValue(), sibling.popFirstKey() correctedValue := value if !node.IsLeaf { correctedValue = parent.valueAt(i) } node.appendValue(correctedValue) node.appendChild(key) parent.replaceValueAt(i, value) } } return nil } if node.IsLeaf { node.append(sibling) if prepend { parent.deleteKeyAt(i) } else { parent.deleteKeyAt(i + 1) } if i == parent.lenValues() { i-- } parent.deleteValueAt(i) return t.walkupDelete(key, parent, path, mapping) } valueIndex := i if i == parent.lenValues() { valueIndex-- } parentValue := parent.valueAt(valueIndex) node.appendValue(parentValue) node.append(sibling) parent.deleteKeyAt(i) parent.deleteValueAt(valueIndex) parent.replaceKeyAt(&Key{UUID: node.ID}, valueIndex) return t.walkupDelete(key, parent, path, mapping) }]}
{Id:1 FileId:84 StartLine:25 StartColumn:1 EndLine:36 EndColumn:2 Name:TestEmptyList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	head, ok := Empty.Head()
	assert.Nil(head)
	assert.False(ok)

	tail, ok := Empty.Tail()
	assert.Nil(tail)
	assert.False(ok)

	assert.True(Empty.IsEmpty())
} PrettyPrintBody:[{ assert := assert.New(t) head, ok := Empty.Head() assert.Nil(head) assert.False(ok) tail, ok := Empty.Tail() assert.Nil(tail) assert.False(ok) assert.True(Empty.IsEmpty()) }]}
{Id:2 FileId:84 StartLine:38 StartColumn:1 EndLine:90 EndColumn:2 Name:TestAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	l1 := Empty.Add(1)

	assert.False(l1.IsEmpty())
	head, ok := l1.Head()
	assert.True(ok)
	assert.Equal(1, head)
	tail, ok := l1.Tail()
	assert.True(ok)
	assert.Equal(Empty, tail)

	l1 = l1.Add(2)

	head, ok = l1.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l1.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err := l1.Insert("a", 1)
	assert.Nil(err)

	head, ok = l1.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l1.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal("a", head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)
} PrettyPrintBody:[{ assert := assert.New(t) l1 := Empty.Add(1) assert.False(l1.IsEmpty()) head, ok := l1.Head() assert.True(ok) assert.Equal(1, head) tail, ok := l1.Tail() assert.True(ok) assert.Equal(Empty, tail) l1 = l1.Add(2) head, ok = l1.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l1.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err := l1.Insert("a", 1) assert.Nil(err) head, ok = l1.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l1.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) head, ok = l2.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal("a", head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) }]}
{Id:3 FileId:84 StartLine:92 StartColumn:1 EndLine:122 EndColumn:2 Name:TestInsertAndGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	_, err := Empty.Insert(1, 5)
	assert.Error(err)

	l, err := Empty.Insert(1, 0)
	assert.Nil(err)

	item, ok := l.Get(0)
	assert.True(ok)
	assert.Equal(1, item)

	l, err = l.Insert(2, 0)
	assert.Nil(err)

	item, ok = l.Get(0)
	assert.True(ok)
	assert.Equal(2, item)
	item, ok = l.Get(1)
	assert.True(ok)
	assert.Equal(1, item)

	_, ok = l.Get(2)
	assert.False(ok)

	l, err = l.Insert("a", 3)
	assert.Nil(l)
	assert.Error(err)
} PrettyPrintBody:[{ assert := assert.New(t) _, err := Empty.Insert(1, 5) assert.Error(err) l, err := Empty.Insert(1, 0) assert.Nil(err) item, ok := l.Get(0) assert.True(ok) assert.Equal(1, item) l, err = l.Insert(2, 0) assert.Nil(err) item, ok = l.Get(0) assert.True(ok) assert.Equal(2, item) item, ok = l.Get(1) assert.True(ok) assert.Equal(1, item) _, ok = l.Get(2) assert.False(ok) l, err = l.Insert("a", 3) assert.Nil(l) assert.Error(err) }]}
{Id:4 FileId:84 StartLine:124 StartColumn:1 EndLine:225 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	l, err := Empty.Remove(0)
	assert.Nil(l)
	assert.Error(err)

	l = Empty.Add(1)
	l = l.Add(2)
	l = l.Add(3)

	l1, err := l.Remove(3)
	assert.Nil(l1)
	assert.Error(err)

	l2, err := l.Remove(0)

	assert.Nil(err)
	head, ok := l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok := l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err = l.Remove(1)

	assert.Nil(err)
	head, ok = l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err = l.Remove(2)

	assert.Nil(err)
	head, ok = l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
} PrettyPrintBody:[{ assert := assert.New(t) l, err := Empty.Remove(0) assert.Nil(l) assert.Error(err) l = Empty.Add(1) l = l.Add(2) l = l.Add(3) l1, err := l.Remove(3) assert.Nil(l1) assert.Error(err) l2, err := l.Remove(0) assert.Nil(err) head, ok := l.Head() assert.True(ok) assert.Equal(3, head) tail, ok := l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err = l.Remove(1) assert.Nil(err) head, ok = l.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err = l.Remove(2) assert.Nil(err) head, ok = l.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) }]}
{Id:5 FileId:84 StartLine:227 StartColumn:1 EndLine:248 EndColumn:2 Name:TestFind Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	pred := func(item interface{}) bool {
		return item == 1
	}

	found, ok := Empty.Find(pred)
	assert.Nil(found)
	assert.False(ok)

	l := Empty.Add("blah").Add("bleh")

	found, ok = l.Find(pred)
	assert.Nil(found)
	assert.False(ok)

	l = l.Add(1).Add("foo")

	found, ok = l.Find(pred)
	assert.Equal(1, found)
	assert.True(ok)
} PrettyPrintBody:[{ assert := assert.New(t) pred := func(item interface{}) bool { return item == 1 } found, ok := Empty.Find(pred) assert.Nil(found) assert.False(ok) l := Empty.Add("blah").Add("bleh") found, ok = l.Find(pred) assert.Nil(found) assert.False(ok) l = l.Add(1).Add("foo") found, ok = l.Find(pred) assert.Equal(1, found) assert.True(ok) }]}
{Id:6 FileId:84 StartLine:250 StartColumn:1 EndLine:268 EndColumn:2 Name:TestFindIndex Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	pred := func(item interface{}) bool {
		return item == 1
	}

	idx := Empty.FindIndex(pred)
	assert.Equal(-1, idx)

	l := Empty.Add("blah").Add("bleh")

	idx = l.FindIndex(pred)
	assert.Equal(-1, idx)

	l = l.Add(1).Add("foo")

	idx = l.FindIndex(pred)
	assert.Equal(1, idx)
} PrettyPrintBody:[{ assert := assert.New(t) pred := func(item interface{}) bool { return item == 1 } idx := Empty.FindIndex(pred) assert.Equal(-1, idx) l := Empty.Add("blah").Add("bleh") idx = l.FindIndex(pred) assert.Equal(-1, idx) l = l.Add(1).Add("foo") idx = l.FindIndex(pred) assert.Equal(1, idx) }]}
{Id:7 FileId:84 StartLine:270 StartColumn:1 EndLine:278 EndColumn:2 Name:TestLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	assert.Equal(uint(0), Empty.Length())

	l := Empty.Add("foo")
	assert.Equal(uint(1), l.Length())
	l = l.Add("bar").Add("baz")
	assert.Equal(uint(3), l.Length())
} PrettyPrintBody:[{ assert := assert.New(t) assert.Equal(uint(0), Empty.Length()) l := Empty.Add("foo") assert.Equal(uint(1), l.Length()) l = l.Add("bar").Add("baz") assert.Equal(uint(3), l.Length()) }]}
{Id:8 FileId:84 StartLine:280 StartColumn:1 EndLine:289 EndColumn:2 Name:TestMap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	f := func(x interface{}) interface{} {
		return x.(int) * x.(int)
	}
	assert.Nil(Empty.Map(f))

	l := Empty.Add(1).Add(2).Add(3).Add(4)
	assert.Equal([]interface{}{1, 4, 9, 16}, l.Map(f))
} PrettyPrintBody:[{ assert := assert.New(t) f := func(x interface{}) interface{} { return x.(int) * x.(int) } assert.Nil(Empty.Map(f)) l := Empty.Add(1).Add(2).Add(3).Add(4) assert.Equal([]interface{}{1, 4, 9, 16}, l.Map(f)) }]}
{Id:1 FileId:26 StartLine:25 StartColumn:1 EndLine:72 EndColumn:2 Name:TestOrSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	sba.SetBit(s - 1)
	other.SetBit(s - 1)

	result := orSparseWithSparseBitArray(sba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 2)
	assert.Nil(t, err)
	assert.False(t, ok)

	other.SetBit(2000)
	result = orSparseWithSparseBitArray(sba, other)

	ok, err = result.GetBit(2000)
	assert.Nil(t, err)
	assert.True(t, ok)

	sba.SetBit(2000)
	result = orSparseWithSparseBitArray(sba, other)

	ok, err = result.GetBit(2000)
	assert.Nil(t, err)
	assert.True(t, ok)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() ctx := false for i := uint64(0); i < 1000; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } sba.SetBit(s - 1) other.SetBit(s - 1) result := orSparseWithSparseBitArray(sba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 2) assert.Nil(t, err) assert.False(t, ok) other.SetBit(2000) result = orSparseWithSparseBitArray(sba, other) ok, err = result.GetBit(2000) assert.Nil(t, err) assert.True(t, ok) sba.SetBit(2000) result = orSparseWithSparseBitArray(sba, other) ok, err = result.GetBit(2000) assert.Nil(t, err) assert.True(t, ok) }]}
{Id:2 FileId:26 StartLine:74 StartColumn:1 EndLine:95 EndColumn:2 Name:BenchmarkOrSparseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newSparseBitArray()

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orSparseWithSparseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newSparseBitArray() ctx := false for i := uint64(0); i < numItems; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orSparseWithSparseBitArray(sba, other) } }]}
{Id:3 FileId:26 StartLine:97 StartColumn:1 EndLine:142 EndColumn:2 Name:TestOrSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(2000)

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	other.SetBit(1500)
	other.SetBit(s - 1)
	sba.SetBit(s - 1)

	result := orSparseWithDenseBitArray(sba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(1500)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 2)
	assert.Nil(t, err)
	assert.False(t, ok)

	sba.SetBit(2500)
	result = orSparseWithDenseBitArray(sba, other)

	ok, err = result.GetBit(2500)
	assert.Nil(t, err)
	assert.True(t, ok)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(2000) ctx := false for i := uint64(0); i < 1000; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } other.SetBit(1500) other.SetBit(s - 1) sba.SetBit(s - 1) result := orSparseWithDenseBitArray(sba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(1500) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 2) assert.Nil(t, err) assert.False(t, ok) sba.SetBit(2500) result = orSparseWithDenseBitArray(sba, other) ok, err = result.GetBit(2500) assert.Nil(t, err) assert.True(t, ok) }]}
{Id:4 FileId:26 StartLine:144 StartColumn:1 EndLine:165 EndColumn:2 Name:BenchmarkOrSparseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newBitArray(numItems)

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orSparseWithDenseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newBitArray(numItems) ctx := false for i := uint64(0); i < numItems; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orSparseWithDenseBitArray(sba, other) } }]}
{Id:5 FileId:26 StartLine:167 StartColumn:1 EndLine:205 EndColumn:2 Name:TestOrDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			dba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	other.SetBit(1500)
	other.SetBit(s - 1)
	dba.SetBit(s - 1)

	result := orDenseWithDenseBitArray(dba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(1500)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(1700)
	assert.Nil(t, err)
	assert.False(t, ok)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) ctx := false for i := uint64(0); i < 1000; i += s { if ctx { dba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } other.SetBit(1500) other.SetBit(s - 1) dba.SetBit(s - 1) result := orDenseWithDenseBitArray(dba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(1500) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(1700) assert.Nil(t, err) assert.False(t, ok) }]}
{Id:6 FileId:26 StartLine:207 StartColumn:1 EndLine:228 EndColumn:2 Name:BenchmarkOrDenseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	dba := newBitArray(numItems)
	other := newBitArray(numItems)

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			dba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orDenseWithDenseBitArray(dba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) dba := newBitArray(numItems) other := newBitArray(numItems) ctx := false for i := uint64(0); i < numItems; i += s { if ctx { dba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orDenseWithDenseBitArray(dba, other) } }]}
{Id:7 FileId:26 StartLine:230 StartColumn:1 EndLine:244 EndColumn:2 Name:TestOrSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	result := orSparseWithSparseBitArray(sba, other)
	assert.Equal(t, sba, result)

	sba.Reset()
	other.SetBit(5)

	result = orSparseWithSparseBitArray(sba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) result := orSparseWithSparseBitArray(sba, other) assert.Equal(t, sba, result) sba.Reset() other.SetBit(5) result = orSparseWithSparseBitArray(sba, other) assert.Equal(t, other, result) }]}
{Id:8 FileId:26 StartLine:246 StartColumn:1 EndLine:259 EndColumn:2 Name:TestOrSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	result := orSparseWithDenseBitArray(sba, other)
	assert.Equal(t, sba, result)

	sba.Reset()
	other.SetBit(5)

	result = orSparseWithDenseBitArray(sba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) result := orSparseWithDenseBitArray(sba, other) assert.Equal(t, sba, result) sba.Reset() other.SetBit(5) result = orSparseWithDenseBitArray(sba, other) assert.Equal(t, other, result) }]}
{Id:9 FileId:26 StartLine:261 StartColumn:1 EndLine:273 EndColumn:2 Name:TestOrDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	result := orDenseWithDenseBitArray(dba, other)
	assert.Equal(t, dba, result)

	dba.Reset()
	other.SetBit(5)
	result = orDenseWithDenseBitArray(dba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) result := orDenseWithDenseBitArray(dba, other) assert.Equal(t, dba, result) dba.Reset() other.SetBit(5) result = orDenseWithDenseBitArray(dba, other) assert.Equal(t, other, result) }]}
{Id:1 FileId:9 StartLine:27 StartColumn:1 EndLine:30 EndColumn:2 Name:TestNoCalculateBytes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	_, err := New(0, 0, 100, 5, nil)
	assert.Error(t, err)
} PrettyPrintBody:[{ _, err := New(0, 0, 100, 5, nil) assert.Error(t, err) }]}
{Id:2 FileId:9 StartLine:32 StartColumn:1 EndLine:46 EndColumn:2 Name:TestMaxItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 100, 100000, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	for i := 0; i < 1000; i++ {
		assert.Nil(b.Put("foo bar baz"))
	}

	batch, err := b.Get()
	assert.Len(batch, 100)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 100, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) for i := 0; i < 1000; i++ { assert.Nil(b.Put("foo bar baz")) } batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) }]}
{Id:3 FileId:9 StartLine:48 StartColumn:1 EndLine:64 EndColumn:2 Name:TestMaxBytes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10000, 100, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	go func() {
		for i := 0; i < 1000; i++ {
			b.Put("a")
		}
	}()

	batch, err := b.Get()
	assert.Len(batch, 100)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10000, 100, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) go func() { for i := 0; i < 1000; i++ { b.Put("a") } }() batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) }]}
{Id:4 FileId:9 StartLine:66 StartColumn:1 EndLine:90 EndColumn:2 Name:TestMaxTime Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(time.Millisecond*200, 100000, 100000, 10,
		func(str interface{}) uint {
			return uint(len(str.(string)))
		},
	)
	assert.Nil(err)

	go func() {
		for i := 0; i < 10000; i++ {
			b.Put("a")
			time.Sleep(time.Millisecond)
		}
	}()

	before := time.Now()
	batch, err := b.Get()

	assert.InDelta(200, time.Since(before).Seconds()*1000, 100)
	assert.True(len(batch) > 0)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(time.Millisecond*200, 100000, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }, ) assert.Nil(err) go func() { for i := 0; i < 10000; i++ { b.Put("a") time.Sleep(time.Millisecond) } }() before := time.Now() batch, err := b.Get() assert.InDelta(200, time.Since(before).Seconds()*1000, 100) assert.True(len(batch) > 0) assert.Nil(err) }]}
{Id:5 FileId:9 StartLine:92 StartColumn:1 EndLine:109 EndColumn:2 Name:TestFlush Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10, 10, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	b.Put("a")
	wait := make(chan bool)
	go func() {
		batch, err := b.Get()
		assert.Equal([]interface{}{"a"}, batch)
		assert.Nil(err)
		wait <- true
	}()

	b.Flush()
	<-wait
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10, 10, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) b.Put("a") wait := make(chan bool) go func() { batch, err := b.Get() assert.Equal([]interface{}{"a"}, batch) assert.Nil(err) wait <- true }() b.Flush() <-wait }]}
{Id:6 FileId:9 StartLine:111 StartColumn:1 EndLine:136 EndColumn:2 Name:TestMultiConsumer Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 100, 100000, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	var wg sync.WaitGroup
	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			batch, err := b.Get()
			assert.Len(batch, 100)
			assert.Nil(err)
			wg.Done()
		}()
	}

	go func() {
		for i := 0; i < 500; i++ {
			b.Put("a")
		}
	}()

	wg.Wait()
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 100, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) var wg sync.WaitGroup wg.Add(5) for i := 0; i < 5; i++ { go func() { batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) wg.Done() }() } go func() { for i := 0; i < 500; i++ { b.Put("a") } }() wg.Wait() }]}
{Id:7 FileId:9 StartLine:138 StartColumn:1 EndLine:168 EndColumn:2 Name:TestDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(1, 2, 100000, 2, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	b.Put("a")
	b.Put("b")
	b.Put("c")

	batch1, err := b.Get()
	assert.Equal([]interface{}{"a", "b"}, batch1)
	assert.Nil(err)

	batch2, err := b.Get()
	assert.Equal([]interface{}{"c"}, batch2)
	assert.Nil(err)

	b.Put("d")
	b.Put("e")
	b.Put("f")

	b.Dispose()

	_, err = b.Get()
	assert.Equal(ErrDisposed, err)

	assert.Equal(ErrDisposed, b.Put("j"))
	assert.Equal(ErrDisposed, b.Flush())

} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(1, 2, 100000, 2, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) b.Put("a") b.Put("b") b.Put("c") batch1, err := b.Get() assert.Equal([]interface{}{"a", "b"}, batch1) assert.Nil(err) batch2, err := b.Get() assert.Equal([]interface{}{"c"}, batch2) assert.Nil(err) b.Put("d") b.Put("e") b.Put("f") b.Dispose() _, err = b.Get() assert.Equal(ErrDisposed, err) assert.Equal(ErrDisposed, b.Put("j")) assert.Equal(ErrDisposed, b.Flush()) }]}
{Id:8 FileId:9 StartLine:170 StartColumn:1 EndLine:179 EndColumn:2 Name:TestIsDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10, 10, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	assert.False(b.IsDisposed())
	b.Dispose()
	assert.True(b.IsDisposed())
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10, 10, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) assert.False(b.IsDisposed()) b.Dispose() assert.True(b.IsDisposed()) }]}
{Id:1 FileId:45 StartLine:12 StartColumn:1 EndLine:16 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001226d20 Body:{
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = msgp.AppendBytes(o, []byte(z)) return }]}
{Id:2 FileId:45 StartLine:19 StartColumn:1 EndLine:30 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602320 Body:{
	{
		var tmp []byte
		tmp, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		(*z) = ID(tmp)
	}
	if err != nil {
		return
	}
	o = bts
	return
} PrettyPrintBody:[{ { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte((*z))) (*z) = ID(tmp) } if err != nil { return } o = bts return }]}
{Id:3 FileId:45 StartLine:32 StartColumn:1 EndLine:35 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc001309340 Body:{
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
} PrettyPrintBody:[{ s = msgp.BytesPrefixSize + len([]byte(z)) return }]}
{Id:4 FileId:45 StartLine:38 StartColumn:1 EndLine:54 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000f530a0 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x83, 0xa1, 0x75)
	o = msgp.AppendBytes(o, []byte(z.UUID))

	o = append(o, 0xa1, 0x76)
	o, err = msgp.AppendIntf(o, z.Value)
	if err != nil {
		return
	}

	o = append(o, 0xa1, 0x70)
	o = msgp.AppendBytes(o, z.Payload)
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x83, 0xa1, 0x75) o = msgp.AppendBytes(o, []byte(z.UUID)) o = append(o, 0xa1, 0x76) o, err = msgp.AppendIntf(o, z.Value) if err != nil { return } o = append(o, 0xa1, 0x70) o = msgp.AppendBytes(o, z.Payload) return }]}
{Id:5 FileId:45 StartLine:57 StartColumn:1 EndLine:100 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000df6920 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			{
				var tmp []byte
				tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.UUID))
				z.UUID = ID(tmp)
			}
			if err != nil {
				return
			}
		case "v":
			z.Value, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				return
			}
		case "p":
			z.Payload, bts, err = msgp.ReadBytesBytes(bts, z.Payload)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "u": { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.UUID)) z.UUID = ID(tmp) } if err != nil { return } case "v": z.Value, bts, err = msgp.ReadIntfBytes(bts) if err != nil { return } case "p": z.Payload, bts, err = msgp.ReadBytesBytes(bts, z.Payload) if err != nil { return } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]}
{Id:6 FileId:45 StartLine:102 StartColumn:1 EndLine:105 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc000a8a4a0 Body:{
	s = 1 + 2 + msgp.BytesPrefixSize + len([]byte(z.UUID)) + 2 + msgp.GuessSize(z.Value) + 2 + msgp.BytesPrefixSize + len(z.Payload)
	return
} PrettyPrintBody:[{ s = 1 + 2 + msgp.BytesPrefixSize + len([]byte(z.UUID)) + 2 + msgp.GuessSize(z.Value) + 2 + msgp.BytesPrefixSize + len(z.Payload) return }]}
{Id:7 FileId:45 StartLine:108 StartColumn:1 EndLine:122 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001581360 Body:{
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for xvk := range z {
		if z[xvk] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z[xvk].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = msgp.AppendArrayHeader(o, uint32(len(z))) for xvk := range z { if z[xvk] == nil { o = msgp.AppendNil(o) } else { o, err = z[xvk].MarshalMsg(o) if err != nil { return } } } return }]}
{Id:8 FileId:45 StartLine:125 StartColumn:1 EndLine:155 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602d60 Body:{
	var xsz uint32
	xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap((*z)) >= int(xsz) {
		(*z) = (*z)[:xsz]
	} else {
		(*z) = make(Keys, xsz)
	}
	for bzg := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[bzg] = nil
		} else {
			if (*z)[bzg] == nil {
				(*z)[bzg] = new(Key)
			}
			bts, err = (*z)[bzg].UnmarshalMsg(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap((*z)) >= int(xsz) { (*z) = (*z)[:xsz] } else { (*z) = make(Keys, xsz) } for bzg := range *z { if msgp.IsNil(bts) { bts, err = msgp.ReadNilBytes(bts) if err != nil { return } (*z)[bzg] = nil } else { if (*z)[bzg] == nil { (*z)[bzg] = new(Key) } bts, err = (*z)[bzg].UnmarshalMsg(bts) if err != nil { return } } } o = bts return }]}
{Id:9 FileId:45 StartLine:157 StartColumn:1 EndLine:167 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc001602e20 Body:{
	s = msgp.ArrayHeaderSize
	for bai := range z {
		if z[bai] == nil {
			s += msgp.NilSize
		} else {
			s += z[bai].Msgsize()
		}
	}
	return
} PrettyPrintBody:[{ s = msgp.ArrayHeaderSize for bai := range z { if z[bai] == nil { s += msgp.NilSize } else { s += z[bai].Msgsize() } } return }]}
{Id:10 FileId:45 StartLine:170 StartColumn:1 EndLine:202 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602f80 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x84, 0xa2, 0x69, 0x64)
	o = msgp.AppendBytes(o, []byte(z.ID))

	o = append(o, 0xa2, 0x69, 0x6c)
	o = msgp.AppendBool(o, z.IsLeaf)

	o = append(o, 0xa2, 0x63, 0x76)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChildValues)))
	for cmr := range z.ChildValues {
		o, err = msgp.AppendIntf(o, z.ChildValues[cmr])
		if err != nil {
			return
		}
	}

	o = append(o, 0xa2, 0x63, 0x6b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChildKeys)))
	for ajw := range z.ChildKeys {
		if z.ChildKeys[ajw] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ChildKeys[ajw].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x84, 0xa2, 0x69, 0x64) o = msgp.AppendBytes(o, []byte(z.ID)) o = append(o, 0xa2, 0x69, 0x6c) o = msgp.AppendBool(o, z.IsLeaf) o = append(o, 0xa2, 0x63, 0x76) o = msgp.AppendArrayHeader(o, uint32(len(z.ChildValues))) for cmr := range z.ChildValues { o, err = msgp.AppendIntf(o, z.ChildValues[cmr]) if err != nil { return } } o = append(o, 0xa2, 0x63, 0x6b) o = msgp.AppendArrayHeader(o, uint32(len(z.ChildKeys))) for ajw := range z.ChildKeys { if z.ChildKeys[ajw] == nil { o = msgp.AppendNil(o) } else { o, err = z.ChildKeys[ajw].MarshalMsg(o) if err != nil { return } } } return }]}
{Id:11 FileId:45 StartLine:205 StartColumn:1 EndLine:288 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc0001e6620 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			{
				var tmp []byte
				tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.ID))
				z.ID = ID(tmp)
			}
			if err != nil {
				return
			}
		case "il":
			z.IsLeaf, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				return
			}
		case "cv":
			var xsz uint32
			xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.ChildValues) >= int(xsz) {
				z.ChildValues = z.ChildValues[:xsz]
			} else {
				z.ChildValues = make([]interface{}, xsz)
			}
			for cmr := range z.ChildValues {
				z.ChildValues[cmr], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					return
				}
			}
		case "ck":
			var xsz uint32
			xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.ChildKeys) >= int(xsz) {
				z.ChildKeys = z.ChildKeys[:xsz]
			} else {
				z.ChildKeys = make(Keys, xsz)
			}
			for ajw := range z.ChildKeys {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ChildKeys[ajw] = nil
				} else {
					if z.ChildKeys[ajw] == nil {
						z.ChildKeys[ajw] = new(Key)
					}
					bts, err = z.ChildKeys[ajw].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "id": { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.ID)) z.ID = ID(tmp) } if err != nil { return } case "il": z.IsLeaf, bts, err = msgp.ReadBoolBytes(bts) if err != nil { return } case "cv": var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap(z.ChildValues) >= int(xsz) { z.ChildValues = z.ChildValues[:xsz] } else { z.ChildValues = make([]interface{}, xsz) } for cmr := range z.ChildValues { z.ChildValues[cmr], bts, err = msgp.ReadIntfBytes(bts) if err != nil { return } } case "ck": var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap(z.ChildKeys) >= int(xsz) { z.ChildKeys = z.ChildKeys[:xsz] } else { z.ChildKeys = make(Keys, xsz) } for ajw := range z.ChildKeys { if msgp.IsNil(bts) { bts, err = msgp.ReadNilBytes(bts) if err != nil { return } z.ChildKeys[ajw] = nil } else { if z.ChildKeys[ajw] == nil { z.ChildKeys[ajw] = new(Key) } bts, err = z.ChildKeys[ajw].UnmarshalMsg(bts) if err != nil { return } } } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]}
{Id:12 FileId:45 StartLine:290 StartColumn:1 EndLine:304 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc0009921e0 Body:{
	s = 1 + 3 + msgp.BytesPrefixSize + len([]byte(z.ID)) + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize
	for cmr := range z.ChildValues {
		s += msgp.GuessSize(z.ChildValues[cmr])
	}
	s += 3 + msgp.ArrayHeaderSize
	for ajw := range z.ChildKeys {
		if z.ChildKeys[ajw] == nil {
			s += msgp.NilSize
		} else {
			s += z.ChildKeys[ajw].Msgsize()
		}
	}
	return
} PrettyPrintBody:[{ s = 1 + 3 + msgp.BytesPrefixSize + len([]byte(z.ID)) + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize for cmr := range z.ChildValues { s += msgp.GuessSize(z.ChildValues[cmr]) } s += 3 + msgp.ArrayHeaderSize for ajw := range z.ChildKeys { if z.ChildKeys[ajw] == nil { s += msgp.NilSize } else { s += z.ChildKeys[ajw].Msgsize() } } return }]}
{Id:1 FileId:59 StartLine:26 StartColumn:1 EndLine:42 EndColumn:2 Name:TestSearchKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := keys{newMockKey(1), newMockKey(2), newMockKey(4)}

	testKey := newMockKey(5)
	assert.Equal(t, 3, keySearch(keys, testKey))

	testKey = newMockKey(2)
	assert.Equal(t, 1, keySearch(keys, testKey))

	testKey = newMockKey(0)
	assert.Equal(t, 0, keySearch(keys, testKey))

	testKey = newMockKey(3)
	assert.Equal(t, 2, keySearch(keys, testKey))

	assert.Equal(t, 0, keySearch(nil, testKey))
} PrettyPrintBody:[{ keys := keys{newMockKey(1), newMockKey(2), newMockKey(4)} testKey := newMockKey(5) assert.Equal(t, 3, keySearch(keys, testKey)) testKey = newMockKey(2) assert.Equal(t, 1, keySearch(keys, testKey)) testKey = newMockKey(0) assert.Equal(t, 0, keySearch(keys, testKey)) testKey = newMockKey(3) assert.Equal(t, 2, keySearch(keys, testKey)) assert.Equal(t, 0, keySearch(nil, testKey)) }]}
{Id:2 FileId:59 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:TestTreeInsert2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)

	tree.Insert(keys...)

	assert.Len(t, tree.root.(*inode).keys, 2)
	assert.Len(t, tree.root.(*inode).nodes, 3)
	assert.IsType(t, &inode{}, tree.root)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) tree.Insert(keys...) assert.Len(t, tree.root.(*inode).keys, 2) assert.Len(t, tree.root.(*inode).nodes, 3) assert.IsType(t, &inode{}, tree.root) }]}
{Id:3 FileId:59 StartLine:55 StartColumn:1 EndLine:64 EndColumn:2 Name:TestTreeInsert3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	assert.Len(t, tree.root.(*inode).keys, 1)
	assert.Len(t, tree.root.(*inode).nodes, 2)
	assert.IsType(t, &inode{}, tree.root)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) assert.Len(t, tree.root.(*inode).keys, 1) assert.Len(t, tree.root.(*inode).nodes, 2) assert.IsType(t, &inode{}, tree.root) }]}
{Id:4 FileId:59 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:TestTreeInsertQuery2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:5 FileId:59 StartLine:78 StartColumn:1 EndLine:88 EndColumn:2 Name:TestTreeInsertQuery3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:6 FileId:59 StartLine:90 StartColumn:1 EndLine:103 EndColumn:2 Name:TestTreeInsertReverseOrder2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]}
{Id:7 FileId:59 StartLine:105 StartColumn:1 EndLine:118 EndColumn:2 Name:TestTreeInsertReverseOrder3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]}
{Id:8 FileId:59 StartLine:120 StartColumn:1 EndLine:133 EndColumn:2 Name:TestTreeInsert3_4_5_WithEndDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(4)
	tree.Insert(duplicate)
	keys[4] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(4) tree.Insert(duplicate) keys[4] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:9 FileId:59 StartLine:135 StartColumn:1 EndLine:148 EndColumn:2 Name:TestTreeInsert3_4_5_WithMiddleDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(2)
	tree.Insert(duplicate)
	keys[2] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(2) tree.Insert(duplicate) keys[2] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:10 FileId:59 StartLine:150 StartColumn:1 EndLine:163 EndColumn:2 Name:TestTreeInsert3_4_5WithEarlyDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(0)
	tree.Insert(duplicate)
	keys[0] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(0) tree.Insert(duplicate) keys[0] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:11 FileId:59 StartLine:165 StartColumn:1 EndLine:177 EndColumn:2 Name:TestTreeInsert3_4_5WithDuplicateID Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	key := newMockKey(2)
	tree.Insert(keys...)
	tree.Insert(key)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) key := newMockKey(2) tree.Insert(keys...) tree.Insert(key) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:12 FileId:59 StartLine:179 StartColumn:1 EndLine:189 EndColumn:2 Name:TestTreeInsert3_4_5MiddleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(2))
	result := iter.exhaust()

	assert.Equal(t, keys[2:], result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(2)) result := iter.exhaust() assert.Equal(t, keys[2:], result) }]}
{Id:13 FileId:59 StartLine:191 StartColumn:1 EndLine:201 EndColumn:2 Name:TestTreeInsert3_4_5LateQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(4))
	result := iter.exhaust()

	assert.Equal(t, keys[4:], result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(4)) result := iter.exhaust() assert.Equal(t, keys[4:], result) }]}
{Id:14 FileId:59 StartLine:203 StartColumn:1 EndLine:213 EndColumn:2 Name:TestTreeInsert3_4_5AfterQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(5))
	result := iter.exhaust()

	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(5)) result := iter.exhaust() assert.Len(t, result, 0) }]}
{Id:15 FileId:59 StartLine:215 StartColumn:1 EndLine:225 EndColumn:2 Name:TestTreeInternalNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(10)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(10) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]}
{Id:16 FileId:59 StartLine:227 StartColumn:1 EndLine:239 EndColumn:2 Name:TestTreeInternalNodeSplitReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(10)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(10) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]}
{Id:17 FileId:59 StartLine:241 StartColumn:1 EndLine:259 EndColumn:2 Name:TestTreeInternalNodeSplitRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5}
	keys := make(keys, 0, len(ids))

	for _, id := range ids {
		keys = append(keys, newMockKey(id))
	}

	tree := newBTree(4)
	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Len(t, result, 10)
	for i, key := range result {
		assert.Equal(t, newMockKey(i), key)
	}
} PrettyPrintBody:[{ ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5} keys := make(keys, 0, len(ids)) for _, id := range ids { keys = append(keys, newMockKey(id)) } tree := newBTree(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Len(t, result, 10) for i, key := range result { assert.Equal(t, newMockKey(i), key) } }]}
{Id:18 FileId:59 StartLine:261 StartColumn:1 EndLine:279 EndColumn:2 Name:TestTreeRandomOrderQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5}
	keys := make(keys, 0, len(ids))

	for _, id := range ids {
		keys = append(keys, newMockKey(id))
	}

	tree := newBTree(4)
	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(4))
	result := iter.exhaust()

	assert.Len(t, result, 6)
	for i, key := range result {
		assert.Equal(t, newMockKey(i+4), key)
	}
} PrettyPrintBody:[{ ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5} keys := make(keys, 0, len(ids)) for _, id := range ids { keys = append(keys, newMockKey(id)) } tree := newBTree(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(4)) result := iter.exhaust() assert.Len(t, result, 6) for i, key := range result { assert.Equal(t, newMockKey(i+4), key) } }]}
{Id:19 FileId:59 StartLine:281 StartColumn:1 EndLine:291 EndColumn:2 Name:TestTreeGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructRandomMockKeys(100)
	tree := newBTree(64)
	tree.Insert(keys...)

	assert.Equal(t, uint64(100), tree.Len())
	fromTree := tree.Get(keys...)
	for _, key := range keys {
		assert.Contains(t, fromTree, key)
	}
} PrettyPrintBody:[{ keys := constructRandomMockKeys(100) tree := newBTree(64) tree.Insert(keys...) assert.Equal(t, uint64(100), tree.Len()) fromTree := tree.Get(keys...) for _, key := range keys { assert.Contains(t, fromTree, key) } }]}
{Id:20 FileId:59 StartLine:293 StartColumn:1 EndLine:299 EndColumn:2 Name:TestTreeGetNotFound Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockKeys(5)
	tree := newBTree(64)
	tree.Insert(keys...)

	assert.Equal(t, Keys{nil}, tree.Get(newMockKey(20)))
} PrettyPrintBody:[{ keys := constructMockKeys(5) tree := newBTree(64) tree.Insert(keys...) assert.Equal(t, Keys{nil}, tree.Get(newMockKey(20))) }]}
{Id:21 FileId:59 StartLine:301 StartColumn:1 EndLine:308 EndColumn:2 Name:TestGetExactMatchesOnly Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := newMockKey(0)
	k2 := newMockKey(5)
	tree := newBTree(64)
	tree.Insert(k1, k2)

	assert.Equal(t, Keys{nil}, tree.Get(newMockKey(3)))
} PrettyPrintBody:[{ k1 := newMockKey(0) k2 := newMockKey(5) tree := newBTree(64) tree.Insert(k1, k2) assert.Equal(t, Keys{nil}, tree.Get(newMockKey(3))) }]}
{Id:22 FileId:59 StartLine:310 StartColumn:1 EndLine:325 EndColumn:2 Name:BenchmarkIteration Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)
	tree.Insert(keys...)

	searchKey := newMockKey(0)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		iter := tree.Iter(searchKey)
		iter.exhaust()
	}
} PrettyPrintBody:[{ numItems := 1000 ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) tree.Insert(keys...) searchKey := newMockKey(0) b.ResetTimer() for i := 0; i < b.N; i++ { iter := tree.Iter(searchKey) iter.exhaust() } }]}
{Id:23 FileId:59 StartLine:327 StartColumn:1 EndLine:338 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]}
{Id:24 FileId:59 StartLine:340 StartColumn:1 EndLine:350 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := constructRandomMockKeys(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newBTree(1024)
		tree.Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := constructRandomMockKeys(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newBTree(1024) tree.Insert(keys...) } }]}
{Id:25 FileId:59 StartLine:352 StartColumn:1 EndLine:365 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]}
{Id:26 FileId:59 StartLine:367 StartColumn:1 EndLine:381 EndColumn:2 Name:BenchmarkBulkAddToExisting Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	keySet := make([]keys, 0, b.N)
	for i := 0; i < b.N; i++ {
		keySet = append(keySet, constructRandomMockKeys(numItems))
	}

	tree := newBTree(1024)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keySet[i]...)
	}
} PrettyPrintBody:[{ numItems := 100000 keySet := make([]keys, 0, b.N) for i := 0; i < b.N; i++ { keySet = append(keySet, constructRandomMockKeys(numItems)) } tree := newBTree(1024) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keySet[i]...) } }]}
{Id:27 FileId:59 StartLine:383 StartColumn:1 EndLine:397 EndColumn:2 Name:BenchmarkReadAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ks := make([]keys, 0, b.N)
	for i := 0; i < b.N; i++ {
		ks = append(ks, constructRandomMockKeys(numItems))
	}

	tree := newBTree(16)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(ks[i]...)
		tree.Get(ks[i]...)
	}
} PrettyPrintBody:[{ numItems := 1000 ks := make([]keys, 0, b.N) for i := 0; i < b.N; i++ { ks = append(ks, constructRandomMockKeys(numItems)) } tree := newBTree(16) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(ks[i]...) tree.Get(ks[i]...) } }]}
{Id:28 FileId:59 StartLine:399 StartColumn:1 EndLine:428 EndColumn:2 Name:BenchmarkSimultaneousReadsAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	numRoutines := 8
	keys := constructRandomMockKeys(numItems)
	chunks := chunkKeys(keys, int64(numRoutines))

	trees := make([]*btree, 0, numItems)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newBTree(8))
	}

	var wg sync.WaitGroup
	var lock sync.Mutex
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(numRoutines)
		for j := 0; j < numRoutines; j++ {
			go func(i, j int) {
				lock.Lock()
				trees[i].Insert(chunks[j]...)
				trees[i].Get(chunks[j]...)
				lock.Unlock()
				wg.Done()
			}(i, j)
		}

		wg.Wait()
	}
} PrettyPrintBody:[{ numItems := 10000 numRoutines := 8 keys := constructRandomMockKeys(numItems) chunks := chunkKeys(keys, int64(numRoutines)) trees := make([]*btree, 0, numItems) for i := 0; i < b.N; i++ { trees = append(trees, newBTree(8)) } var wg sync.WaitGroup var lock sync.Mutex b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(numRoutines) for j := 0; j < numRoutines; j++ { go func(i, j int) { lock.Lock() trees[i].Insert(chunks[j]...) trees[i].Get(chunks[j]...) lock.Unlock() wg.Done() }(i, j) } wg.Wait() } }]}
{Id:2 FileId:138 StartLine:11 StartColumn:1 EndLine:21 EndColumn:2 Name:Compare Params:[{Name:other Type:Comparator}] Results:[{Name: Type:int}] Receiver:0xc00113e660 Body:{
	if mc == other.(mockComparator) {
		return 0
	}

	if mc > other.(mockComparator) {
		return 1
	}

	return -1
} PrettyPrintBody:[{ if mc == other.(mockComparator) { return 0 } if mc > other.(mockComparator) { return 1 } return -1 }]}
{Id:3 FileId:138 StartLine:23 StartColumn:1 EndLine:30 EndColumn:2 Name:constructMockComparators Params:[{Name:values Type:...int}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	comparators := make(Comparators, 0, len(values))
	for _, v := range values {
		comparators = append(comparators, mockComparator(v))
	}

	return comparators
} PrettyPrintBody:[{ comparators := make(Comparators, 0, len(values)) for _, v := range values { comparators = append(comparators, mockComparator(v)) } return comparators }]}
{Id:4 FileId:138 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:constructOrderedMockComparators Params:[{Name:upTo Type:int}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	comparators := make(Comparators, 0, upTo)
	for i := 0; i < upTo; i++ {
		comparators = append(comparators, mockComparator(i))
	}

	return comparators
} PrettyPrintBody:[{ comparators := make(Comparators, 0, upTo) for i := 0; i < upTo; i++ { comparators = append(comparators, mockComparator(i)) } return comparators }]}
{Id:5 FileId:138 StartLine:41 StartColumn:1 EndLine:47 EndColumn:2 Name:reverseComparators Params:[{Name:comparators Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	for i := 0; i < len(comparators); i++ {
		li := len(comparators) - i - 1
		comparators[i], comparators[li] = comparators[li], comparators[i]
	}
	return comparators
} PrettyPrintBody:[{ for i := 0; i < len(comparators); i++ { li := len(comparators) - i - 1 comparators[i], comparators[li] = comparators[li], comparators[i] } return comparators }]}
{Id:6 FileId:138 StartLine:49 StartColumn:1 EndLine:56 EndColumn:2 Name:TestDecomposeForSymMergeOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(7)

	v1, w, v2 := decomposeForSymMerge(3, comparators)
	assert.Equal(t, comparators[:2], v1)
	assert.Equal(t, comparators[2:5], w)
	assert.Equal(t, comparators[5:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(7) v1, w, v2 := decomposeForSymMerge(3, comparators) assert.Equal(t, comparators[:2], v1) assert.Equal(t, comparators[2:5], w) assert.Equal(t, comparators[5:], v2) }]}
{Id:7 FileId:138 StartLine:58 StartColumn:1 EndLine:65 EndColumn:2 Name:TestDecomposeForSymMergeEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	v1, w, v2 := decomposeForSymMerge(5, comparators)

	assert.Equal(t, comparators[:1], v1)
	assert.Equal(t, comparators[1:6], w)
	assert.Equal(t, comparators[6:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) v1, w, v2 := decomposeForSymMerge(5, comparators) assert.Equal(t, comparators[:1], v1) assert.Equal(t, comparators[1:6], w) assert.Equal(t, comparators[6:], v2) }]}
{Id:8 FileId:138 StartLine:67 StartColumn:1 EndLine:74 EndColumn:2 Name:TestNearCompleteDecomposeForSymMerge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	v1, w, v2 := decomposeForSymMerge(7, comparators)

	assert.Len(t, v1, 0)
	assert.Equal(t, comparators[:7], w)
	assert.Equal(t, comparators[7:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) v1, w, v2 := decomposeForSymMerge(7, comparators) assert.Len(t, v1, 0) assert.Equal(t, comparators[:7], w) assert.Equal(t, comparators[7:], v2) }]}
{Id:9 FileId:138 StartLine:76 StartColumn:1 EndLine:81 EndColumn:2 Name:TestDecomposePanicsWithWrongLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	assert.Panics(t, func() {
		decomposeForSymMerge(8, comparators)
	})
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) assert.Panics(t, func() { decomposeForSymMerge(8, comparators) }) }]}
{Id:10 FileId:138 StartLine:83 StartColumn:1 EndLine:95 EndColumn:2 Name:TestSymSearch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5, 7, 9)
	w := constructMockComparators(1, 3, 9, 10)

	result := symSearch(u, w)
	assert.Equal(t, 2, result)

	u = constructMockComparators(1, 5, 7)
	w = constructMockComparators(1, 3, 9)

	result = symSearch(u, w)
	assert.Equal(t, 1, result)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5, 7, 9) w := constructMockComparators(1, 3, 9, 10) result := symSearch(u, w) assert.Equal(t, 2, result) u = constructMockComparators(1, 5, 7) w = constructMockComparators(1, 3, 9) result = symSearch(u, w) assert.Equal(t, 1, result) }]}
{Id:11 FileId:138 StartLine:97 StartColumn:1 EndLine:107 EndColumn:2 Name:TestSwap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5, 7, 9)
	w := constructMockComparators(2, 8, 11, 13)
	u1 := constructMockComparators(1, 5, 2, 8)
	w1 := constructMockComparators(7, 9, 11, 13)

	swap(u, w, 2)

	assert.Equal(t, u1, u)
	assert.Equal(t, w1, w)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5, 7, 9) w := constructMockComparators(2, 8, 11, 13) u1 := constructMockComparators(1, 5, 2, 8) w1 := constructMockComparators(7, 9, 11, 13) swap(u, w, 2) assert.Equal(t, u1, u) assert.Equal(t, w1, w) }]}
{Id:12 FileId:138 StartLine:109 StartColumn:1 EndLine:116 EndColumn:2 Name:TestSymMergeSmallLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5)
	w := constructMockComparators(2, 8)
	expected := constructMockComparators(1, 2, 5, 8)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5) w := constructMockComparators(2, 8) expected := constructMockComparators(1, 2, 5, 8) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:13 FileId:138 StartLine:118 StartColumn:1 EndLine:125 EndColumn:2 Name:TestSymMergeAlreadySorted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5)
	w := constructMockComparators(6, 7)
	expected := constructMockComparators(1, 5, 6, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5) w := constructMockComparators(6, 7) expected := constructMockComparators(1, 5, 6, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:14 FileId:138 StartLine:127 StartColumn:1 EndLine:134 EndColumn:2 Name:TestSymMergeAlreadySortedReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(6, 7)
	w := constructMockComparators(1, 5)
	expected := constructMockComparators(1, 5, 6, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(6, 7) w := constructMockComparators(1, 5) expected := constructMockComparators(1, 5, 6, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:15 FileId:138 StartLine:136 StartColumn:1 EndLine:143 EndColumn:2 Name:TestSymMergeUnevenLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 7)
	w := constructMockComparators(2, 4)
	expected := constructMockComparators(1, 2, 3, 4, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 7) w := constructMockComparators(2, 4) expected := constructMockComparators(1, 2, 3, 4, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:16 FileId:138 StartLine:145 StartColumn:1 EndLine:152 EndColumn:2 Name:TestSymMergeUnevenListsWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 7)
	expected := constructMockComparators(1, 2, 3, 4, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 7) expected := constructMockComparators(1, 2, 3, 4, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:17 FileId:138 StartLine:154 StartColumn:1 EndLine:161 EndColumn:2 Name:TestMergeVeryUnevenLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 7, 12, 15)
	w := constructMockComparators(2, 4)
	expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 7, 12, 15) w := constructMockComparators(2, 4) expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:18 FileId:138 StartLine:163 StartColumn:1 EndLine:170 EndColumn:2 Name:TestMergeVeryUnevenListsWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 7, 12, 15)
	expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 7, 12, 15) expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:19 FileId:138 StartLine:172 StartColumn:1 EndLine:179 EndColumn:2 Name:TestMergeVeryUnevenListsAlreadySorted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(5, 7, 9, 10, 11, 12)
	expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(5, 7, 9, 10, 11, 12) expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:20 FileId:138 StartLine:181 StartColumn:1 EndLine:188 EndColumn:2 Name:TestMergeVeryUnevenListsAlreadySortedWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	w := constructMockComparators(2, 4)
	u := constructMockComparators(5, 7, 9, 10, 11, 12)
	expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ w := constructMockComparators(2, 4) u := constructMockComparators(5, 7, 9, 10, 11, 12) expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:21 FileId:138 StartLine:190 StartColumn:1 EndLine:197 EndColumn:2 Name:TestMergeVeryUnevenListIsSubset Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 5, 7, 9)
	expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 5, 7, 9) expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:22 FileId:138 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:TestMergeVeryUnevenListIsSubsetReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	w := constructMockComparators(2, 4)
	u := constructMockComparators(1, 3, 5, 7, 9)
	expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ w := constructMockComparators(2, 4) u := constructMockComparators(1, 3, 5, 7, 9) expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:23 FileId:138 StartLine:208 StartColumn:1 EndLine:215 EndColumn:2 Name:TestMergeUnevenOneListIsOne Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1)
	w := constructMockComparators(0, 3, 5, 7, 9)
	expected := constructMockComparators(0, 1, 3, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1) w := constructMockComparators(0, 3, 5, 7, 9) expected := constructMockComparators(0, 1, 3, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]}
{Id:24 FileId:138 StartLine:217 StartColumn:1 EndLine:223 EndColumn:2 Name:TestMergeEmptyList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 5)
	expected := constructMockComparators(1, 3, 5)

	u = SymMerge(u, nil)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 5) expected := constructMockComparators(1, 3, 5) u = SymMerge(u, nil) assert.Equal(t, expected, u) }]}
{Id:1 FileId:12 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:getIndexAndRemainder Params:[{Name:k Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:uint64}] Receiver:<nil> Body:{
	return k / s, k % s
} PrettyPrintBody:[{ return k / s, k % s }]}
{Id:2 FileId:12 StartLine:35 StartColumn:1 EndLine:50 EndColumn:2 Name:setLowest Params:[] Results:[] Receiver:0xc000e7fd00 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		if ba.blocks[i] == 0 {
			continue
		}

		pos := ba.blocks[i].findRightPosition()
		ba.lowest = (i * s) + pos
		ba.anyset = true
		return
	}

	ba.anyset = false
	ba.lowest = 0
	ba.highest = 0
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { if ba.blocks[i] == 0 { continue } pos := ba.blocks[i].findRightPosition() ba.lowest = (i * s) + pos ba.anyset = true return } ba.anyset = false ba.lowest = 0 ba.highest = 0 }]}
{Id:3 FileId:12 StartLine:52 StartColumn:1 EndLine:67 EndColumn:2 Name:setHighest Params:[] Results:[] Receiver:0xc000e569a0 Body:{
	for i := len(ba.blocks) - 1; i >= 0; i-- {
		if ba.blocks[i] == 0 {
			continue
		}

		pos := ba.blocks[i].findLeftPosition()
		ba.highest = (uint64(i) * s) + pos
		ba.anyset = true
		return
	}

	ba.anyset = false
	ba.highest = 0
	ba.lowest = 0
} PrettyPrintBody:[{ for i := len(ba.blocks) - 1; i >= 0; i-- { if ba.blocks[i] == 0 { continue } pos := ba.blocks[i].findLeftPosition() ba.highest = (uint64(i) * s) + pos ba.anyset = true return } ba.anyset = false ba.highest = 0 ba.lowest = 0 }]}
{Id:4 FileId:12 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:Capacity Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000bb6140 Body:{
	return uint64(len(ba.blocks)) * s
} PrettyPrintBody:[{ return uint64(len(ba.blocks)) * s }]}
{Id:5 FileId:12 StartLine:75 StartColumn:1 EndLine:82 EndColumn:2 Name:ToNums Params:[] Results:[{Name: Type:[]uint64}] Receiver:0xc0001186a0 Body:{
	nums := make([]uint64, 0, ba.highest-ba.lowest/4)
	for i, block := range ba.blocks {
		block.toNums(uint64(i)*s, &nums)
	}

	return nums
} PrettyPrintBody:[{ nums := make([]uint64, 0, ba.highest-ba.lowest/4) for i, block := range ba.blocks { block.toNums(uint64(i)*s, &nums) } return nums }]}
{Id:6 FileId:12 StartLine:85 StartColumn:1 EndLine:105 EndColumn:2 Name:SetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc000a23740 Body:{
	if k >= ba.Capacity() {
		return OutOfRangeError(k)
	}

	if !ba.anyset {
		ba.lowest = k
		ba.highest = k
		ba.anyset = true
	} else {
		if k < ba.lowest {
			ba.lowest = k
		} else if k > ba.highest {
			ba.highest = k
		}
	}

	i, pos := getIndexAndRemainder(k)
	ba.blocks[i] = ba.blocks[i].insert(pos)
	return nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return OutOfRangeError(k) } if !ba.anyset { ba.lowest = k ba.highest = k ba.anyset = true } else { if k < ba.lowest { ba.lowest = k } else if k > ba.highest { ba.highest = k } } i, pos := getIndexAndRemainder(k) ba.blocks[i] = ba.blocks[i].insert(pos) return nil }]}
{Id:7 FileId:12 StartLine:109 StartColumn:1 EndLine:117 EndColumn:2 Name:GetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001309760 Body:{
	if k >= ba.Capacity() {
		return false, OutOfRangeError(k)
	}

	i, pos := getIndexAndRemainder(k)
	result := ba.blocks[i]&block(1<<pos) != 0
	return result, nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return false, OutOfRangeError(k) } i, pos := getIndexAndRemainder(k) result := ba.blocks[i]&block(1<<pos) != 0 return result, nil }]}
{Id:8 FileId:12 StartLine:120 StartColumn:1 EndLine:138 EndColumn:2 Name:ClearBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001409d00 Body:{
	if k >= ba.Capacity() {
		return OutOfRangeError(k)
	}

	if !ba.anyset {
		return nil
	}

	i, pos := getIndexAndRemainder(k)
	ba.blocks[i] &^= block(1 << pos)

	if k == ba.highest {
		ba.setHighest()
	} else if k == ba.lowest {
		ba.setLowest()
	}
	return nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return OutOfRangeError(k) } if !ba.anyset { return nil } i, pos := getIndexAndRemainder(k) ba.blocks[i] &^= block(1 << pos) if k == ba.highest { ba.setHighest() } else if k == ba.lowest { ba.setLowest() } return nil }]}
{Id:9 FileId:12 StartLine:142 StartColumn:1 EndLine:148 EndColumn:2 Name:Or Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc00019e160 Body:{
	if dba, ok := other.(*bitArray); ok {
		return orDenseWithDenseBitArray(ba, dba)
	}

	return orSparseWithDenseBitArray(other.(*sparseBitArray), ba)
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return orDenseWithDenseBitArray(ba, dba) } return orSparseWithDenseBitArray(other.(*sparseBitArray), ba) }]}
{Id:10 FileId:12 StartLine:152 StartColumn:1 EndLine:158 EndColumn:2 Name:And Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc000a8a740 Body:{
	if dba, ok := other.(*bitArray); ok {
		return andDenseWithDenseBitArray(ba, dba)
	}

	return andSparseWithDenseBitArray(other.(*sparseBitArray), ba)
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return andDenseWithDenseBitArray(ba, dba) } return andSparseWithDenseBitArray(other.(*sparseBitArray), ba) }]}
{Id:11 FileId:12 StartLine:162 StartColumn:1 EndLine:168 EndColumn:2 Name:Nand Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc0001e6360 Body:{
	if dba, ok := other.(*bitArray); ok {
		return nandDenseWithDenseBitArray(ba, dba)
	}

	return nandDenseWithSparseBitArray(ba, other.(*sparseBitArray))
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return nandDenseWithDenseBitArray(ba, dba) } return nandDenseWithSparseBitArray(ba, other.(*sparseBitArray)) }]}
{Id:12 FileId:12 StartLine:171 StartColumn:1 EndLine:176 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0001e6380 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		ba.blocks[i] &= block(0)
	}
	ba.anyset = false
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] &= block(0) } ba.anyset = false }]}
{Id:13 FileId:12 StartLine:179 StartColumn:1 EndLine:212 EndColumn:2 Name:Equals Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc000993940 Body:{
	if other.Capacity() == 0 && ba.highest > 0 {
		return false
	}

	if other.Capacity() == 0 && !ba.anyset {
		return true
	}

	var selfIndex uint64
	for iter := other.Blocks(); iter.Next(); {
		toIndex, otherBlock := iter.Value()
		if toIndex > selfIndex {
			for i := selfIndex; i < toIndex; i++ {
				if ba.blocks[i] > 0 {
					return false
				}
			}
		}

		selfIndex = toIndex
		if !ba.blocks[selfIndex].equals(otherBlock) {
			return false
		}
		selfIndex++
	}

	lastIndex, _ := getIndexAndRemainder(ba.highest)
	if lastIndex >= selfIndex {
		return false
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 && ba.highest > 0 { return false } if other.Capacity() == 0 && !ba.anyset { return true } var selfIndex uint64 for iter := other.Blocks(); iter.Next(); { toIndex, otherBlock := iter.Value() if toIndex > selfIndex { for i := selfIndex; i < toIndex; i++ { if ba.blocks[i] > 0 { return false } } } selfIndex = toIndex if !ba.blocks[selfIndex].equals(otherBlock) { return false } selfIndex++ } lastIndex, _ := getIndexAndRemainder(ba.highest) if lastIndex >= selfIndex { return false } return true }]}
{Id:14 FileId:12 StartLine:218 StartColumn:1 EndLine:228 EndColumn:2 Name:Intersects Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc0001e6720 Body:{
	if other.Capacity() > ba.Capacity() {
		return false
	}

	if sba, ok := other.(*sparseBitArray); ok {
		return ba.intersectsSparseBitArray(sba)
	}

	return ba.intersectsDenseBitArray(other.(*bitArray))
} PrettyPrintBody:[{ if other.Capacity() > ba.Capacity() { return false } if sba, ok := other.(*sparseBitArray); ok { return ba.intersectsSparseBitArray(sba) } return ba.intersectsDenseBitArray(other.(*bitArray)) }]}
{Id:15 FileId:12 StartLine:231 StartColumn:1 EndLine:233 EndColumn:2 Name:Blocks Params:[] Results:[{Name: Type:Iterator}] Receiver:0xc0003e56e0 Body:{
	return newBitArrayIterator(ba)
} PrettyPrintBody:[{ return newBitArrayIterator(ba) }]}
{Id:16 FileId:12 StartLine:235 StartColumn:1 EndLine:237 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095b240 Body:{
	return !ba.anyset
} PrettyPrintBody:[{ return !ba.anyset }]}
{Id:17 FileId:12 StartLine:240 StartColumn:1 EndLine:249 EndColumn:2 Name:complement Params:[] Results:[] Receiver:0xc00019e660 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		ba.blocks[i] = ^ba.blocks[i]
	}

	ba.setLowest()
	if ba.anyset {
		ba.setHighest()
	}
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] = ^ba.blocks[i] } ba.setLowest() if ba.anyset { ba.setHighest() } }]}
{Id:18 FileId:12 StartLine:251 StartColumn:1 EndLine:259 EndColumn:2 Name:intersectsSparseBitArray Params:[{Name:other Type:*sparseBitArray}] Results:[{Name: Type:bool}] Receiver:0xc0001e6a00 Body:{
	for i, index := range other.indices {
		if !ba.blocks[index].intersects(other.blocks[i]) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, index := range other.indices { if !ba.blocks[index].intersects(other.blocks[i]) { return false } } return true }]}
{Id:19 FileId:12 StartLine:261 StartColumn:1 EndLine:269 EndColumn:2 Name:intersectsDenseBitArray Params:[{Name:other Type:*bitArray}] Results:[{Name: Type:bool}] Receiver:0xc000992380 Body:{
	for i, block := range other.blocks {
		if !ba.blocks[i].intersects(block) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, block := range other.blocks { if !ba.blocks[i].intersects(block) { return false } } return true }]}
{Id:20 FileId:12 StartLine:271 StartColumn:1 EndLine:280 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:BitArray}] Receiver:0xc00095b480 Body:{
	blocks := make(blocks, len(ba.blocks))
	copy(blocks, ba.blocks)
	return &bitArray{
		blocks:		blocks,
		lowest:		ba.lowest,
		highest:	ba.highest,
		anyset:		ba.anyset,
	}
} PrettyPrintBody:[{ blocks := make(blocks, len(ba.blocks)) copy(blocks, ba.blocks) return &bitArray{ blocks:		blocks, lowest:		ba.lowest, highest:	ba.highest, anyset:		ba.anyset, } }]}
{Id:21 FileId:12 StartLine:285 StartColumn:1 EndLine:307 EndColumn:2 Name:newBitArray Params:[{Name:size Type:uint64} {Name:args Type:...bool}] Results:[{Name: Type:*bitArray}] Receiver:<nil> Body:{
	i, r := getIndexAndRemainder(size)
	if r > 0 {
		i++
	}

	ba := &bitArray{
		blocks:	make([]block, i),
		anyset:	false,
	}

	if len(args) > 0 && args[0] == true {
		for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
			ba.blocks[i] = maximumBlock
		}

		ba.lowest = 0
		ba.highest = i*s - 1
		ba.anyset = true
	}

	return ba
} PrettyPrintBody:[{ i, r := getIndexAndRemainder(size) if r > 0 { i++ } ba := &bitArray{ blocks:	make([]block, i), anyset:	false, } if len(args) > 0 && args[0] == true { for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] = maximumBlock } ba.lowest = 0 ba.highest = i*s - 1 ba.anyset = true } return ba }]}
{Id:22 FileId:12 StartLine:312 StartColumn:1 EndLine:314 EndColumn:2 Name:NewBitArray Params:[{Name:size Type:uint64} {Name:args Type:...bool}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	return newBitArray(size, args...)
} PrettyPrintBody:[{ return newBitArray(size, args...) }]}
{Id:1 FileId:95 StartLine:26 StartColumn:1 EndLine:41 EndColumn:2 Name:TestPriorityPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(2))

	assert.Len(t, q.items, 1)
	assert.Equal(t, mockItem(2), q.items[0])

	q.Put(mockItem(1))

	if !assert.Len(t, q.items, 2) {
		return
	}
	assert.Equal(t, mockItem(1), q.items[0])
	assert.Equal(t, mockItem(2), q.items[1])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(2)) assert.Len(t, q.items, 1) assert.Equal(t, mockItem(2), q.items[0]) q.Put(mockItem(1)) if !assert.Len(t, q.items, 2) { return } assert.Equal(t, mockItem(1), q.items[0]) assert.Equal(t, mockItem(2), q.items[1]) }]}
{Id:2 FileId:95 StartLine:43 StartColumn:1 EndLine:84 EndColumn:2 Name:TestPriorityGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(2))
	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(2), result[0])
	assert.Len(t, q.items, 0)

	q.Put(mockItem(2))
	q.Put(mockItem(1))

	result, err = q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(1), result[0])
	assert.Len(t, q.items, 1)

	result, err = q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(2), result[0])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(2)) result, err := q.Get(2) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(2), result[0]) assert.Len(t, q.items, 0) q.Put(mockItem(2)) q.Put(mockItem(1)) result, err = q.Get(1) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(1), result[0]) assert.Len(t, q.items, 1) result, err = q.Get(2) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(2), result[0]) }]}
{Id:3 FileId:95 StartLine:86 StartColumn:1 EndLine:92 EndColumn:2 Name:TestAddEmptyPriorityPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put()

	assert.Len(t, q.items, 0)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put() assert.Len(t, q.items, 0) }]}
{Id:4 FileId:95 StartLine:94 StartColumn:1 EndLine:112 EndColumn:2 Name:TestPriorityGetNonPositiveNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(1))

	result, err := q.Get(0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 0)

	result, err = q.Get(-1)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 0)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) result, err := q.Get(0) if !assert.Nil(t, err) { return } assert.Len(t, result, 0) result, err = q.Get(-1) if !assert.Nil(t, err) { return } assert.Len(t, result, 0) }]}
{Id:5 FileId:95 StartLine:114 StartColumn:1 EndLine:121 EndColumn:2 Name:TestPriorityEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	assert.True(t, q.Empty())

	q.Put(mockItem(1))

	assert.False(t, q.Empty())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) assert.True(t, q.Empty()) q.Put(mockItem(1)) assert.False(t, q.Empty()) }]}
{Id:6 FileId:95 StartLine:123 StartColumn:1 EndLine:139 EndColumn:2 Name:TestPriorityGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	go func() {
		q.Put(mockItem(1))
	}()

	result, err := q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}
	assert.Equal(t, mockItem(1), result[0])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) go func() { q.Put(mockItem(1)) }() result, err := q.Get(1) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(1), result[0]) }]}
{Id:7 FileId:95 StartLine:141 StartColumn:1 EndLine:175 EndColumn:2 Name:TestMultiplePriorityGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	var wg sync.WaitGroup
	wg.Add(2)
	results := make([][]Item, 2)

	go func() {
		wg.Done()
		local, _ := q.Get(1)
		results[0] = local
		wg.Done()
	}()

	go func() {
		wg.Done()
		local, _ := q.Get(1)
		results[1] = local
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	q.Put(mockItem(1), mockItem(3), mockItem(2))
	wg.Wait()

	if !assert.Len(t, results[0], 1) || !assert.Len(t, results[1], 1) {
		return
	}

	assert.True(
		t, (results[0][0] == mockItem(1) && results[1][0] == mockItem(2)) ||
			results[0][0] == mockItem(2) && results[1][0] == mockItem(1),
	)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) var wg sync.WaitGroup wg.Add(2) results := make([][]Item, 2) go func() { wg.Done() local, _ := q.Get(1) results[0] = local wg.Done() }() go func() { wg.Done() local, _ := q.Get(1) results[1] = local wg.Done() }() wg.Wait() wg.Add(2) q.Put(mockItem(1), mockItem(3), mockItem(2)) wg.Wait() if !assert.Len(t, results[0], 1) || !assert.Len(t, results[1], 1) { return } assert.True( t, (results[0][0] == mockItem(1) && results[1][0] == mockItem(2)) || results[0][0] == mockItem(2) && results[1][0] == mockItem(1), ) }]}
{Id:8 FileId:95 StartLine:177 StartColumn:1 EndLine:197 EndColumn:2 Name:TestEmptyPriorityGetWithDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	var wg sync.WaitGroup
	wg.Add(1)

	var err error
	go func() {
		wg.Done()
		_, err = q.Get(1)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)

	q.Dispose()

	wg.Wait()

	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) var wg sync.WaitGroup wg.Add(1) var err error go func() { wg.Done() _, err = q.Get(1) wg.Done() }() wg.Wait() wg.Add(1) q.Dispose() wg.Wait() assert.IsType(t, ErrDisposed, err) }]}
{Id:9 FileId:95 StartLine:199 StartColumn:1 EndLine:208 EndColumn:2 Name:TestPriorityGetPutDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Dispose()

	_, err := q.Get(1)
	assert.IsType(t, ErrDisposed, err)

	err = q.Put(mockItem(1))
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Dispose() _, err := q.Get(1) assert.IsType(t, ErrDisposed, err) err = q.Put(mockItem(1)) assert.IsType(t, ErrDisposed, err) }]}
{Id:10 FileId:95 StartLine:210 StartColumn:1 EndLine:232 EndColumn:2 Name:BenchmarkPriorityQueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(b.N, false)
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			q.Get(1)
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		q.Put(mockItem(i))
	}

	wg.Wait()
} PrettyPrintBody:[{ q := NewPriorityQueue(b.N, false) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { q.Get(1) i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { q.Put(mockItem(i)) } wg.Wait() }]}
{Id:11 FileId:95 StartLine:234 StartColumn:1 EndLine:239 EndColumn:2 Name:TestPriorityPeek Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Put(mockItem(1))

	assert.Equal(t, mockItem(1), q.Peek())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) assert.Equal(t, mockItem(1), q.Peek()) }]}
{Id:12 FileId:95 StartLine:241 StartColumn:1 EndLine:247 EndColumn:2 Name:TestInsertDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Put(mockItem(1))
	q.Put(mockItem(1))

	assert.Equal(t, 1, q.Len())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) q.Put(mockItem(1)) assert.Equal(t, 1, q.Len()) }]}
{Id:13 FileId:95 StartLine:249 StartColumn:1 EndLine:255 EndColumn:2 Name:TestAllowDuplicates Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(2, true)
	q.Put(mockItem(1))
	q.Put(mockItem(1))

	assert.Equal(t, 2, q.Len())
} PrettyPrintBody:[{ q := NewPriorityQueue(2, true) q.Put(mockItem(1)) q.Put(mockItem(1)) assert.Equal(t, 2, q.Len()) }]}
{Id:1 FileId:37 StartLine:27 StartColumn:1 EndLine:43 EndColumn:2 Name:AddItems Params:[{Name:its Type:...*Item}] Results:[{Name: Type:[]*Item} {Name: Type:error}] Receiver:0xc001308d40 Body:{
	if len(its) == 0 {
		return nil, nil
	}

	keys := make(Keys, 0, len(its))
	for _, item := range its {
		keys = append(keys, &Key{Value: item.Value, Payload: item.Payload})
	}

	overwrittens, err := t.add(keys)
	if err != nil {
		return nil, err
	}

	return overwrittens.toItems(), nil
} PrettyPrintBody:[{ if len(its) == 0 { return nil, nil } keys := make(Keys, 0, len(its)) for _, item := range its { keys = append(keys, &Key{Value: item.Value, Payload: item.Payload}) } overwrittens, err := t.add(keys) if err != nil { return nil, err } return overwrittens.toItems(), nil }]}
{Id:2 FileId:37 StartLine:45 StartColumn:1 EndLine:116 EndColumn:2 Name:add Params:[{Name:keys Type:Keys}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:0xc001246160 Body:{
	if t.Root == nil {
		n := t.createRoot()
		t.Root = n.ID
		t.context.addNode(n)
	}

	nodes, err := t.determinePaths(keys)
	if err != nil {
		return nil, err
	}

	var overwrittens Keys

	var wg sync.WaitGroup
	wg.Add(len(nodes))
	var treeLock sync.Mutex
	localOverwrittens := make([]Keys, len(nodes))
	tree := make(map[string]*path, runtime.NumCPU())
	lerr := terr.New()

	i := 0
	for id, bundles := range nodes {
		go func(i int, id string, bundles []*nodeBundle) {
			defer wg.Done()
			if len(bundles) == 0 {
				return
			}

			n, err := t.contextOrCachedNode(ID(id), true)
			if err != nil {
				lerr.Set(err)
				return
			}

			if !t.context.nodeExists(n.ID) {
				n = n.copy()
				t.context.addNode(n)
			}

			overwrittens, err := insertLastDimension(t, n, bundles)

			if err != nil {
				lerr.Set(err)
				return
			}

			localOverwrittens[i] = overwrittens
			path := bundles[0].path
			treeLock.Lock()
			tree[string(n.ID)] = path
			treeLock.Unlock()
		}(i, id, bundles)
		i++
	}

	wg.Wait()

	if lerr.Get() != nil {
		return nil, lerr.Get()
	}

	t.walkupInsert(tree)

	for _, chunk := range localOverwrittens {
		overwrittens = append(overwrittens, chunk...)
	}

	t.Count += len(keys) - len(overwrittens)

	return overwrittens, nil
} PrettyPrintBody:[{ if t.Root == nil { n := t.createRoot() t.Root = n.ID t.context.addNode(n) } nodes, err := t.determinePaths(keys) if err != nil { return nil, err } var overwrittens Keys var wg sync.WaitGroup wg.Add(len(nodes)) var treeLock sync.Mutex localOverwrittens := make([]Keys, len(nodes)) tree := make(map[string]*path, runtime.NumCPU()) lerr := terr.New() i := 0 for id, bundles := range nodes { go func(i int, id string, bundles []*nodeBundle) { defer wg.Done() if len(bundles) == 0 { return } n, err := t.contextOrCachedNode(ID(id), true) if err != nil { lerr.Set(err) return } if !t.context.nodeExists(n.ID) { n = n.copy() t.context.addNode(n) } overwrittens, err := insertLastDimension(t, n, bundles) if err != nil { lerr.Set(err) return } localOverwrittens[i] = overwrittens path := bundles[0].path treeLock.Lock() tree[string(n.ID)] = path treeLock.Unlock() }(i, id, bundles) i++ } wg.Wait() if lerr.Get() != nil { return nil, lerr.Get() } t.walkupInsert(tree) for _, chunk := range localOverwrittens { overwrittens = append(overwrittens, chunk...) } t.Count += len(keys) - len(overwrittens) return overwrittens, nil }]}
{Id:3 FileId:37 StartLine:118 StartColumn:1 EndLine:162 EndColumn:2 Name:determinePaths Params:[{Name:keys Type:Keys}] Results:[{Name: Type:map[string][]*nodeBundle} {Name: Type:error}] Receiver:0xc0015811c0 Body:{
	chunks := splitKeys(keys, runtime.NumCPU())
	var wg sync.WaitGroup
	wg.Add(len(chunks))
	chunkPaths := make([]map[interface{}]*nodeBundle, len(chunks))
	lerr := terr.New()

	for i := range chunks {
		go func(i int) {
			defer wg.Done()
			keys := chunks[i]
			if len(keys) == 0 {
				return
			}
			mp := make(map[interface{}]*nodeBundle, len(keys))
			for _, key := range keys {
				path, err := t.iterativeFind(
					key.Value, t.Root,
				)

				if err != nil {
					lerr.Set(err)
					return
				}
				mp[key.Value] = &nodeBundle{path: path, k: key}
			}
			chunkPaths[i] = mp
		}(i)
	}

	wg.Wait()

	if lerr.Get() != nil {
		return nil, lerr.Get()
	}

	nodes := make(map[string][]*nodeBundle, 10)
	for _, chunk := range chunkPaths {
		for _, pb := range chunk {
			nodes[string(pb.path.peek().n.ID)] = append(nodes[string(pb.path.pop().n.ID)], pb)
		}
	}

	return nodes, nil
} PrettyPrintBody:[{ chunks := splitKeys(keys, runtime.NumCPU()) var wg sync.WaitGroup wg.Add(len(chunks)) chunkPaths := make([]map[interface{}]*nodeBundle, len(chunks)) lerr := terr.New() for i := range chunks { go func(i int) { defer wg.Done() keys := chunks[i] if len(keys) == 0 { return } mp := make(map[interface{}]*nodeBundle, len(keys)) for _, key := range keys { path, err := t.iterativeFind( key.Value, t.Root, ) if err != nil { lerr.Set(err) return } mp[key.Value] = &nodeBundle{path: path, k: key} } chunkPaths[i] = mp }(i) } wg.Wait() if lerr.Get() != nil { return nil, lerr.Get() } nodes := make(map[string][]*nodeBundle, 10) for _, chunk := range chunkPaths { for _, pb := range chunk { nodes[string(pb.path.peek().n.ID)] = append(nodes[string(pb.path.pop().n.ID)], pb) } } return nodes, nil }]}
{Id:4 FileId:37 StartLine:164 StartColumn:1 EndLine:203 EndColumn:2 Name:insertByMerge Params:[{Name:comparator Type:Comparator} {Name:n Type:*Node} {Name:bundles Type:[]*nodeBundle}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:<nil> Body:{
	positions := make(map[interface{}]int, len(n.ChildValues))
	overwrittens := make(Keys, 0, 10)

	for i, value := range n.ChildValues {
		positions[value] = i
	}

	for _, bundle := range bundles {
		if i, ok := positions[bundle.k.Value]; ok {
			overwrittens = append(overwrittens, n.ChildKeys[i])
			n.ChildKeys[i] = bundle.k
		} else {
			n.ChildValues = append(n.ChildValues, bundle.k.Value)
			n.ChildKeys = append(n.ChildKeys, bundle.k)
		}
	}

	nsw := &nodeSortWrapper{
		values:		n.ChildValues,
		keys:		n.ChildKeys,
		comparator:	comparator,
	}

	sort.Sort(nsw)

	for i := 0; i < len(nsw.values); i++ {
		if nsw.values[i] != nil {
			nsw.values = nsw.values[i:]
			nsw.keys = nsw.keys[i:]
			break
		}

		nsw.keys[i] = nil
	}

	n.ChildValues = nsw.values
	n.ChildKeys = nsw.keys
	return overwrittens, nil
} PrettyPrintBody:[{ positions := make(map[interface{}]int, len(n.ChildValues)) overwrittens := make(Keys, 0, 10) for i, value := range n.ChildValues { positions[value] = i } for _, bundle := range bundles { if i, ok := positions[bundle.k.Value]; ok { overwrittens = append(overwrittens, n.ChildKeys[i]) n.ChildKeys[i] = bundle.k } else { n.ChildValues = append(n.ChildValues, bundle.k.Value) n.ChildKeys = append(n.ChildKeys, bundle.k) } } nsw := &nodeSortWrapper{ values:		n.ChildValues, keys:		n.ChildKeys, comparator:	comparator, } sort.Sort(nsw) for i := 0; i < len(nsw.values); i++ { if nsw.values[i] != nil { nsw.values = nsw.values[i:] nsw.keys = nsw.keys[i:] break } nsw.keys[i] = nil } n.ChildValues = nsw.values n.ChildKeys = nsw.keys return overwrittens, nil }]}
{Id:5 FileId:37 StartLine:205 StartColumn:1 EndLine:219 EndColumn:2 Name:insertLastDimension Params:[{Name:t Type:*Tr} {Name:n Type:*Node} {Name:bundles Type:[]*nodeBundle}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:<nil> Body:{
	if n.IsLeaf && len(bundles) >= n.lenValues()/16 {
		return insertByMerge(t.config.Comparator, n, bundles)
	}

	overwrittens := make(Keys, 0, len(bundles))
	for _, bundle := range bundles {
		overwritten := n.insert(t.config.Comparator, bundle.k)
		if overwritten != nil {
			overwrittens = append(overwrittens, overwritten)
		}
	}

	return overwrittens, nil
} PrettyPrintBody:[{ if n.IsLeaf && len(bundles) >= n.lenValues()/16 { return insertByMerge(t.config.Comparator, n, bundles) } overwrittens := make(Keys, 0, len(bundles)) for _, bundle := range bundles { overwritten := n.insert(t.config.Comparator, bundle.k) if overwritten != nil { overwrittens = append(overwrittens, overwritten) } } return overwrittens, nil }]}
{Id:6 FileId:37 StartLine:221 StartColumn:1 EndLine:230 EndColumn:2 Name:iterativeSplit Params:[{Name:n Type:*Node}] Results:[{Name: Type:Keys}] Receiver:0xc000993b60 Body:{
	keys := make(Keys, 0, 10)
	for n.needsSplit(t.config.NodeWidth) {
		leftValue, leftNode := n.splitAt(t.config.NodeWidth / 2)
		t.context.addNode(leftNode)
		keys = append(keys, &Key{UUID: leftNode.ID, Value: leftValue})
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, 10) for n.needsSplit(t.config.NodeWidth) { leftValue, leftNode := n.splitAt(t.config.NodeWidth / 2) t.context.addNode(leftNode) keys = append(keys, &Key{UUID: leftNode.ID, Value: leftValue}) } return keys }]}
{Id:7 FileId:37 StartLine:235 StartColumn:1 EndLine:319 EndColumn:2 Name:walkupInsert Params:[{Name:nodes Type:map[string]*path}] Results:[{Name: Type:error}] Receiver:0xc000a8b260 Body:{
	mapping := make(map[string]*Node, len(nodes))

	for len(nodes) > 0 {
		splitNodes := make(map[string]Keys)
		newNodes := make(map[string]*path)
		for id, path := range nodes {
			node := t.context.getNode(ID(id))

			parentPath := path.pop()
			if parentPath == nil {
				t.Root = node.ID
				continue
			}

			parent := parentPath.n
			newNode := mapping[string(parent.ID)]
			if newNode == nil {
				if !t.context.nodeExists(parent.ID) {
					cp := parent.copy()
					if string(t.Root) == string(parent.ID) {
						t.Root = cp.ID
					}

					t.context.addNode(cp)
					mapping[string(parent.ID)] = cp
					parent = cp
				} else {
					newNode = t.context.getNode(parent.ID)
					mapping[string(parent.ID)] = newNode
					parent = newNode
				}
			} else {
				parent = newNode
			}

			i := parentPath.i

			parent.replaceKeyAt(&Key{UUID: node.ID}, i)
			splitNodes[string(parent.ID)] = append(splitNodes[string(parent.ID)], t.iterativeSplit(node)...)
			newNodes[string(parent.ID)] = path
		}

		var wg sync.WaitGroup
		wg.Add(len(splitNodes))
		lerr := terr.New()

		for id, keys := range splitNodes {
			go func(id ID, keys Keys) {
				defer wg.Done()
				n, err := t.contextOrCachedNode(id, true)
				if err != nil {
					lerr.Set(err)
					return
				}
				for _, key := range keys {
					n.insert(t.config.Comparator, key)
				}
			}(ID(id), keys)
		}

		wg.Wait()

		if lerr.Get() != nil {
			return lerr.Get()
		}

		nodes = newNodes
	}

	n := t.context.getNode(t.Root)
	for n.needsSplit(t.config.NodeWidth) {
		root := newNode()
		t.Root = root.ID
		t.context.addNode(root)
		root.appendChild(&Key{UUID: n.ID})
		keys := t.iterativeSplit(n)
		for _, key := range keys {
			root.insert(t.config.Comparator, key)
		}
		n = root
	}

	return nil
} PrettyPrintBody:[{ mapping := make(map[string]*Node, len(nodes)) for len(nodes) > 0 { splitNodes := make(map[string]Keys) newNodes := make(map[string]*path) for id, path := range nodes { node := t.context.getNode(ID(id)) parentPath := path.pop() if parentPath == nil { t.Root = node.ID continue } parent := parentPath.n newNode := mapping[string(parent.ID)] if newNode == nil { if !t.context.nodeExists(parent.ID) { cp := parent.copy() if string(t.Root) == string(parent.ID) { t.Root = cp.ID } t.context.addNode(cp) mapping[string(parent.ID)] = cp parent = cp } else { newNode = t.context.getNode(parent.ID) mapping[string(parent.ID)] = newNode parent = newNode } } else { parent = newNode } i := parentPath.i parent.replaceKeyAt(&Key{UUID: node.ID}, i) splitNodes[string(parent.ID)] = append(splitNodes[string(parent.ID)], t.iterativeSplit(node)...) newNodes[string(parent.ID)] = path } var wg sync.WaitGroup wg.Add(len(splitNodes)) lerr := terr.New() for id, keys := range splitNodes { go func(id ID, keys Keys) { defer wg.Done() n, err := t.contextOrCachedNode(id, true) if err != nil { lerr.Set(err) return } for _, key := range keys { n.insert(t.config.Comparator, key) } }(ID(id), keys) } wg.Wait() if lerr.Get() != nil { return lerr.Get() } nodes = newNodes } n := t.context.getNode(t.Root) for n.needsSplit(t.config.NodeWidth) { root := newNode() t.Root = root.ID t.context.addNode(root) root.appendChild(&Key{UUID: n.ID}) keys := t.iterativeSplit(n) for _, key := range keys { root.insert(t.config.Comparator, key) } n = root } return nil }]}
{Id:1 FileId:64 StartLine:26 StartColumn:1 EndLine:33 EndColumn:2 Name:constructMockPayloads Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(i)) } return keys }]}
{Id:2 FileId:64 StartLine:35 StartColumn:1 EndLine:43 EndColumn:2 Name:constructMockKeys Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)

	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(i)) } return keys }]}
{Id:3 FileId:64 StartLine:45 StartColumn:1 EndLine:52 EndColumn:2 Name:constructRandomMockKeys Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(rand.Int()))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(rand.Int())) } return keys }]}
{Id:4 FileId:64 StartLine:54 StartColumn:1 EndLine:72 EndColumn:2 Name:constructMockNodes Params:[{Name:num Type:int}] Results:[{Name: Type:nodes}] Receiver:<nil> Body:{
	nodes := make(nodes, 0, num)
	for i := 0; i < num; i++ {
		keys := make(keys, 0, num)
		for j := 0; j < num; j++ {
			keys = append(keys, newMockKey(j*i+j))
		}

		node := &lnode{
			keys: keys,
		}
		nodes = append(nodes, node)
		if i > 0 {
			nodes[i-1].(*lnode).pointer = node
		}
	}

	return nodes
} PrettyPrintBody:[{ nodes := make(nodes, 0, num) for i := 0; i < num; i++ { keys := make(keys, 0, num) for j := 0; j < num; j++ { keys = append(keys, newMockKey(j*i+j)) } node := &lnode{ keys: keys, } nodes = append(nodes, node) if i > 0 { nodes[i-1].(*lnode).pointer = node } } return nodes }]}
{Id:5 FileId:64 StartLine:74 StartColumn:1 EndLine:89 EndColumn:2 Name:constructMockInternalNode Params:[{Name:nodes Type:nodes}] Results:[{Name: Type:*inode}] Receiver:<nil> Body:{
	if len(nodes) < 2 {
		return nil
	}

	keys := make(keys, 0, len(nodes)-1)
	for i := 1; i < len(nodes); i++ {
		keys = append(keys, nodes[i].(*lnode).keys[0])
	}

	in := &inode{
		keys:	keys,
		nodes:	nodes,
	}
	return in
} PrettyPrintBody:[{ if len(nodes) < 2 { return nil } keys := make(keys, 0, len(nodes)-1) for i := 1; i < len(nodes); i++ { keys = append(keys, nodes[i].(*lnode).keys[0]) } in := &inode{ keys:	keys, nodes:	nodes, } return in }]}
{Id:6 FileId:64 StartLine:91 StartColumn:1 EndLine:102 EndColumn:2 Name:TestLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)
	key := newMockKey(3)

	n.insert(tree, key)

	assert.Len(t, n.keys, 1)
	assert.Nil(t, n.pointer)
	assert.Equal(t, n.keys[0], key)
	assert.Equal(t, 0, n.keys[0].Compare(key))
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) key := newMockKey(3) n.insert(tree, key) assert.Len(t, n.keys, 1) assert.Nil(t, n.pointer) assert.Equal(t, n.keys[0], key) assert.Equal(t, 0, n.keys[0].Compare(key)) }]}
{Id:7 FileId:64 StartLine:104 StartColumn:1 EndLine:113 EndColumn:2 Name:TestDuplicateLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)
	k1 := newMockKey(3)
	k2 := newMockKey(3)

	assert.True(t, n.insert(tree, k1))
	assert.False(t, n.insert(tree, k2))
	assert.False(t, n.insert(tree, k1))
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) k1 := newMockKey(3) k2 := newMockKey(3) assert.True(t, n.insert(tree, k1)) assert.False(t, n.insert(tree, k2)) assert.False(t, n.insert(tree, k1)) }]}
{Id:8 FileId:64 StartLine:115 StartColumn:1 EndLine:131 EndColumn:2 Name:TestMultipleLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)

	k1 := newMockKey(3)
	k2 := newMockKey(4)

	assert.True(t, n.insert(tree, k1))
	n.insert(tree, k2)

	if !assert.Len(t, n.keys, 2) {
		return
	}
	assert.Nil(t, n.pointer)
	assert.Equal(t, k1, n.keys[0])
	assert.Equal(t, k2, n.keys[1])
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) k1 := newMockKey(3) k2 := newMockKey(4) assert.True(t, n.insert(tree, k1)) n.insert(tree, k2) if !assert.Len(t, n.keys, 2) { return } assert.Nil(t, n.pointer) assert.Equal(t, k1, n.keys[0]) assert.Equal(t, k2, n.keys[1]) }]}
{Id:9 FileId:64 StartLine:133 StartColumn:1 EndLine:145 EndColumn:2 Name:TestLeafNodeSplitEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(4)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[2], key)
	assert.Equal(t, left.(*lnode).keys, keys[:2])
	assert.Equal(t, right.(*lnode).keys, keys[2:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(4) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[2], key) assert.Equal(t, left.(*lnode).keys, keys[:2]) assert.Equal(t, right.(*lnode).keys, keys[2:]) assert.Equal(t, left.(*lnode).pointer, right) }]}
{Id:10 FileId:64 StartLine:147 StartColumn:1 EndLine:159 EndColumn:2 Name:TestLeafNodeSplitOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(3)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[1], key)
	assert.Equal(t, left.(*lnode).keys, keys[:1])
	assert.Equal(t, right.(*lnode).keys, keys[1:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(3) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[1], key) assert.Equal(t, left.(*lnode).keys, keys[:1]) assert.Equal(t, right.(*lnode).keys, keys[1:]) assert.Equal(t, left.(*lnode).pointer, right) }]}
{Id:11 FileId:64 StartLine:161 StartColumn:1 EndLine:173 EndColumn:2 Name:TestTwoKeysLeafNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(2)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[1], key)
	assert.Equal(t, left.(*lnode).keys, keys[:1])
	assert.Equal(t, right.(*lnode).keys, keys[1:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(2) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[1], key) assert.Equal(t, left.(*lnode).keys, keys[:1]) assert.Equal(t, right.(*lnode).keys, keys[1:]) assert.Equal(t, left.(*lnode).pointer, right) }]}
{Id:12 FileId:64 StartLine:175 StartColumn:1 EndLine:186 EndColumn:2 Name:TestLessThanTwoKeysSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(1)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Nil(t, key)
	assert.Nil(t, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(1) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Nil(t, key) assert.Nil(t, left) assert.Nil(t, right) }]}
{Id:13 FileId:64 StartLine:188 StartColumn:1 EndLine:198 EndColumn:2 Name:TestInternalNodeSplit2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(4)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Equal(t, nodes[3].(*lnode).keys[0], key)
	assert.Len(t, left.(*inode).keys, 1)
	assert.Len(t, right.(*inode).keys, 1)
	assert.Equal(t, nodes[:2], left.(*inode).nodes)
	assert.Equal(t, nodes[2:], right.(*inode).nodes)
} PrettyPrintBody:[{ nodes := constructMockNodes(4) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Equal(t, nodes[3].(*lnode).keys[0], key) assert.Len(t, left.(*inode).keys, 1) assert.Len(t, right.(*inode).keys, 1) assert.Equal(t, nodes[:2], left.(*inode).nodes) assert.Equal(t, nodes[2:], right.(*inode).nodes) }]}
{Id:14 FileId:64 StartLine:200 StartColumn:1 EndLine:210 EndColumn:2 Name:TestInternalNodeSplit3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(5)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Equal(t, nodes[4].(*lnode).keys[0], key)
	assert.Len(t, left.(*inode).keys, 2)
	assert.Len(t, right.(*inode).keys, 1)
	assert.Equal(t, nodes[:3], left.(*inode).nodes)
	assert.Equal(t, nodes[3:], right.(*inode).nodes)
} PrettyPrintBody:[{ nodes := constructMockNodes(5) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Equal(t, nodes[4].(*lnode).keys[0], key) assert.Len(t, left.(*inode).keys, 2) assert.Len(t, right.(*inode).keys, 1) assert.Equal(t, nodes[:3], left.(*inode).nodes) assert.Equal(t, nodes[3:], right.(*inode).nodes) }]}
{Id:15 FileId:64 StartLine:212 StartColumn:1 EndLine:220 EndColumn:2 Name:TestInternalNodeLessThan3Keys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(2)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Nil(t, key)
	assert.Nil(t, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ nodes := constructMockNodes(2) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Nil(t, key) assert.Nil(t, left) assert.Nil(t, right) }]}
{Id:1 FileId:28 StartLine:25 StartColumn:1 EndLine:31 EndColumn:2 Name:TestGetCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() result, err := ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) }]}
{Id:2 FileId:28 StartLine:33 StartColumn:1 EndLine:46 EndColumn:2 Name:BenchmarkGetCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()

	for i := 0; i < numItems; i++ {
		ba.SetBit(uint64(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.GetBit(s)
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() for i := 0; i < numItems; i++ { ba.SetBit(uint64(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.GetBit(s) } }]}
{Id:3 FileId:28 StartLine:48 StartColumn:1 EndLine:65 EndColumn:2 Name:TestGetSetCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()

	ba.SetBit(5)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.True(t, result)
	result, err = ba.GetBit(7)
	assert.Nil(t, err)
	assert.False(t, result)

	ba.SetBit(s * 2)
	result, _ = ba.GetBit(s * 2)
	assert.True(t, result)
	result, _ = ba.GetBit(s*2 + 1)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) result, err := ba.GetBit(5) assert.Nil(t, err) assert.True(t, result) result, err = ba.GetBit(7) assert.Nil(t, err) assert.False(t, result) ba.SetBit(s * 2) result, _ = ba.GetBit(s * 2) assert.True(t, result) result, _ = ba.GetBit(s*2 + 1) assert.False(t, result) }]}
{Id:4 FileId:28 StartLine:67 StartColumn:1 EndLine:77 EndColumn:2 Name:BenchmarkSetCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for j := 0; j < numItems; j++ {
			ba.SetBit(uint64(j))
		}
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() b.ResetTimer() for i := 0; i < b.N; i++ { for j := 0; j < numItems; j++ { ba.SetBit(uint64(j)) } } }]}
{Id:5 FileId:28 StartLine:79 StartColumn:1 EndLine:97 EndColumn:2 Name:TestClearCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	ba.SetBit(5)
	ba.ClearBit(5)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
	assert.Len(t, ba.blocks, 0)
	assert.Len(t, ba.indices, 0)

	ba.SetBit(s * 2)
	ba.ClearBit(s * 2)

	result, _ = ba.GetBit(s * 2)
	assert.False(t, result)
	assert.Len(t, ba.indices, 0)
	assert.Len(t, ba.blocks, 0)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) ba.ClearBit(5) result, err := ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) assert.Len(t, ba.blocks, 0) assert.Len(t, ba.indices, 0) ba.SetBit(s * 2) ba.ClearBit(s * 2) result, _ = ba.GetBit(s * 2) assert.False(t, result) assert.Len(t, ba.indices, 0) assert.Len(t, ba.blocks, 0) }]}
{Id:6 FileId:28 StartLine:99 StartColumn:1 EndLine:111 EndColumn:2 Name:BenchmarkClearCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()
	for i := 0; i < numItems; i++ {
		ba.SetBit(uint64(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.ClearBit(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() for i := 0; i < numItems; i++ { ba.SetBit(uint64(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.ClearBit(uint64(i)) } }]}
{Id:7 FileId:28 StartLine:113 StartColumn:1 EndLine:131 EndColumn:2 Name:TestClearCompressedBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	ba.SetBit(5)
	ba.SetBit(s * 2)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.True(t, result)
	result, _ = ba.GetBit(s * 2)
	assert.True(t, result)

	ba.Reset()

	result, err = ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
	result, _ = ba.GetBit(s * 2)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) ba.SetBit(s * 2) result, err := ba.GetBit(5) assert.Nil(t, err) assert.True(t, result) result, _ = ba.GetBit(s * 2) assert.True(t, result) ba.Reset() result, err = ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) result, _ = ba.GetBit(s * 2) assert.False(t, result) }]}
{Id:8 FileId:28 StartLine:133 StartColumn:1 EndLine:147 EndColumn:2 Name:TestCompressedEquals Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	assert.True(t, ba.Equals(other))

	ba.SetBit(5)
	assert.False(t, ba.Equals(other))

	other.SetBit(5)
	assert.True(t, ba.Equals(other))

	ba.ClearBit(5)
	assert.False(t, ba.Equals(other))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() assert.True(t, ba.Equals(other)) ba.SetBit(5) assert.False(t, ba.Equals(other)) other.SetBit(5) assert.True(t, ba.Equals(other)) ba.ClearBit(5) assert.False(t, ba.Equals(other)) }]}
{Id:9 FileId:28 StartLine:149 StartColumn:1 EndLine:169 EndColumn:2 Name:TestCompressedIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	assert.True(t, ba.Intersects(other))

	other.SetBit(5)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	ba.SetBit(5)

	assert.True(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	other.SetBit(10)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() assert.True(t, ba.Intersects(other)) other.SetBit(5) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) ba.SetBit(5) assert.True(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) other.SetBit(10) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) }]}
{Id:10 FileId:28 StartLine:171 StartColumn:1 EndLine:194 EndColumn:2 Name:TestLongCompressedIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	ba.SetBit(5)
	other.SetBit(5)

	assert.True(t, ba.Intersects(other))

	other.SetBit(s * 2)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	ba.SetBit(s * 2)

	assert.True(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	other.SetBit(s*2 + 1)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() ba.SetBit(5) other.SetBit(5) assert.True(t, ba.Intersects(other)) other.SetBit(s * 2) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) ba.SetBit(s * 2) assert.True(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) other.SetBit(s*2 + 1) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) }]}
{Id:11 FileId:28 StartLine:196 StartColumn:1 EndLine:212 EndColumn:2 Name:BenchmarkCompressedIntersects Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	ba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Intersects(other)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) ba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i++ { ba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.Intersects(other) } }]}
{Id:12 FileId:28 StartLine:214 StartColumn:1 EndLine:237 EndColumn:2 Name:TestSparseIntersectsBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cba := newSparseBitArray()
	ba := newBitArray(s * 2)

	assert.True(t, cba.Intersects(ba))
	ba.SetBit(5)

	assert.False(t, cba.Intersects(ba))
	cba.SetBit(5)

	assert.True(t, cba.Intersects(ba))
	cba.SetBit(10)

	assert.True(t, cba.Intersects(ba))
	ba.SetBit(s + 1)

	assert.False(t, cba.Intersects(ba))
	cba.SetBit(s + 1)

	assert.True(t, cba.Intersects(ba))
	cba.SetBit(s * 3)

	assert.True(t, cba.Intersects(ba))
} PrettyPrintBody:[{ cba := newSparseBitArray() ba := newBitArray(s * 2) assert.True(t, cba.Intersects(ba)) ba.SetBit(5) assert.False(t, cba.Intersects(ba)) cba.SetBit(5) assert.True(t, cba.Intersects(ba)) cba.SetBit(10) assert.True(t, cba.Intersects(ba)) ba.SetBit(s + 1) assert.False(t, cba.Intersects(ba)) cba.SetBit(s + 1) assert.True(t, cba.Intersects(ba)) cba.SetBit(s * 3) assert.True(t, cba.Intersects(ba)) }]}
{Id:13 FileId:28 StartLine:239 StartColumn:1 EndLine:256 EndColumn:2 Name:TestSparseEqualsBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cba := newSparseBitArray()
	ba := newBitArray(s * 2)

	assert.True(t, cba.Equals(ba))

	ba.SetBit(5)
	assert.False(t, cba.Equals(ba))

	cba.SetBit(5)
	assert.True(t, cba.Equals(ba))

	ba.SetBit(s + 1)
	assert.False(t, cba.Equals(ba))

	cba.SetBit(s + 1)
	assert.True(t, cba.Equals(ba))
} PrettyPrintBody:[{ cba := newSparseBitArray() ba := newBitArray(s * 2) assert.True(t, cba.Equals(ba)) ba.SetBit(5) assert.False(t, cba.Equals(ba)) cba.SetBit(5) assert.True(t, cba.Equals(ba)) ba.SetBit(s + 1) assert.False(t, cba.Equals(ba)) cba.SetBit(s + 1) assert.True(t, cba.Equals(ba)) }]}
{Id:14 FileId:28 StartLine:258 StartColumn:1 EndLine:273 EndColumn:2 Name:BenchmarkCompressedEquals Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	cba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		cba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		cba.Equals(other)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) cba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i++ { cba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { cba.Equals(other) } }]}
{Id:15 FileId:28 StartLine:275 StartColumn:1 EndLine:284 EndColumn:2 Name:TestInsertPreviousBlockInSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()

	sba.SetBit(s * 2)
	sba.SetBit(s - 1)

	result, err := sba.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() sba.SetBit(s * 2) sba.SetBit(s - 1) result, err := sba.GetBit(s - 1) assert.Nil(t, err) assert.True(t, result) }]}
{Id:16 FileId:28 StartLine:286 StartColumn:1 EndLine:296 EndColumn:2 Name:TestSparseBitArrayToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()

	sba.SetBit(s - 1)
	sba.SetBit(s + 1)

	expected := []uint64{s - 1, s + 1}

	results := sba.ToNums()
	assert.Equal(t, expected, results)
} PrettyPrintBody:[{ sba := newSparseBitArray() sba.SetBit(s - 1) sba.SetBit(s + 1) expected := []uint64{s - 1, s + 1} results := sba.ToNums() assert.Equal(t, expected, results) }]}
{Id:17 FileId:28 StartLine:298 StartColumn:1 EndLine:310 EndColumn:2 Name:BenchmarkSparseBitArrayToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	sba := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		sba.SetBit(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sba.ToNums()
	}
} PrettyPrintBody:[{ numItems := uint64(1000) sba := newSparseBitArray() for i := uint64(0); i < numItems; i++ { sba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { sba.ToNums() } }]}
{Id:1 FileId:66 StartLine:10 StartColumn:1 EndLine:22 EndColumn:2 Name:TestEvictionPolicy Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	c := &cache{keyList: list.New()}
	EvictionPolicy(LeastRecentlyUsed)(c)
	accessed, added := c.recordAccess("foo"), c.recordAdd("foo")
	assert.NotNil(t, accessed)
	assert.Nil(t, added)

	c = &cache{keyList: list.New()}
	EvictionPolicy(LeastRecentlyAdded)(c)
	accessed, added = c.recordAccess("foo"), c.recordAdd("foo")
	assert.Nil(t, accessed)
	assert.NotNil(t, added)
} PrettyPrintBody:[{ c := &cache{keyList: list.New()} EvictionPolicy(LeastRecentlyUsed)(c) accessed, added := c.recordAccess("foo"), c.recordAdd("foo") assert.NotNil(t, accessed) assert.Nil(t, added) c = &cache{keyList: list.New()} EvictionPolicy(LeastRecentlyAdded)(c) accessed, added = c.recordAccess("foo"), c.recordAdd("foo") assert.Nil(t, accessed) assert.NotNil(t, added) }]}
{Id:2 FileId:66 StartLine:24 StartColumn:1 EndLine:41 EndColumn:2 Name:TestNew Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	optionApplied := false
	option := func(*cache) {
		optionApplied = true
	}

	c := New(314159, option).(*cache)

	assert.Equal(t, uint64(314159), c.cap)
	assert.Equal(t, uint64(0), c.size)
	assert.NotNil(t, c.items)
	assert.NotNil(t, c.keyList)
	assert.True(t, optionApplied)

	accessed, added := c.recordAccess("foo"), c.recordAdd("foo")
	assert.NotNil(t, accessed)
	assert.Nil(t, added)
} PrettyPrintBody:[{ optionApplied := false option := func(*cache) { optionApplied = true } c := New(314159, option).(*cache) assert.Equal(t, uint64(314159), c.cap) assert.Equal(t, uint64(0), c.size) assert.NotNil(t, c.items) assert.NotNil(t, c.keyList) assert.True(t, optionApplied) accessed, added := c.recordAccess("foo"), c.recordAdd("foo") assert.NotNil(t, accessed) assert.Nil(t, added) }]}
{Id:4 FileId:66 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000f52720 Body:{
	return uint64(ti)
} PrettyPrintBody:[{ return uint64(ti) }]}
{Id:5 FileId:66 StartLine:49 StartColumn:1 EndLine:122 EndColumn:2 Name:TestPutGetRemoveSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := []string{"foo", "bar", "baz"}
	testCases := []struct {
		label		string
		cache		Cache
		useCache	func(c Cache)
		expectedSize	uint64
		expectedItems	[]Item
	}{{
		label:	"Items added, key doesn't exist",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
		},
		expectedSize:	1,
		expectedItems:	[]Item{testItem(1), nil, nil},
	}, {
		label:	"Items added, key exists",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("foo", testItem(10))
		},
		expectedSize:	10,
		expectedItems:	[]Item{testItem(10), nil, nil},
	}, {
		label:	"Items added, LRA eviction",
		cache:	New(2, EvictionPolicy(LeastRecentlyAdded)),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("bar", testItem(1))
			c.Get("foo")
			c.Put("baz", testItem(1))
		},
		expectedSize:	2,
		expectedItems:	[]Item{nil, testItem(1), testItem(1)},
	}, {
		label:	"Items added, LRU eviction",
		cache:	New(2, EvictionPolicy(LeastRecentlyUsed)),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("bar", testItem(1))
			c.Get("foo")
			c.Put("baz", testItem(1))
		},
		expectedSize:	2,
		expectedItems:	[]Item{testItem(1), nil, testItem(1)},
	}, {
		label:	"Items removed, key doesn't exist",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Remove("baz")
		},
		expectedSize:	1,
		expectedItems:	[]Item{testItem(1), nil, nil},
	}, {
		label:	"Items removed, key exists",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Remove("foo")
		},
		expectedSize:	0,
		expectedItems:	[]Item{nil, nil, nil},
	}}

	for _, testCase := range testCases {
		t.Log(testCase.label)
		testCase.useCache(testCase.cache)
		assert.Equal(t, testCase.expectedSize, testCase.cache.Size())
		assert.Equal(t, testCase.expectedItems, testCase.cache.Get(keys...))
	}
} PrettyPrintBody:[{ keys := []string{"foo", "bar", "baz"} testCases := []struct { label		string cache		Cache useCache	func(c Cache) expectedSize	uint64 expectedItems	[]Item }{{ label:	"Items added, key doesn't exist", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) }, expectedSize:	1, expectedItems:	[]Item{testItem(1), nil, nil}, }, { label:	"Items added, key exists", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("foo", testItem(10)) }, expectedSize:	10, expectedItems:	[]Item{testItem(10), nil, nil}, }, { label:	"Items added, LRA eviction", cache:	New(2, EvictionPolicy(LeastRecentlyAdded)), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("bar", testItem(1)) c.Get("foo") c.Put("baz", testItem(1)) }, expectedSize:	2, expectedItems:	[]Item{nil, testItem(1), testItem(1)}, }, { label:	"Items added, LRU eviction", cache:	New(2, EvictionPolicy(LeastRecentlyUsed)), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("bar", testItem(1)) c.Get("foo") c.Put("baz", testItem(1)) }, expectedSize:	2, expectedItems:	[]Item{testItem(1), nil, testItem(1)}, }, { label:	"Items removed, key doesn't exist", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Remove("baz") }, expectedSize:	1, expectedItems:	[]Item{testItem(1), nil, nil}, }, { label:	"Items removed, key exists", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Remove("foo") }, expectedSize:	0, expectedItems:	[]Item{nil, nil, nil}, }} for _, testCase := range testCases { t.Log(testCase.label) testCase.useCache(testCase.cache) assert.Equal(t, testCase.expectedSize, testCase.cache.Size()) assert.Equal(t, testCase.expectedItems, testCase.cache.Get(keys...)) } }]}
{Id:0 FileId:63 StartLine:19 StartColumn:1 EndLine:47 EndColumn:2 Name:split Params:[{Name:tree Type:*btree} {Name:parent Type:node}] Results:[{Name: Type:node}] Receiver:<nil> Body:{
	if !child.needsSplit(tree.nodeSize) {
		return parent
	}

	key, left, right := child.split()
	if parent == nil {
		in := newInternalNode(tree.nodeSize)
		in.keys = append(in.keys, key)
		in.nodes = append(in.nodes, left)
		in.nodes = append(in.nodes, right)
		return in
	}

	p := parent.(*inode)
	i := p.search(key)

	if cr, ok := left.(*lnode); ok {
		if i > 0 {
			p.nodes[i-1].(*lnode).pointer = cr
		}
	}
	p.keys.insertAt(i, key)
	p.nodes[i] = left
	p.nodes.insertAt(i+1, right)

	return parent
} PrettyPrintBody:[{ if !child.needsSplit(tree.nodeSize) { return parent } key, left, right := child.split() if parent == nil { in := newInternalNode(tree.nodeSize) in.keys = append(in.keys, key) in.nodes = append(in.nodes, left) in.nodes = append(in.nodes, right) return in } p := parent.(*inode) i := p.search(key) if cr, ok := left.(*lnode); ok { if i > 0 { p.nodes[i-1].(*lnode).pointer = cr } } p.keys.insertAt(i, key) p.nodes[i] = left p.nodes.insertAt(i+1, right) return parent }]}
{Id:3 FileId:63 StartLine:61 StartColumn:1 EndLine:70 EndColumn:2 Name:insertAt Params:[{Name:i Type:int} {Name:node Type:node}] Results:[] Receiver:0xc001001de0 Body:{
	if i == len(*nodes) {
		*nodes = append(*nodes, node)
		return
	}

	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
} PrettyPrintBody:[{ if i == len(*nodes) { *nodes = append(*nodes, node) return } *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node }]}
{Id:4 FileId:63 StartLine:72 StartColumn:1 EndLine:78 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:nodes} {Name: Type:nodes}] Receiver:0xc001308c00 Body:{
	left := make(nodes, i, cap(ns))
	right := make(nodes, len(ns)-i, cap(ns))
	copy(left, ns[:i])
	copy(right, ns[i:])
	return left, right
} PrettyPrintBody:[{ left := make(nodes, i, cap(ns)) right := make(nodes, len(ns)-i, cap(ns)) copy(left, ns[:i]) copy(right, ns[i:]) return left, right }]}
{Id:6 FileId:63 StartLine:85 StartColumn:1 EndLine:87 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000e7fe80 Body:{
	return node.keys.search(key)
} PrettyPrintBody:[{ return node.keys.search(key) }]}
{Id:7 FileId:63 StartLine:89 StartColumn:1 EndLine:102 EndColumn:2 Name:find Params:[{Name:key Type:Key}] Results:[{Name: Type:*iterator}] Receiver:0xc000c565e0 Body:{
	i := node.search(key)
	if i == len(node.keys) {
		return node.nodes[len(node.nodes)-1].find(key)
	}

	found := node.keys[i]
	switch found.Compare(key) {
	case 0, 1:
		return node.nodes[i+1].find(key)
	default:
		return node.nodes[i].find(key)
	}
} PrettyPrintBody:[{ i := node.search(key) if i == len(node.keys) { return node.nodes[len(node.nodes)-1].find(key) } found := node.keys[i] switch found.Compare(key) { case 0, 1: return node.nodes[i+1].find(key) default: return node.nodes[i].find(key) } }]}
{Id:8 FileId:63 StartLine:104 StartColumn:1 EndLine:129 EndColumn:2 Name:insert Params:[{Name:tree Type:*btree} {Name:key Type:Key}] Results:[{Name: Type:bool}] Receiver:0xc001033700 Body:{
	i := n.search(key)
	var child node
	if i == len(n.keys) {
		child = n.nodes[len(n.nodes)-1]
	} else {
		match := n.keys[i]
		switch match.Compare(key) {
		case 1, 0:
			child = n.nodes[i+1]
		default:
			child = n.nodes[i]
		}
	}

	result := child.insert(tree, key)
	if !result {
		return result
	}

	if child.needsSplit(tree.nodeSize) {
		split(tree, n, child)
	}

	return result
} PrettyPrintBody:[{ i := n.search(key) var child node if i == len(n.keys) { child = n.nodes[len(n.nodes)-1] } else { match := n.keys[i] switch match.Compare(key) { case 1, 0: child = n.nodes[i+1] default: child = n.nodes[i] } } result := child.insert(tree, key) if !result { return result } if child.needsSplit(tree.nodeSize) { split(tree, n, child) } return result }]}
{Id:9 FileId:63 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:needsSplit Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001581220 Body:{
	return uint64(len(n.keys)) >= nodeSize
} PrettyPrintBody:[{ return uint64(len(n.keys)) >= nodeSize }]}
{Id:10 FileId:63 StartLine:135 StartColumn:1 EndLine:155 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:node} {Name: Type:node}] Receiver:0xc0011721c0 Body:{
	if len(n.keys) < 3 {
		return nil, nil, nil
	}

	i := len(n.keys) / 2
	key := n.keys[i]

	ourKeys := make(keys, len(n.keys)-i-1, cap(n.keys))
	otherKeys := make(keys, i, cap(n.keys))
	copy(ourKeys, n.keys[i+1:])
	copy(otherKeys, n.keys[:i])
	left, right := n.nodes.splitAt(i + 1)
	otherNode := &inode{
		keys:	otherKeys,
		nodes:	left,
	}
	n.keys = ourKeys
	n.nodes = right
	return key, otherNode, n
} PrettyPrintBody:[{ if len(n.keys) < 3 { return nil, nil, nil } i := len(n.keys) / 2 key := n.keys[i] ourKeys := make(keys, len(n.keys)-i-1, cap(n.keys)) otherKeys := make(keys, i, cap(n.keys)) copy(ourKeys, n.keys[i+1:]) copy(otherKeys, n.keys[:i]) left, right := n.nodes.splitAt(i + 1) otherNode := &inode{ keys:	otherKeys, nodes:	left, } n.keys = ourKeys n.nodes = right return key, otherNode, n }]}
{Id:11 FileId:63 StartLine:157 StartColumn:1 EndLine:162 EndColumn:2 Name:newInternalNode Params:[{Name:size Type:uint64}] Results:[{Name: Type:*inode}] Receiver:<nil> Body:{
	return &inode{
		keys:	make(keys, 0, size),
		nodes:	make(nodes, 0, size+1),
	}
} PrettyPrintBody:[{ return &inode{ keys:	make(keys, 0, size), nodes:	make(nodes, 0, size+1), } }]}
{Id:13 FileId:63 StartLine:170 StartColumn:1 EndLine:172 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0003e5120 Body:{
	return node.keys.search(key)
} PrettyPrintBody:[{ return node.keys.search(key) }]}
{Id:14 FileId:63 StartLine:174 StartColumn:1 EndLine:194 EndColumn:2 Name:insert Params:[{Name:tree Type:*btree} {Name:key Type:Key}] Results:[{Name: Type:bool}] Receiver:0xc00095a7e0 Body:{
	i := keySearch(lnode.keys, key)
	var inserted bool
	if i == len(lnode.keys) {
		lnode.keys = append(lnode.keys, key)
		inserted = true
	} else {
		if lnode.keys[i].Compare(key) == 0 {
			lnode.keys[i] = key
		} else {
			lnode.keys.insertAt(i, key)
			inserted = true
		}
	}

	if !inserted {
		return false
	}

	return true
} PrettyPrintBody:[{ i := keySearch(lnode.keys, key) var inserted bool if i == len(lnode.keys) { lnode.keys = append(lnode.keys, key) inserted = true } else { if lnode.keys[i].Compare(key) == 0 { lnode.keys[i] = key } else { lnode.keys.insertAt(i, key) inserted = true } } if !inserted { return false } return true }]}
{Id:15 FileId:63 StartLine:196 StartColumn:1 EndLine:214 EndColumn:2 Name:find Params:[{Name:key Type:Key}] Results:[{Name: Type:*iterator}] Receiver:0xc0001e62e0 Body:{
	i := node.search(key)
	if i == len(node.keys) {
		if node.pointer == nil {
			return nilIterator()
		}

		return &iterator{
			node:	node.pointer,
			index:	-1,
		}
	}

	iter := &iterator{
		node:	node,
		index:	i - 1,
	}
	return iter
} PrettyPrintBody:[{ i := node.search(key) if i == len(node.keys) { if node.pointer == nil { return nilIterator() } return &iterator{ node:	node.pointer, index:	-1, } } iter := &iterator{ node:	node, index:	i - 1, } return iter }]}
{Id:16 FileId:63 StartLine:216 StartColumn:1 EndLine:237 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:node} {Name: Type:node}] Receiver:0xc000a8a980 Body:{
	if len(node.keys) < 2 {
		return nil, nil, nil
	}
	i := len(node.keys) / 2
	key := node.keys[i]
	otherKeys := make(keys, i, cap(node.keys))
	ourKeys := make(keys, len(node.keys)-i, cap(node.keys))

	copy(otherKeys, node.keys[:i])
	copy(ourKeys, node.keys[i:])

	node.keys = ourKeys
	otherNode := &lnode{
		keys:		otherKeys,
		pointer:	node,
	}
	return key, otherNode, node
} PrettyPrintBody:[{ if len(node.keys) < 2 { return nil, nil, nil } i := len(node.keys) / 2 key := node.keys[i] otherKeys := make(keys, i, cap(node.keys)) ourKeys := make(keys, len(node.keys)-i, cap(node.keys)) copy(otherKeys, node.keys[:i]) copy(ourKeys, node.keys[i:]) node.keys = ourKeys otherNode := &lnode{ keys:		otherKeys, pointer:	node, } return key, otherNode, node }]}
{Id:17 FileId:63 StartLine:239 StartColumn:1 EndLine:241 EndColumn:2 Name:needsSplit Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000a8bae0 Body:{
	return uint64(len(lnode.keys)) >= nodeSize
} PrettyPrintBody:[{ return uint64(len(lnode.keys)) >= nodeSize }]}
{Id:18 FileId:63 StartLine:243 StartColumn:1 EndLine:247 EndColumn:2 Name:newLeafNode Params:[{Name:size Type:uint64}] Results:[{Name: Type:*lnode}] Receiver:<nil> Body:{
	return &lnode{
		keys: make(keys, 0, size),
	}
} PrettyPrintBody:[{ return &lnode{ keys: make(keys, 0, size), } }]}
{Id:20 FileId:63 StartLine:251 StartColumn:1 EndLine:253 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000992240 Body:{
	return keySearch(keys, key)
} PrettyPrintBody:[{ return keySearch(keys, key) }]}
{Id:21 FileId:63 StartLine:255 StartColumn:1 EndLine:264 EndColumn:2 Name:insertAt Params:[{Name:i Type:int} {Name:key Type:Key}] Results:[] Receiver:0xc0001e69a0 Body:{
	if i == len(*keys) {
		*keys = append(*keys, key)
		return
	}

	*keys = append(*keys, nil)
	copy((*keys)[i+1:], (*keys)[i:])
	(*keys)[i] = key
} PrettyPrintBody:[{ if i == len(*keys) { *keys = append(*keys, key) return } *keys = append(*keys, nil) copy((*keys)[i+1:], (*keys)[i:]) (*keys)[i] = key }]}
{Id:22 FileId:63 StartLine:266 StartColumn:1 EndLine:270 EndColumn:2 Name:reverse Params:[] Results:[] Receiver:0xc0009923c0 Body:{
	for i := 0; i < len(keys)/2; i++ {
		keys[i], keys[len(keys)-i-1] = keys[len(keys)-i-1], keys[i]
	}
} PrettyPrintBody:[{ for i := 0; i < len(keys)/2; i++ { keys[i], keys[len(keys)-i-1] = keys[len(keys)-i-1], keys[i] } }]}
{Id:1 FileId:24 StartLine:25 StartColumn:1 EndLine:64 EndColumn:2 Name:TestNandSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(3)
	sba.SetBit(280)
	other.SetBit(9)
	other.SetBit(100)
	sba.SetBit(1000)
	other.SetBit(1001)

	sba.SetBit(1)
	other.SetBit(1)
	sba.SetBit(2680)
	other.SetBit(2680)
	sba.SetBit(30)
	other.SetBit(30)

	ba := nandSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 30, false)
	checkBit(t, ba, 2680, false)

	checkBit(t, ba, 3, true)
	checkBit(t, ba, 280, true)
	checkBit(t, ba, 1000, true)

	checkBit(t, ba, 9, false)
	checkBit(t, ba, 100, false)
	checkBit(t, ba, 2, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{3, 280, 1000}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(3) sba.SetBit(280) other.SetBit(9) other.SetBit(100) sba.SetBit(1000) other.SetBit(1001) sba.SetBit(1) other.SetBit(1) sba.SetBit(2680) other.SetBit(2680) sba.SetBit(30) other.SetBit(30) ba := nandSparseWithSparseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 30, false) checkBit(t, ba, 2680, false) checkBit(t, ba, 3, true) checkBit(t, ba, 280, true) checkBit(t, ba, 1000, true) checkBit(t, ba, 9, false) checkBit(t, ba, 100, false) checkBit(t, ba, 2, false) nums := ba.ToNums() assert.Equal(t, []uint64{3, 280, 1000}, nums) }]}
{Id:2 FileId:24 StartLine:66 StartColumn:1 EndLine:94 EndColumn:2 Name:TestNandSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(300)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := nandSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)
	checkBit(t, ba, 300, false)

	checkBit(t, ba, 155, true)

	checkBit(t, ba, 156, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(300) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 300, false) checkBit(t, ba, 155, true) checkBit(t, ba, 156, false) nums := ba.ToNums() assert.Equal(t, []uint64{155}, nums) }]}
{Id:3 FileId:24 StartLine:96 StartColumn:1 EndLine:124 EndColumn:2 Name:TestNandDenseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newBitArray(300)
	other := newSparseBitArray()

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := nandDenseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)
	checkBit(t, ba, 300, false)

	checkBit(t, ba, 155, true)

	checkBit(t, ba, 156, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155}, nums)
} PrettyPrintBody:[{ sba := newBitArray(300) other := newSparseBitArray() other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := nandDenseWithSparseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 300, false) checkBit(t, ba, 155, true) checkBit(t, ba, 156, false) nums := ba.ToNums() assert.Equal(t, []uint64{155}, nums) }]}
{Id:4 FileId:24 StartLine:126 StartColumn:1 EndLine:158 EndColumn:2 Name:TestNandSparseWithSmallerDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(512)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	sba.SetBit(500)

	other.SetBit(128)
	sba.SetBit(1500)
	sba.SetBit(1200)

	ba := nandSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)

	checkBit(t, ba, 155, true)
	checkBit(t, ba, 500, true)
	checkBit(t, ba, 1200, true)
	checkBit(t, ba, 1500, true)

	checkBit(t, ba, 128, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155, 500, 1200, 1500}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(512) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) sba.SetBit(500) other.SetBit(128) sba.SetBit(1500) sba.SetBit(1200) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 155, true) checkBit(t, ba, 500, true) checkBit(t, ba, 1200, true) checkBit(t, ba, 1500, true) checkBit(t, ba, 128, false) nums := ba.ToNums() assert.Equal(t, []uint64{155, 500, 1200, 1500}, nums) }]}
{Id:5 FileId:24 StartLine:160 StartColumn:1 EndLine:194 EndColumn:2 Name:TestNandDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	dba.SetBit(1)
	other.SetBit(18)
	dba.SetBit(222)
	other.SetBit(222)
	other.SetBit(1501)

	ba := nandDenseWithDenseBitArray(dba, other)

	checkBit(t, ba, 222, false)

	checkBit(t, ba, 1, true)

	checkBit(t, ba, 18, false)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 3, false)

	_, err := ba.GetBit(1500)
	assert.Equal(t, OutOfRangeError(1500), err)
	_, err = ba.GetBit(1501)
	assert.Equal(t, OutOfRangeError(1501), err)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{1}, nums)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) dba.SetBit(1) other.SetBit(18) dba.SetBit(222) other.SetBit(222) other.SetBit(1501) ba := nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 222, false) checkBit(t, ba, 1, true) checkBit(t, ba, 18, false) checkBit(t, ba, 0, false) checkBit(t, ba, 3, false) _, err := ba.GetBit(1500) assert.Equal(t, OutOfRangeError(1500), err) _, err = ba.GetBit(1501) assert.Equal(t, OutOfRangeError(1501), err) nums := ba.ToNums() assert.Equal(t, []uint64{1}, nums) }]}
{Id:6 FileId:24 StartLine:196 StartColumn:1 EndLine:207 EndColumn:2 Name:TestNandSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	ba := nandSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 5, true)
	checkBit(t, ba, 100, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) ba := nandSparseWithSparseBitArray(sba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 5, true) checkBit(t, ba, 100, false) }]}
{Id:7 FileId:24 StartLine:209 StartColumn:1 EndLine:222 EndColumn:2 Name:TestNandSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	ba := nandSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, true)

	sba.Reset()
	other.SetBit(5)

	ba = nandSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, true) sba.Reset() other.SetBit(5) ba = nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) }]}
{Id:8 FileId:24 StartLine:224 StartColumn:1 EndLine:236 EndColumn:2 Name:TestNandDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	ba := nandDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, true)

	dba.Reset()
	other.SetBit(5)
	ba = nandDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) ba := nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, true) dba.Reset() other.SetBit(5) ba = nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) }]}
{Id:9 FileId:24 StartLine:238 StartColumn:1 EndLine:256 EndColumn:2 Name:BenchmarkNandSparseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i += s {
		if i%200 == 0 {
			sba.SetBit(i)
		} else if i%300 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandSparseWithSparseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i += s { if i%200 == 0 { sba.SetBit(i) } else if i%300 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandSparseWithSparseBitArray(sba, other) } }]}
{Id:10 FileId:24 StartLine:258 StartColumn:1 EndLine:276 EndColumn:2 Name:BenchmarkNandSparseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newBitArray(numItems)

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			sba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandSparseWithDenseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newBitArray(numItems) for i := uint64(0); i < numItems; i += s { if i%2 == 0 { sba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandSparseWithDenseBitArray(sba, other) } }]}
{Id:11 FileId:24 StartLine:278 StartColumn:1 EndLine:296 EndColumn:2 Name:BenchmarkNandDenseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	ba := newBitArray(numItems)
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			ba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandDenseWithSparseBitArray(ba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) ba := newBitArray(numItems) other := newSparseBitArray() for i := uint64(0); i < numItems; i += s { if i%2 == 0 { ba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandDenseWithSparseBitArray(ba, other) } }]}
{Id:12 FileId:24 StartLine:298 StartColumn:1 EndLine:316 EndColumn:2 Name:BenchmarkNandDenseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	dba := newBitArray(numItems)
	other := newBitArray(numItems)

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			dba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandDenseWithDenseBitArray(dba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) dba := newBitArray(numItems) other := newBitArray(numItems) for i := uint64(0); i < numItems; i += s { if i%2 == 0 { dba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandDenseWithDenseBitArray(dba, other) } }]}
{Id:1 FileId:82 StartLine:11 StartColumn:1 EndLine:21 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:[]uint64}] Receiver:<nil> Body:{
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, num)
	for i := 0; i < num; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	return keys
} PrettyPrintBody:[{ r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, num) for i := 0; i < num; i++ { key := uint64(r.Int63()) keys = append(keys, key) } return keys }]}
{Id:2 FileId:82 StartLine:23 StartColumn:1 EndLine:32 EndColumn:2 Name:TestRoundUp Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	result := roundUp(21)
	assert.Equal(t, uint64(32), result)

	result = roundUp(uint64(1<<31) - 234)
	assert.Equal(t, uint64(1<<31), result)

	result = roundUp(uint64(1<<63) - 324)
	assert.Equal(t, uint64(1<<63), result)
} PrettyPrintBody:[{ result := roundUp(21) assert.Equal(t, uint64(32), result) result = roundUp(uint64(1<<31) - 234) assert.Equal(t, uint64(1<<31), result) result = roundUp(uint64(1<<63) - 324) assert.Equal(t, uint64(1<<63), result) }]}
{Id:3 FileId:82 StartLine:34 StartColumn:1 EndLine:44 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)

	assert.True(t, hm.Exists(5))
	value, ok := hm.Get(5)
	assert.Equal(t, uint64(5), value)
	assert.True(t, ok)
	assert.Equal(t, uint64(16), hm.Cap())
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) assert.True(t, hm.Exists(5)) value, ok := hm.Get(5) assert.Equal(t, uint64(5), value) assert.True(t, ok) assert.Equal(t, uint64(16), hm.Cap()) }]}
{Id:4 FileId:82 StartLine:46 StartColumn:1 EndLine:56 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(5, 10)

	assert.True(t, hm.Exists(5))
	value, ok := hm.Get(5)
	assert.Equal(t, uint64(10), value)
	assert.True(t, ok)
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(5, 10) assert.True(t, hm.Exists(5)) value, ok := hm.Get(5) assert.Equal(t, uint64(10), value) assert.True(t, ok) }]}
{Id:5 FileId:82 StartLine:58 StartColumn:1 EndLine:64 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	value, ok := hm.Get(5)
	assert.False(t, ok)
	assert.Equal(t, uint64(0), value)
} PrettyPrintBody:[{ hm := New(10) value, ok := hm.Get(5) assert.False(t, ok) assert.Equal(t, uint64(0), value) }]}
{Id:6 FileId:82 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:TestMultipleInserts Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(6, 6)

	assert.True(t, hm.Exists(6))
	value, ok := hm.Get(6)
	assert.True(t, ok)
	assert.Equal(t, uint64(6), value)
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(6, 6) assert.True(t, hm.Exists(6)) value, ok := hm.Get(6) assert.True(t, ok) assert.Equal(t, uint64(6), value) }]}
{Id:7 FileId:82 StartLine:78 StartColumn:1 EndLine:91 EndColumn:2 Name:TestRebuild Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100)

	hm := New(10)

	for i := uint64(0); i < numItems; i++ {
		hm.Set(i, i)
	}

	for i := uint64(0); i < numItems; i++ {
		value, _ := hm.Get(i)
		assert.Equal(t, i, value)
	}
} PrettyPrintBody:[{ numItems := uint64(100) hm := New(10) for i := uint64(0); i < numItems; i++ { hm.Set(i, i) } for i := uint64(0); i < numItems; i++ { value, _ := hm.Get(i) assert.Equal(t, i, value) } }]}
{Id:8 FileId:82 StartLine:93 StartColumn:1 EndLine:107 EndColumn:2 Name:TestDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(6, 6)

	hm.Delete(5)

	assert.Equal(t, uint64(1), hm.Len())
	assert.False(t, hm.Exists(5))

	hm.Delete(6)
	assert.Equal(t, uint64(0), hm.Len())
	assert.False(t, hm.Exists(6))
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(6, 6) hm.Delete(5) assert.Equal(t, uint64(1), hm.Len()) assert.False(t, hm.Exists(5)) hm.Delete(6) assert.Equal(t, uint64(0), hm.Len()) assert.False(t, hm.Exists(6)) }]}
{Id:9 FileId:82 StartLine:109 StartColumn:1 EndLine:122 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100)

	hm := New(10)

	for i := uint64(0); i < numItems; i++ {
		hm.Set(i, i)
	}

	for i := uint64(0); i < numItems; i++ {
		hm.Delete(i)
		assert.False(t, hm.Exists(i))
	}
} PrettyPrintBody:[{ numItems := uint64(100) hm := New(10) for i := uint64(0); i < numItems; i++ { hm.Set(i, i) } for i := uint64(0); i < numItems; i++ { hm.Delete(i) assert.False(t, hm.Exists(i)) } }]}
{Id:10 FileId:82 StartLine:124 StartColumn:1 EndLine:139 EndColumn:2 Name:TestDeleteCollision Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{

	if hash(1)%32 != 12 || hash(27)%32 != 12 || hash(42)%32 != 12 {
		t.Error("test values don't hash to the same value")
	}

	m := New(32)
	m.Set(1, 1)
	m.Set(27, 27)
	m.Set(42, 42)

	m.Delete(27)
	value, ok := m.Get(42)
	assert.True(t, ok)
	assert.Equal(t, uint64(42), value)
} PrettyPrintBody:[{ if hash(1)%32 != 12 || hash(27)%32 != 12 || hash(42)%32 != 12 { t.Error("test values don't hash to the same value") } m := New(32) m.Set(1, 1) m.Set(27, 27) m.Set(42, 42) m.Delete(27) value, ok := m.Get(42) assert.True(t, ok) assert.Equal(t, uint64(42), value) }]}
{Id:11 FileId:82 StartLine:141 StartColumn:1 EndLine:154 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := New(numItems * 2)
		for _, k := range keys {
			hm.Set(k, k)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) b.ResetTimer() for i := 0; i < b.N; i++ { hm := New(numItems * 2) for _, k := range keys { hm.Set(k, k) } } }]}
{Id:12 FileId:82 StartLine:156 StartColumn:1 EndLine:169 EndColumn:2 Name:BenchmarkGoMapInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, numItems*2)
		for _, k := range keys {
			hm[k] = k
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) b.ResetTimer() for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, numItems*2) for _, k := range keys { hm[k] = k } } }]}
{Id:13 FileId:82 StartLine:171 StartColumn:1 EndLine:187 EndColumn:2 Name:BenchmarkExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))
	hm := New(numItems * 2)
	for _, key := range keys {
		hm.Set(key, key)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hm.Exists(key)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) hm := New(numItems * 2) for _, key := range keys { hm.Set(key, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hm.Exists(key) } } }]}
{Id:14 FileId:82 StartLine:189 StartColumn:1 EndLine:210 EndColumn:2 Name:BenchmarkGoMapExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))
	hm := make(map[uint64]uint64, numItems*2)
	for _, key := range keys {
		hm[key] = key
	}

	b.ResetTimer()

	var ok bool
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			_, ok = hm[key]
		}
	}

	b.StopTimer()
	if ok {
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) hm := make(map[uint64]uint64, numItems*2) for _, key := range keys { hm[key] = key } b.ResetTimer() var ok bool for i := 0; i < b.N; i++ { for _, key := range keys { _, ok = hm[key] } } b.StopTimer() if ok { } }]}
{Id:15 FileId:82 StartLine:212 StartColumn:1 EndLine:232 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]*FastIntegerHashMap, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := New(numItems * 2)
		for j := uint64(0); j < numItems; j++ {
			hm.Set(j, j)
		}
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm.Delete(j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]*FastIntegerHashMap, 0, b.N) for i := 0; i < b.N; i++ { hm := New(numItems * 2) for j := uint64(0); j < numItems; j++ { hm.Set(j, j) } hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm.Delete(j) } } }]}
{Id:16 FileId:82 StartLine:234 StartColumn:1 EndLine:254 EndColumn:2 Name:BenchmarkGoDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]map[uint64]uint64, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, numItems*2)
		for j := uint64(0); j < numItems; j++ {
			hm[j] = j
		}
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			delete(hm, j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]map[uint64]uint64, 0, b.N) for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, numItems*2) for j := uint64(0); j < numItems; j++ { hm[j] = j } hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { delete(hm, j) } } }]}
{Id:17 FileId:82 StartLine:256 StartColumn:1 EndLine:273 EndColumn:2 Name:BenchmarkInsertWithExpand Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]*FastIntegerHashMap, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := New(10)
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm.Set(j, j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]*FastIntegerHashMap, 0, b.N) for i := 0; i < b.N; i++ { hm := New(10) hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm.Set(j, j) } } }]}
{Id:18 FileId:82 StartLine:275 StartColumn:1 EndLine:292 EndColumn:2 Name:BenchmarkGoInsertWithExpand Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]map[uint64]uint64, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, 10)
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm[j] = j
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]map[uint64]uint64, 0, b.N) for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, 10) hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm[j] = j } } }]}
{Id:1 FileId:55 StartLine:26 StartColumn:1 EndLine:34 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:key Type:common.Comparator}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		n = parent.searchNode(key)
		parent = n
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { n = parent.searchNode(key) parent = n } return parent }]}
{Id:3 FileId:55 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:push Params:[{Name:n Type:*node}] Results:[] Receiver:0xc001032f60 Body:{
	ns.list = append(ns.list, n)
} PrettyPrintBody:[{ ns.list = append(ns.list, n) }]}
{Id:4 FileId:55 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*nodes} {Name: Type:*nodes}] Receiver:0xc001408a00 Body:{
	i++
	right := make([]*node, uint64(len(ns.list))-i, capacity)
	copy(right, ns.list[i:])
	for j := i; j < uint64(len(ns.list)); j++ {
		ns.list[j] = nil
	}
	ns.list = ns.list[:i]
	return ns, &nodes{list: right}
} PrettyPrintBody:[{ i++ right := make([]*node, uint64(len(ns.list))-i, capacity) copy(right, ns.list[i:]) for j := i; j < uint64(len(ns.list)); j++ { ns.list[j] = nil } ns.list = ns.list[:i] return ns, &nodes{list: right} }]}
{Id:5 FileId:55 StartLine:55 StartColumn:1 EndLine:61 EndColumn:2 Name:byPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0010bd840 Body:{
	if pos >= uint64(len(ns.list)) {
		return nil
	}

	return ns.list[pos]
} PrettyPrintBody:[{ if pos >= uint64(len(ns.list)) { return nil } return ns.list[pos] }]}
{Id:6 FileId:55 StartLine:63 StartColumn:1 EndLine:67 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:n Type:*node}] Results:[] Receiver:0xc001309320 Body:{
	ns.list = append(ns.list, nil)
	copy(ns.list[i+1:], ns.list[i:])
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list = append(ns.list, nil) copy(ns.list[i+1:], ns.list[i:]) ns.list[i] = n }]}
{Id:7 FileId:55 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:replaceAt Params:[{Name:i Type:uint64} {Name:n Type:*node}] Results:[] Receiver:0xc001580ce0 Body:{
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list[i] = n }]}
{Id:8 FileId:55 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409980 Body:{
	return uint64(len(ns.list))
} PrettyPrintBody:[{ return uint64(len(ns.list)) }]}
{Id:9 FileId:55 StartLine:77 StartColumn:1 EndLine:81 EndColumn:2 Name:newNodes Params:[{Name:size Type:uint64}] Results:[{Name: Type:*nodes}] Receiver:<nil> Body:{
	return &nodes{
		list: make([]*node, 0, size),
	}
} PrettyPrintBody:[{ return &nodes{ list: make([]*node, 0, size), } }]}
{Id:11 FileId:55 StartLine:87 StartColumn:1 EndLine:96 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*keys} {Name: Type:*keys}] Receiver:0xc001241b80 Body:{
	i++
	right := make(common.Comparators, uint64(len(ks.list))-i, capacity)
	copy(right, ks.list[i:])
	for j := i; j < uint64(len(ks.list)); j++ {
		ks.list[j] = nil
	}
	ks.list = ks.list[:i]
	return ks, &keys{list: right}
} PrettyPrintBody:[{ i++ right := make(common.Comparators, uint64(len(ks.list))-i, capacity) copy(right, ks.list[i:]) for j := i; j < uint64(len(ks.list)); j++ { ks.list[j] = nil } ks.list = ks.list[:i] return ks, &keys{list: right} }]}
{Id:12 FileId:55 StartLine:98 StartColumn:1 EndLine:100 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000a8a440 Body:{
	return uint64(len(ks.list))
} PrettyPrintBody:[{ return uint64(len(ks.list)) }]}
{Id:13 FileId:55 StartLine:102 StartColumn:1 EndLine:107 EndColumn:2 Name:byPosition Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator}] Receiver:0xc001033b80 Body:{
	if i >= uint64(len(ks.list)) {
		return nil
	}
	return ks.list[i]
} PrettyPrintBody:[{ if i >= uint64(len(ks.list)) { return nil } return ks.list[i] }]}
{Id:14 FileId:55 StartLine:109 StartColumn:1 EndLine:124 EndColumn:2 Name:delete Params:[{Name:k Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc001602760 Body:{
	i := ks.search(k)
	if i >= uint64(len(ks.list)) {
		return nil
	}

	if ks.list[i].Compare(k) != 0 {
		return nil
	}
	old := ks.list[i]

	copy(ks.list[i:], ks.list[i+1:])
	ks.list[len(ks.list)-1] = nil
	ks.list = ks.list[:len(ks.list)-1]
	return old
} PrettyPrintBody:[{ i := ks.search(k) if i >= uint64(len(ks.list)) { return nil } if ks.list[i].Compare(k) != 0 { return nil } old := ks.list[i] copy(ks.list[i:], ks.list[i+1:]) ks.list[len(ks.list)-1] = nil ks.list = ks.list[:len(ks.list)-1] return old }]}
{Id:15 FileId:55 StartLine:126 StartColumn:1 EndLine:132 EndColumn:2 Name:search Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:uint64}] Receiver:0xc001581520 Body:{
	i := sort.Search(len(ks.list), func(i int) bool {
		return ks.list[i].Compare(key) > -1
	})

	return uint64(i)
} PrettyPrintBody:[{ i := sort.Search(len(ks.list), func(i int) bool { return ks.list[i].Compare(key) > -1 }) return uint64(i) }]}
{Id:16 FileId:55 StartLine:134 StartColumn:1 EndLine:150 EndColumn:2 Name:insert Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc00095a680 Body:{
	i := ks.search(key)
	if i == uint64(len(ks.list)) {
		ks.list = append(ks.list, key)
		return nil, i
	}

	var old common.Comparator
	if ks.list[i].Compare(key) == 0 {
		old = ks.list[i]
		ks.list[i] = key
	} else {
		ks.insertAt(i, key)
	}

	return old, i
} PrettyPrintBody:[{ i := ks.search(key) if i == uint64(len(ks.list)) { ks.list = append(ks.list, key) return nil, i } var old common.Comparator if ks.list[i].Compare(key) == 0 { old = ks.list[i] ks.list[i] = key } else { ks.insertAt(i, key) } return old, i }]}
{Id:17 FileId:55 StartLine:152 StartColumn:1 EndLine:154 EndColumn:2 Name:last Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc000a8a820 Body:{
	return ks.list[len(ks.list)-1]
} PrettyPrintBody:[{ return ks.list[len(ks.list)-1] }]}
{Id:18 FileId:55 StartLine:156 StartColumn:1 EndLine:160 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:k Type:common.Comparator}] Results:[] Receiver:0xc000a8aae0 Body:{
	ks.list = append(ks.list, nil)
	copy(ks.list[i+1:], ks.list[i:])
	ks.list[i] = k
} PrettyPrintBody:[{ ks.list = append(ks.list, nil) copy(ks.list[i+1:], ks.list[i:]) ks.list[i] = k }]}
{Id:19 FileId:55 StartLine:162 StartColumn:1 EndLine:172 EndColumn:2 Name:withPosition Params:[{Name:k Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc000a8b180 Body:{
	i := ks.search(k)
	if i == uint64(len(ks.list)) {
		return nil, i
	}
	if ks.list[i].Compare(k) == 0 {
		return ks.list[i], i
	}

	return nil, i
} PrettyPrintBody:[{ i := ks.search(k) if i == uint64(len(ks.list)) { return nil, i } if ks.list[i].Compare(k) == 0 { return ks.list[i], i } return nil, i }]}
{Id:20 FileId:55 StartLine:174 StartColumn:1 EndLine:178 EndColumn:2 Name:newKeys Params:[{Name:size Type:uint64}] Results:[{Name: Type:*keys}] Receiver:<nil> Body:{
	return &keys{
		list: make(common.Comparators, 0, size),
	}
} PrettyPrintBody:[{ return &keys{ list: make(common.Comparators, 0, size), } }]}
{Id:22 FileId:55 StartLine:187 StartColumn:1 EndLine:189 EndColumn:2 Name:needsSplit Params:[{Name:ary Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc0000ed7e0 Body:{
	return n.keys.len() >= ary
} PrettyPrintBody:[{ return n.keys.len() >= ary }]}
{Id:23 FileId:55 StartLine:191 StartColumn:1 EndLine:202 EndColumn:2 Name:splitLeaf Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b120 Body:{
	key := n.keys.byPosition(i)
	_, rightKeys := n.keys.splitAt(i, capacity)
	nn := &node{
		keys:	rightKeys,
		nodes:	newNodes(uint64(cap(n.nodes.list))),
		isLeaf:	true,
		right:	n.right,
	}
	n.right = nn
	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) _, rightKeys := n.keys.splitAt(i, capacity) nn := &node{ keys:	rightKeys, nodes:	newNodes(uint64(cap(n.nodes.list))), isLeaf:	true, right:	n.right, } n.right = nn return key, n, nn }]}
{Id:24 FileId:55 StartLine:204 StartColumn:1 EndLine:217 EndColumn:2 Name:splitInternal Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc0009921c0 Body:{
	key := n.keys.byPosition(i)
	n.keys.delete(key)

	_, rightKeys := n.keys.splitAt(i-1, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)

	nn := newNode(false, rightKeys, rightNodes)
	for _, n := range rightNodes.list {
		n.parent = nn
	}

	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) n.keys.delete(key) _, rightKeys := n.keys.splitAt(i-1, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := newNode(false, rightKeys, rightNodes) for _, n := range rightNodes.list { n.parent = nn } return key, n, nn }]}
{Id:25 FileId:55 StartLine:219 StartColumn:1 EndLine:225 EndColumn:2 Name:split Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b4c0 Body:{
	if n.isLeaf {
		return n.splitLeaf(i, capacity)
	}

	return n.splitInternal(i, capacity)
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf(i, capacity) } return n.splitInternal(i, capacity) }]}
{Id:26 FileId:55 StartLine:227 StartColumn:1 EndLine:229 EndColumn:2 Name:search Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:uint64}] Receiver:0xc00019e800 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]}
{Id:27 FileId:55 StartLine:231 StartColumn:1 EndLine:235 EndColumn:2 Name:searchNode Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:*node}] Receiver:0xc001603960 Body:{
	i := n.search(key)

	return n.nodes.byPosition(uint64(i))
} PrettyPrintBody:[{ i := n.search(key) return n.nodes.byPosition(uint64(i)) }]}
{Id:28 FileId:55 StartLine:237 StartColumn:1 EndLine:239 EndColumn:2 Name:key Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc0009925c0 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]}
{Id:29 FileId:55 StartLine:241 StartColumn:1 EndLine:256 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc000992600 Body:{
	output.Printf(`NODE: %+v, %p`, n, n)
	for _, k := range n.keys.list {
		output.Printf(`KEY: %+v`, k)
	}
	if !n.isLeaf {
		for _, n := range n.nodes.list {
			if n == nil {
				output.Println(`NIL NODE`)
				continue
			}

			n.print(output)
		}
	}
} PrettyPrintBody:[{ output.Printf(`NODE: %+v, %p`, n, n) for _, k := range n.keys.list { output.Printf(`KEY: %+v`, k) } if !n.isLeaf { for _, n := range n.nodes.list { if n == nil { output.Println(`NIL NODE`) continue } n.print(output) } } }]}
{Id:30 FileId:55 StartLine:261 StartColumn:1 EndLine:263 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000992660 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:31 FileId:55 StartLine:265 StartColumn:1 EndLine:271 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:*keys} {Name:ns Type:*nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]}
{Id:3 FileId:113 StartLine:51 StartColumn:1 EndLine:62 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000dceac0 Body:{
	otherSe := other.(skipEntry)
	if se == otherSe {
		return 0
	}

	if se > otherSe {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherSe := other.(skipEntry) if se == otherSe { return 0 } if se > otherSe { return 1 } return -1 }]}
{Id:4 FileId:113 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001308ba0 Body:{
	return uint64(se)
} PrettyPrintBody:[{ return uint64(se) }]}
{Id:5 FileId:113 StartLine:70 StartColumn:1 EndLine:76 EndColumn:2 Name:isLastDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if dimension >= lastDimension {
		panic(`Dimension is greater than possible dimensions.`)
	}

	return dimension == lastDimension-1
} PrettyPrintBody:[{ if dimension >= lastDimension { panic(`Dimension is greater than possible dimensions.`) } return dimension == lastDimension-1 }]}
{Id:6 FileId:113 StartLine:80 StartColumn:1 EndLine:89 EndColumn:2 Name:needsDeletion Params:[{Name:value Type:int64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if number > 0 {
		return false
	}

	number = -number
	offset := value - index

	return offset >= 0 && offset < number
} PrettyPrintBody:[{ if number > 0 { return false } number = -number offset := value - index return offset >= 0 && offset < number }]}
{Id:8 FileId:113 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000a23640 Body:{
	keyed := e.(keyed)
	if db.id == keyed.key() {
		return 0
	}

	if db.id > keyed.key() {
		return 1
	}

	return -1
} PrettyPrintBody:[{ keyed := e.(keyed) if db.id == keyed.key() { return 0 } if db.id > keyed.key() { return 1 } return -1 }]}
{Id:9 FileId:113 StartLine:114 StartColumn:1 EndLine:116 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001580e80 Body:{
	return db.id
} PrettyPrintBody:[{ return db.id }]}
{Id:11 FileId:113 StartLine:127 StartColumn:1 EndLine:138 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc001580ee0 Body:{
	keyed := e.(keyed)
	if lb.id == keyed.key() {
		return 0
	}

	if lb.id > keyed.key() {
		return 1
	}

	return -1
} PrettyPrintBody:[{ keyed := e.(keyed) if lb.id == keyed.key() { return 0 } if lb.id > keyed.key() { return 1 } return -1 }]}
{Id:12 FileId:113 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00095a4e0 Body:{
	return lb.id
} PrettyPrintBody:[{ return lb.id }]}
{Id:14 FileId:113 StartLine:150 StartColumn:1 EndLine:153 EndColumn:2 Name:init Params:[{Name:dimensions Type:uint64}] Results:[] Receiver:0xc001580f80 Body:{
	rt.dimensions = dimensions
	rt.top = skip.New(uint64(0))
} PrettyPrintBody:[{ rt.dimensions = dimensions rt.top = skip.New(uint64(0)) }]}
{Id:15 FileId:113 StartLine:155 StartColumn:1 EndLine:193 EndColumn:2 Name:add Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc000a8a260 Body:{
	var (
		value	int64
		e	common.Comparator
		sl	= rt.top
		db	*dimensionalBundle
		lb	*lastBundle
	)

	for i := uint64(0); i < rt.dimensions; i++ {
		value = entry.ValueAtDimension(i)
		e = sl.Get(skipEntry(value))[0]
		if isLastDimension(i, rt.dimensions) {
			if e != nil {
				lb = e.(*lastBundle)
				oldEntry := lb.entry
				lb.entry = entry
				return oldEntry
			}

			lb = &lastBundle{id: uint64(value), entry: entry}
			rt.number++
			sl.Insert(lb)
			return nil
		}

		if e == nil {
			db = &dimensionalBundle{id: uint64(value), sl: skip.New(uint64(0))}
			sl.Insert(db)
		} else {
			db = e.(*dimensionalBundle)
		}

		sl = db.sl
	}

	panic(`Ran out of dimensions before for loop completed.`)
} PrettyPrintBody:[{ var ( value	int64 e	common.Comparator sl	= rt.top db	*dimensionalBundle lb	*lastBundle ) for i := uint64(0); i < rt.dimensions; i++ { value = entry.ValueAtDimension(i) e = sl.Get(skipEntry(value))[0] if isLastDimension(i, rt.dimensions) { if e != nil { lb = e.(*lastBundle) oldEntry := lb.entry lb.entry = entry return oldEntry } lb = &lastBundle{id: uint64(value), entry: entry} rt.number++ sl.Insert(lb) return nil } if e == nil { db = &dimensionalBundle{id: uint64(value), sl: skip.New(uint64(0))} sl.Insert(db) } else { db = e.(*dimensionalBundle) } sl = db.sl } panic(`Ran out of dimensions before for loop completed.`) }]}
{Id:16 FileId:113 StartLine:200 StartColumn:1 EndLine:207 EndColumn:2 Name:Add Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc001602aa0 Body:{
	overwritten := make(rangetree.Entries, len(entries))
	for i, e := range entries {
		overwritten[i] = rt.add(e)
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(rangetree.Entries, len(entries)) for i, e := range entries { overwritten[i] = rt.add(e) } return overwritten }]}
{Id:17 FileId:113 StartLine:209 StartColumn:1 EndLine:230 EndColumn:2 Name:get Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc0009920e0 Body:{
	var (
		sl	= rt.top
		e	common.Comparator
		value	uint64
	)
	for i := uint64(0); i < rt.dimensions; i++ {
		value = uint64(entry.ValueAtDimension(i))
		e = sl.Get(skipEntry(value))[0]
		if e == nil {
			return nil
		}

		if isLastDimension(i, rt.dimensions) {
			return e.(*lastBundle).entry
		}

		sl = e.(*dimensionalBundle).sl
	}

	panic(`Reached past for loop without finding last dimension.`)
} PrettyPrintBody:[{ var ( sl	= rt.top e	common.Comparator value	uint64 ) for i := uint64(0); i < rt.dimensions; i++ { value = uint64(entry.ValueAtDimension(i)) e = sl.Get(skipEntry(value))[0] if e == nil { return nil } if isLastDimension(i, rt.dimensions) { return e.(*lastBundle).entry } sl = e.(*dimensionalBundle).sl } panic(`Reached past for loop without finding last dimension.`) }]}
{Id:18 FileId:113 StartLine:235 StartColumn:1 EndLine:242 EndColumn:2 Name:Get Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0003e5100 Body:{
	results := make(rangetree.Entries, 0, len(entries))
	for _, e := range entries {
		results = append(results, rt.get(e))
	}

	return results
} PrettyPrintBody:[{ results := make(rangetree.Entries, 0, len(entries)) for _, e := range entries { results = append(results, rt.get(e)) } return results }]}
{Id:19 FileId:113 StartLine:245 StartColumn:1 EndLine:247 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602c60 Body:{
	return rt.number
} PrettyPrintBody:[{ return rt.number }]}
{Id:20 FileId:113 StartLine:252 StartColumn:1 EndLine:281 EndColumn:2 Name:deleteRecursive Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc001602ca0 Body:{

	value := entry.ValueAtDimension(dimension)
	if isLastDimension(dimension, rt.dimensions) {
		entries := sl.Delete(skipEntry(value))
		if entries[0] == nil {
			return nil
		}

		rt.number--
		return entries[0].(*lastBundle).entry
	}

	db, ok := sl.Get(skipEntry(value))[0].(*dimensionalBundle)
	if !ok {
		return nil
	}

	result := rt.deleteRecursive(db.sl, dimension+1, entry)
	if result == nil {
		return nil
	}

	if db.sl.Len() == 0 {
		sl.Delete(db)
	}

	return result
} PrettyPrintBody:[{ value := entry.ValueAtDimension(dimension) if isLastDimension(dimension, rt.dimensions) { entries := sl.Delete(skipEntry(value)) if entries[0] == nil { return nil } rt.number-- return entries[0].(*lastBundle).entry } db, ok := sl.Get(skipEntry(value))[0].(*dimensionalBundle) if !ok { return nil } result := rt.deleteRecursive(db.sl, dimension+1, entry) if result == nil { return nil } if db.sl.Len() == 0 { sl.Delete(db) } return result }]}
{Id:21 FileId:113 StartLine:283 StartColumn:1 EndLine:285 EndColumn:2 Name:delete Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc000a8aa20 Body:{
	return rt.deleteRecursive(rt.top, 0, entry)
} PrettyPrintBody:[{ return rt.deleteRecursive(rt.top, 0, entry) }]}
{Id:22 FileId:113 StartLine:291 StartColumn:1 EndLine:298 EndColumn:2 Name:Delete Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc000a8b1e0 Body:{
	deletedEntries := make(rangetree.Entries, len(entries))
	for i, e := range entries {
		deletedEntries[i] = rt.delete(e)
	}

	return deletedEntries
} PrettyPrintBody:[{ deletedEntries := make(rangetree.Entries, len(entries)) for i, e := range entries { deletedEntries[i] = rt.delete(e) } return deletedEntries }]}
{Id:23 FileId:113 StartLine:300 StartColumn:1 EndLine:326 EndColumn:2 Name:apply Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[{Name: Type:bool}] Receiver:0xc001603220 Body:{

	lowValue, highValue := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	var e common.Comparator

	for iter := sl.Iter(skipEntry(lowValue)); iter.Next(); {
		e = iter.Value()
		if int64(e.(keyed).key()) >= highValue {
			break
		}

		if isLastDimension(dimension, rt.dimensions) {
			if !fn(e.(*lastBundle).entry) {
				return false
			}
		} else {

			if !rt.apply(e.(*dimensionalBundle).sl, dimension+1, interval, fn) {
				return false
			}
		}
	}

	return true
} PrettyPrintBody:[{ lowValue, highValue := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) var e common.Comparator for iter := sl.Iter(skipEntry(lowValue)); iter.Next(); { e = iter.Value() if int64(e.(keyed).key()) >= highValue { break } if isLastDimension(dimension, rt.dimensions) { if !fn(e.(*lastBundle).entry) { return false } } else { if !rt.apply(e.(*dimensionalBundle).sl, dimension+1, interval, fn) { return false } } } return true }]}
{Id:24 FileId:113 StartLine:332 StartColumn:1 EndLine:334 EndColumn:2 Name:Apply Params:[{Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[] Receiver:0xc00095aea0 Body:{
	rt.apply(rt.top, 0, interval, fn)
} PrettyPrintBody:[{ rt.apply(rt.top, 0, interval, fn) }]}
{Id:25 FileId:113 StartLine:338 StartColumn:1 EndLine:346 EndColumn:2 Name:Query Params:[{Name:interval Type:rangetree.Interval}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc00019e4e0 Body:{
	entries := make(rangetree.Entries, 0, 100)
	rt.apply(rt.top, 0, interval, func(e rangetree.Entry) bool {
		entries = append(entries, e)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, 100) rt.apply(rt.top, 0, interval, func(e rangetree.Entry) bool { entries = append(entries, e) return true }) return entries }]}
{Id:26 FileId:113 StartLine:348 StartColumn:1 EndLine:357 EndColumn:2 Name:flatten Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:entries Type:*rangetree.Entries}] Results:[] Receiver:0xc001603320 Body:{
	lastDimension := isLastDimension(dimension, rt.dimensions)
	for iter := sl.Iter(skipEntry(0)); iter.Next(); {
		if lastDimension {
			*entries = append(*entries, iter.Value().(*lastBundle).entry)
		} else {
			rt.flatten(iter.Value().(*dimensionalBundle).sl, dimension+1, entries)
		}
	}
} PrettyPrintBody:[{ lastDimension := isLastDimension(dimension, rt.dimensions) for iter := sl.Iter(skipEntry(0)); iter.Next(); { if lastDimension { *entries = append(*entries, iter.Value().(*lastBundle).entry) } else { rt.flatten(iter.Value().(*dimensionalBundle).sl, dimension+1, entries) } } }]}
{Id:27 FileId:113 StartLine:359 StartColumn:1 EndLine:410 EndColumn:2 Name:insert Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:index Type:int64} {Name:deleted Type:*rangetree.Entries}] Results:[] Receiver:0xc00095b0c0 Body:{

	var e common.Comparator
	lastDimension := isLastDimension(dimension, rt.dimensions)
	affectedDimension := dimension == insertDimension
	var iter skip.Iterator
	if dimension == insertDimension {
		iter = sl.Iter(skipEntry(index))
	} else {
		iter = sl.Iter(skipEntry(0))
	}

	var toDelete common.Comparators
	if number < 0 {
		toDelete = make(common.Comparators, 0, 100)
	}

	for iter.Next() {
		e = iter.Value()
		if !affectedDimension {
			rt.insert(e.(*dimensionalBundle).sl, dimension+1,
				insertDimension, index, number, deleted, affected,
			)
			continue
		}
		if needsDeletion(int64(e.(keyed).key()), index, number) {
			toDelete = append(toDelete, e)
			continue
		}

		if lastDimension {
			e.(*lastBundle).id += uint64(number)
			*affected = append(*affected, e.(*lastBundle).entry)
		} else {
			e.(*dimensionalBundle).id += uint64(number)
			rt.flatten(e.(*dimensionalBundle).sl, dimension+1, affected)
		}
	}

	if len(toDelete) > 0 {
		for _, e := range toDelete {
			if lastDimension {
				*deleted = append(*deleted, e.(*lastBundle).entry)
			} else {
				rt.flatten(e.(*dimensionalBundle).sl, dimension+1, deleted)
			}
		}

		sl.Delete(toDelete...)
	}
} PrettyPrintBody:[{ var e common.Comparator lastDimension := isLastDimension(dimension, rt.dimensions) affectedDimension := dimension == insertDimension var iter skip.Iterator if dimension == insertDimension { iter = sl.Iter(skipEntry(index)) } else { iter = sl.Iter(skipEntry(0)) } var toDelete common.Comparators if number < 0 { toDelete = make(common.Comparators, 0, 100) } for iter.Next() { e = iter.Value() if !affectedDimension { rt.insert(e.(*dimensionalBundle).sl, dimension+1, insertDimension, index, number, deleted, affected, ) continue } if needsDeletion(int64(e.(keyed).key()), index, number) { toDelete = append(toDelete, e) continue } if lastDimension { e.(*lastBundle).id += uint64(number) *affected = append(*affected, e.(*lastBundle).entry) } else { e.(*dimensionalBundle).id += uint64(number) rt.flatten(e.(*dimensionalBundle).sl, dimension+1, affected) } } if len(toDelete) > 0 { for _, e := range toDelete { if lastDimension { *deleted = append(*deleted, e.(*lastBundle).entry) } else { rt.flatten(e.(*dimensionalBundle).sl, dimension+1, deleted) } } sl.Delete(toDelete...) } }]}
{Id:28 FileId:113 StartLine:417 StartColumn:1 EndLine:433 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:rangetree.Entries} {Name: Type:rangetree.Entries}] Receiver:0xc0009923a0 Body:{

	if dimension >= rt.dimensions || number == 0 {
		return rangetree.Entries{}, rangetree.Entries{}
	}

	affected := make(rangetree.Entries, 0, 100)
	var deleted rangetree.Entries
	if number < 0 {
		deleted = make(rangetree.Entries, 0, 100)
	}

	rt.insert(rt.top, 0, dimension, index, number, &deleted, &affected)
	rt.number -= uint64(len(deleted))
	return affected, deleted
} PrettyPrintBody:[{ if dimension >= rt.dimensions || number == 0 { return rangetree.Entries{}, rangetree.Entries{} } affected := make(rangetree.Entries, 0, 100) var deleted rangetree.Entries if number < 0 { deleted = make(rangetree.Entries, 0, 100) } rt.insert(rt.top, 0, dimension, index, number, &deleted, &affected) rt.number -= uint64(len(deleted)) return affected, deleted }]}
{Id:29 FileId:113 StartLine:435 StartColumn:1 EndLine:439 EndColumn:2 Name:new Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*skipListRT}] Receiver:<nil> Body:{
	sl := &skipListRT{}
	sl.init(dimensions)
	return sl
} PrettyPrintBody:[{ sl := &skipListRT{} sl.init(dimensions) return sl }]}
{Id:30 FileId:113 StartLine:443 StartColumn:1 EndLine:445 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:rangetree.RangeTree}] Receiver:<nil> Body:{
	return new(dimensions)
} PrettyPrintBody:[{ return new(dimensions) }]}
{Id:1 FileId:163 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:generateEntries Params:[{Name:num Type:int}] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	entries := make(Entries, 0, num)
	for i := uint64(0); i < uint64(num); i++ {
		entries = append(entries, newMockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, num) for i := uint64(0); i < uint64(num); i++ { entries = append(entries, newMockEntry(i)) } return entries }]}
{Id:2 FileId:163 StartLine:34 StartColumn:1 EndLine:56 EndColumn:2 Name:TestTrieSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)
	e3 := newMockEntry(8)

	yfast.Insert(e1, e2, e3)

	result := yfast.get(3)
	assert.Equal(t, e1, result)

	result = yfast.get(7)
	assert.Equal(t, e2, result)

	result = yfast.get(8)
	assert.Equal(t, e3, result)

	result = yfast.get(250)
	assert.Nil(t, result)

	assert.Equal(t, uint64(3), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(7) e3 := newMockEntry(8) yfast.Insert(e1, e2, e3) result := yfast.get(3) assert.Equal(t, e1, result) result = yfast.get(7) assert.Equal(t, e2, result) result = yfast.get(8) assert.Equal(t, e3, result) result = yfast.get(250) assert.Nil(t, result) assert.Equal(t, uint64(3), yfast.Len()) }]}
{Id:3 FileId:163 StartLine:58 StartColumn:1 EndLine:68 EndColumn:2 Name:TestTrieOverwriteInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(3)
	yfast.Insert(e1)

	yfast.Insert(e2)
	assert.Equal(t, e2, yfast.Get(3))
	assert.Equal(t, uint64(1), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(3) yfast.Insert(e1) yfast.Insert(e2) assert.Equal(t, e2, yfast.Get(3)) assert.Equal(t, uint64(1), yfast.Len()) }]}
{Id:4 FileId:163 StartLine:70 StartColumn:1 EndLine:97 EndColumn:2 Name:TestTrieDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)
	e3 := newMockEntry(8)

	yfast.Insert(e1, e2, e3)

	result := yfast.Delete(3)
	assert.Equal(t, Entries{e1}, result)
	assert.Nil(t, yfast.Get(3))
	assert.Equal(t, uint64(2), yfast.Len())

	result = yfast.Delete(7)
	assert.Equal(t, Entries{e2}, result)
	assert.Nil(t, yfast.Get(7))
	assert.Equal(t, uint64(1), yfast.Len())

	result = yfast.Delete(8)
	assert.Equal(t, Entries{e3}, result)
	assert.Nil(t, yfast.Get(8))
	assert.Equal(t, uint64(0), yfast.Len())

	result = yfast.Delete(5)
	assert.Equal(t, Entries{nil}, result)
	assert.Equal(t, uint64(0), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(7) e3 := newMockEntry(8) yfast.Insert(e1, e2, e3) result := yfast.Delete(3) assert.Equal(t, Entries{e1}, result) assert.Nil(t, yfast.Get(3)) assert.Equal(t, uint64(2), yfast.Len()) result = yfast.Delete(7) assert.Equal(t, Entries{e2}, result) assert.Nil(t, yfast.Get(7)) assert.Equal(t, uint64(1), yfast.Len()) result = yfast.Delete(8) assert.Equal(t, Entries{e3}, result) assert.Nil(t, yfast.Get(8)) assert.Equal(t, uint64(0), yfast.Len()) result = yfast.Delete(5) assert.Equal(t, Entries{nil}, result) assert.Equal(t, uint64(0), yfast.Len()) }]}
{Id:5 FileId:163 StartLine:99 StartColumn:1 EndLine:130 EndColumn:2 Name:TestTrieSuccessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e3 := newMockEntry(13)
	yfast.Insert(e3)

	successor := yfast.Successor(0)
	assert.Equal(t, e3, successor)

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)

	yfast.Insert(e1, e2)

	successor = yfast.Successor(0)
	assert.Equal(t, e1, successor)

	successor = yfast.Successor(3)
	assert.Equal(t, e1, successor)

	successor = yfast.Successor(4)
	assert.Equal(t, e2, successor)

	successor = yfast.Successor(8)
	assert.Equal(t, e3, successor)

	successor = yfast.Successor(14)
	assert.Nil(t, successor)

	successor = yfast.Successor(100)
	assert.Nil(t, successor)
} PrettyPrintBody:[{ yfast := New(uint8(0)) e3 := newMockEntry(13) yfast.Insert(e3) successor := yfast.Successor(0) assert.Equal(t, e3, successor) e1 := newMockEntry(3) e2 := newMockEntry(7) yfast.Insert(e1, e2) successor = yfast.Successor(0) assert.Equal(t, e1, successor) successor = yfast.Successor(3) assert.Equal(t, e1, successor) successor = yfast.Successor(4) assert.Equal(t, e2, successor) successor = yfast.Successor(8) assert.Equal(t, e3, successor) successor = yfast.Successor(14) assert.Nil(t, successor) successor = yfast.Successor(100) assert.Nil(t, successor) }]}
{Id:6 FileId:163 StartLine:132 StartColumn:1 EndLine:158 EndColumn:2 Name:TestTriePredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	predecessor := yfast.Predecessor(5)
	assert.Nil(t, predecessor)

	e1 := newMockEntry(5)
	yfast.Insert(e1)

	predecessor = yfast.Predecessor(13)
	assert.Equal(t, e1, predecessor)

	e2 := newMockEntry(12)
	yfast.Insert(e2)

	predecessor = yfast.Predecessor(11)
	assert.Equal(t, e1, predecessor)

	predecessor = yfast.Predecessor(5)
	assert.Equal(t, e1, predecessor)

	predecessor = yfast.Predecessor(4)
	assert.Nil(t, predecessor)

	predecessor = yfast.Predecessor(100)
	assert.Equal(t, e2, predecessor)
} PrettyPrintBody:[{ yfast := New(uint8(0)) predecessor := yfast.Predecessor(5) assert.Nil(t, predecessor) e1 := newMockEntry(5) yfast.Insert(e1) predecessor = yfast.Predecessor(13) assert.Equal(t, e1, predecessor) e2 := newMockEntry(12) yfast.Insert(e2) predecessor = yfast.Predecessor(11) assert.Equal(t, e1, predecessor) predecessor = yfast.Predecessor(5) assert.Equal(t, e1, predecessor) predecessor = yfast.Predecessor(4) assert.Nil(t, predecessor) predecessor = yfast.Predecessor(100) assert.Equal(t, e2, predecessor) }]}
{Id:7 FileId:163 StartLine:160 StartColumn:1 EndLine:192 EndColumn:2 Name:TestTrieIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	iter := yfast.Iter(5)
	assert.Equal(t, Entries{}, iter.exhaust())

	e1 := newMockEntry(5)
	yfast.Insert(e1)

	iter = yfast.Iter(5)
	assert.Equal(t, Entries{e1}, iter.exhaust())

	e2 := newMockEntry(12)
	yfast.Insert(e2)

	iter = yfast.Iter(5)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())

	iter = yfast.Iter(6)
	assert.Equal(t, Entries{e2}, iter.exhaust())

	e3 := newMockEntry(6)
	yfast.Insert(e3)

	iter = yfast.Iter(7)
	assert.Equal(t, Entries{e2}, iter.exhaust())

	iter = yfast.Iter(0)
	assert.Equal(t, Entries{e1, e3, e2}, iter.exhaust())

	iter = yfast.Iter(13)
	assert.Equal(t, Entries{}, iter.exhaust())
} PrettyPrintBody:[{ yfast := New(uint8(0)) iter := yfast.Iter(5) assert.Equal(t, Entries{}, iter.exhaust()) e1 := newMockEntry(5) yfast.Insert(e1) iter = yfast.Iter(5) assert.Equal(t, Entries{e1}, iter.exhaust()) e2 := newMockEntry(12) yfast.Insert(e2) iter = yfast.Iter(5) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) iter = yfast.Iter(6) assert.Equal(t, Entries{e2}, iter.exhaust()) e3 := newMockEntry(6) yfast.Insert(e3) iter = yfast.Iter(7) assert.Equal(t, Entries{e2}, iter.exhaust()) iter = yfast.Iter(0) assert.Equal(t, Entries{e1, e3, e2}, iter.exhaust()) iter = yfast.Iter(13) assert.Equal(t, Entries{}, iter.exhaust()) }]}
{Id:8 FileId:163 StartLine:194 StartColumn:1 EndLine:203 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint64(0))
	entries := generateEntries(b.N)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Insert(entries[i])
	}
} PrettyPrintBody:[{ yfast := New(uint64(0)) entries := generateEntries(b.N) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Insert(entries[i]) } }]}
{Id:9 FileId:163 StartLine:205 StartColumn:1 EndLine:218 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000

	entries := generateEntries(numItems)

	yfast := New(uint32(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Get(uint64(numItems / 2))
	}
} PrettyPrintBody:[{ numItems := 1000 entries := generateEntries(numItems) yfast := New(uint32(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Get(uint64(numItems / 2)) } }]}
{Id:10 FileId:163 StartLine:220 StartColumn:1 EndLine:230 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	entries := generateEntries(b.N)
	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Delete(uint64(i))
	}
} PrettyPrintBody:[{ entries := generateEntries(b.N) yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Delete(uint64(i)) } }]}
{Id:11 FileId:163 StartLine:232 StartColumn:1 EndLine:248 EndColumn:2 Name:BenchmarkSuccessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	entries := make(Entries, 0, numItems)
	for i := uint64(0); i < uint64(numItems); i++ {
		entries = append(entries, newMockEntry(i+uint64(b.N/2)))
	}

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Successor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { entries = append(entries, newMockEntry(i+uint64(b.N/2))) } yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Successor(uint64(i)) } }]}
{Id:12 FileId:163 StartLine:250 StartColumn:1 EndLine:266 EndColumn:2 Name:BenchmarkPredecessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	entries := make(Entries, 0, numItems)
	for i := uint64(0); i < uint64(numItems); i++ {
		entries = append(entries, newMockEntry(i+uint64(b.N/2)))
	}

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Predecessor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { entries = append(entries, newMockEntry(i+uint64(b.N/2))) } yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Predecessor(uint64(i)) } }]}
{Id:13 FileId:163 StartLine:268 StartColumn:1 EndLine:282 EndColumn:2 Name:BenchmarkIterator Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	entries := generateEntries(numItems)

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for iter := yfast.Iter(0); iter.Next(); {
			iter.Value()
		}
	}
} PrettyPrintBody:[{ numItems := 1000 entries := generateEntries(numItems) yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { for iter := yfast.Iter(0); iter.Next(); { iter.Value() } } }]}
{Id:1 FileId:155 StartLine:51 StartColumn:1 EndLine:56 EndColumn:2 Name:isInternal Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n == nil {
		return false
	}
	return n.entry == nil
} PrettyPrintBody:[{ if n == nil { return false } return n.entry == nil }]}
{Id:2 FileId:155 StartLine:60 StartColumn:1 EndLine:62 EndColumn:2 Name:hasInternal Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return isInternal(n.children[0]) || isInternal(n.children[1])
} PrettyPrintBody:[{ return isInternal(n.children[0]) || isInternal(n.children[1]) }]}
{Id:3 FileId:155 StartLine:66 StartColumn:1 EndLine:71 EndColumn:2 Name:isLeaf Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n == nil {
		return false
	}
	return !isInternal(n)
} PrettyPrintBody:[{ if n == nil { return false } return !isInternal(n) }]}
{Id:8 FileId:155 StartLine:131 StartColumn:1 EndLine:137 EndColumn:2 Name:newNode Params:[{Name:parent Type:*node} {Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		children:	[2]*node{},
		entry:		entry,
		parent:		parent,
	}
} PrettyPrintBody:[{ return &node{ children:	[2]*node{}, entry:		entry, parent:		parent, } }]}
{Id:9 FileId:155 StartLine:144 StartColumn:1 EndLine:161 EndColumn:2 Name:binarySearchHashMaps Params:[{Name:layers Type:[]map[uint64]*node} {Name:key Type:uint64}] Results:[{Name: Type:int} {Name: Type:*node}] Receiver:<nil> Body:{
	low, high := 0, len(layers)-1
	diff := 64 - len(layers)
	var mid int
	var node *node
	for low <= high {
		mid = (low + high) / 2
		n, ok := layers[mid][key&masks[diff+mid]]
		if ok {
			node = n
			low = mid + 1
		} else {
			high = mid - 1
		}
	}

	return low, node
} PrettyPrintBody:[{ low, high := 0, len(layers)-1 diff := 64 - len(layers) var mid int var node *node for low <= high { mid = (low + high) / 2 n, ok := layers[mid][key&masks[diff+mid]] if ok { node = n low = mid + 1 } else { high = mid - 1 } } return low, node }]}
{Id:10 FileId:155 StartLine:168 StartColumn:1 EndLine:178 EndColumn:2 Name:whichSide Params:[{Name:n Type:*node}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if parent.children[0] == n {
		return 0
	}

	if parent.children[1] == n {
		return 1
	}

	panic(fmt.Sprintf(`Node: %+v, %p not a child of: %+v, %p`, n, n, parent, parent))
} PrettyPrintBody:[{ if parent.children[0] == n { return 0 } if parent.children[1] == n { return 1 } panic(fmt.Sprintf(`Node: %+v, %p not a child of: %+v, %p`, n, n, parent, parent)) }]}
{Id:12 FileId:155 StartLine:216 StartColumn:1 EndLine:240 EndColumn:2 Name:init Params:[{Name:intType Type:interface{}}] Results:[] Receiver:0xc000df7c80 Body:{
	bits := uint8(0)
	switch intType.(type) {
	case uint8:
		bits = 8
	case uint16:
		bits = 16
	case uint32:
		bits = 32
	case uint, uint64:
		bits = 64
	default:

		panic(`Invalid universe size provided.`)
	}

	xft.layers = make([]map[uint64]*node, bits)
	xft.bits = bits
	xft.diff = 64 - bits
	for i := uint8(0); i < bits; i++ {
		xft.layers[i] = make(map[uint64]*node, 50)
	}
	xft.num = 0
	xft.root = newNode(nil, nil)
} PrettyPrintBody:[{ bits := uint8(0) switch intType.(type) { case uint8: bits = 8 case uint16: bits = 16 case uint32: bits = 32 case uint, uint64: bits = 64 default: panic(`Invalid universe size provided.`) } xft.layers = make([]map[uint64]*node, bits) xft.bits = bits xft.diff = 64 - bits for i := uint8(0); i < bits; i++ { xft.layers[i] = make(map[uint64]*node, 50) } xft.num = 0 xft.root = newNode(nil, nil) }]}
{Id:13 FileId:155 StartLine:244 StartColumn:1 EndLine:249 EndColumn:2 Name:Exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001581040 Body:{

	_, ok := xft.layers[xft.bits-1][key]
	return ok
} PrettyPrintBody:[{ _, ok := xft.layers[xft.bits-1][key] return ok }]}
{Id:14 FileId:155 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001033a80 Body:{
	return xft.num
} PrettyPrintBody:[{ return xft.num }]}
{Id:15 FileId:155 StartLine:259 StartColumn:1 EndLine:265 EndColumn:2 Name:Max Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001033ac0 Body:{
	if xft.max == nil {
		return nil
	}

	return xft.max.entry
} PrettyPrintBody:[{ if xft.max == nil { return nil } return xft.max.entry }]}
{Id:16 FileId:155 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:Min Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001581260 Body:{
	if xft.min == nil {
		return nil
	}

	return xft.min.entry
} PrettyPrintBody:[{ if xft.min == nil { return nil } return xft.min.entry }]}
{Id:17 FileId:155 StartLine:279 StartColumn:1 EndLine:378 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[] Receiver:0xc001309c40 Body:{
	key := entry.Key()
	n := xft.layers[xft.bits-1][key]
	if n != nil {
		n.entry = entry
		return
	}

	var predecessor, successor *node
	if xft.min != nil && key < xft.min.entry.Key() {
		successor = xft.min
	} else {
		successor = xft.successor(key)
	}

	if successor == nil {
		if xft.max != nil && key > xft.max.entry.Key() {
			predecessor = xft.max
		} else {
			predecessor = xft.predecessor(key)
		}
	}

	layer, root := binarySearchHashMaps(xft.layers, key)
	if root == nil {
		n = xft.root
		layer = 0
	} else {
		n = root
	}

	var leftOrRight uint64

	for i := uint8(layer); i < xft.bits; i++ {

		leftOrRight = (key & positions[xft.diff+i]) >> (xft.bits - 1 - i)
		if n.children[leftOrRight] == nil || isLeaf(n.children[leftOrRight]) {
			var nn *node
			if i < xft.bits-1 {
				nn = newNode(n, nil)
			} else {
				nn = newNode(n, entry)
				xft.num++
			}

			n.children[leftOrRight] = nn
			xft.layers[i][key&masks[xft.diff+i]] = nn
		}

		n = n.children[leftOrRight]
	}

	if successor != nil {
		predecessor = successor.children[0]
		if predecessor != nil {
			predecessor.children[1] = n
			n.children[0] = predecessor
		}
		n.children[1] = successor
		successor.children[0] = n
	} else if predecessor != nil {
		n.children[0] = predecessor
		predecessor.children[1] = n
	}

	if successor != nil {
		xft.walkUpSuccessor(root, n, successor)
	}

	if predecessor != nil {
		xft.walkUpPredecessor(root, n, predecessor)
	}

	xft.walkUpNode(root, n, predecessor, successor)

	if xft.max == nil || key > xft.max.entry.Key() {
		xft.max = n
	}

	if xft.min == nil || key < xft.min.entry.Key() {
		xft.min = n
	}
} PrettyPrintBody:[{ key := entry.Key() n := xft.layers[xft.bits-1][key] if n != nil { n.entry = entry return } var predecessor, successor *node if xft.min != nil && key < xft.min.entry.Key() { successor = xft.min } else { successor = xft.successor(key) } if successor == nil { if xft.max != nil && key > xft.max.entry.Key() { predecessor = xft.max } else { predecessor = xft.predecessor(key) } } layer, root := binarySearchHashMaps(xft.layers, key) if root == nil { n = xft.root layer = 0 } else { n = root } var leftOrRight uint64 for i := uint8(layer); i < xft.bits; i++ { leftOrRight = (key & positions[xft.diff+i]) >> (xft.bits - 1 - i) if n.children[leftOrRight] == nil || isLeaf(n.children[leftOrRight]) { var nn *node if i < xft.bits-1 { nn = newNode(n, nil) } else { nn = newNode(n, entry) xft.num++ } n.children[leftOrRight] = nn xft.layers[i][key&masks[xft.diff+i]] = nn } n = n.children[leftOrRight] } if successor != nil { predecessor = successor.children[0] if predecessor != nil { predecessor.children[1] = n n.children[0] = predecessor } n.children[1] = successor successor.children[0] = n } else if predecessor != nil { n.children[0] = predecessor predecessor.children[1] = n } if successor != nil { xft.walkUpSuccessor(root, n, successor) } if predecessor != nil { xft.walkUpPredecessor(root, n, predecessor) } xft.walkUpNode(root, n, predecessor, successor) if xft.max == nil || key > xft.max.entry.Key() { xft.max = n } if xft.min == nil || key < xft.min.entry.Key() { xft.min = n } }]}
{Id:18 FileId:155 StartLine:383 StartColumn:1 EndLine:393 EndColumn:2 Name:walkUpSuccessor Params:[{Name:root Type:*node}] Results:[] Receiver:0xc001602ba0 Body:{
	n := successor.parent
	for n != nil && n != root {

		if !isInternal(n.children[0]) && n.children[0] != successor {
			n.children[0] = node
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := successor.parent for n != nil && n != root { if !isInternal(n.children[0]) && n.children[0] != successor { n.children[0] = node } n = n.parent } }]}
{Id:19 FileId:155 StartLine:398 StartColumn:1 EndLine:406 EndColumn:2 Name:walkUpPredecessor Params:[{Name:root Type:*node}] Results:[] Receiver:0xc001033ee0 Body:{
	n := predecessor.parent
	for n != nil && n != root {
		if !isInternal(n.children[1]) && n.children[1] != predecessor {
			n.children[1] = node
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := predecessor.parent for n != nil && n != root { if !isInternal(n.children[1]) && n.children[1] != predecessor { n.children[1] = node } n = n.parent } }]}
{Id:20 FileId:155 StartLine:411 StartColumn:1 EndLine:422 EndColumn:2 Name:walkUpNode Params:[{Name:root Type:*node}] Results:[] Receiver:0xc0003e5380 Body:{
	n := node.parent
	for n != nil && n != root {
		if !isInternal(n.children[1]) && n.children[1] != successor && n.children[1] != node {
			n.children[1] = successor
		}
		if !isInternal(n.children[0]) && n.children[0] != predecessor && n.children[0] != node {
			n.children[0] = predecessor
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := node.parent for n != nil && n != root { if !isInternal(n.children[1]) && n.children[1] != successor && n.children[1] != node { n.children[1] = successor } if !isInternal(n.children[0]) && n.children[0] != predecessor && n.children[0] != node { n.children[0] = predecessor } n = n.parent } }]}
{Id:21 FileId:155 StartLine:427 StartColumn:1 EndLine:431 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[] Receiver:0xc001033f80 Body:{
	for _, e := range entries {
		xft.insert(e)
	}
} PrettyPrintBody:[{ for _, e := range entries { xft.insert(e) } }]}
{Id:22 FileId:155 StartLine:433 StartColumn:1 EndLine:497 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc001173dc0 Body:{
	n := xft.layers[xft.bits-1][key]
	if n == nil {
		return
	}

	successor, predecessor := n.children[1], n.children[0]

	i := uint8(1)
	delete(xft.layers[xft.bits-1], key)
	leftOrRight := whichSide(n, n.parent)
	n.parent.children[leftOrRight] = nil
	n.children[0], n.children[1] = nil, nil
	n = n.parent
	hasImmediateSibling := false
	if successor != nil && successor.parent == n {
		hasImmediateSibling = true
	}
	if predecessor != nil && predecessor.parent == n {
		hasImmediateSibling = true
	}

	for n != nil && n.parent != nil {

		if hasInternal(n) || (i == 1 && hasImmediateSibling) {
			n = n.parent
			break
		}

		leftOrRight = whichSide(n, n.parent)
		n.parent.children[leftOrRight] = nil
		n.children[0], n.children[1] = nil, nil
		delete(xft.layers[xft.bits-i-1], key&masks[len(masks)-1-int(i)])
		n = n.parent
		i++
	}

	if predecessor != nil {
		predecessor.children[1] = successor
		xft.walkUpPredecessor(n, successor, predecessor)
	}

	if successor != nil {
		successor.children[0] = predecessor
		xft.walkUpSuccessor(n, predecessor, successor)
	}

	if xft.max.entry.Key() == key {
		xft.max = predecessor
	}

	if xft.min.entry.Key() == key {
		xft.min = successor
	}

	xft.num--
} PrettyPrintBody:[{ n := xft.layers[xft.bits-1][key] if n == nil { return } successor, predecessor := n.children[1], n.children[0] i := uint8(1) delete(xft.layers[xft.bits-1], key) leftOrRight := whichSide(n, n.parent) n.parent.children[leftOrRight] = nil n.children[0], n.children[1] = nil, nil n = n.parent hasImmediateSibling := false if successor != nil && successor.parent == n { hasImmediateSibling = true } if predecessor != nil && predecessor.parent == n { hasImmediateSibling = true } for n != nil && n.parent != nil { if hasInternal(n) || (i == 1 && hasImmediateSibling) { n = n.parent break } leftOrRight = whichSide(n, n.parent) n.parent.children[leftOrRight] = nil n.children[0], n.children[1] = nil, nil delete(xft.layers[xft.bits-i-1], key&masks[len(masks)-1-int(i)]) n = n.parent i++ } if predecessor != nil { predecessor.children[1] = successor xft.walkUpPredecessor(n, successor, predecessor) } if successor != nil { successor.children[0] = predecessor xft.walkUpSuccessor(n, predecessor, successor) } if xft.max.entry.Key() == key { xft.max = predecessor } if xft.min.entry.Key() == key { xft.min = successor } xft.num-- }]}
{Id:23 FileId:155 StartLine:502 StartColumn:1 EndLine:506 EndColumn:2 Name:Delete Params:[{Name:keys Type:...uint64}] Results:[] Receiver:0xc00019e720 Body:{
	for _, key := range keys {
		xft.delete(key)
	}
} PrettyPrintBody:[{ for _, key := range keys { xft.delete(key) } }]}
{Id:24 FileId:155 StartLine:510 StartColumn:1 EndLine:539 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc001603820 Body:{
	if xft.root == nil || xft.max == nil {
		return nil
	}

	if key >= xft.max.entry.Key() {
		return xft.max
	}

	if key < xft.min.entry.Key() {
		return nil
	}

	n := xft.layers[xft.bits-1][key]
	if n != nil {
		return n
	}

	layer, n := binarySearchHashMaps(xft.layers, key)
	if n == nil && layer > 1 {
		return nil
	} else if n == nil {
		n = xft.root
	}

	if isInternal(n.children[0]) && isLeaf(n.children[1]) {
		return n.children[1].children[0]
	}
	return n.children[0]
} PrettyPrintBody:[{ if xft.root == nil || xft.max == nil { return nil } if key >= xft.max.entry.Key() { return xft.max } if key < xft.min.entry.Key() { return nil } n := xft.layers[xft.bits-1][key] if n != nil { return n } layer, n := binarySearchHashMaps(xft.layers, key) if n == nil && layer > 1 { return nil } else if n == nil { n = xft.root } if isInternal(n.children[0]) && isLeaf(n.children[1]) { return n.children[1].children[0] } return n.children[0] }]}
{Id:25 FileId:155 StartLine:543 StartColumn:1 EndLine:572 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0001e6ba0 Body:{
	if xft.root == nil || xft.min == nil {
		return nil
	}

	if key <= xft.min.entry.Key() {
		return xft.min
	}

	if key > xft.max.entry.Key() {
		return nil
	}

	n := xft.layers[xft.bits-1][key]
	if n != nil {
		return n
	}

	layer, n := binarySearchHashMaps(xft.layers, key)
	if n == nil && layer > 1 {
		return nil
	} else if n == nil {
		n = xft.root
	}

	if isInternal(n.children[1]) && isLeaf(n.children[0]) {
		return n.children[0].children[1]
	}
	return n.children[1]
} PrettyPrintBody:[{ if xft.root == nil || xft.min == nil { return nil } if key <= xft.min.entry.Key() { return xft.min } if key > xft.max.entry.Key() { return nil } n := xft.layers[xft.bits-1][key] if n != nil { return n } layer, n := binarySearchHashMaps(xft.layers, key) if n == nil && layer > 1 { return nil } else if n == nil { n = xft.root } if isInternal(n.children[1]) && isLeaf(n.children[0]) { return n.children[0].children[1] } return n.children[1] }]}
{Id:26 FileId:155 StartLine:577 StartColumn:1 EndLine:584 EndColumn:2 Name:Successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0016039e0 Body:{
	n := xft.successor(key)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.successor(key) if n == nil { return nil } return n.entry }]}
{Id:27 FileId:155 StartLine:589 StartColumn:1 EndLine:596 EndColumn:2 Name:Predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0009927e0 Body:{
	n := xft.predecessor(key)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.predecessor(key) if n == nil { return nil } return n.entry }]}
{Id:28 FileId:155 StartLine:601 StartColumn:1 EndLine:606 EndColumn:2 Name:Iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc000992840 Body:{
	return &Iterator{
		n:	xft.successor(key),
		first:	true,
	}
} PrettyPrintBody:[{ return &Iterator{ n:	xft.successor(key), first:	true, } }]}
{Id:29 FileId:155 StartLine:611 StartColumn:1 EndLine:620 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc00019e9c0 Body:{

	n := xft.layers[xft.bits-1][key]
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.layers[xft.bits-1][key] if n == nil { return nil } return n.entry }]}
{Id:30 FileId:155 StartLine:627 StartColumn:1 EndLine:631 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*XFastTrie}] Receiver:<nil> Body:{
	xft := &XFastTrie{}
	xft.init(ifc)
	return xft
} PrettyPrintBody:[{ xft := &XFastTrie{} xft.init(ifc) return xft }]}
{Id:2 FileId:150 StartLine:43 StartColumn:1 EndLine:43 EndColumn:48 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00111ebe0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:3 FileId:150 StartLine:44 StartColumn:1 EndLine:44 EndColumn:50 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc00111ec20 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:4 FileId:150 StartLine:45 StartColumn:1 EndLine:45 EndColumn:50 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0010dbf00 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:5 FileId:150 StartLine:47 StartColumn:1 EndLine:49 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00123c0e0 Body:{
	return fmt.Sprint(n.entries)
} PrettyPrintBody:[{ return fmt.Sprint(n.entries) }]}
{Id:7 FileId:150 StartLine:55 StartColumn:1 EndLine:55 EndColumn:57 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00123c580 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:8 FileId:150 StartLine:56 StartColumn:1 EndLine:56 EndColumn:59 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc001227d60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:9 FileId:150 StartLine:57 StartColumn:1 EndLine:57 EndColumn:59 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000e7e720 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:10 FileId:150 StartLine:59 StartColumn:1 EndLine:61 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc000e7e980 Body:{
	return fmt.Sprintf("<COLLISIONS %v>%v", len(n.entries), n.entries)
} PrettyPrintBody:[{ return fmt.Sprintf("<COLLISIONS %v>%v", len(n.entries), n.entries) }]}
{Id:12 FileId:150 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:emptyNode Params:[{Name:level Type:uint8} {Name:capacity Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{entries: make([]Entry, capacity), level: level}
} PrettyPrintBody:[{ return &node{entries: make([]Entry, capacity), level: level} }]}
{Id:13 FileId:150 StartLine:74 StartColumn:1 EndLine:125 EndColumn:2 Name:insert Params:[{Name:n Type:*node} {Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	index := uint(mask(entry.KeyHash(), n.level))
	newNode := n
	if newNode.level == 6 {
		if newNode.entries[index] == nil {
			newNode.entries[index] = entry
			newNode.dataMap = newNode.dataMap.SetBit(index)
			return newNode
		}
		if newNode.dataMap.GetBit(index) {
			if newNode.entries[index].Key() == entry.Key() {
				newNode.entries[index] = entry
				return newNode
			}
			cNode := &collisionNode{entries: make([]Entry, 2)}
			cNode.entries[0] = newNode.entries[index]
			cNode.entries[1] = entry
			newNode.entries[index] = cNode
			newNode.dataMap = newNode.dataMap.ClearBit(index)
			return newNode
		}
		cNode := newNode.entries[index].(*collisionNode)
		cNode.entries = append(cNode.entries, entry)
		return newNode
	}
	if !newNode.dataMap.GetBit(index) && !newNode.nodeMap.GetBit(index) {
		newNode.entries[index] = entry
		newNode.dataMap = newNode.dataMap.SetBit(index)
		return newNode
	}
	if newNode.nodeMap.GetBit(index) {
		newNode.entries[index] = insert(newNode.entries[index].(*node), entry)
		return newNode
	}
	if newNode.entries[index].Key() == entry.Key() {
		newNode.entries[index] = entry
		return newNode
	}

	var subNode *node
	if newNode.level == 5 {
		subNode = emptyNode(newNode.level+1, 4)
	} else {
		subNode = emptyNode(newNode.level+1, 32)
	}
	subNode = insert(subNode, newNode.entries[index])
	subNode = insert(subNode, entry)
	newNode.dataMap = newNode.dataMap.ClearBit(index)
	newNode.nodeMap = newNode.nodeMap.SetBit(index)
	newNode.entries[index] = subNode
	return newNode
} PrettyPrintBody:[{ index := uint(mask(entry.KeyHash(), n.level)) newNode := n if newNode.level == 6 { if newNode.entries[index] == nil { newNode.entries[index] = entry newNode.dataMap = newNode.dataMap.SetBit(index) return newNode } if newNode.dataMap.GetBit(index) { if newNode.entries[index].Key() == entry.Key() { newNode.entries[index] = entry return newNode } cNode := &collisionNode{entries: make([]Entry, 2)} cNode.entries[0] = newNode.entries[index] cNode.entries[1] = entry newNode.entries[index] = cNode newNode.dataMap = newNode.dataMap.ClearBit(index) return newNode } cNode := newNode.entries[index].(*collisionNode) cNode.entries = append(cNode.entries, entry) return newNode } if !newNode.dataMap.GetBit(index) && !newNode.nodeMap.GetBit(index) { newNode.entries[index] = entry newNode.dataMap = newNode.dataMap.SetBit(index) return newNode } if newNode.nodeMap.GetBit(index) { newNode.entries[index] = insert(newNode.entries[index].(*node), entry) return newNode } if newNode.entries[index].Key() == entry.Key() { newNode.entries[index] = entry return newNode } var subNode *node if newNode.level == 5 { subNode = emptyNode(newNode.level+1, 4) } else { subNode = emptyNode(newNode.level+1, 32) } subNode = insert(subNode, newNode.entries[index]) subNode = insert(subNode, entry) newNode.dataMap = newNode.dataMap.ClearBit(index) newNode.nodeMap = newNode.nodeMap.SetBit(index) newNode.entries[index] = subNode return newNode }]}
{Id:14 FileId:150 StartLine:128 StartColumn:1 EndLine:148 EndColumn:2 Name:get Params:[{Name:n Type:*node} {Name:keyHash Type:uint32} {Name:key Type:interface{}}] Results:[{Name: Type:Entry}] Receiver:<nil> Body:{
	index := uint(mask(keyHash, n.level))
	if n.dataMap.GetBit(index) {
		return n.entries[index]
	}
	if n.nodeMap.GetBit(index) {
		return get(n.entries[index].(*node), keyHash, key)
	}
	if n.level == 6 {
		if n.entries[index] == nil {
			return nil
		}
		cNode := n.entries[index].(*collisionNode)
		for _, e := range cNode.entries {
			if e.Key() == key {
				return e
			}
		}
	}
	return nil
} PrettyPrintBody:[{ index := uint(mask(keyHash, n.level)) if n.dataMap.GetBit(index) { return n.entries[index] } if n.nodeMap.GetBit(index) { return get(n.entries[index].(*node), keyHash, key) } if n.level == 6 { if n.entries[index] == nil { return nil } cNode := n.entries[index].(*collisionNode) for _, e := range cNode.entries { if e.Key() == key { return e } } } return nil }]}
{Id:15 FileId:150 StartLine:150 StartColumn:1 EndLine:193 EndColumn:2 Name:remove Params:[{Name:n Type:*node} {Name:keyHash Type:uint32} {Name:key Type:interface{}}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	index := uint(mask(keyHash, n.level))
	newNode := n
	if n.dataMap.GetBit(index) {
		newNode.entries[index] = nil
		newNode.dataMap = newNode.dataMap.ClearBit(index)
		return newNode
	}
	if n.nodeMap.GetBit(index) {
		subNode := newNode.entries[index].(*node)
		subNode = remove(subNode, keyHash, key)

		if subNode.nodeMap.PopCount() == 0 && subNode.dataMap.PopCount() == 1 {
			var e Entry
			for i := uint(0); i < 32; i++ {
				if subNode.dataMap.GetBit(i) {
					e = subNode.entries[i]
					break
				}
			}
			newNode.entries[index] = e
			newNode.nodeMap = newNode.nodeMap.ClearBit(index)
			newNode.dataMap = newNode.dataMap.SetBit(index)
		}
		newNode.entries[index] = subNode
		return newNode
	}
	if n.level == 6 {
		cNode := newNode.entries[index].(*collisionNode)
		for i, e := range cNode.entries {
			if e.Key() == key {
				cNode.entries = append(cNode.entries[:i], cNode.entries[i+1:]...)
				break
			}
		}

		if len(cNode.entries) == 1 {
			newNode.entries[index] = cNode.entries[0]
			newNode.dataMap = newNode.dataMap.SetBit(index)
		}
		return newNode
	}
	return n
} PrettyPrintBody:[{ index := uint(mask(keyHash, n.level)) newNode := n if n.dataMap.GetBit(index) { newNode.entries[index] = nil newNode.dataMap = newNode.dataMap.ClearBit(index) return newNode } if n.nodeMap.GetBit(index) { subNode := newNode.entries[index].(*node) subNode = remove(subNode, keyHash, key) if subNode.nodeMap.PopCount() == 0 && subNode.dataMap.PopCount() == 1 { var e Entry for i := uint(0); i < 32; i++ { if subNode.dataMap.GetBit(i) { e = subNode.entries[i] break } } newNode.entries[index] = e newNode.nodeMap = newNode.nodeMap.ClearBit(index) newNode.dataMap = newNode.dataMap.SetBit(index) } newNode.entries[index] = subNode return newNode } if n.level == 6 { cNode := newNode.entries[index].(*collisionNode) for i, e := range cNode.entries { if e.Key() == key { cNode.entries = append(cNode.entries[:i], cNode.entries[i+1:]...) break } } if len(cNode.entries) == 1 { newNode.entries[index] = cNode.entries[0] newNode.dataMap = newNode.dataMap.SetBit(index) } return newNode } return n }]}
{Id:16 FileId:150 StartLine:195 StartColumn:1 EndLine:202 EndColumn:2 Name:iterate Params:[{Name:n Type:*node} {Name:stop Type:<-chan struct{}}] Results:[{Name: Type:<-chan Entry}] Receiver:<nil> Body:{
	out := make(chan Entry)
	go func() {
		defer close(out)
		pushEntries(n, stop, out)
	}()
	return out
} PrettyPrintBody:[{ out := make(chan Entry) go func() { defer close(out) pushEntries(n, stop, out) }() return out }]}
{Id:17 FileId:150 StartLine:204 StartColumn:1 EndLine:234 EndColumn:2 Name:pushEntries Params:[{Name:n Type:*node} {Name:stop Type:<-chan struct{}} {Name:out Type:chan Entry}] Results:[] Receiver:<nil> Body:{
	var wg sync.WaitGroup
	for i, e := range n.entries {
		select {
		case <-stop:
			return
		default:
			index := uint(i)
			switch {
			case n.dataMap.GetBit(index):
				out <- e
			case n.nodeMap.GetBit(index):
				wg.Add(1)
				go func() {
					defer wg.Done()
					pushEntries(e.(*node), stop, out)
				}()
				wg.Wait()
			case n.level == 6 && e != nil:
				for _, ce := range n.entries[index].(*collisionNode).entries {
					select {
					case <-stop:
						return
					default:
						out <- ce
					}
				}
			}
		}
	}
} PrettyPrintBody:[{ var wg sync.WaitGroup for i, e := range n.entries { select { case <-stop: return default: index := uint(i) switch { case n.dataMap.GetBit(index): out <- e case n.nodeMap.GetBit(index): wg.Add(1) go func() { defer wg.Done() pushEntries(e.(*node), stop, out) }() wg.Wait() case n.level == 6 && e != nil: for _, ce := range n.entries[index].(*collisionNode).entries { select { case <-stop: return default: out <- ce } } } } } }]}
{Id:18 FileId:72 StartLine:126 StartColumn:1 EndLine:150 EndColumn:2 Name:TestEnqueueDequeueMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence1); i++ {
		heap.Enqueue(NumberSequence1[i])
	}

	var min *Entry
	var err error
	for heap.Size() > 0 {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		if heap.Size() == 199 {
			assert.Equal(t, Seq1FirstMinimum, min.Priority)
		}
		if heap.Size() == 197 {
			assert.Equal(t, Seq1ThirdMinimum, min.Priority)
		}
		if heap.Size() == 195 {
			assert.Equal(t, Seq1FifthMinimum, min.Priority)
		}
		if heap.Size() == 0 {
			assert.Equal(t, Seq1LastMinimum, min.Priority)
		}
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < len(NumberSequence1); i++ { heap.Enqueue(NumberSequence1[i]) } var min *Entry var err error for heap.Size() > 0 { min, err = heap.DequeueMin() require.NoError(t, err) if heap.Size() == 199 { assert.Equal(t, Seq1FirstMinimum, min.Priority) } if heap.Size() == 197 { assert.Equal(t, Seq1ThirdMinimum, min.Priority) } if heap.Size() == 195 { assert.Equal(t, Seq1FifthMinimum, min.Priority) } if heap.Size() == 0 { assert.Equal(t, Seq1LastMinimum, min.Priority) } } }]}
{Id:19 FileId:72 StartLine:152 StartColumn:1 EndLine:161 EndColumn:2 Name:TestFibHeap_Enqueue_Min Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence1); i++ {
		heap.Enqueue(NumberSequence1[i])
	}

	min, err := heap.Min()
	require.NoError(t, err)
	assert.Equal(t, Seq1FirstMinimum, min.Priority)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < len(NumberSequence1); i++ { heap.Enqueue(NumberSequence1[i]) } min, err := heap.Min() require.NoError(t, err) assert.Equal(t, Seq1FirstMinimum, min.Priority) }]}
{Id:20 FileId:72 StartLine:163 StartColumn:1 EndLine:176 EndColumn:2 Name:TestFibHeap_Min_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	heap.Enqueue(0)
	min, err := heap.DequeueMin()
	require.NoError(t, err)

	min, err = heap.Min()

	assert.EqualError(t, err, "Trying to get minimum element of empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(0) min, err := heap.DequeueMin() require.NoError(t, err) min, err = heap.Min() assert.EqualError(t, err, "Trying to get minimum element of empty heap") assert.Nil(t, min) }]}
{Id:21 FileId:72 StartLine:178 StartColumn:1 EndLine:185 EndColumn:2 Name:TestFibHeap_DequeueMin_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	min, err := heap.DequeueMin()

	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot dequeue minimum of empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() min, err := heap.DequeueMin() assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot dequeue minimum of empty heap") assert.Nil(t, min) }]}
{Id:22 FileId:72 StartLine:187 StartColumn:1 EndLine:219 EndColumn:2 Name:TestEnqueueDecreaseKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	var e1, e2, e3 *Entry
	for i := 0; i < len(NumberSequence2); i++ {
		if NumberSequence2[i] == Seq2DecreaseKey1Orig {
			e1 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey2Orig {
			e2 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey3Orig {
			e3 = heap.Enqueue(NumberSequence2[i])
		} else {
			heap.Enqueue(NumberSequence2[i])
		}
	}

	require.NotNil(t, e1)
	require.NotNil(t, e2)
	require.NotNil(t, e3)

	_, err := heap.DecreaseKey(e1, Seq2DecreaseKey1Trgt)
	require.NoError(t, err)
	_, err = heap.DecreaseKey(e2, Seq2DecreaseKey2Trgt)
	require.NoError(t, err)
	_, err = heap.DecreaseKey(e3, Seq2DecreaseKey3Trgt)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequence2Sorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequence2Sorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() var e1, e2, e3 *Entry for i := 0; i < len(NumberSequence2); i++ { if NumberSequence2[i] == Seq2DecreaseKey1Orig { e1 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey2Orig { e2 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey3Orig { e3 = heap.Enqueue(NumberSequence2[i]) } else { heap.Enqueue(NumberSequence2[i]) } } require.NotNil(t, e1) require.NotNil(t, e2) require.NotNil(t, e3) _, err := heap.DecreaseKey(e1, Seq2DecreaseKey1Trgt) require.NoError(t, err) _, err = heap.DecreaseKey(e2, Seq2DecreaseKey2Trgt) require.NoError(t, err) _, err = heap.DecreaseKey(e3, Seq2DecreaseKey3Trgt) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequence2Sorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequence2Sorted[i], min.Priority) } }]}
{Id:23 FileId:72 StartLine:221 StartColumn:1 EndLine:233 EndColumn:2 Name:TestFibHeap_DecreaseKey_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	elem := heap.Enqueue(15)
	heap.DequeueMin()

	min, err := heap.DecreaseKey(elem, 0)

	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot decrease key in an empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() elem := heap.Enqueue(15) heap.DequeueMin() min, err := heap.DecreaseKey(elem, 0) assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot decrease key in an empty heap") assert.Nil(t, min) }]}
{Id:24 FileId:72 StartLine:235 StartColumn:1 EndLine:243 EndColumn:2 Name:TestFibHeap_DecreaseKey_NilNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(1)
	min, err := heap.DecreaseKey(nil, 0)

	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "Cannot decrease key: given node is nil")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(1) min, err := heap.DecreaseKey(nil, 0) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "Cannot decrease key: given node is nil") assert.Nil(t, min) }]}
{Id:25 FileId:72 StartLine:245 StartColumn:1 EndLine:252 EndColumn:2 Name:TestFibHeap_DecreaseKey_LargerNewPriority Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(1)
	min, err := heap.DecreaseKey(node, 20)

	assert.EqualError(t, err, "The given new priority: 20, is larger than or equal to the old: 1")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(1) min, err := heap.DecreaseKey(node, 20) assert.EqualError(t, err, "The given new priority: 20, is larger than or equal to the old: 1") assert.Nil(t, min) }]}
{Id:26 FileId:72 StartLine:254 StartColumn:1 EndLine:288 EndColumn:2 Name:TestEnqueueDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	var e1, e2, e3 *Entry
	for i := 0; i < len(NumberSequence2); i++ {
		if NumberSequence2[i] == Seq2DecreaseKey1Orig {
			e1 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey2Orig {
			e2 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey3Orig {
			e3 = heap.Enqueue(NumberSequence2[i])
		} else {
			heap.Enqueue(NumberSequence2[i])
		}
	}

	assert.NotNil(t, e1)
	assert.NotNil(t, e2)
	assert.NotNil(t, e3)

	var err error

	err = heap.Delete(e1)
	require.NoError(t, err)
	err = heap.Delete(e2)
	require.NoError(t, err)
	err = heap.Delete(e3)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequence2Deleted3ElemSorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequence2Deleted3ElemSorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() var e1, e2, e3 *Entry for i := 0; i < len(NumberSequence2); i++ { if NumberSequence2[i] == Seq2DecreaseKey1Orig { e1 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey2Orig { e2 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey3Orig { e3 = heap.Enqueue(NumberSequence2[i]) } else { heap.Enqueue(NumberSequence2[i]) } } assert.NotNil(t, e1) assert.NotNil(t, e2) assert.NotNil(t, e3) var err error err = heap.Delete(e1) require.NoError(t, err) err = heap.Delete(e2) require.NoError(t, err) err = heap.Delete(e3) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequence2Deleted3ElemSorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequence2Deleted3ElemSorted[i], min.Priority) } }]}
{Id:27 FileId:72 StartLine:290 StartColumn:1 EndLine:300 EndColumn:2 Name:TestFibHeap_Delete_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	elem := heap.Enqueue(15)
	heap.DequeueMin()

	err := heap.Delete(elem)
	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot delete element from an empty heap")
} PrettyPrintBody:[{ heap := NewFloatFibHeap() elem := heap.Enqueue(15) heap.DequeueMin() err := heap.Delete(elem) assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot delete element from an empty heap") }]}
{Id:28 FileId:72 StartLine:302 StartColumn:1 EndLine:308 EndColumn:2 Name:TestFibHeap_Delete_NilNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(1)
	err := heap.Delete(nil)
	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "Cannot delete node: given node is nil")
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(1) err := heap.Delete(nil) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "Cannot delete node: given node is nil") }]}
{Id:29 FileId:72 StartLine:310 StartColumn:1 EndLine:330 EndColumn:2 Name:TestMerge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence3); i++ {
		heap1.Enqueue(NumberSequence3[i])
	}

	heap2 := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence4); i++ {
		heap1.Enqueue(NumberSequence4[i])
	}

	heap, err := heap1.Merge(&heap2)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequenceMerged3And4Sorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequenceMerged3And4Sorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() for i := 0; i < len(NumberSequence3); i++ { heap1.Enqueue(NumberSequence3[i]) } heap2 := NewFloatFibHeap() for i := 0; i < len(NumberSequence4); i++ { heap1.Enqueue(NumberSequence4[i]) } heap, err := heap1.Merge(&heap2) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequenceMerged3And4Sorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequenceMerged3And4Sorted[i], min.Priority) } }]}
{Id:30 FileId:72 StartLine:332 StartColumn:1 EndLine:339 EndColumn:2 Name:TestFibHeap_Merge_NilHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	var heap FloatingFibonacciHeap
	heap = NewFloatFibHeap()
	newHeap, err := heap.Merge(nil)
	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "One of the heaps to merge is nil. Cannot merge")
	assert.Equal(t, newHeap, FloatingFibonacciHeap{})
} PrettyPrintBody:[{ var heap FloatingFibonacciHeap heap = NewFloatFibHeap() newHeap, err := heap.Merge(nil) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "One of the heaps to merge is nil. Cannot merge") assert.Equal(t, newHeap, FloatingFibonacciHeap{}) }]}
{Id:31 FileId:72 StartLine:361 StartColumn:1 EndLine:368 EndColumn:2 Name:BenchmarkFibHeap_Enqueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{

	heap := NewFloatFibHeap()

	for i := 0; i < b.N; i++ {
		heap.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < b.N; i++ { heap.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) } }]}
{Id:32 FileId:72 StartLine:371 StartColumn:1 EndLine:386 EndColumn:2 Name:BenchmarkFibHeap_DequeueMin Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{

	heap := NewFloatFibHeap()
	N := 1000000

	slice := make([]float64, 0, N)
	for i := 0; i < N; i++ {
		slice = append(slice, 2*1E10*(rand.Float64()-0.5))
		heap.Enqueue(slice[i])
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		heap.DequeueMin()
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 1000000 slice := make([]float64, 0, N) for i := 0; i < N; i++ { slice = append(slice, 2*1E10*(rand.Float64()-0.5)) heap.Enqueue(slice[i]) } b.ResetTimer() for i := 0; i < b.N; i++ { heap.DequeueMin() } }]}
{Id:33 FileId:72 StartLine:389 StartColumn:1 EndLine:410 EndColumn:2 Name:BenchmarkFibHeap_DecreaseKey Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	N := 10000000

	sliceFlt := make([]float64, 0, N)
	sliceE := make([]*Entry, 0, N)
	for i := 0; i < N; i++ {
		sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5))
		sliceE = append(sliceE, heap.Enqueue(sliceFlt[i]))
	}

	b.ResetTimer()
	offset := float64(2)
	for i := 0; i < b.N; i++ {

		if i%N == 0 && i > 0 {
			offset *= float64(i / N)
		}

		heap.DecreaseKey(sliceE[i%N], sliceFlt[i%N]-offset)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 10000000 sliceFlt := make([]float64, 0, N) sliceE := make([]*Entry, 0, N) for i := 0; i < N; i++ { sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5)) sliceE = append(sliceE, heap.Enqueue(sliceFlt[i])) } b.ResetTimer() offset := float64(2) for i := 0; i < b.N; i++ { if i%N == 0 && i > 0 { offset *= float64(i / N) } heap.DecreaseKey(sliceE[i%N], sliceFlt[i%N]-offset) } }]}
{Id:34 FileId:72 StartLine:413 StartColumn:1 EndLine:431 EndColumn:2 Name:BenchmarkFibHeap_Delete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	N := 1000000

	sliceFlt := make([]float64, 0, N)
	sliceE := make([]*Entry, 0, N)
	for i := 0; i < N; i++ {
		sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5))
		sliceE = append(sliceE, heap.Enqueue(sliceFlt[i]))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := heap.Delete(sliceE[i])
		assert.NoError(b, err)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 1000000 sliceFlt := make([]float64, 0, N) sliceE := make([]*Entry, 0, N) for i := 0; i < N; i++ { sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5)) sliceE = append(sliceE, heap.Enqueue(sliceFlt[i])) } b.ResetTimer() for i := 0; i < b.N; i++ { err := heap.Delete(sliceE[i]) assert.NoError(b, err) } }]}
{Id:35 FileId:72 StartLine:434 StartColumn:1 EndLine:444 EndColumn:2 Name:BenchmarkFibHeap_Merge Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	heap2 := NewFloatFibHeap()

	for i := 0; i < b.N; i++ {
		heap1.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
		heap2.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
		_, err := heap1.Merge(&heap2)
		assert.NoError(b, err)
	}
} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() heap2 := NewFloatFibHeap() for i := 0; i < b.N; i++ { heap1.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) heap2.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) _, err := heap1.Merge(&heap2) assert.NoError(b, err) } }]}
{Id:0 FileId:1 StartLine:19 StartColumn:1 EndLine:35 EndColumn:2 Name:intervalOverlaps Params:[{Name:n Type:*node} {Name:low Type:int64} {Name:interval Type:Interval} {Name:maxDimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if !overlaps(n.interval.HighAtDimension(1), high, n.interval.LowAtDimension(1), low) {
		return false
	}

	if interval == nil {
		return true
	}

	for i := uint64(2); i <= maxDimension; i++ {
		if !n.interval.OverlapsAtDimension(interval, i) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if !overlaps(n.interval.HighAtDimension(1), high, n.interval.LowAtDimension(1), low) { return false } if interval == nil { return true } for i := uint64(2); i <= maxDimension; i++ { if !n.interval.OverlapsAtDimension(interval, i) { return false } } return true }]}
{Id:1 FileId:1 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:overlaps Params:[{Name:high Type:int64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return high >= otherLow && low <= otherHigh
} PrettyPrintBody:[{ return high >= otherLow && low <= otherHigh }]}
{Id:2 FileId:1 StartLine:43 StartColumn:1 EndLine:53 EndColumn:2 Name:compare Params:[{Name:nodeLow Type:int64} {Name:nodeID Type:uint64}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if ivLow > nodeLow {
		return 1
	}

	if ivLow < nodeLow {
		return 0
	}

	return intFromBool(ivID > nodeID)
} PrettyPrintBody:[{ if ivLow > nodeLow { return 1 } if ivLow < nodeLow { return 0 } return intFromBool(ivID > nodeID) }]}
{Id:4 FileId:1 StartLine:63 StartColumn:1 EndLine:75 EndColumn:2 Name:query Params:[{Name:low Type:int64} {Name:interval Type:Interval} {Name:maxDimension Type:uint64} {Name:fn Type:func(node *node)}] Results:[] Receiver:0xc001580ca0 Body:{
	if n.children[0] != nil && overlaps(n.children[0].max, high, n.children[0].min, low) {
		n.children[0].query(low, high, interval, maxDimension, fn)
	}

	if intervalOverlaps(n, low, high, interval, maxDimension) {
		fn(n)
	}

	if n.children[1] != nil && overlaps(n.children[1].max, high, n.children[1].min, low) {
		n.children[1].query(low, high, interval, maxDimension, fn)
	}
} PrettyPrintBody:[{ if n.children[0] != nil && overlaps(n.children[0].max, high, n.children[0].min, low) { n.children[0].query(low, high, interval, maxDimension, fn) } if intervalOverlaps(n, low, high, interval, maxDimension) { fn(n) } if n.children[1] != nil && overlaps(n.children[1].max, high, n.children[1].min, low) { n.children[1].query(low, high, interval, maxDimension, fn) } }]}
{Id:5 FileId:1 StartLine:77 StartColumn:1 EndLine:85 EndColumn:2 Name:adjustRanges Params:[] Results:[] Receiver:0xc000118720 Body:{
	for i := 0; i <= 1; i++ {
		if n.children[i] != nil {
			n.children[i].adjustRanges()
		}
	}

	n.adjustRange()
} PrettyPrintBody:[{ for i := 0; i <= 1; i++ { if n.children[i] != nil { n.children[i].adjustRanges() } } n.adjustRange() }]}
{Id:6 FileId:1 StartLine:87 StartColumn:1 EndLine:90 EndColumn:2 Name:adjustRange Params:[] Results:[] Receiver:0xc001033380 Body:{
	setMin(n)
	setMax(n)
} PrettyPrintBody:[{ setMin(n) setMax(n) }]}
{Id:7 FileId:1 StartLine:92 StartColumn:1 EndLine:96 EndColumn:2 Name:newDummy Params:[] Results:[{Name: Type:node}] Receiver:<nil> Body:{
	return node{
		children: [2]*node{},
	}
} PrettyPrintBody:[{ return node{ children: [2]*node{}, } }]}
{Id:8 FileId:1 StartLine:98 StartColumn:1 EndLine:111 EndColumn:2 Name:newNode Params:[{Name:interval Type:Interval} {Name:min Type:int64} {Name:dimension Type:uint64}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	itn := &node{
		interval:	interval,
		min:		min,
		max:		max,
		red:		true,
		children:	[2]*node{},
	}
	if interval != nil {
		itn.id = interval.ID()
	}

	return itn
} PrettyPrintBody:[{ itn := &node{ interval:	interval, min:		min, max:		max, red:		true, children:	[2]*node{}, } if interval != nil { itn.id = interval.ID() } return itn }]}
{Id:10 FileId:1 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:Traverse Params:[{Name:fn Type:func(id Interval)}] Results:[] Receiver:0xc001580e40 Body:{
	nodes := []*node{t.root}

	for len(nodes) != 0 {
		c := nodes[len(nodes)-1]
		nodes = nodes[:len(nodes)-1]
		if c != nil {
			fn(c.interval)
			if c.children[0] != nil {
				nodes = append(nodes, c.children[0])
			}
			if c.children[1] != nil {
				nodes = append(nodes, c.children[1])
			}
		}
	}
} PrettyPrintBody:[{ nodes := []*node{t.root} for len(nodes) != 0 { c := nodes[len(nodes)-1] nodes = nodes[:len(nodes)-1] if c != nil { fn(c.interval) if c.children[0] != nil { nodes = append(nodes, c.children[0]) } if c.children[1] != nil { nodes = append(nodes, c.children[1]) } } } }]}
{Id:11 FileId:1 StartLine:137 StartColumn:1 EndLine:140 EndColumn:2 Name:resetDummy Params:[] Results:[] Receiver:0xc001409b00 Body:{
	tree.dummy.children[0], tree.dummy.children[1] = nil, nil
	tree.dummy.red = false
} PrettyPrintBody:[{ tree.dummy.children[0], tree.dummy.children[1] = nil, nil tree.dummy.red = false }]}
{Id:12 FileId:1 StartLine:143 StartColumn:1 EndLine:145 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000a8a160 Body:{
	return tree.number
} PrettyPrintBody:[{ return tree.number }]}
{Id:13 FileId:1 StartLine:148 StartColumn:1 EndLine:219 EndColumn:2 Name:add Params:[{Name:iv Type:Interval}] Results:[] Receiver:0xc0016025c0 Body:{
	if tree.root == nil {
		tree.root = newNode(
			iv, iv.LowAtDimension(1),
			iv.HighAtDimension(1),
			1,
		)
		tree.root.red = false
		tree.number++
		return
	}

	tree.resetDummy()
	var (
		dummy			= tree.dummy
		parent, grandParent	*node
		node			= tree.root
		dir, last		int
		otherLast		= 1
		id			= iv.ID()
		max			= iv.HighAtDimension(1)
		ivLow			= iv.LowAtDimension(1)
		helper			= &dummy
	)

	helper.children[1] = tree.root
	for {
		if node == nil {
			node = newNode(iv, ivLow, max, 1)
			parent.children[dir] = node
			tree.number++
		} else if isRed(node.children[0]) && isRed(node.children[1]) {
			node.red = true
			node.children[0].red = false
			node.children[1].red = false
		}
		if max > node.max {
			node.max = max
		}

		if ivLow < node.min {
			node.min = ivLow
		}

		if isRed(parent) && isRed(node) {
			localDir := intFromBool(helper.children[1] == grandParent)

			if node == parent.children[last] {
				helper.children[localDir] = rotate(grandParent, otherLast)
			} else {
				helper.children[localDir] = doubleRotate(grandParent, otherLast)
			}
		}

		if node.id == id {
			break
		}

		last = dir
		otherLast = takeOpposite(last)
		dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id)

		if grandParent != nil {
			helper = grandParent
		}
		grandParent, parent, node = parent, node, node.children[dir]
	}

	tree.root = dummy.children[1]
	tree.root.red = false
} PrettyPrintBody:[{ if tree.root == nil { tree.root = newNode( iv, iv.LowAtDimension(1), iv.HighAtDimension(1), 1, ) tree.root.red = false tree.number++ return } tree.resetDummy() var ( dummy			= tree.dummy parent, grandParent	*node node			= tree.root dir, last		int otherLast		= 1 id			= iv.ID() max			= iv.HighAtDimension(1) ivLow			= iv.LowAtDimension(1) helper			= &dummy ) helper.children[1] = tree.root for { if node == nil { node = newNode(iv, ivLow, max, 1) parent.children[dir] = node tree.number++ } else if isRed(node.children[0]) && isRed(node.children[1]) { node.red = true node.children[0].red = false node.children[1].red = false } if max > node.max { node.max = max } if ivLow < node.min { node.min = ivLow } if isRed(parent) && isRed(node) { localDir := intFromBool(helper.children[1] == grandParent) if node == parent.children[last] { helper.children[localDir] = rotate(grandParent, otherLast) } else { helper.children[localDir] = doubleRotate(grandParent, otherLast) } } if node.id == id { break } last = dir otherLast = takeOpposite(last) dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id) if grandParent != nil { helper = grandParent } grandParent, parent, node = parent, node, node.children[dir] } tree.root = dummy.children[1] tree.root.red = false }]}
{Id:14 FileId:1 StartLine:222 StartColumn:1 EndLine:226 EndColumn:2 Name:Add Params:[{Name:intervals Type:...Interval}] Results:[] Receiver:0xc001581620 Body:{
	for _, iv := range intervals {
		tree.add(iv)
	}
} PrettyPrintBody:[{ for _, iv := range intervals { tree.add(iv) } }]}
{Id:15 FileId:1 StartLine:229 StartColumn:1 EndLine:307 EndColumn:2 Name:delete Params:[{Name:iv Type:Interval}] Results:[] Receiver:0xc001581660 Body:{
	if tree.root == nil {
		return
	}

	tree.resetDummy()
	var (
		dummy				= tree.dummy
		found, parent, grandParent	*node
		last, otherDir, otherLast	int
		id				= iv.ID()
		dir				= 1
		node				= &dummy
		ivLow				= iv.LowAtDimension(1)
	)

	node.children[1] = tree.root
	for node.children[dir] != nil {
		last = dir
		otherLast = takeOpposite(last)

		grandParent, parent, node = parent, node, node.children[dir]

		dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id)
		otherDir = takeOpposite(dir)

		if node.id == id {
			found = node
		}

		if !isRed(node) && !isRed(node.children[dir]) {
			if isRed(node.children[otherDir]) {
				parent.children[last] = rotate(node, dir)
				parent = parent.children[last]
			} else if !isRed(node.children[otherDir]) {
				t := parent.children[otherLast]

				if t != nil {
					if !isRed(t.children[otherLast]) && !isRed(t.children[last]) {
						parent.red = false
						node.red = true
						t.red = true
					} else {
						localDir := intFromBool(grandParent.children[1] == parent)

						if isRed(t.children[last]) {
							grandParent.children[localDir] = doubleRotate(
								parent, last,
							)
						} else if isRed(t.children[otherLast]) {
							grandParent.children[localDir] = rotate(
								parent, last,
							)
						}

						node.red = true
						grandParent.children[localDir].red = true
						grandParent.children[localDir].children[0].red = false
						grandParent.children[localDir].children[1].red = false
					}
				}
			}
		}
	}

	if found != nil {
		tree.number--
		found.interval, found.max, found.min, found.id = node.interval, node.max, node.min, node.id
		parentDir := intFromBool(parent.children[1] == node)
		childDir := intFromBool(node.children[0] == nil)

		parent.children[parentDir] = node.children[childDir]
	}

	tree.root = dummy.children[1]
	if tree.root != nil {
		tree.root.red = false
	}
} PrettyPrintBody:[{ if tree.root == nil { return } tree.resetDummy() var ( dummy				= tree.dummy found, parent, grandParent	*node last, otherDir, otherLast	int id				= iv.ID() dir				= 1 node				= &dummy ivLow				= iv.LowAtDimension(1) ) node.children[1] = tree.root for node.children[dir] != nil { last = dir otherLast = takeOpposite(last) grandParent, parent, node = parent, node, node.children[dir] dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id) otherDir = takeOpposite(dir) if node.id == id { found = node } if !isRed(node) && !isRed(node.children[dir]) { if isRed(node.children[otherDir]) { parent.children[last] = rotate(node, dir) parent = parent.children[last] } else if !isRed(node.children[otherDir]) { t := parent.children[otherLast] if t != nil { if !isRed(t.children[otherLast]) && !isRed(t.children[last]) { parent.red = false node.red = true t.red = true } else { localDir := intFromBool(grandParent.children[1] == parent) if isRed(t.children[last]) { grandParent.children[localDir] = doubleRotate( parent, last, ) } else if isRed(t.children[otherLast]) { grandParent.children[localDir] = rotate( parent, last, ) } node.red = true grandParent.children[localDir].red = true grandParent.children[localDir].children[0].red = false grandParent.children[localDir].children[1].red = false } } } } } if found != nil { tree.number-- found.interval, found.max, found.min, found.id = node.interval, node.max, node.min, node.id parentDir := intFromBool(parent.children[1] == node) childDir := intFromBool(node.children[0] == nil) parent.children[parentDir] = node.children[childDir] } tree.root = dummy.children[1] if tree.root != nil { tree.root.red = false } }]}
{Id:16 FileId:1 StartLine:310 StartColumn:1 EndLine:317 EndColumn:2 Name:Delete Params:[{Name:intervals Type:...Interval}] Results:[] Receiver:0xc0016037a0 Body:{
	for _, iv := range intervals {
		tree.delete(iv)
	}
	if tree.root != nil {
		tree.root.adjustRanges()
	}
} PrettyPrintBody:[{ for _, iv := range intervals { tree.delete(iv) } if tree.root != nil { tree.root.adjustRanges() } }]}
{Id:17 FileId:1 StartLine:322 StartColumn:1 EndLine:338 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Intervals}] Receiver:0xc0001e68e0 Body:{
	if tree.root == nil {
		return nil
	}

	var (
		Intervals	= intervalsPool.Get().(Intervals)
		ivLow		= interval.LowAtDimension(1)
		ivHigh		= interval.HighAtDimension(1)
	)

	tree.root.query(ivLow, ivHigh, interval, tree.maxDimension, func(node *node) {
		Intervals = append(Intervals, node.interval)
	})

	return Intervals
} PrettyPrintBody:[{ if tree.root == nil { return nil } var ( Intervals	= intervalsPool.Get().(Intervals) ivLow		= interval.LowAtDimension(1) ivHigh		= interval.HighAtDimension(1) ) tree.root.query(ivLow, ivHigh, interval, tree.maxDimension, func(node *node) { Intervals = append(Intervals, node.interval) }) return Intervals }]}
{Id:18 FileId:1 StartLine:340 StartColumn:1 EndLine:342 EndColumn:2 Name:isRed Params:[{Name:node Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return node != nil && node.red
} PrettyPrintBody:[{ return node != nil && node.red }]}
{Id:19 FileId:1 StartLine:344 StartColumn:1 EndLine:354 EndColumn:2 Name:setMax Params:[{Name:parent Type:*node}] Results:[] Receiver:<nil> Body:{
	parent.max = parent.interval.HighAtDimension(1)

	if parent.children[0] != nil && parent.children[0].max > parent.max {
		parent.max = parent.children[0].max
	}

	if parent.children[1] != nil && parent.children[1].max > parent.max {
		parent.max = parent.children[1].max
	}
} PrettyPrintBody:[{ parent.max = parent.interval.HighAtDimension(1) if parent.children[0] != nil && parent.children[0].max > parent.max { parent.max = parent.children[0].max } if parent.children[1] != nil && parent.children[1].max > parent.max { parent.max = parent.children[1].max } }]}
{Id:20 FileId:1 StartLine:356 StartColumn:1 EndLine:369 EndColumn:2 Name:setMin Params:[{Name:parent Type:*node}] Results:[] Receiver:<nil> Body:{
	parent.min = parent.interval.LowAtDimension(1)
	if parent.children[0] != nil && parent.children[0].min < parent.min {
		parent.min = parent.children[0].min
	}

	if parent.children[1] != nil && parent.children[1].min < parent.min {
		parent.min = parent.children[1].min
	}

	if parent.interval.LowAtDimension(1) < parent.min {
		parent.min = parent.interval.LowAtDimension(1)
	}
} PrettyPrintBody:[{ parent.min = parent.interval.LowAtDimension(1) if parent.children[0] != nil && parent.children[0].min < parent.min { parent.min = parent.children[0].min } if parent.children[1] != nil && parent.children[1].min < parent.min { parent.min = parent.children[1].min } if parent.interval.LowAtDimension(1) < parent.min { parent.min = parent.interval.LowAtDimension(1) } }]}
{Id:21 FileId:1 StartLine:371 StartColumn:1 EndLine:386 EndColumn:2 Name:rotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	child := parent.children[otherDir]
	parent.children[otherDir] = child.children[dir]
	child.children[dir] = parent
	parent.red = true
	child.red = false
	child.max = parent.max
	setMax(child)
	setMax(parent)
	setMin(child)
	setMin(parent)

	return child
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) child := parent.children[otherDir] parent.children[otherDir] = child.children[dir] child.children[dir] = parent parent.red = true child.red = false child.max = parent.max setMax(child) setMax(parent) setMin(child) setMin(parent) return child }]}
{Id:22 FileId:1 StartLine:388 StartColumn:1 EndLine:393 EndColumn:2 Name:doubleRotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	parent.children[otherDir] = rotate(parent.children[otherDir], otherDir)
	return rotate(parent, dir)
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) parent.children[otherDir] = rotate(parent.children[otherDir], otherDir) return rotate(parent, dir) }]}
{Id:23 FileId:1 StartLine:395 StartColumn:1 EndLine:401 EndColumn:2 Name:intFromBool Params:[{Name:value Type:bool}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if value {
		return 1
	}

	return 0
} PrettyPrintBody:[{ if value { return 1 } return 0 }]}
{Id:24 FileId:1 StartLine:403 StartColumn:1 EndLine:405 EndColumn:2 Name:takeOpposite Params:[{Name:value Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	return 1 - value
} PrettyPrintBody:[{ return 1 - value }]}
{Id:25 FileId:1 StartLine:407 StartColumn:1 EndLine:412 EndColumn:2 Name:newTree Params:[{Name:maxDimension Type:uint64}] Results:[{Name: Type:*tree}] Receiver:<nil> Body:{
	return &tree{
		maxDimension:	maxDimension,
		dummy:		newDummy(),
	}
} PrettyPrintBody:[{ return &tree{ maxDimension:	maxDimension, dummy:		newDummy(), } }]}
{Id:26 FileId:1 StartLine:416 StartColumn:1 EndLine:418 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:Tree}] Receiver:<nil> Body:{
	return newTree(dimensions)
} PrettyPrintBody:[{ return newTree(dimensions) }]}
{Id:5 FileId:56 StartLine:45 StartColumn:1 EndLine:51 EndColumn:2 Name:dispose Params:[{Name:ptree Type:*ptree}] Results:[] Receiver:0xc0012622c0 Body:{
	if ptree.kbRing.Len() == ptree.kbRing.Cap() {
		return
	}
	kb.key, kb.left, kb.right = nil, nil, nil
	ptree.kbRing.Put(kb)
} PrettyPrintBody:[{ if ptree.kbRing.Len() == ptree.kbRing.Cap() { return } kb.key, kb.left, kb.right = nil, nil, nil ptree.kbRing.Put(kb) }]}
{Id:7 FileId:56 StartLine:71 StartColumn:1 EndLine:117 EndColumn:2 Name:checkAndRun Params:[{Name:action Type:action}] Results:[] Receiver:0xc001238920 Body:{
	if ptree.actions.Len() > 0 {
		if action != nil {
			ptree.actions.Put(action)
		}
		if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) {
			var a interface{}
			var err error
			for ptree.actions.Len() > 0 {
				a, err = ptree.actions.Get()
				if err != nil {
					return
				}
				ptree.cache = append(ptree.cache, a)
				if uint64(len(ptree.cache)) >= ptree.bufferSize {
					break
				}
			}

			go ptree.operationRunner(ptree.cache, true)
		}
	} else if action != nil {
		if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) {
			switch action.operation() {
			case get:
				ptree.read(action)
				action.complete()
				ptree.reset()
			case add, remove:
				if len(action.keys()) > multiThreadAt {
					ptree.operationRunner(interfaces{action}, true)
				} else {
					ptree.operationRunner(interfaces{action}, false)
				}
			case apply:
				q := action.(*applyAction)
				n := getParent(ptree.root, q.start)
				ptree.apply(n, q)
				q.complete()
				ptree.reset()
			}
		} else {
			ptree.actions.Put(action)
			ptree.checkAndRun(nil)
		}
	}
} PrettyPrintBody:[{ if ptree.actions.Len() > 0 { if action != nil { ptree.actions.Put(action) } if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) { var a interface{} var err error for ptree.actions.Len() > 0 { a, err = ptree.actions.Get() if err != nil { return } ptree.cache = append(ptree.cache, a) if uint64(len(ptree.cache)) >= ptree.bufferSize { break } } go ptree.operationRunner(ptree.cache, true) } } else if action != nil { if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) { switch action.operation() { case get: ptree.read(action) action.complete() ptree.reset() case add, remove: if len(action.keys()) > multiThreadAt { ptree.operationRunner(interfaces{action}, true) } else { ptree.operationRunner(interfaces{action}, false) } case apply: q := action.(*applyAction) n := getParent(ptree.root, q.start) ptree.apply(n, q) q.complete() ptree.reset() } } else { ptree.actions.Put(action) ptree.checkAndRun(nil) } } }]}
{Id:8 FileId:56 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:init Params:[{Name:bufferSize Type:uint64}] Results:[] Receiver:0xc0012468c0 Body:{
	ptree.bufferSize = bufferSize
	ptree.ary = ary
	ptree.cache = make([]interface{}, 0, bufferSize)
	ptree.root = newNode(true, newKeys(ary), newNodes(ary))
	ptree.actions = queue.NewRingBuffer(ptree.bufferSize)
	ptree.kbRing = queue.NewRingBuffer(1024)
	for i := uint64(0); i < ptree.kbRing.Cap(); i++ {
		ptree.kbRing.Put(&keyBundle{})
	}
	ptree.disposeChannel = make(chan bool)
	ptree.mpChannel = make(chan map[*node][]*keyBundle, 1024)
	var wg sync.WaitGroup
	wg.Add(1)
	go ptree.disposer(&wg)
	wg.Wait()
} PrettyPrintBody:[{ ptree.bufferSize = bufferSize ptree.ary = ary ptree.cache = make([]interface{}, 0, bufferSize) ptree.root = newNode(true, newKeys(ary), newNodes(ary)) ptree.actions = queue.NewRingBuffer(ptree.bufferSize) ptree.kbRing = queue.NewRingBuffer(1024) for i := uint64(0); i < ptree.kbRing.Cap(); i++ { ptree.kbRing.Put(&keyBundle{}) } ptree.disposeChannel = make(chan bool) ptree.mpChannel = make(chan map[*node][]*keyBundle, 1024) var wg sync.WaitGroup wg.Add(1) go ptree.disposer(&wg) wg.Wait() }]}
{Id:9 FileId:56 StartLine:137 StartColumn:1 EndLine:148 EndColumn:2 Name:newKeyBundle Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:*keyBundle}] Receiver:0xc000a23860 Body:{
	if ptree.kbRing.Len() == 0 {
		return &keyBundle{key: key}
	}
	ifc, err := ptree.kbRing.Get()
	if err != nil {
		return nil
	}
	kb := ifc.(*keyBundle)
	kb.key = key
	return kb
} PrettyPrintBody:[{ if ptree.kbRing.Len() == 0 { return &keyBundle{key: key} } ifc, err := ptree.kbRing.Get() if err != nil { return nil } kb := ifc.(*keyBundle) kb.key = key return kb }]}
{Id:10 FileId:56 StartLine:150 StartColumn:1 EndLine:158 EndColumn:2 Name:operationRunner Params:[{Name:xns Type:interfaces} {Name:threaded Type:bool}] Results:[] Receiver:0xc000e7ffe0 Body:{
	writeOperations, deleteOperations, toComplete := ptree.fetchKeys(xns, threaded)
	ptree.recursiveMutate(writeOperations, deleteOperations, false, threaded)
	for _, a := range toComplete {
		a.complete()
	}

	ptree.reset()
} PrettyPrintBody:[{ writeOperations, deleteOperations, toComplete := ptree.fetchKeys(xns, threaded) ptree.recursiveMutate(writeOperations, deleteOperations, false, threaded) for _, a := range toComplete { a.complete() } ptree.reset() }]}
{Id:11 FileId:56 StartLine:160 StartColumn:1 EndLine:174 EndColumn:2 Name:read Params:[{Name:action Type:action}] Results:[] Receiver:0xc001309840 Body:{
	for i, k := range action.keys() {
		n := getParent(ptree.root, k)
		if n == nil {
			action.keys()[i] = nil
		} else {
			key, _ := n.keys.withPosition(k)
			if key == nil {
				action.keys()[i] = nil
			} else {
				action.keys()[i] = key
			}
		}
	}
} PrettyPrintBody:[{ for i, k := range action.keys() { n := getParent(ptree.root, k) if n == nil { action.keys()[i] = nil } else { key, _ := n.keys.withPosition(k) if key == nil { action.keys()[i] = nil } else { action.keys()[i] = key } } } }]}
{Id:12 FileId:56 StartLine:176 StartColumn:1 EndLine:205 EndColumn:2 Name:fetchKeys Params:[{Name:xns Type:interfaces} {Name:inParallel Type:bool}] Results:[{Name: Type:map[*node][]*keyBundle} {Name: Type:map[*node][]*keyBundle} {Name: Type:actions}] Receiver:0xc001602680 Body:{
	if inParallel {
		ptree.fetchKeysInParallel(xns)
	} else {
		ptree.fetchKeysInSerial(xns)
	}

	writeOperations := make(map[*node][]*keyBundle)
	deleteOperations := make(map[*node][]*keyBundle)
	toComplete := make(actions, 0, len(xns)/2)
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add:
			for i, n := range action.nodes() {
				writeOperations[n] = append(writeOperations[n], ptree.newKeyBundle(action.keys()[i]))
			}
			toComplete = append(toComplete, action)
		case remove:
			for i, n := range action.nodes() {
				deleteOperations[n] = append(deleteOperations[n], ptree.newKeyBundle(action.keys()[i]))
			}
			toComplete = append(toComplete, action)
		case get, apply:
			action.complete()
		}
	}

	return writeOperations, deleteOperations, toComplete
} PrettyPrintBody:[{ if inParallel { ptree.fetchKeysInParallel(xns) } else { ptree.fetchKeysInSerial(xns) } writeOperations := make(map[*node][]*keyBundle) deleteOperations := make(map[*node][]*keyBundle) toComplete := make(actions, 0, len(xns)/2) for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add: for i, n := range action.nodes() { writeOperations[n] = append(writeOperations[n], ptree.newKeyBundle(action.keys()[i])) } toComplete = append(toComplete, action) case remove: for i, n := range action.nodes() { deleteOperations[n] = append(deleteOperations[n], ptree.newKeyBundle(action.keys()[i])) } toComplete = append(toComplete, action) case get, apply: action.complete() } } return writeOperations, deleteOperations, toComplete }]}
{Id:13 FileId:56 StartLine:207 StartColumn:1 EndLine:224 EndColumn:2 Name:apply Params:[{Name:n Type:*node} {Name:aa Type:*applyAction}] Results:[] Receiver:0xc001602ac0 Body:{
	i := n.search(aa.start)
	if i == n.keys.len() {
		return
	}

	var k common.Comparator
	for n != nil {
		for j := i; j < n.keys.len(); j++ {
			k = n.keys.byPosition(j)
			if aa.stop.Compare(k) < 1 || !aa.fn(k) {
				return
			}
		}
		n = n.right
		i = 0
	}
} PrettyPrintBody:[{ i := n.search(aa.start) if i == n.keys.len() { return } var k common.Comparator for n != nil { for j := i; j < n.keys.len(); j++ { k = n.keys.byPosition(j) if aa.stop.Compare(k) < 1 || !aa.fn(k) { return } } n = n.right i = 0 } }]}
{Id:14 FileId:56 StartLine:226 StartColumn:1 EndLine:237 EndColumn:2 Name:disposer Params:[{Name:wg Type:*sync.WaitGroup}] Results:[] Receiver:0xc001602b20 Body:{
	wg.Done()

	for {
		select {
		case mp := <-ptree.mpChannel:
			ptree.cleanMap(mp)
		case <-ptree.disposeChannel:
			return
		}
	}
} PrettyPrintBody:[{ wg.Done() for { select { case mp := <-ptree.mpChannel: ptree.cleanMap(mp) case <-ptree.disposeChannel: return } } }]}
{Id:15 FileId:56 StartLine:239 StartColumn:1 EndLine:264 EndColumn:2 Name:fetchKeysInSerial Params:[{Name:xns Type:interfaces}] Results:[] Receiver:0xc001602b80 Body:{
	for _, ifc := range xns {
		action := ifc.(action)
		for i, key := range action.keys() {
			n := getParent(ptree.root, key)
			switch action.operation() {
			case add, remove:
				action.addNode(int64(i), n)
			case get:
				if n == nil {
					action.keys()[i] = nil
				} else {
					k, _ := n.keys.withPosition(key)
					if k == nil {
						action.keys()[i] = nil
					} else {
						action.keys()[i] = k
					}
				}
			case apply:
				q := action.(*applyAction)
				ptree.apply(n, q)
			}
		}
	}
} PrettyPrintBody:[{ for _, ifc := range xns { action := ifc.(action) for i, key := range action.keys() { n := getParent(ptree.root, key) switch action.operation() { case add, remove: action.addNode(int64(i), n) case get: if n == nil { action.keys()[i] = nil } else { k, _ := n.keys.withPosition(key) if k == nil { action.keys()[i] = nil } else { action.keys()[i] = k } } case apply: q := action.(*applyAction) ptree.apply(n, q) } } } }]}
{Id:16 FileId:56 StartLine:266 StartColumn:1 EndLine:274 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001602d40 Body:{
	for i := range ptree.cache {
		ptree.cache[i] = nil
	}

	ptree.cache = ptree.cache[:0]
	atomic.StoreUint64(&ptree.running, 0)
	ptree.checkAndRun(nil)
} PrettyPrintBody:[{ for i := range ptree.cache { ptree.cache[i] = nil } ptree.cache = ptree.cache[:0] atomic.StoreUint64(&ptree.running, 0) ptree.checkAndRun(nil) }]}
{Id:17 FileId:56 StartLine:276 StartColumn:1 EndLine:334 EndColumn:2 Name:fetchKeysInParallel Params:[{Name:xns Type:[]interface{}}] Results:[] Receiver:0xc001602de0 Body:{
	var forCache struct {
		i	int64
		buffer	[8]uint64
		js	[]int64
	}

	for j := 0; j < len(xns); j++ {
		forCache.js = append(forCache.js, -1)
	}
	numCPU := runtime.NumCPU()
	if numCPU > 1 {
		numCPU--
	}
	var wg sync.WaitGroup
	wg.Add(numCPU)

	for k := 0; k < numCPU; k++ {
		go func() {
			for {
				index := atomic.LoadInt64(&forCache.i)
				if index >= int64(len(xns)) {
					break
				}
				action := xns[index].(action)

				j := atomic.AddInt64(&forCache.js[index], 1)
				if j > int64(len(action.keys())) {
					continue
				} else if j == int64(len(action.keys())) {
					atomic.StoreInt64(&forCache.i, index+1)
					continue
				}

				n := getParent(ptree.root, action.keys()[j])
				switch action.operation() {
				case add, remove:
					action.addNode(j, n)
				case get:
					if n == nil {
						action.keys()[j] = nil
					} else {
						k, _ := n.keys.withPosition(action.keys()[j])
						if k == nil {
							action.keys()[j] = nil
						} else {
							action.keys()[j] = k
						}
					}
				case apply:
					q := action.(*applyAction)
					ptree.apply(n, q)
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
} PrettyPrintBody:[{ var forCache struct { i	int64 buffer	[8]uint64 js	[]int64 } for j := 0; j < len(xns); j++ { forCache.js = append(forCache.js, -1) } numCPU := runtime.NumCPU() if numCPU > 1 { numCPU-- } var wg sync.WaitGroup wg.Add(numCPU) for k := 0; k < numCPU; k++ { go func() { for { index := atomic.LoadInt64(&forCache.i) if index >= int64(len(xns)) { break } action := xns[index].(action) j := atomic.AddInt64(&forCache.js[index], 1) if j > int64(len(action.keys())) { continue } else if j == int64(len(action.keys())) { atomic.StoreInt64(&forCache.i, index+1) continue } n := getParent(ptree.root, action.keys()[j]) switch action.operation() { case add, remove: action.addNode(j, n) case get: if n == nil { action.keys()[j] = nil } else { k, _ := n.keys.withPosition(action.keys()[j]) if k == nil { action.keys()[j] = nil } else { action.keys()[j] = k } } case apply: q := action.(*applyAction) ptree.apply(n, q) } } wg.Done() }() } wg.Wait() }]}
{Id:18 FileId:56 StartLine:336 StartColumn:1 EndLine:353 EndColumn:2 Name:splitNode Params:[{Name:n Type:*node} {Name:nodes Type:*[]*node} {Name:keys Type:*common.Comparators}] Results:[] Receiver:0xc00095aaa0 Body:{
	if !n.needsSplit(ptree.ary) {
		return
	}

	length := n.keys.len()
	splitAt := ptree.ary - 1

	for i := splitAt; i < length; i += splitAt {
		offset := length - i
		k, left, right := n.split(offset, ptree.ary)
		left.right = right
		*keys = append(*keys, k)
		*nodes = append(*nodes, left, right)
		left.parent = parent
		right.parent = parent
	}
} PrettyPrintBody:[{ if !n.needsSplit(ptree.ary) { return } length := n.keys.len() splitAt := ptree.ary - 1 for i := splitAt; i < length; i += splitAt { offset := length - i k, left, right := n.split(offset, ptree.ary) left.right = right *keys = append(*keys, k) *nodes = append(*nodes, left, right) left.parent = parent right.parent = parent } }]}
{Id:19 FileId:56 StartLine:355 StartColumn:1 EndLine:389 EndColumn:2 Name:applyNode Params:[{Name:n Type:*node} {Name:adds Type:[]*keyBundle}] Results:[] Receiver:0xc0003e5420 Body:{
	for _, kb := range deletes {
		if n.keys.len() == 0 {
			break
		}

		deleted := n.keys.delete(kb.key)
		if deleted != nil {
			atomic.AddUint64(&ptree.number, ^uint64(0))
		}
	}

	for _, kb := range adds {
		if n.keys.len() == 0 {
			oldKey, _ := n.keys.insert(kb.key)
			if n.isLeaf && oldKey == nil {
				atomic.AddUint64(&ptree.number, 1)
			}
			if kb.left != nil {
				n.nodes.push(kb.left)
				n.nodes.push(kb.right)
			}
			continue
		}

		oldKey, index := n.keys.insert(kb.key)
		if n.isLeaf && oldKey == nil {
			atomic.AddUint64(&ptree.number, 1)
		}
		if kb.left != nil {
			n.nodes.replaceAt(index, kb.left)
			n.nodes.insertAt(index+1, kb.right)
		}
	}
} PrettyPrintBody:[{ for _, kb := range deletes { if n.keys.len() == 0 { break } deleted := n.keys.delete(kb.key) if deleted != nil { atomic.AddUint64(&ptree.number, ^uint64(0)) } } for _, kb := range adds { if n.keys.len() == 0 { oldKey, _ := n.keys.insert(kb.key) if n.isLeaf && oldKey == nil { atomic.AddUint64(&ptree.number, 1) } if kb.left != nil { n.nodes.push(kb.left) n.nodes.push(kb.right) } continue } oldKey, index := n.keys.insert(kb.key) if n.isLeaf && oldKey == nil { atomic.AddUint64(&ptree.number, 1) } if kb.left != nil { n.nodes.replaceAt(index, kb.left) n.nodes.insertAt(index+1, kb.right) } } }]}
{Id:20 FileId:56 StartLine:391 StartColumn:1 EndLine:397 EndColumn:2 Name:cleanMap Params:[{Name:op Type:map[*node][]*keyBundle}] Results:[] Receiver:0xc0001e64a0 Body:{
	for _, bundles := range op {
		for _, kb := range bundles {
			kb.dispose(ptree)
		}
	}
} PrettyPrintBody:[{ for _, bundles := range op { for _, kb := range bundles { kb.dispose(ptree) } } }]}
{Id:21 FileId:56 StartLine:399 StartColumn:1 EndLine:485 EndColumn:2 Name:recursiveMutate Params:[{Name:adds Type:map[*node][]*keyBundle} {Name:setRoot Type:bool}] Results:[] Receiver:0xc0000ed660 Body:{
	if len(adds) == 0 && len(deletes) == 0 {
		return
	}

	if setRoot && len(adds) > 1 {
		panic(`SHOULD ONLY HAVE ONE ROOT`)
	}

	ifs := make(interfaces, 0, len(adds))
	for n := range adds {
		if n.parent == nil {
			setRoot = true
		}
		ifs = append(ifs, n)
	}

	for n := range deletes {
		if n.parent == nil {
			setRoot = true
		}

		if _, ok := adds[n]; !ok {
			ifs = append(ifs, n)
		}
	}

	var dummyRoot *node
	if setRoot {
		dummyRoot = &node{
			keys:	newKeys(ptree.ary),
			nodes:	newNodes(ptree.ary),
		}
	}

	var write sync.Mutex
	nextLayerWrite := make(map[*node][]*keyBundle)
	nextLayerDelete := make(map[*node][]*keyBundle)

	var mutate func(interfaces, func(interface{}))
	if inParallel {
		mutate = executeInterfacesInParallel
	} else {
		mutate = executeInterfacesInSerial
	}

	mutate(ifs, func(ifc interface{}) {
		n := ifc.(*node)
		adds := adds[n]
		deletes := deletes[n]

		if len(adds) == 0 && len(deletes) == 0 {
			return
		}

		if setRoot {
			ptree.root = n
		}

		parent := n.parent
		if parent == nil {
			parent = dummyRoot
			setRoot = true
		}

		ptree.applyNode(n, adds, deletes)

		if n.needsSplit(ptree.ary) {
			keys := make(common.Comparators, 0, n.keys.len())
			nodes := make([]*node, 0, n.nodes.len())
			ptree.splitNode(n, parent, &nodes, &keys)
			write.Lock()
			for i, k := range keys {
				kb := ptree.newKeyBundle(k)
				kb.left = nodes[i*2]
				kb.right = nodes[i*2+1]
				nextLayerWrite[parent] = append(nextLayerWrite[parent], kb)
			}
			write.Unlock()
		}
	})

	ptree.mpChannel <- adds
	ptree.mpChannel <- deletes

	ptree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel)
} PrettyPrintBody:[{ if len(adds) == 0 && len(deletes) == 0 { return } if setRoot && len(adds) > 1 { panic(`SHOULD ONLY HAVE ONE ROOT`) } ifs := make(interfaces, 0, len(adds)) for n := range adds { if n.parent == nil { setRoot = true } ifs = append(ifs, n) } for n := range deletes { if n.parent == nil { setRoot = true } if _, ok := adds[n]; !ok { ifs = append(ifs, n) } } var dummyRoot *node if setRoot { dummyRoot = &node{ keys:	newKeys(ptree.ary), nodes:	newNodes(ptree.ary), } } var write sync.Mutex nextLayerWrite := make(map[*node][]*keyBundle) nextLayerDelete := make(map[*node][]*keyBundle) var mutate func(interfaces, func(interface{})) if inParallel { mutate = executeInterfacesInParallel } else { mutate = executeInterfacesInSerial } mutate(ifs, func(ifc interface{}) { n := ifc.(*node) adds := adds[n] deletes := deletes[n] if len(adds) == 0 && len(deletes) == 0 { return } if setRoot { ptree.root = n } parent := n.parent if parent == nil { parent = dummyRoot setRoot = true } ptree.applyNode(n, adds, deletes) if n.needsSplit(ptree.ary) { keys := make(common.Comparators, 0, n.keys.len()) nodes := make([]*node, 0, n.nodes.len()) ptree.splitNode(n, parent, &nodes, &keys) write.Lock() for i, k := range keys { kb := ptree.newKeyBundle(k) kb.left = nodes[i*2] kb.right = nodes[i*2+1] nextLayerWrite[parent] = append(nextLayerWrite[parent], kb) } write.Unlock() } }) ptree.mpChannel <- adds ptree.mpChannel <- deletes ptree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel) }]}
{Id:22 FileId:56 StartLine:488 StartColumn:1 EndLine:492 EndColumn:2 Name:Insert Params:[{Name:keys Type:...common.Comparator}] Results:[] Receiver:0xc0001e6c00 Body:{
	ia := newInsertAction(keys)
	ptree.checkAndRun(ia)
	ia.completer.Wait()
} PrettyPrintBody:[{ ia := newInsertAction(keys) ptree.checkAndRun(ia) ia.completer.Wait() }]}
{Id:23 FileId:56 StartLine:496 StartColumn:1 EndLine:500 EndColumn:2 Name:Delete Params:[{Name:keys Type:...common.Comparator}] Results:[] Receiver:0xc0001e6c40 Body:{
	ra := newRemoveAction(keys)
	ptree.checkAndRun(ra)
	ra.completer.Wait()
} PrettyPrintBody:[{ ra := newRemoveAction(keys) ptree.checkAndRun(ra) ra.completer.Wait() }]}
{Id:24 FileId:56 StartLine:503 StartColumn:1 EndLine:508 EndColumn:2 Name:Get Params:[{Name:keys Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0001e6c80 Body:{
	ga := newGetAction(keys)
	ptree.checkAndRun(ga)
	ga.completer.Wait()
	return ga.result
} PrettyPrintBody:[{ ga := newGetAction(keys) ptree.checkAndRun(ga) ga.completer.Wait() return ga.result }]}
{Id:25 FileId:56 StartLine:511 StartColumn:1 EndLine:513 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00019e940 Body:{
	return atomic.LoadUint64(&ptree.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&ptree.number) }]}
{Id:26 FileId:56 StartLine:518 StartColumn:1 EndLine:527 EndColumn:2 Name:Query Params:[{Name:start Type:common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0009926e0 Body:{
	cmps := make(common.Comparators, 0, 32)
	aa := newApplyAction(func(cmp common.Comparator) bool {
		cmps = append(cmps, cmp)
		return true
	}, start, stop)
	ptree.checkAndRun(aa)
	aa.completer.Wait()
	return cmps
} PrettyPrintBody:[{ cmps := make(common.Comparators, 0, 32) aa := newApplyAction(func(cmp common.Comparator) bool { cmps = append(cmps, cmp) return true }, start, stop) ptree.checkAndRun(aa) aa.completer.Wait() return cmps }]}
{Id:27 FileId:56 StartLine:531 StartColumn:1 EndLine:538 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0009928e0 Body:{
	if atomic.LoadUint64(&ptree.disposed) == 1 {
		return
	}
	ptree.actions.Dispose()
	atomic.StoreUint64(&ptree.disposed, 1)
	close(ptree.disposeChannel)
} PrettyPrintBody:[{ if atomic.LoadUint64(&ptree.disposed) == 1 { return } ptree.actions.Dispose() atomic.StoreUint64(&ptree.disposed, 1) close(ptree.disposeChannel) }]}
{Id:28 FileId:56 StartLine:540 StartColumn:1 EndLine:547 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc00095b880 Body:{
	println(`PRINTING TREE`)
	if ptree.root == nil {
		return
	}

	ptree.root.print(output)
} PrettyPrintBody:[{ println(`PRINTING TREE`) if ptree.root == nil { return } ptree.root.print(output) }]}
{Id:29 FileId:56 StartLine:549 StartColumn:1 EndLine:553 EndColumn:2 Name:newTree Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:*ptree}] Receiver:<nil> Body:{
	ptree := &ptree{}
	ptree.init(bufferSize, ary)
	return ptree
} PrettyPrintBody:[{ ptree := &ptree{} ptree.init(bufferSize, ary) return ptree }]}
{Id:30 FileId:56 StartLine:558 StartColumn:1 EndLine:560 EndColumn:2 Name:New Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:BTree}] Receiver:<nil> Body:{
	return newTree(bufferSize, ary)
} PrettyPrintBody:[{ return newTree(bufferSize, ary) }]}
{Id:1 FileId:99 StartLine:28 StartColumn:1 EndLine:43 EndColumn:2 Name:TestRingInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)
	assert.Equal(t, uint64(8), rb.Cap())

	err := rb.Put(5)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 5, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) assert.Equal(t, uint64(8), rb.Cap()) err := rb.Put(5) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 5, result) }]}
{Id:2 FileId:99 StartLine:45 StartColumn:1 EndLine:71 EndColumn:2 Name:TestRingMultipleInserts Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)

	err := rb.Put(1)
	if !assert.Nil(t, err) {
		return
	}

	err = rb.Put(2)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 1, result)

	result, err = rb.Get()
	if assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 2, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) err := rb.Put(1) if !assert.Nil(t, err) { return } err = rb.Put(2) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 1, result) result, err = rb.Get() if assert.Nil(t, err) { return } assert.Equal(t, 2, result) }]}
{Id:3 FileId:99 StartLine:73 StartColumn:1 EndLine:98 EndColumn:2 Name:TestIntertwinedGetAndPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)
	err := rb.Put(1)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 1, result)

	err = rb.Put(2)
	if !assert.Nil(t, err) {
		return
	}

	result, err = rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 2, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) err := rb.Put(1) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 1, result) err = rb.Put(2) if !assert.Nil(t, err) { return } result, err = rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 2, result) }]}
{Id:4 FileId:99 StartLine:100 StartColumn:1 EndLine:130 EndColumn:2 Name:TestPutToFull Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	for i := 0; i < 4; i++ {
		err := rb.Put(i)
		if !assert.Nil(t, err) {
			return
		}
	}

	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		err := rb.Put(4)
		assert.Nil(t, err)
		wg.Done()
	}()

	go func() {
		defer wg.Done()
		result, err := rb.Get()
		if !assert.Nil(t, err) {
			return
		}

		assert.Equal(t, 0, result)
	}()

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(3) for i := 0; i < 4; i++ { err := rb.Put(i) if !assert.Nil(t, err) { return } } var wg sync.WaitGroup wg.Add(2) go func() { err := rb.Put(4) assert.Nil(t, err) wg.Done() }() go func() { defer wg.Done() result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 0, result) }() wg.Wait() }]}
{Id:5 FileId:99 StartLine:132 StartColumn:1 EndLine:151 EndColumn:2 Name:TestOffer Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(2)

	ok, err := rb.Offer("foo")
	assert.True(t, ok)
	assert.Nil(t, err)
	ok, err = rb.Offer("bar")
	assert.True(t, ok)
	assert.Nil(t, err)
	ok, err = rb.Offer("baz")
	assert.False(t, ok)
	assert.Nil(t, err)

	item, err := rb.Get()
	assert.Nil(t, err)
	assert.Equal(t, "foo", item)
	item, err = rb.Get()
	assert.Nil(t, err)
	assert.Equal(t, "bar", item)
} PrettyPrintBody:[{ rb := NewRingBuffer(2) ok, err := rb.Offer("foo") assert.True(t, ok) assert.Nil(t, err) ok, err = rb.Offer("bar") assert.True(t, ok) assert.Nil(t, err) ok, err = rb.Offer("baz") assert.False(t, ok) assert.Nil(t, err) item, err := rb.Get() assert.Nil(t, err) assert.Equal(t, "foo", item) item, err = rb.Get() assert.Nil(t, err) assert.Equal(t, "bar", item) }]}
{Id:6 FileId:99 StartLine:153 StartColumn:1 EndLine:178 EndColumn:2 Name:TestRingGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		wg.Done()
		result, err := rb.Get()
		assert.Nil(t, err)
		assert.Equal(t, 0, result)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	go func() {
		defer wg.Done()
		err := rb.Put(0)
		assert.Nil(t, err)
	}()

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(3) var wg sync.WaitGroup wg.Add(1) go func() { wg.Done() result, err := rb.Get() assert.Nil(t, err) assert.Equal(t, 0, result) wg.Done() }() wg.Wait() wg.Add(2) go func() { defer wg.Done() err := rb.Put(0) assert.Nil(t, err) }() wg.Wait() }]}
{Id:7 FileId:99 StartLine:180 StartColumn:1 EndLine:185 EndColumn:2 Name:TestRingPollEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	_, err := rb.Poll(1)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ rb := NewRingBuffer(3) _, err := rb.Poll(1) assert.Equal(t, ErrTimeout, err) }]}
{Id:8 FileId:99 StartLine:187 StartColumn:1 EndLine:226 EndColumn:2 Name:TestRingPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(10)

	rb.Poll(time.Millisecond)

	rb.Put(`test`)
	result, err := rb.Poll(0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `test`, result)
	assert.Equal(t, uint64(0), rb.Len())

	rb.Put(`1`)
	rb.Put(`2`)

	result, err = rb.Poll(time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `1`, result)
	assert.Equal(t, uint64(1), rb.Len())

	result, err = rb.Poll(time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result)

	before := time.Now()
	_, err = rb.Poll(5 * time.Millisecond)

	assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ rb := NewRingBuffer(10) rb.Poll(time.Millisecond) rb.Put(`test`) result, err := rb.Poll(0) if !assert.Nil(t, err) { return } assert.Equal(t, `test`, result) assert.Equal(t, uint64(0), rb.Len()) rb.Put(`1`) rb.Put(`2`) result, err = rb.Poll(time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `1`, result) assert.Equal(t, uint64(1), rb.Len()) result, err = rb.Poll(time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result) before := time.Now() _, err = rb.Poll(5 * time.Millisecond) assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10) assert.Equal(t, ErrTimeout, err) }]}
{Id:9 FileId:99 StartLine:228 StartColumn:1 EndLine:245 EndColumn:2 Name:TestRingLen Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(4)
	assert.Equal(t, uint64(0), rb.Len())

	rb.Put(1)
	assert.Equal(t, uint64(1), rb.Len())

	rb.Get()
	assert.Equal(t, uint64(0), rb.Len())

	for i := 0; i < 4; i++ {
		rb.Put(1)
	}
	assert.Equal(t, uint64(4), rb.Len())

	rb.Get()
	assert.Equal(t, uint64(3), rb.Len())
} PrettyPrintBody:[{ rb := NewRingBuffer(4) assert.Equal(t, uint64(0), rb.Len()) rb.Put(1) assert.Equal(t, uint64(1), rb.Len()) rb.Get() assert.Equal(t, uint64(0), rb.Len()) for i := 0; i < 4; i++ { rb.Put(1) } assert.Equal(t, uint64(4), rb.Len()) rb.Get() assert.Equal(t, uint64(3), rb.Len()) }]}
{Id:10 FileId:99 StartLine:247 StartColumn:1 EndLine:269 EndColumn:2 Name:TestDisposeOnGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numThreads := 8
	var wg sync.WaitGroup
	wg.Add(numThreads)
	rb := NewRingBuffer(4)
	var spunUp sync.WaitGroup
	spunUp.Add(numThreads)

	for i := 0; i < numThreads; i++ {
		go func() {
			spunUp.Done()
			defer wg.Done()
			_, err := rb.Get()
			assert.NotNil(t, err)
		}()
	}

	spunUp.Wait()
	rb.Dispose()

	wg.Wait()
	assert.True(t, rb.IsDisposed())
} PrettyPrintBody:[{ numThreads := 8 var wg sync.WaitGroup wg.Add(numThreads) rb := NewRingBuffer(4) var spunUp sync.WaitGroup spunUp.Add(numThreads) for i := 0; i < numThreads; i++ { go func() { spunUp.Done() defer wg.Done() _, err := rb.Get() assert.NotNil(t, err) }() } spunUp.Wait() rb.Dispose() wg.Wait() assert.True(t, rb.IsDisposed()) }]}
{Id:11 FileId:99 StartLine:271 StartColumn:1 EndLine:301 EndColumn:2 Name:TestDisposeOnPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numThreads := 8
	var wg sync.WaitGroup
	wg.Add(numThreads)
	rb := NewRingBuffer(4)
	var spunUp sync.WaitGroup
	spunUp.Add(numThreads)

	for i := 0; i < 4; i++ {
		rb.Put(i)
	}

	for i := 0; i < numThreads; i++ {
		go func(i int) {
			spunUp.Done()
			defer wg.Done()
			err := rb.Put(i)
			assert.NotNil(t, err)
		}(i)
	}

	spunUp.Wait()

	rb.Dispose()

	wg.Wait()

	assert.True(t, rb.IsDisposed())
} PrettyPrintBody:[{ numThreads := 8 var wg sync.WaitGroup wg.Add(numThreads) rb := NewRingBuffer(4) var spunUp sync.WaitGroup spunUp.Add(numThreads) for i := 0; i < 4; i++ { rb.Put(i) } for i := 0; i < numThreads; i++ { go func(i int) { spunUp.Done() defer wg.Done() err := rb.Put(i) assert.NotNil(t, err) }(i) } spunUp.Wait() rb.Dispose() wg.Wait() assert.True(t, rb.IsDisposed()) }]}
{Id:12 FileId:99 StartLine:303 StartColumn:1 EndLine:329 EndColumn:2 Name:BenchmarkRBLifeCycle Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(64)

	counter := uint64(0)
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		for {
			_, err := rb.Get()
			assert.Nil(b, err)

			if atomic.AddUint64(&counter, 1) == uint64(b.N) {
				return
			}
		}
	}()

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rb.Put(i)
	}

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(64) counter := uint64(0) var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() for { _, err := rb.Get() assert.Nil(b, err) if atomic.AddUint64(&counter, 1) == uint64(b.N) { return } } }() b.ResetTimer() for i := 0; i < b.N; i++ { rb.Put(i) } wg.Wait() }]}
{Id:13 FileId:99 StartLine:331 StartColumn:1 EndLine:367 EndColumn:2 Name:BenchmarkRBLifeCycleContention Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(64)

	var wwg sync.WaitGroup
	var rwg sync.WaitGroup
	wwg.Add(10)
	rwg.Add(10)

	for i := 0; i < 10; i++ {
		go func() {
			for {
				_, err := rb.Get()
				if err == ErrDisposed {
					rwg.Done()
					return
				} else {
					assert.Nil(b, err)
				}
			}
		}()
	}

	b.ResetTimer()

	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < b.N; j++ {
				rb.Put(j)
			}
			wwg.Done()
		}()
	}

	wwg.Wait()
	rb.Dispose()
	rwg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(64) var wwg sync.WaitGroup var rwg sync.WaitGroup wwg.Add(10) rwg.Add(10) for i := 0; i < 10; i++ { go func() { for { _, err := rb.Get() if err == ErrDisposed { rwg.Done() return } else { assert.Nil(b, err) } } }() } b.ResetTimer() for i := 0; i < 10; i++ { go func() { for j := 0; j < b.N; j++ { rb.Put(j) } wwg.Done() }() } wwg.Wait() rb.Dispose() rwg.Wait() }]}
{Id:14 FileId:99 StartLine:369 StartColumn:1 EndLine:384 EndColumn:2 Name:BenchmarkRBPut Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(uint64(b.N))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ok, err := rb.Offer(i)
		if !ok {
			b.Fail()
		}
		if err != nil {
			b.Log(err)
			b.Fail()
		}
	}
} PrettyPrintBody:[{ rb := NewRingBuffer(uint64(b.N)) b.ResetTimer() for i := 0; i < b.N; i++ { ok, err := rb.Offer(i) if !ok { b.Fail() } if err != nil { b.Log(err) b.Fail() } } }]}
{Id:15 FileId:99 StartLine:386 StartColumn:1 EndLine:398 EndColumn:2 Name:BenchmarkRBGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(uint64(b.N))

	for i := 0; i < b.N; i++ {
		rb.Offer(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rb.Get()
	}
} PrettyPrintBody:[{ rb := NewRingBuffer(uint64(b.N)) for i := 0; i < b.N; i++ { rb.Offer(i) } b.ResetTimer() for i := 0; i < b.N; i++ { rb.Get() } }]}
{Id:16 FileId:99 StartLine:400 StartColumn:1 EndLine:404 EndColumn:2 Name:BenchmarkRBAllocation Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		NewRingBuffer(1024)
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { NewRingBuffer(1024) } }]}
{Id:3 FileId:118 StartLine:29 StartColumn:1 EndLine:61 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:key Type:hilbert} {Name:r1 Type:rtree.Rectangle}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		n = parent.searchNode(key)
		parent = n
	}

	if parent != nil && r1 != nil {

		i := parent.search(key)
		for parent.keys.byPosition(i) == key {
			if equal(parent.nodes.list[i], r1) {
				break
			}

			i++
			if i == parent.keys.len() {
				if parent.right == nil {
					break
				}

				if parent.right.keys.byPosition(0) != key {
					break
				}

				parent = parent.right
				i = 0
			}
		}
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { n = parent.searchNode(key) parent = n } if parent != nil && r1 != nil { i := parent.search(key) for parent.keys.byPosition(i) == key { if equal(parent.nodes.list[i], r1) { break } i++ if i == parent.keys.len() { if parent.right == nil { break } if parent.right.keys.byPosition(0) != key { break } parent = parent.right i = 0 } } } return parent }]}
{Id:5 FileId:118 StartLine:67 StartColumn:1 EndLine:69 EndColumn:2 Name:push Params:[{Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc000e7fec0 Body:{
	ns.list = append(ns.list, n)
} PrettyPrintBody:[{ ns.list = append(ns.list, n) }]}
{Id:6 FileId:118 StartLine:71 StartColumn:1 EndLine:80 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*nodes} {Name: Type:*nodes}] Receiver:0xc000e7ff00 Body:{
	i++
	right := make(rtree.Rectangles, uint64(len(ns.list))-i, capacity)
	copy(right, ns.list[i:])
	for j := i; j < uint64(len(ns.list)); j++ {
		ns.list[j] = nil
	}
	ns.list = ns.list[:i]
	return ns, &nodes{list: right}
} PrettyPrintBody:[{ i++ right := make(rtree.Rectangles, uint64(len(ns.list))-i, capacity) copy(right, ns.list[i:]) for j := i; j < uint64(len(ns.list)); j++ { ns.list[j] = nil } ns.list = ns.list[:i] return ns, &nodes{list: right} }]}
{Id:7 FileId:118 StartLine:82 StartColumn:1 EndLine:88 EndColumn:2 Name:byPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0001187a0 Body:{
	if pos >= uint64(len(ns.list)) {
		return nil
	}

	return ns.list[pos].(*node)
} PrettyPrintBody:[{ if pos >= uint64(len(ns.list)) { return nil } return ns.list[pos].(*node) }]}
{Id:8 FileId:118 StartLine:90 StartColumn:1 EndLine:94 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc0010333e0 Body:{
	ns.list = append(ns.list, nil)
	copy(ns.list[i+1:], ns.list[i:])
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list = append(ns.list, nil) copy(ns.list[i+1:], ns.list[i:]) ns.list[i] = n }]}
{Id:9 FileId:118 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:replaceAt Params:[{Name:i Type:uint64} {Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc001309860 Body:{
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list[i] = n }]}
{Id:10 FileId:118 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0013098a0 Body:{
	return uint64(len(ns.list))
} PrettyPrintBody:[{ return uint64(len(ns.list)) }]}
{Id:11 FileId:118 StartLine:104 StartColumn:1 EndLine:107 EndColumn:2 Name:deleteAt Params:[{Name:i Type:uint64}] Results:[] Receiver:0xc001581120 Body:{
	copy(ns.list[i:], ns.list[i+1:])
	ns.list = ns.list[:len(ns.list)-1]
} PrettyPrintBody:[{ copy(ns.list[i:], ns.list[i+1:]) ns.list = ns.list[:len(ns.list)-1] }]}
{Id:12 FileId:118 StartLine:109 StartColumn:1 EndLine:113 EndColumn:2 Name:newNodes Params:[{Name:size Type:uint64}] Results:[{Name: Type:*nodes}] Receiver:<nil> Body:{
	return &nodes{
		list: make(rtree.Rectangles, 0, size),
	}
} PrettyPrintBody:[{ return &nodes{ list: make(rtree.Rectangles, 0, size), } }]}
{Id:14 FileId:118 StartLine:119 StartColumn:1 EndLine:125 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*keys} {Name: Type:*keys}] Receiver:0xc0010dfc80 Body:{
	i++
	right := make(hilberts, uint64(len(ks.list))-i, capacity)
	copy(right, ks.list[i:])
	ks.list = ks.list[:i]
	return ks, &keys{list: right}
} PrettyPrintBody:[{ i++ right := make(hilberts, uint64(len(ks.list))-i, capacity) copy(right, ks.list[i:]) ks.list = ks.list[:i] return ks, &keys{list: right} }]}
{Id:15 FileId:118 StartLine:127 StartColumn:1 EndLine:129 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000993a40 Body:{
	return uint64(len(ks.list))
} PrettyPrintBody:[{ return uint64(len(ks.list)) }]}
{Id:16 FileId:118 StartLine:131 StartColumn:1 EndLine:136 EndColumn:2 Name:byPosition Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert}] Receiver:0xc0003e52c0 Body:{
	if i >= uint64(len(ks.list)) {
		return -1
	}
	return ks.list[i]
} PrettyPrintBody:[{ if i >= uint64(len(ks.list)) { return -1 } return ks.list[i] }]}
{Id:17 FileId:118 StartLine:138 StartColumn:1 EndLine:141 EndColumn:2 Name:deleteAt Params:[{Name:i Type:uint64}] Results:[] Receiver:0xc0003e5300 Body:{
	copy(ks.list[i:], ks.list[i+1:])
	ks.list = ks.list[:len(ks.list)-1]
} PrettyPrintBody:[{ copy(ks.list[i:], ks.list[i+1:]) ks.list = ks.list[:len(ks.list)-1] }]}
{Id:18 FileId:118 StartLine:143 StartColumn:1 EndLine:155 EndColumn:2 Name:delete Params:[{Name:k Type:hilbert}] Results:[{Name: Type:hilbert}] Receiver:0xc001409e20 Body:{
	i := ks.search(k)
	if i >= uint64(len(ks.list)) {
		return -1
	}

	if ks.list[i] != k {
		return -1
	}
	old := ks.list[i]
	ks.deleteAt(i)
	return old
} PrettyPrintBody:[{ i := ks.search(k) if i >= uint64(len(ks.list)) { return -1 } if ks.list[i] != k { return -1 } old := ks.list[i] ks.deleteAt(i) return old }]}
{Id:19 FileId:118 StartLine:157 StartColumn:1 EndLine:163 EndColumn:2 Name:search Params:[{Name:key Type:hilbert}] Results:[{Name: Type:uint64}] Receiver:0xc000a8a960 Body:{
	i := sort.Search(len(ks.list), func(i int) bool {
		return ks.list[i] >= key
	})

	return uint64(i)
} PrettyPrintBody:[{ i := sort.Search(len(ks.list), func(i int) bool { return ks.list[i] >= key }) return uint64(i) }]}
{Id:20 FileId:118 StartLine:165 StartColumn:1 EndLine:181 EndColumn:2 Name:insert Params:[{Name:key Type:hilbert}] Results:[{Name: Type:hilbert} {Name: Type:uint64}] Receiver:0xc001409fe0 Body:{
	i := ks.search(key)
	if i == uint64(len(ks.list)) {
		ks.list = append(ks.list, key)
		return -1, i
	}

	var old hilbert
	if ks.list[i] == key {
		old = ks.list[i]
		ks.list[i] = key
	} else {
		ks.insertAt(i, key)
	}

	return old, i
} PrettyPrintBody:[{ i := ks.search(key) if i == uint64(len(ks.list)) { ks.list = append(ks.list, key) return -1, i } var old hilbert if ks.list[i] == key { old = ks.list[i] ks.list[i] = key } else { ks.insertAt(i, key) } return old, i }]}
{Id:21 FileId:118 StartLine:183 StartColumn:1 EndLine:185 EndColumn:2 Name:last Params:[] Results:[{Name: Type:hilbert}] Receiver:0xc00095ae80 Body:{
	return ks.list[len(ks.list)-1]
} PrettyPrintBody:[{ return ks.list[len(ks.list)-1] }]}
{Id:22 FileId:118 StartLine:187 StartColumn:1 EndLine:191 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:k Type:hilbert}] Results:[] Receiver:0xc001603360 Body:{
	ks.list = append(ks.list, -1)
	copy(ks.list[i+1:], ks.list[i:])
	ks.list[i] = k
} PrettyPrintBody:[{ ks.list = append(ks.list, -1) copy(ks.list[i+1:], ks.list[i:]) ks.list[i] = k }]}
{Id:23 FileId:118 StartLine:193 StartColumn:1 EndLine:203 EndColumn:2 Name:withPosition Params:[{Name:k Type:hilbert}] Results:[{Name: Type:hilbert} {Name: Type:uint64}] Receiver:0xc0016033e0 Body:{
	i := ks.search(k)
	if i == uint64(len(ks.list)) {
		return -1, i
	}
	if ks.list[i] == k {
		return ks.list[i], i
	}

	return -1, i
} PrettyPrintBody:[{ i := ks.search(k) if i == uint64(len(ks.list)) { return -1, i } if ks.list[i] == k { return ks.list[i], i } return -1, i }]}
{Id:24 FileId:118 StartLine:205 StartColumn:1 EndLine:209 EndColumn:2 Name:newKeys Params:[{Name:size Type:uint64}] Results:[{Name: Type:*keys}] Receiver:<nil> Body:{
	return &keys{
		list: make(hilberts, 0, size),
	}
} PrettyPrintBody:[{ return &keys{ list: make(hilberts, 0, size), } }]}
{Id:26 FileId:118 StartLine:220 StartColumn:1 EndLine:256 EndColumn:2 Name:insert Params:[{Name:kb Type:*keyBundle}] Results:[{Name: Type:rtree.Rectangle}] Receiver:0xc00095b000 Body:{
	i := n.keys.search(kb.key)
	if n.isLeaf {
		for i < n.keys.len() && n.keys.list[i] == kb.key {
			if equal(n.nodes.list[i], kb.left) {
				old := n.nodes.list[i]
				n.nodes.list[i] = kb.left
				return old
			}
			i++
		}
	}

	if i == n.keys.len() {
		n.maxHilbert = kb.key
	}

	n.keys.insertAt(i, kb.key)
	if n.isLeaf {
		n.nodes.insertAt(i, kb.left)
	} else {
		if n.nodes.len() == 0 {
			n.nodes.push(kb.left)
			n.nodes.push(kb.right)
		} else {
			n.nodes.replaceAt(i, kb.left)
			n.nodes.insertAt(i+1, kb.right)
		}
		n.mbr.adjust(kb.left)
		n.mbr.adjust(kb.right)
		if kb.right.(*node).maxHilbert > n.maxHilbert {
			n.maxHilbert = kb.right.(*node).maxHilbert
		}
	}

	return nil
} PrettyPrintBody:[{ i := n.keys.search(kb.key) if n.isLeaf { for i < n.keys.len() && n.keys.list[i] == kb.key { if equal(n.nodes.list[i], kb.left) { old := n.nodes.list[i] n.nodes.list[i] = kb.left return old } i++ } } if i == n.keys.len() { n.maxHilbert = kb.key } n.keys.insertAt(i, kb.key) if n.isLeaf { n.nodes.insertAt(i, kb.left) } else { if n.nodes.len() == 0 { n.nodes.push(kb.left) n.nodes.push(kb.right) } else { n.nodes.replaceAt(i, kb.left) n.nodes.insertAt(i+1, kb.right) } n.mbr.adjust(kb.left) n.mbr.adjust(kb.right) if kb.right.(*node).maxHilbert > n.maxHilbert { n.maxHilbert = kb.right.(*node).maxHilbert } } return nil }]}
{Id:27 FileId:118 StartLine:258 StartColumn:1 EndLine:272 EndColumn:2 Name:delete Params:[{Name:kb Type:*keyBundle}] Results:[{Name: Type:rtree.Rectangle}] Receiver:0xc000a8ba00 Body:{
	i := n.keys.search(kb.key)
	if n.keys.byPosition(i) != kb.key {
		return nil
	}

	if !equal(n.nodes.list[i], kb.left) {
		return nil
	}

	old := n.nodes.list[i]
	n.keys.deleteAt(i)
	n.nodes.deleteAt(i)
	return old
} PrettyPrintBody:[{ i := n.keys.search(kb.key) if n.keys.byPosition(i) != kb.key { return nil } if !equal(n.nodes.list[i], kb.left) { return nil } old := n.nodes.list[i] n.keys.deleteAt(i) n.nodes.deleteAt(i) return old }]}
{Id:28 FileId:118 StartLine:274 StartColumn:1 EndLine:276 EndColumn:2 Name:LowerLeft Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc0009923e0 Body:{
	return n.mbr.xlow, n.mbr.ylow
} PrettyPrintBody:[{ return n.mbr.xlow, n.mbr.ylow }]}
{Id:29 FileId:118 StartLine:278 StartColumn:1 EndLine:280 EndColumn:2 Name:UpperRight Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc000a8bc80 Body:{
	return n.mbr.xhigh, n.mbr.yhigh
} PrettyPrintBody:[{ return n.mbr.xhigh, n.mbr.yhigh }]}
{Id:30 FileId:118 StartLine:282 StartColumn:1 EndLine:284 EndColumn:2 Name:needsSplit Params:[{Name:ary Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc0009924e0 Body:{
	return n.keys.len() >= ary
} PrettyPrintBody:[{ return n.keys.len() >= ary }]}
{Id:31 FileId:118 StartLine:286 StartColumn:1 EndLine:303 EndColumn:2 Name:splitLeaf Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc000992520 Body:{
	key := n.keys.byPosition(i)
	_, rightKeys := n.keys.splitAt(i, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)
	nn := &node{
		keys:	rightKeys,
		nodes:	rightNodes,
		isLeaf:	true,
		right:	n.right,
		parent:	n.parent,
	}
	n.right = nn
	nn.mbr = newRectangleFromRects(rightNodes.list)
	n.mbr = newRectangleFromRects(n.nodes.list)
	nn.maxHilbert = rightKeys.last()
	n.maxHilbert = n.keys.last()
	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) _, rightKeys := n.keys.splitAt(i, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := &node{ keys:	rightKeys, nodes:	rightNodes, isLeaf:	true, right:	n.right, parent:	n.parent, } n.right = nn nn.mbr = newRectangleFromRects(rightNodes.list) n.mbr = newRectangleFromRects(n.nodes.list) nn.maxHilbert = rightKeys.last() n.maxHilbert = n.keys.last() return key, n, nn }]}
{Id:32 FileId:118 StartLine:305 StartColumn:1 EndLine:322 EndColumn:2 Name:splitInternal Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc000992780 Body:{
	key := n.keys.byPosition(i)
	n.keys.delete(key)

	_, rightKeys := n.keys.splitAt(i-1, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)

	nn := newNode(false, rightKeys, rightNodes)
	for _, n := range rightNodes.list {
		n.(*node).parent = nn
	}
	nn.mbr = newRectangleFromRects(rightNodes.list)
	n.mbr = newRectangleFromRects(n.nodes.list)
	nn.maxHilbert = nn.keys.last()
	n.maxHilbert = n.keys.last()

	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) n.keys.delete(key) _, rightKeys := n.keys.splitAt(i-1, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := newNode(false, rightKeys, rightNodes) for _, n := range rightNodes.list { n.(*node).parent = nn } nn.mbr = newRectangleFromRects(rightNodes.list) n.mbr = newRectangleFromRects(n.nodes.list) nn.maxHilbert = nn.keys.last() n.maxHilbert = n.keys.last() return key, n, nn }]}
{Id:33 FileId:118 StartLine:324 StartColumn:1 EndLine:330 EndColumn:2 Name:split Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b940 Body:{
	if n.isLeaf {
		return n.splitLeaf(i, capacity)
	}

	return n.splitInternal(i, capacity)
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf(i, capacity) } return n.splitInternal(i, capacity) }]}
{Id:34 FileId:118 StartLine:332 StartColumn:1 EndLine:334 EndColumn:2 Name:search Params:[{Name:key Type:hilbert}] Results:[{Name: Type:uint64}] Receiver:0xc0001e7e40 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]}
{Id:35 FileId:118 StartLine:336 StartColumn:1 EndLine:340 EndColumn:2 Name:searchNode Params:[{Name:key Type:hilbert}] Results:[{Name: Type:*node}] Receiver:0xc0000ed980 Body:{
	i := n.search(key)

	return n.nodes.byPosition(uint64(i))
} PrettyPrintBody:[{ i := n.search(key) return n.nodes.byPosition(uint64(i)) }]}
{Id:36 FileId:118 StartLine:342 StartColumn:1 EndLine:351 EndColumn:2 Name:searchRects Params:[{Name:r Type:*rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc00019ea80 Body:{
	rects := make(rtree.Rectangles, 0, n.nodes.len())
	for _, child := range n.nodes.list {
		if intersect(r, child) {
			rects = append(rects, child)
		}
	}

	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, n.nodes.len()) for _, child := range n.nodes.list { if intersect(r, child) { rects = append(rects, child) } } return rects }]}
{Id:37 FileId:118 StartLine:353 StartColumn:1 EndLine:355 EndColumn:2 Name:key Params:[] Results:[{Name: Type:hilbert}] Receiver:0xc00019eb80 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]}
{Id:38 FileId:118 StartLine:357 StartColumn:1 EndLine:363 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:*keys} {Name:ns Type:*nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]}
{Id:1 FileId:13 StartLine:25 StartColumn:1 EndLine:78 EndColumn:2 Name:TestBitOperations Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}
	if !result {
		t.Errorf(`Expected true at position: %d`, 5)
	}

	result, err = ba.GetBit(3)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position %d`, 3)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position: %d`, 5)
	}

	ba = newBitArray(24)
	err = ba.SetBit(16)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(16)
	if err != nil {
		t.Fatal(err)
	}

	if !result {
		t.Errorf(`Expected true at position: %d`, 16)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 5) } result, err = ba.GetBit(3) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position %d`, 3) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } result, err = ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position: %d`, 5) } ba = newBitArray(24) err = ba.SetBit(16) if err != nil { t.Fatal(err) } result, err = ba.GetBit(16) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 16) } }]}
{Id:2 FileId:13 StartLine:80 StartColumn:1 EndLine:120 EndColumn:2 Name:TestDuplicateOperation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if !result {
		t.Errorf(`Expected true at position: %d`, 5)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position: %d`, 5)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } err = ba.SetBit(5) if err != nil { t.Fatal(err) } result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 5) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } result, err = ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position: %d`, 5) } }]}
{Id:3 FileId:13 StartLine:122 StartColumn:1 EndLine:135 EndColumn:2 Name:TestOutOfBounds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(4)

	err := ba.SetBit(s + 1)

	if _, ok := err.(OutOfRangeError); !ok {
		t.Errorf(`Expected out of range error.`)
	}

	_, err = ba.GetBit(s + 1)
	if _, ok := err.(OutOfRangeError); !ok {
		t.Errorf(`Expected out of range error.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(4) err := ba.SetBit(s + 1) if _, ok := err.(OutOfRangeError); !ok { t.Errorf(`Expected out of range error.`) } _, err = ba.GetBit(s + 1) if _, ok := err.(OutOfRangeError); !ok { t.Errorf(`Expected out of range error.`) } }]}
{Id:4 FileId:13 StartLine:137 StartColumn:1 EndLine:143 EndColumn:2 Name:TestIsEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	assert.True(t, ba.IsEmpty())

	ba.SetBit(5)
	assert.False(t, ba.IsEmpty())
} PrettyPrintBody:[{ ba := newBitArray(10) assert.True(t, ba.IsEmpty()) ba.SetBit(5) assert.False(t, ba.IsEmpty()) }]}
{Id:5 FileId:13 StartLine:145 StartColumn:1 EndLine:178 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.SetBit(9)
	if err != nil {
		t.Fatal(err)
	}

	ba.Reset()

	assert.False(t, ba.anyset)
	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`BA not reset.`)
	}

	result, err = ba.GetBit(9)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`BA not reset.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } err = ba.SetBit(9) if err != nil { t.Fatal(err) } ba.Reset() assert.False(t, ba.anyset) result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`BA not reset.`) } result, err = ba.GetBit(9) if err != nil { t.Fatal(err) } if result { t.Errorf(`BA not reset.`) } }]}
{Id:6 FileId:13 StartLine:180 StartColumn:1 EndLine:196 EndColumn:2 Name:BenchmarkGetBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(168000)

	ba := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for j := uint64(0); j < numItems; j++ {
			ba.GetBit(j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(168000) ba := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { ba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { for j := uint64(0); j < numItems; j++ { ba.GetBit(j) } } }]}
{Id:7 FileId:13 StartLine:198 StartColumn:1 EndLine:218 EndColumn:2 Name:TestEquality Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s + 1)
	other := newBitArray(s + 1)

	if !ba.Equals(other) {
		t.Errorf(`Expected equality.`)
	}

	ba.SetBit(s + 1)
	other.SetBit(s + 1)

	if !ba.Equals(other) {
		t.Errorf(`Expected equality.`)
	}

	other.SetBit(0)

	if ba.Equals(other) {
		t.Errorf(`Expected inequality.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(s + 1) other := newBitArray(s + 1) if !ba.Equals(other) { t.Errorf(`Expected equality.`) } ba.SetBit(s + 1) other.SetBit(s + 1) if !ba.Equals(other) { t.Errorf(`Expected equality.`) } other.SetBit(0) if ba.Equals(other) { t.Errorf(`Expected inequality.`) } }]}
{Id:8 FileId:13 StartLine:220 StartColumn:1 EndLine:229 EndColumn:2 Name:BenchmarkEquality Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(160000)
	other := newBitArray(ba.Capacity())

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Equals(other)
	}
} PrettyPrintBody:[{ ba := newBitArray(160000) other := newBitArray(ba.Capacity()) b.ResetTimer() for i := 0; i < b.N; i++ { ba.Equals(other) } }]}
{Id:9 FileId:13 StartLine:231 StartColumn:1 EndLine:256 EndColumn:2 Name:TestIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	other := newBitArray(ba.Capacity())

	ba.SetBit(1)
	ba.SetBit(2)

	other.SetBit(1)

	if !ba.Intersects(other) {
		t.Errorf(`Is intersecting.`)
	}

	other.SetBit(5)

	if ba.Intersects(other) {
		t.Errorf(`Is not intersecting.`)
	}

	other = newBitArray(ba.Capacity() + 1)
	other.SetBit(1)

	if ba.Intersects(other) {
		t.Errorf(`Is not intersecting.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) other := newBitArray(ba.Capacity()) ba.SetBit(1) ba.SetBit(2) other.SetBit(1) if !ba.Intersects(other) { t.Errorf(`Is intersecting.`) } other.SetBit(5) if ba.Intersects(other) { t.Errorf(`Is not intersecting.`) } other = newBitArray(ba.Capacity() + 1) other.SetBit(1) if ba.Intersects(other) { t.Errorf(`Is not intersecting.`) } }]}
{Id:10 FileId:13 StartLine:258 StartColumn:1 EndLine:270 EndColumn:2 Name:BenchmarkIntersects Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(162432)
	other := newBitArray(ba.Capacity())

	ba.SetBit(159999)
	other.SetBit(159999)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Intersects(other)
	}
} PrettyPrintBody:[{ ba := newBitArray(162432) other := newBitArray(ba.Capacity()) ba.SetBit(159999) other.SetBit(159999) b.ResetTimer() for i := 0; i < b.N; i++ { ba.Intersects(other) } }]}
{Id:11 FileId:13 StartLine:272 StartColumn:1 EndLine:286 EndColumn:2 Name:TestComplement Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	ba.SetBit(5)

	ba.complement()

	if ok, _ := ba.GetBit(5); ok {
		t.Errorf(`Expected clear.`)
	}

	if ok, _ := ba.GetBit(4); !ok {
		t.Errorf(`Expected set.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.complement() if ok, _ := ba.GetBit(5); ok { t.Errorf(`Expected clear.`) } if ok, _ := ba.GetBit(4); !ok { t.Errorf(`Expected set.`) } }]}
{Id:12 FileId:13 StartLine:288 StartColumn:1 EndLine:296 EndColumn:2 Name:BenchmarkComplement Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(160000)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.complement()
	}
} PrettyPrintBody:[{ ba := newBitArray(160000) b.ResetTimer() for i := 0; i < b.N; i++ { ba.complement() } }]}
{Id:13 FileId:13 StartLine:298 StartColumn:1 EndLine:314 EndColumn:2 Name:TestSetHighestLowest Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)

	ba.SetBit(5)

	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(5), ba.highest)

	ba.SetBit(8)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(8), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(10) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) ba.SetBit(5) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(5), ba.highest) ba.SetBit(8) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(8), ba.highest) }]}
{Id:14 FileId:13 StartLine:316 StartColumn:1 EndLine:320 EndColumn:2 Name:TestGetBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	_, err := ba.GetBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) _, err := ba.GetBit(s * 2) assert.Error(t, err) }]}
{Id:15 FileId:13 StartLine:322 StartColumn:1 EndLine:326 EndColumn:2 Name:TestSetBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	err := ba.SetBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) err := ba.SetBit(s * 2) assert.Error(t, err) }]}
{Id:16 FileId:13 StartLine:328 StartColumn:1 EndLine:332 EndColumn:2 Name:TestClearBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	err := ba.ClearBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) err := ba.ClearBit(s * 2) assert.Error(t, err) }]}
{Id:17 FileId:13 StartLine:334 StartColumn:1 EndLine:368 EndColumn:2 Name:TestClearHighestLowest Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	ba.SetBit(5)
	ba.ClearBit(5)

	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)

	ba.SetBit(3)
	ba.SetBit(5)
	ba.SetBit(7)

	ba.ClearBit(7)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.highest)
	assert.Equal(t, uint64(3), ba.lowest)

	ba.SetBit(7)
	ba.ClearBit(3)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(7), ba.highest)

	ba.ClearBit(7)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(5), ba.highest)

	ba.ClearBit(5)
	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.ClearBit(5) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) ba.SetBit(3) ba.SetBit(5) ba.SetBit(7) ba.ClearBit(7) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.highest) assert.Equal(t, uint64(3), ba.lowest) ba.SetBit(7) ba.ClearBit(3) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(7), ba.highest) ba.ClearBit(7) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(5), ba.highest) ba.ClearBit(5) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) }]}
{Id:18 FileId:13 StartLine:370 StartColumn:1 EndLine:377 EndColumn:2 Name:TestComplementResetsBounds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(5)

	ba.complement()
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(s-1), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(5) ba.complement() assert.True(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(s-1), ba.highest) }]}
{Id:19 FileId:13 StartLine:379 StartColumn:1 EndLine:396 EndColumn:2 Name:TestBitArrayIntersectsSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	cba := newSparseBitArray()

	assert.True(t, ba.Intersects(cba))

	cba.SetBit(5)
	assert.False(t, ba.Intersects(cba))

	ba.SetBit(5)
	assert.True(t, ba.Intersects(cba))

	cba.SetBit(s + 1)
	assert.False(t, ba.Intersects(cba))

	ba.SetBit(s + 1)
	assert.True(t, ba.Intersects(cba))
} PrettyPrintBody:[{ ba := newBitArray(s * 2) cba := newSparseBitArray() assert.True(t, ba.Intersects(cba)) cba.SetBit(5) assert.False(t, ba.Intersects(cba)) ba.SetBit(5) assert.True(t, ba.Intersects(cba)) cba.SetBit(s + 1) assert.False(t, ba.Intersects(cba)) ba.SetBit(s + 1) assert.True(t, ba.Intersects(cba)) }]}
{Id:20 FileId:13 StartLine:398 StartColumn:1 EndLine:415 EndColumn:2 Name:TestBitArrayEqualsSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	cba := newSparseBitArray()

	assert.True(t, ba.Equals(cba))

	ba.SetBit(5)
	assert.False(t, ba.Equals(cba))

	cba.SetBit(5)
	assert.True(t, ba.Equals(cba))

	ba.SetBit(s + 1)
	assert.False(t, ba.Equals(cba))

	cba.SetBit(s + 1)
	assert.True(t, ba.Equals(cba))
} PrettyPrintBody:[{ ba := newBitArray(s * 2) cba := newSparseBitArray() assert.True(t, ba.Equals(cba)) ba.SetBit(5) assert.False(t, ba.Equals(cba)) cba.SetBit(5) assert.True(t, ba.Equals(cba)) ba.SetBit(s + 1) assert.False(t, ba.Equals(cba)) cba.SetBit(s + 1) assert.True(t, ba.Equals(cba)) }]}
{Id:21 FileId:13 StartLine:417 StartColumn:1 EndLine:426 EndColumn:2 Name:TestConstructorSetBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(8, true)

	result, err := ba.GetBit(7)
	assert.Nil(t, err)
	assert.True(t, result)
	assert.Equal(t, s-1, ba.highest)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.True(t, ba.anyset)
} PrettyPrintBody:[{ ba := newBitArray(8, true) result, err := ba.GetBit(7) assert.Nil(t, err) assert.True(t, result) assert.Equal(t, s-1, ba.highest) assert.Equal(t, uint64(0), ba.lowest) assert.True(t, ba.anyset) }]}
{Id:22 FileId:13 StartLine:428 StartColumn:1 EndLine:438 EndColumn:2 Name:TestCopyBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	ba.SetBit(5)
	ba.SetBit(1)

	result := ba.copy().(*bitArray)
	assert.Equal(t, ba.anyset, result.anyset)
	assert.Equal(t, ba.lowest, result.lowest)
	assert.Equal(t, ba.highest, result.highest)
	assert.Equal(t, ba.blocks, result.blocks)
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.SetBit(1) result := ba.copy().(*bitArray) assert.Equal(t, ba.anyset, result.anyset) assert.Equal(t, ba.lowest, result.lowest) assert.Equal(t, ba.highest, result.highest) assert.Equal(t, ba.blocks, result.blocks) }]}
{Id:23 FileId:13 StartLine:440 StartColumn:1 EndLine:455 EndColumn:2 Name:BenchmarkDenseIntersectsCompressed Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numBits := uint64(162432)
	ba := newBitArray(numBits)
	other := newSparseBitArray()

	for i := uint64(0); i < numBits; i++ {
		ba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.intersectsSparseBitArray(other)
	}
} PrettyPrintBody:[{ numBits := uint64(162432) ba := newBitArray(numBits) other := newSparseBitArray() for i := uint64(0); i < numBits; i++ { ba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.intersectsSparseBitArray(other) } }]}
{Id:24 FileId:13 StartLine:457 StartColumn:1 EndLine:468 EndColumn:2 Name:TestBitArrayToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)

	ba.SetBit(s - 1)
	ba.SetBit(s + 1)

	expected := []uint64{s - 1, s + 1}

	result := ba.ToNums()

	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) ba.SetBit(s - 1) ba.SetBit(s + 1) expected := []uint64{s - 1, s + 1} result := ba.ToNums() assert.Equal(t, expected, result) }]}
{Id:25 FileId:13 StartLine:470 StartColumn:1 EndLine:482 EndColumn:2 Name:BenchmarkBitArrayToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	ba := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ba.ToNums()
	}
} PrettyPrintBody:[{ numItems := uint64(1000) ba := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { ba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.ToNums() } }]}
{Id:1 FileId:91 StartLine:10 StartColumn:1 EndLine:22 EndColumn:2 Name:TestNelderMead Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		return vars[0] * vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	float64(9),
		Fn:	fn,
		Vars:	[]float64{2, 4},
	}

	result, _ := fn(NelderMead(config))
	assert.True(t, math.Abs(result-config.Target) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return vars[0] * vars[1], true } config := NelderMeadConfiguration{ Target:	float64(9), Fn:	fn, Vars:	[]float64{2, 4}, } result, _ := fn(NelderMead(config)) assert.True(t, math.Abs(result-config.Target) <= .01) }]}
{Id:2 FileId:91 StartLine:24 StartColumn:1 EndLine:40 EndColumn:2 Name:TestNelderMeadPolynomial Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	float64(-100),
		Fn:	fn,
		Vars:	[]float64{-10, 10},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(7-math.Abs(calced)) <= .01)
	assert.True(t, math.Abs(3-result[0]) <= .1)
	assert.True(t, math.Abs(2-result[1]) <= .1)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(-100), Fn:	fn, Vars:	[]float64{-10, 10}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(7-math.Abs(calced)) <= .01) assert.True(t, math.Abs(3-result[0]) <= .1) assert.True(t, math.Abs(2-result[1]) <= .1) }]}
{Id:3 FileId:91 StartLine:42 StartColumn:1 EndLine:58 EndColumn:2 Name:TestNelderMeadPolynomialMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	math.Inf(-1),
		Fn:	fn,
		Vars:	[]float64{-10, 10},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(7-math.Abs(calced)) <= .01)
	assert.True(t, math.Abs(3-result[0]) <= .01)
	assert.True(t, math.Abs(2-result[1]) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	math.Inf(-1), Fn:	fn, Vars:	[]float64{-10, 10}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(7-math.Abs(calced)) <= .01) assert.True(t, math.Abs(3-result[0]) <= .01) assert.True(t, math.Abs(2-result[1]) <= .01) }]}
{Id:4 FileId:91 StartLine:60 StartColumn:1 EndLine:75 EndColumn:2 Name:TestNelderMeadPolynomialMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return 3 + math.Sin(vars[0]) + 2*math.Pow(math.Cos(vars[1]), 2), true
	}

	config := NelderMeadConfiguration{
		Target:	math.Inf(1),
		Fn:	fn,
		Vars:	[]float64{-5, 5},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(6-math.Abs(calced)) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return 3 + math.Sin(vars[0]) + 2*math.Pow(math.Cos(vars[1]), 2), true } config := NelderMeadConfiguration{ Target:	math.Inf(1), Fn:	fn, Vars:	[]float64{-5, 5}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(6-math.Abs(calced)) <= .01) }]}
{Id:5 FileId:91 StartLine:77 StartColumn:1 EndLine:123 EndColumn:2 Name:TestNelderMeadConstrained Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		if vars[0] < 1 || vars[1] < 1 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config := NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{6, 3},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(14-math.Abs(calced)) <= .01)
	assert.True(t, result[0] >= 1)
	assert.True(t, result[1] >= 1)

	fn = func(vars []float64) (float64, bool) {
		if vars[0] < 6 || vars[0] > 8 {
			return 0, false
		}

		if vars[1] < 0 || vars[1] > 2 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config = NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{6, .5},
	}

	result = NelderMead(config)
	calced, _ = fn(result)

	assert.True(t, math.Abs(14-math.Abs(calced)) <= .01 || math.Abs(8.75-math.Abs(calced)) <= .01)
	assert.True(t, result[0] >= 6 && result[0] <= 8)
	assert.True(t, result[1] >= 0 && result[1] <= 2)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { if vars[0] < 1 || vars[1] < 1 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{6, 3}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(14-math.Abs(calced)) <= .01) assert.True(t, result[0] >= 1) assert.True(t, result[1] >= 1) fn = func(vars []float64) (float64, bool) { if vars[0] < 6 || vars[0] > 8 { return 0, false } if vars[1] < 0 || vars[1] > 2 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config = NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{6, .5}, } result = NelderMead(config) calced, _ = fn(result) assert.True(t, math.Abs(14-math.Abs(calced)) <= .01 || math.Abs(8.75-math.Abs(calced)) <= .01) assert.True(t, result[0] >= 6 && result[0] <= 8) assert.True(t, result[1] >= 0 && result[1] <= 2) }]}
{Id:6 FileId:91 StartLine:125 StartColumn:1 EndLine:144 EndColumn:2 Name:TestNelderMeadConstrainedBadGuess Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		if vars[0] < 1 || vars[1] < 1 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config := NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{0, 3},
	}

	result := NelderMead(config)
	assert.Equal(t, float64(0), result[0])
	assert.Equal(t, float64(3), result[1])
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { if vars[0] < 1 || vars[1] < 1 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{0, 3}, } result := NelderMead(config) assert.Equal(t, float64(0), result[0]) assert.Equal(t, float64(3), result[1]) }]}
{Id:6 FileId:120 StartLine:72 StartColumn:1 EndLine:114 EndColumn:2 Name:checkAndRun Params:[{Name:action Type:action}] Results:[] Receiver:0xc0011dbc40 Body:{
	if tree.actions.Len() > 0 {
		if action != nil {
			tree.actions.Put(action)
		}
		if atomic.CompareAndSwapUint64(&tree.running, 0, 1) {
			var a interface{}
			var err error
			for tree.actions.Len() > 0 {
				a, err = tree.actions.Get()
				if err != nil {
					return
				}
				tree.cache = append(tree.cache, a)
				if uint64(len(tree.cache)) >= tree.bufferSize {
					break
				}
			}

			go tree.operationRunner(tree.cache, true)
		}
	} else if action != nil {
		if atomic.CompareAndSwapUint64(&tree.running, 0, 1) {
			switch action.operation() {
			case get:
				ga := action.(*getAction)
				result := tree.search(ga.lookup)
				ga.result = result
				action.complete()
				tree.reset()
			case add, remove:
				if len(action.keys()) > multiThreadAt {
					tree.operationRunner(interfaces{action}, true)
				} else {
					tree.operationRunner(interfaces{action}, false)
				}
			}
		} else {
			tree.actions.Put(action)
			tree.checkAndRun(nil)
		}
	}
} PrettyPrintBody:[{ if tree.actions.Len() > 0 { if action != nil { tree.actions.Put(action) } if atomic.CompareAndSwapUint64(&tree.running, 0, 1) { var a interface{} var err error for tree.actions.Len() > 0 { a, err = tree.actions.Get() if err != nil { return } tree.cache = append(tree.cache, a) if uint64(len(tree.cache)) >= tree.bufferSize { break } } go tree.operationRunner(tree.cache, true) } } else if action != nil { if atomic.CompareAndSwapUint64(&tree.running, 0, 1) { switch action.operation() { case get: ga := action.(*getAction) result := tree.search(ga.lookup) ga.result = result action.complete() tree.reset() case add, remove: if len(action.keys()) > multiThreadAt { tree.operationRunner(interfaces{action}, true) } else { tree.operationRunner(interfaces{action}, false) } } } else { tree.actions.Put(action) tree.checkAndRun(nil) } } }]}
{Id:7 FileId:120 StartLine:116 StartColumn:1 EndLine:123 EndColumn:2 Name:init Params:[{Name:bufferSize Type:uint64}] Results:[] Receiver:0xc0015016c0 Body:{
	tree.bufferSize = bufferSize
	tree.ary = ary
	tree.cache = make([]interface{}, 0, bufferSize)
	tree.root = newNode(true, newKeys(ary), newNodes(ary))
	tree.root.mbr = &rectangle{}
	tree.actions = queue.NewRingBuffer(tree.bufferSize)
} PrettyPrintBody:[{ tree.bufferSize = bufferSize tree.ary = ary tree.cache = make([]interface{}, 0, bufferSize) tree.root = newNode(true, newKeys(ary), newNodes(ary)) tree.root.mbr = &rectangle{} tree.actions = queue.NewRingBuffer(tree.bufferSize) }]}
{Id:8 FileId:120 StartLine:125 StartColumn:1 EndLine:133 EndColumn:2 Name:operationRunner Params:[{Name:xns Type:interfaces} {Name:threaded Type:bool}] Results:[] Receiver:0xc001409ae0 Body:{
	writeOperations, deleteOperations, toComplete := tree.fetchKeys(xns, threaded)
	tree.recursiveMutate(writeOperations, deleteOperations, false, threaded)
	for _, a := range toComplete {
		a.complete()
	}

	tree.reset()
} PrettyPrintBody:[{ writeOperations, deleteOperations, toComplete := tree.fetchKeys(xns, threaded) tree.recursiveMutate(writeOperations, deleteOperations, false, threaded) for _, a := range toComplete { a.complete() } tree.reset() }]}
{Id:9 FileId:120 StartLine:135 StartColumn:1 EndLine:164 EndColumn:2 Name:fetchKeys Params:[{Name:xns Type:interfaces} {Name:inParallel Type:bool}] Results:[{Name: Type:map[*node][]*keyBundle} {Name: Type:map[*node][]*keyBundle} {Name: Type:actions}] Receiver:0xc001409c40 Body:{
	if inParallel {
		tree.fetchKeysInParallel(xns)
	} else {
		tree.fetchKeysInSerial(xns)
	}

	writeOperations := make(map[*node][]*keyBundle)
	deleteOperations := make(map[*node][]*keyBundle)
	toComplete := make(actions, 0, len(xns)/2)
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add:
			for i, n := range action.nodes() {
				writeOperations[n] = append(writeOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect})
			}
			toComplete = append(toComplete, action)
		case remove:
			for i, n := range action.nodes() {
				deleteOperations[n] = append(deleteOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect})
			}
			toComplete = append(toComplete, action)
		case get:
			action.complete()
		}
	}

	return writeOperations, deleteOperations, toComplete
} PrettyPrintBody:[{ if inParallel { tree.fetchKeysInParallel(xns) } else { tree.fetchKeysInSerial(xns) } writeOperations := make(map[*node][]*keyBundle) deleteOperations := make(map[*node][]*keyBundle) toComplete := make(actions, 0, len(xns)/2) for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add: for i, n := range action.nodes() { writeOperations[n] = append(writeOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}) } toComplete = append(toComplete, action) case remove: for i, n := range action.nodes() { deleteOperations[n] = append(deleteOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}) } toComplete = append(toComplete, action) case get: action.complete() } } return writeOperations, deleteOperations, toComplete }]}
{Id:10 FileId:120 StartLine:166 StartColumn:1 EndLine:181 EndColumn:2 Name:fetchKeysInSerial Params:[{Name:xns Type:interfaces}] Results:[] Receiver:0xc000a8a360 Body:{
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add, remove:
			for i, key := range action.rects() {
				n := getParent(tree.root, key.hilbert, key.rect)
				action.addNode(int64(i), n)
			}
		case get:
			ga := action.(*getAction)
			rects := tree.search(ga.lookup)
			ga.result = rects
		}
	}
} PrettyPrintBody:[{ for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add, remove: for i, key := range action.rects() { n := getParent(tree.root, key.hilbert, key.rect) action.addNode(int64(i), n) } case get: ga := action.(*getAction) rects := tree.search(ga.lookup) ga.result = rects } } }]}
{Id:11 FileId:120 StartLine:183 StartColumn:1 EndLine:191 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001581280 Body:{
	for i := range tree.cache {
		tree.cache[i] = nil
	}

	tree.cache = tree.cache[:0]
	atomic.StoreUint64(&tree.running, 0)
	tree.checkAndRun(nil)
} PrettyPrintBody:[{ for i := range tree.cache { tree.cache[i] = nil } tree.cache = tree.cache[:0] atomic.StoreUint64(&tree.running, 0) tree.checkAndRun(nil) }]}
{Id:12 FileId:120 StartLine:193 StartColumn:1 EndLine:242 EndColumn:2 Name:fetchKeysInParallel Params:[{Name:xns Type:[]interface{}}] Results:[] Receiver:0xc0010df5a0 Body:{
	var forCache struct {
		i	int64
		buffer	[8]uint64
		js	[]int64
	}

	for j := 0; j < len(xns); j++ {
		forCache.js = append(forCache.js, -1)
	}
	numCPU := runtime.NumCPU()
	if numCPU > 1 {
		numCPU--
	}
	var wg sync.WaitGroup
	wg.Add(numCPU)

	for k := 0; k < numCPU; k++ {
		go func() {
			for {
				index := atomic.LoadInt64(&forCache.i)
				if index >= int64(len(xns)) {
					break
				}
				action := xns[index].(action)

				j := atomic.AddInt64(&forCache.js[index], 1)
				if j > int64(len(action.rects())) {
					continue
				} else if j == int64(len(action.rects())) {
					atomic.StoreInt64(&forCache.i, index+1)
					continue
				}

				switch action.operation() {
				case add, remove:
					hb := action.rects()[j]
					n := getParent(tree.root, hb.hilbert, hb.rect)
					action.addNode(j, n)
				case get:
					ga := action.(*getAction)
					result := tree.search(ga.lookup)
					ga.result = result
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
} PrettyPrintBody:[{ var forCache struct { i	int64 buffer	[8]uint64 js	[]int64 } for j := 0; j < len(xns); j++ { forCache.js = append(forCache.js, -1) } numCPU := runtime.NumCPU() if numCPU > 1 { numCPU-- } var wg sync.WaitGroup wg.Add(numCPU) for k := 0; k < numCPU; k++ { go func() { for { index := atomic.LoadInt64(&forCache.i) if index >= int64(len(xns)) { break } action := xns[index].(action) j := atomic.AddInt64(&forCache.js[index], 1) if j > int64(len(action.rects())) { continue } else if j == int64(len(action.rects())) { atomic.StoreInt64(&forCache.i, index+1) continue } switch action.operation() { case add, remove: hb := action.rects()[j] n := getParent(tree.root, hb.hilbert, hb.rect) action.addNode(j, n) case get: ga := action.(*getAction) result := tree.search(ga.lookup) ga.result = result } } wg.Done() }() } wg.Wait() }]}
{Id:13 FileId:120 StartLine:244 StartColumn:1 EndLine:261 EndColumn:2 Name:splitNode Params:[{Name:n Type:*node} {Name:nodes Type:*[]*node} {Name:keys Type:*hilberts}] Results:[] Receiver:0xc000a8a6c0 Body:{
	if !n.needsSplit(tree.ary) {
		return
	}

	length := n.keys.len()
	splitAt := tree.ary - 1

	for i := splitAt; i < length; i += splitAt {
		offset := length - i
		k, left, right := n.split(offset, tree.ary)
		left.right = right
		*keys = append(*keys, k)
		*nodes = append(*nodes, left, right)
		left.parent = parent
		right.parent = parent
	}
} PrettyPrintBody:[{ if !n.needsSplit(tree.ary) { return } length := n.keys.len() splitAt := tree.ary - 1 for i := splitAt; i < length; i += splitAt { offset := length - i k, left, right := n.split(offset, tree.ary) left.right = right *keys = append(*keys, k) *nodes = append(*nodes, left, right) left.parent = parent right.parent = parent } }]}
{Id:14 FileId:120 StartLine:263 StartColumn:1 EndLine:281 EndColumn:2 Name:applyNode Params:[{Name:n Type:*node} {Name:adds Type:[]*keyBundle}] Results:[] Receiver:0xc0003e5440 Body:{
	for _, kb := range deletes {
		if n.keys.len() == 0 {
			break
		}

		deleted := n.delete(kb)
		if deleted != nil {
			atomic.AddUint64(&tree.number, ^uint64(0))
		}
	}

	for _, kb := range adds {
		old := n.insert(kb)
		if n.isLeaf && old == nil {
			atomic.AddUint64(&tree.number, 1)
		}
	}
} PrettyPrintBody:[{ for _, kb := range deletes { if n.keys.len() == 0 { break } deleted := n.delete(kb) if deleted != nil { atomic.AddUint64(&tree.number, ^uint64(0)) } } for _, kb := range adds { old := n.insert(kb) if n.isLeaf && old == nil { atomic.AddUint64(&tree.number, 1) } } }]}
{Id:15 FileId:120 StartLine:283 StartColumn:1 EndLine:364 EndColumn:2 Name:recursiveMutate Params:[{Name:adds Type:map[*node][]*keyBundle} {Name:setRoot Type:bool}] Results:[] Receiver:0xc00019e4c0 Body:{
	if len(adds) == 0 && len(deletes) == 0 {
		return
	}

	if setRoot && len(adds) > 1 {
		panic(`SHOULD ONLY HAVE ONE ROOT`)
	}

	ifs := make(interfaces, 0, len(adds))
	for n := range adds {
		if n.parent == nil {
			setRoot = true
		}
		ifs = append(ifs, n)
	}

	for n := range deletes {
		if n.parent == nil {
			setRoot = true
		}

		if _, ok := adds[n]; !ok {
			ifs = append(ifs, n)
		}
	}

	var dummyRoot *node
	if setRoot {
		dummyRoot = &node{
			keys:	newKeys(tree.ary),
			nodes:	newNodes(tree.ary),
			mbr:	&rectangle{},
		}
	}

	var write sync.Mutex
	nextLayerWrite := make(map[*node][]*keyBundle)
	nextLayerDelete := make(map[*node][]*keyBundle)

	var mutate func(interfaces, func(interface{}))
	if inParallel {
		mutate = executeInterfacesInParallel
	} else {
		mutate = executeInterfacesInSerial
	}

	mutate(ifs, func(ifc interface{}) {
		n := ifc.(*node)
		adds := adds[n]
		deletes := deletes[n]

		if len(adds) == 0 && len(deletes) == 0 {
			return
		}

		if setRoot {
			tree.root = n
		}

		parent := n.parent
		if parent == nil {
			parent = dummyRoot
			setRoot = true
		}

		tree.applyNode(n, adds, deletes)

		if n.needsSplit(tree.ary) {
			keys := make(hilberts, 0, n.keys.len())
			nodes := make([]*node, 0, n.nodes.len())
			tree.splitNode(n, parent, &nodes, &keys)
			write.Lock()
			for i, k := range keys {
				nextLayerWrite[parent] = append(nextLayerWrite[parent], &keyBundle{key: k, left: nodes[i*2], right: nodes[i*2+1]})
			}
			write.Unlock()
		}
	})

	tree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel)
} PrettyPrintBody:[{ if len(adds) == 0 && len(deletes) == 0 { return } if setRoot && len(adds) > 1 { panic(`SHOULD ONLY HAVE ONE ROOT`) } ifs := make(interfaces, 0, len(adds)) for n := range adds { if n.parent == nil { setRoot = true } ifs = append(ifs, n) } for n := range deletes { if n.parent == nil { setRoot = true } if _, ok := adds[n]; !ok { ifs = append(ifs, n) } } var dummyRoot *node if setRoot { dummyRoot = &node{ keys:	newKeys(tree.ary), nodes:	newNodes(tree.ary), mbr:	&rectangle{}, } } var write sync.Mutex nextLayerWrite := make(map[*node][]*keyBundle) nextLayerDelete := make(map[*node][]*keyBundle) var mutate func(interfaces, func(interface{})) if inParallel { mutate = executeInterfacesInParallel } else { mutate = executeInterfacesInSerial } mutate(ifs, func(ifc interface{}) { n := ifc.(*node) adds := adds[n] deletes := deletes[n] if len(adds) == 0 && len(deletes) == 0 { return } if setRoot { tree.root = n } parent := n.parent if parent == nil { parent = dummyRoot setRoot = true } tree.applyNode(n, adds, deletes) if n.needsSplit(tree.ary) { keys := make(hilberts, 0, n.keys.len()) nodes := make([]*node, 0, n.nodes.len()) tree.splitNode(n, parent, &nodes, &keys) write.Lock() for i, k := range keys { nextLayerWrite[parent] = append(nextLayerWrite[parent], &keyBundle{key: k, left: nodes[i*2], right: nodes[i*2+1]}) } write.Unlock() } }) tree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel) }]}
{Id:16 FileId:120 StartLine:367 StartColumn:1 EndLine:371 EndColumn:2 Name:Insert Params:[{Name:rects Type:...rtree.Rectangle}] Results:[] Receiver:0xc000259960 Body:{
	ia := newInsertAction(rects)
	tree.checkAndRun(ia)
	ia.completer.Wait()
} PrettyPrintBody:[{ ia := newInsertAction(rects) tree.checkAndRun(ia) ia.completer.Wait() }]}
{Id:17 FileId:120 StartLine:375 StartColumn:1 EndLine:379 EndColumn:2 Name:Delete Params:[{Name:rects Type:...rtree.Rectangle}] Results:[] Receiver:0xc000259b60 Body:{
	ra := newRemoveAction(rects)
	tree.checkAndRun(ra)
	ra.completer.Wait()
} PrettyPrintBody:[{ ra := newRemoveAction(rects) tree.checkAndRun(ra) ra.completer.Wait() }]}
{Id:18 FileId:120 StartLine:381 StartColumn:1 EndLine:399 EndColumn:2 Name:search Params:[{Name:r Type:*rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc0009929a0 Body:{
	if tree.root == nil {
		return rtree.Rectangles{}
	}

	result := make(rtree.Rectangles, 0, 10)
	whs := tree.root.searchRects(r)
	for len(whs) > 0 {
		wh := whs[0]
		if n, ok := wh.(*node); ok {
			whs = append(whs, n.searchRects(r)...)
		} else {
			result = append(result, wh)
		}
		whs = whs[1:]
	}

	return result
} PrettyPrintBody:[{ if tree.root == nil { return rtree.Rectangles{} } result := make(rtree.Rectangles, 0, 10) whs := tree.root.searchRects(r) for len(whs) > 0 { wh := whs[0] if n, ok := wh.(*node); ok { whs = append(whs, n.searchRects(r)...) } else { result = append(result, wh) } whs = whs[1:] } return result }]}
{Id:19 FileId:120 StartLine:403 StartColumn:1 EndLine:408 EndColumn:2 Name:Search Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc001581780 Body:{
	ga := newGetAction(rect)
	tree.checkAndRun(ga)
	ga.completer.Wait()
	return ga.result
} PrettyPrintBody:[{ ga := newGetAction(rect) tree.checkAndRun(ga) ga.completer.Wait() return ga.result }]}
{Id:20 FileId:120 StartLine:411 StartColumn:1 EndLine:413 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0015817c0 Body:{
	return atomic.LoadUint64(&tree.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&tree.number) }]}
{Id:21 FileId:120 StartLine:417 StartColumn:1 EndLine:420 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0015817e0 Body:{
	tree.actions.Dispose()
	atomic.StoreUint64(&tree.disposed, 1)
} PrettyPrintBody:[{ tree.actions.Dispose() atomic.StoreUint64(&tree.disposed, 1) }]}
{Id:22 FileId:120 StartLine:422 StartColumn:1 EndLine:426 EndColumn:2 Name:newTree Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:*tree}] Receiver:<nil> Body:{
	tree := &tree{}
	tree.init(bufferSize, ary)
	return tree
} PrettyPrintBody:[{ tree := &tree{} tree.init(bufferSize, ary) return tree }]}
{Id:23 FileId:120 StartLine:429 StartColumn:1 EndLine:431 EndColumn:2 Name:New Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:rtree.RTree}] Receiver:<nil> Body:{
	return newTree(bufferSize, ary)
} PrettyPrintBody:[{ return newTree(bufferSize, ary) }]}
{Id:1 FileId:36 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]}
{Id:2 FileId:36 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:generateRandomKeys Params:[{Name:num Type:int}] Results:[{Name: Type:Keys}] Receiver:<nil> Body:{
	keys := make(Keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(uint64(rand.Uint32()%uint32(100))))
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(uint64(rand.Uint32()%uint32(100)))) } return keys }]}
{Id:3 FileId:36 StartLine:41 StartColumn:1 EndLine:48 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:Keys}] Receiver:<nil> Body:{
	keys := make(Keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(uint64(i)))
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(uint64(i))) } return keys }]}
{Id:4 FileId:36 StartLine:50 StartColumn:1 EndLine:60 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := mockKey(5)

	tree := newTree(8, 1)
	result := tree.Insert(k1)
	assert.Equal(t, Keys{nil}, result)
	assert.Equal(t, uint64(1), tree.Len())
	if !assert.Equal(t, Keys{k1}, tree.Get(k1)) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ k1 := mockKey(5) tree := newTree(8, 1) result := tree.Insert(k1) assert.Equal(t, Keys{nil}, result) assert.Equal(t, uint64(1), tree.Len()) if !assert.Equal(t, Keys{k1}, tree.Get(k1)) { tree.print(getConsoleLogger()) } }]}
{Id:5 FileId:36 StartLine:62 StartColumn:1 EndLine:72 EndColumn:2 Name:TestMultipleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := mockKey(10)
	k2 := mockKey(5)
	tree := newTree(8, 1)

	result := tree.Insert(k1, k2)
	assert.Equal(t, Keys{nil, nil}, result)
	assert.Equal(t, uint64(2), tree.Len())
	assert.Equal(t, Keys{k1, k2}, tree.Get(k1, k2))
	checkTree(t, tree)
} PrettyPrintBody:[{ k1 := mockKey(10) k2 := mockKey(5) tree := newTree(8, 1) result := tree.Insert(k1, k2) assert.Equal(t, Keys{nil, nil}, result) assert.Equal(t, uint64(2), tree.Len()) assert.Equal(t, Keys{k1, k2}, tree.Get(k1, k2)) checkTree(t, tree) }]}
{Id:6 FileId:36 StartLine:74 StartColumn:1 EndLine:85 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(15), mockKey(10), mockKey(5)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(15), mockKey(10), mockKey(5) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:7 FileId:36 StartLine:87 StartColumn:1 EndLine:98 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(5), mockKey(10), mockKey(15)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(5), mockKey(10), mockKey(15) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:8 FileId:36 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(10), mockKey(5), mockKey(15)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(10), mockKey(5), mockKey(15) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:9 FileId:36 StartLine:113 StartColumn:1 EndLine:125 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(20), mockKey(15), mockKey(10), mockKey(5)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())

	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(20), mockKey(15), mockKey(10), mockKey(5) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:10 FileId:36 StartLine:127 StartColumn:1 EndLine:138 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(5), mockKey(10), mockKey(15), mockKey(20)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(5), mockKey(10), mockKey(15), mockKey(20) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:11 FileId:36 StartLine:140 StartColumn:1 EndLine:151 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(10), mockKey(15), mockKey(20), mockKey(5)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(10), mockKey(15), mockKey(20), mockKey(5) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:12 FileId:36 StartLine:153 StartColumn:1 EndLine:163 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryMultiThreaded Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(16)
	tree := newTree(16, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateRandomKeys(16) tree := newTree(16, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:13 FileId:36 StartLine:165 StartColumn:1 EndLine:177 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(1600)
	tree := newTree(9, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	checkTree(t, tree)

	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateRandomKeys(1600) tree := newTree(9, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) checkTree(t, tree) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:14 FileId:36 StartLine:179 StartColumn:1 EndLine:193 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateKeys(30000)
	tree := newTree(17, 8)

	reversed := keys.reverse()

	result := tree.Insert(reversed...)

	assert.Len(t, result, len(keys))

	if !assert.Equal(t, keys, tree.Get(keys...)) {

	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateKeys(30000) tree := newTree(17, 8) reversed := keys.reverse() result := tree.Insert(reversed...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { } checkTree(t, tree) }]}
{Id:15 FileId:36 StartLine:195 StartColumn:1 EndLine:204 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(200)
	tree := newTree(12, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ keys := generateRandomKeys(200) tree := newTree(12, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } }]}
{Id:16 FileId:36 StartLine:206 StartColumn:1 EndLine:218 EndColumn:2 Name:TestOverwriteOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(15)
	tree := newTree(3, 8)
	duplicate := mockKey(uint64(keys[0].(mockKey)))

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	oldLength := tree.Len()

	result = tree.Insert(duplicate)
	assert.Equal(t, Keys{keys[0]}, result)
	assert.Equal(t, oldLength, tree.Len())
} PrettyPrintBody:[{ keys := generateRandomKeys(15) tree := newTree(3, 8) duplicate := mockKey(uint64(keys[0].(mockKey))) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) oldLength := tree.Len() result = tree.Insert(duplicate) assert.Equal(t, Keys{keys[0]}, result) assert.Equal(t, oldLength, tree.Len()) }]}
{Id:17 FileId:36 StartLine:220 StartColumn:1 EndLine:232 EndColumn:2 Name:TestOverwriteEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(15)
	tree := newTree(12, 8)
	duplicate := mockKey(uint64(keys[0].(mockKey)))

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	oldLength := tree.Len()

	result = tree.Insert(duplicate)
	assert.Equal(t, Keys{keys[0]}, result)
	assert.Equal(t, oldLength, tree.Len())
} PrettyPrintBody:[{ keys := generateRandomKeys(15) tree := newTree(12, 8) duplicate := mockKey(uint64(keys[0].(mockKey))) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) oldLength := tree.Len() result = tree.Insert(duplicate) assert.Equal(t, Keys{keys[0]}, result) assert.Equal(t, oldLength, tree.Len()) }]}
{Id:18 FileId:36 StartLine:234 StartColumn:1 EndLine:244 EndColumn:2 Name:BenchmarkSimpleAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := generateRandomKeys(numItems)
	tree := newTree(16, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 1000 keys := generateRandomKeys(numItems) tree := newTree(16, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]}
{Id:19 FileId:36 StartLine:246 StartColumn:1 EndLine:257 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := generateRandomKeys(numItems)
	tree := newTree(16, 4)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 1000 keys := generateRandomKeys(numItems) tree := newTree(16, 4) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]}
{Id:20 FileId:36 StartLine:259 StartColumn:1 EndLine:269 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newTree(64, 1)
		tree.Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newTree(64, 1) tree.Insert(keys...) } }]}
{Id:2 FileId:141 StartLine:47 StartColumn:1 EndLine:58 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*Immutable}] Receiver:0xc0011dba40 Body:{
	var root *node
	if immutable.root != nil {
		root = immutable.root.copy()
	}
	cp := &Immutable{
		root:	root,
		number:	immutable.number,
		dummy:	*newNode(nil),
	}
	return cp
} PrettyPrintBody:[{ var root *node if immutable.root != nil { root = immutable.root.copy() } cp := &Immutable{ root:	root, number:	immutable.number, dummy:	*newNode(nil), } return cp }]}
{Id:3 FileId:141 StartLine:60 StartColumn:1 EndLine:63 EndColumn:2 Name:resetDummy Params:[] Results:[] Receiver:0xc001033060 Body:{
	immutable.dummy.children[0], immutable.dummy.children[1] = nil, nil
	immutable.dummy.balance = 0
} PrettyPrintBody:[{ immutable.dummy.children[0], immutable.dummy.children[1] = nil, nil immutable.dummy.balance = 0 }]}
{Id:4 FileId:141 StartLine:65 StartColumn:1 EndLine:69 EndColumn:2 Name:init Params:[] Results:[] Receiver:0xc0010330a0 Body:{
	immutable.dummy = node{
		children: [2]*node{},
	}
} PrettyPrintBody:[{ immutable.dummy = node{ children: [2]*node{}, } }]}
{Id:5 FileId:141 StartLine:71 StartColumn:1 EndLine:86 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001580d00 Body:{
	n := immutable.root
	var result int
	for n != nil {
		switch result = n.entry.Compare(entry); {
		case result == 0:
			return n.entry
		case result > 0:
			n = n.children[0]
		case result < 0:
			n = n.children[1]
		}
	}

	return nil
} PrettyPrintBody:[{ n := immutable.root var result int for n != nil { switch result = n.entry.Compare(entry); { case result == 0: return n.entry case result > 0: n = n.children[0] case result < 0: n = n.children[1] } } return nil }]}
{Id:6 FileId:141 StartLine:90 StartColumn:1 EndLine:97 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc00095a1c0 Body:{
	result := make(Entries, 0, len(entries))
	for _, e := range entries {
		result = append(result, immutable.get(e))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, e := range entries { result = append(result, immutable.get(e)) } return result }]}
{Id:7 FileId:141 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001033740 Body:{
	return immutable.number
} PrettyPrintBody:[{ return immutable.number }]}
{Id:8 FileId:141 StartLine:104 StartColumn:1 EndLine:185 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc000a8a0e0 Body:{

	if immutable.root == nil {
		immutable.root = newNode(entry)
		immutable.number++
		return nil
	}

	immutable.resetDummy()
	var (
		dummy		= immutable.dummy
		p, s, q		*node
		dir, normalized	int
		helper		= &dummy
	)

	helper.children[1] = immutable.root

	for s, p = helper.children[1], helper.children[1]; ; {
		dir = p.entry.Compare(entry)

		normalized = normalizeComparison(dir)
		if dir > 0 {
			if p.children[0] != nil {
				q = p.children[0].copy()
				p.children[0] = q
			} else {
				q = nil
			}
		} else if dir < 0 {
			if p.children[1] != nil {
				q = p.children[1].copy()
				p.children[1] = q
			} else {
				q = nil
			}
		} else {
			oldEntry := p.entry
			p.entry = entry
			return oldEntry
		}
		if q == nil {
			break
		}

		if q.balance != 0 {
			helper = p
			s = q
		}
		p = q
	}

	immutable.number++
	q = newNode(entry)
	p.children[normalized] = q

	immutable.root = dummy.children[1]
	for p = s; p != q; p = p.children[normalized] {
		normalized = normalizeComparison(p.entry.Compare(entry))
		if normalized == 0 {
			p.balance--
		} else {
			p.balance++
		}
	}

	q = s

	if math.Abs(float64(s.balance)) > 1 {
		normalized = normalizeComparison(s.entry.Compare(entry))
		s = insertBalance(s, normalized)
	}

	if q == dummy.children[1] {
		immutable.root = s
	} else {
		helper.children[intFromBool(helper.children[1] == q)] = s
	}
	return nil
} PrettyPrintBody:[{ if immutable.root == nil { immutable.root = newNode(entry) immutable.number++ return nil } immutable.resetDummy() var ( dummy		= immutable.dummy p, s, q		*node dir, normalized	int helper		= &dummy ) helper.children[1] = immutable.root for s, p = helper.children[1], helper.children[1]; ; { dir = p.entry.Compare(entry) normalized = normalizeComparison(dir) if dir > 0 { if p.children[0] != nil { q = p.children[0].copy() p.children[0] = q } else { q = nil } } else if dir < 0 { if p.children[1] != nil { q = p.children[1].copy() p.children[1] = q } else { q = nil } } else { oldEntry := p.entry p.entry = entry return oldEntry } if q == nil { break } if q.balance != 0 { helper = p s = q } p = q } immutable.number++ q = newNode(entry) p.children[normalized] = q immutable.root = dummy.children[1] for p = s; p != q; p = p.children[normalized] { normalized = normalizeComparison(p.entry.Compare(entry)) if normalized == 0 { p.balance-- } else { p.balance++ } } q = s if math.Abs(float64(s.balance)) > 1 { normalized = normalizeComparison(s.entry.Compare(entry)) s = insertBalance(s, normalized) } if q == dummy.children[1] { immutable.root = s } else { helper.children[intFromBool(helper.children[1] == q)] = s } return nil }]}
{Id:9 FileId:141 StartLine:190 StartColumn:1 EndLine:202 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*Immutable} {Name: Type:Entries}] Receiver:0xc00019e2c0 Body:{
	if len(entries) == 0 {
		return immutable, Entries{}
	}

	overwritten := make(Entries, 0, len(entries))
	cp := immutable.copy()
	for _, e := range entries {
		overwritten = append(overwritten, cp.insert(e))
	}

	return cp, overwritten
} PrettyPrintBody:[{ if len(entries) == 0 { return immutable, Entries{} } overwritten := make(Entries, 0, len(entries)) cp := immutable.copy() for _, e := range entries { overwritten = append(overwritten, cp.insert(e)) } return cp, overwritten }]}
{Id:10 FileId:141 StartLine:204 StartColumn:1 EndLine:309 EndColumn:2 Name:delete Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc00095ae60 Body:{

	if immutable.root == nil {
		return nil
	}

	var (
		cache				= make(nodes, 64)
		it, p, q			*node
		top, done, dir, normalized	int
		dirs				= make([]int, 64)
		oldEntry			Entry
	)

	it = immutable.root

	for {
		if it == nil {
			return nil
		}

		dir = it.entry.Compare(entry)
		if dir == 0 {
			break
		}
		normalized = normalizeComparison(dir)
		dirs[top] = normalized
		cache[top] = it
		top++
		it = it.children[normalized]
	}
	immutable.number--
	oldEntry = it.entry

	for i := 0; i < top; i++ {
		p = cache[i]
		if p.children[dirs[i]] != nil {
			q = p.children[dirs[i]].copy()
			p.children[dirs[i]] = q
			if i != top-1 {
				cache[i+1] = q
			}
		}
	}
	it = it.copy()

	oldTop := top
	if it.children[0] == nil || it.children[1] == nil {
		dir = intFromBool(it.children[0] == nil)
		if top != 0 {
			cache[top-1].children[dirs[top-1]] = it.children[dir]
		} else {
			immutable.root = it.children[dir]
		}
	} else {
		heir := it.children[1]
		dirs[top] = 1
		cache[top] = it
		top++

		for heir.children[0] != nil {
			dirs[top] = 0
			cache[top] = heir
			top++
			heir = heir.children[0]
		}

		it.entry = heir.entry
		if oldTop != 0 {
			cache[oldTop-1].children[dirs[oldTop-1]] = it
		} else {
			immutable.root = it
		}
		cache[top-1].children[intFromBool(cache[top-1] == it)] = heir.children[1]
	}

	for top-1 >= 0 && done == 0 {
		top--

		if dirs[top] != 0 {
			cache[top].balance--
		} else {
			cache[top].balance++
		}

		if math.Abs(float64(cache[top].balance)) == 1 {
			break
		} else if math.Abs(float64(cache[top].balance)) > 1 {

			cache[top] = removeBalance(cache[top], dirs[top], &done)

			if top != 0 {
				cache[top-1].children[dirs[top-1]] = cache[top]
			} else {
				immutable.root = cache[0]
			}
		}

	}

	return oldEntry
} PrettyPrintBody:[{ if immutable.root == nil { return nil } var ( cache				= make(nodes, 64) it, p, q			*node top, done, dir, normalized	int dirs				= make([]int, 64) oldEntry			Entry ) it = immutable.root for { if it == nil { return nil } dir = it.entry.Compare(entry) if dir == 0 { break } normalized = normalizeComparison(dir) dirs[top] = normalized cache[top] = it top++ it = it.children[normalized] } immutable.number-- oldEntry = it.entry for i := 0; i < top; i++ { p = cache[i] if p.children[dirs[i]] != nil { q = p.children[dirs[i]].copy() p.children[dirs[i]] = q if i != top-1 { cache[i+1] = q } } } it = it.copy() oldTop := top if it.children[0] == nil || it.children[1] == nil { dir = intFromBool(it.children[0] == nil) if top != 0 { cache[top-1].children[dirs[top-1]] = it.children[dir] } else { immutable.root = it.children[dir] } } else { heir := it.children[1] dirs[top] = 1 cache[top] = it top++ for heir.children[0] != nil { dirs[top] = 0 cache[top] = heir top++ heir = heir.children[0] } it.entry = heir.entry if oldTop != 0 { cache[oldTop-1].children[dirs[oldTop-1]] = it } else { immutable.root = it } cache[top-1].children[intFromBool(cache[top-1] == it)] = heir.children[1] } for top-1 >= 0 && done == 0 { top-- if dirs[top] != 0 { cache[top].balance-- } else { cache[top].balance++ } if math.Abs(float64(cache[top].balance)) == 1 { break } else if math.Abs(float64(cache[top].balance)) > 1 { cache[top] = removeBalance(cache[top], dirs[top], &done) if top != 0 { cache[top-1].children[dirs[top-1]] = cache[top] } else { immutable.root = cache[0] } } } return oldEntry }]}
{Id:11 FileId:141 StartLine:314 StartColumn:1 EndLine:326 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*Immutable} {Name: Type:Entries}] Receiver:0xc0000ed900 Body:{
	if len(entries) == 0 {
		return immutable, Entries{}
	}

	deleted := make(Entries, 0, len(entries))
	cp := immutable.copy()
	for _, e := range entries {
		deleted = append(deleted, cp.delete(e))
	}

	return cp, deleted
} PrettyPrintBody:[{ if len(entries) == 0 { return immutable, Entries{} } deleted := make(Entries, 0, len(entries)) cp := immutable.copy() for _, e := range entries { deleted = append(deleted, cp.delete(e)) } return cp, deleted }]}
{Id:12 FileId:141 StartLine:328 StartColumn:1 EndLine:346 EndColumn:2 Name:insertBalance Params:[{Name:root Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := root.children[dir]
	var bal int8
	if dir == 0 {
		bal = -1
	} else {
		bal = 1
	}

	if n.balance == bal {
		root.balance, n.balance = 0, 0
		root = rotate(root, takeOpposite(dir))
	} else {
		adjustBalance(root, dir, int(bal))
		root = doubleRotate(root, takeOpposite(dir))
	}

	return root
} PrettyPrintBody:[{ n := root.children[dir] var bal int8 if dir == 0 { bal = -1 } else { bal = 1 } if n.balance == bal { root.balance, n.balance = 0, 0 root = rotate(root, takeOpposite(dir)) } else { adjustBalance(root, dir, int(bal)) root = doubleRotate(root, takeOpposite(dir)) } return root }]}
{Id:13 FileId:141 StartLine:348 StartColumn:1 EndLine:372 EndColumn:2 Name:removeBalance Params:[{Name:root Type:*node} {Name:dir Type:int} {Name:done Type:*int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := root.children[takeOpposite(dir)].copy()
	root.children[takeOpposite(dir)] = n
	var bal int8
	if dir == 0 {
		bal = -1
	} else {
		bal = 1
	}

	if n.balance == -bal {
		root.balance, n.balance = 0, 0
		root = rotate(root, dir)
	} else if n.balance == bal {
		adjustBalance(root, takeOpposite(dir), int(-bal))
		root = doubleRotate(root, dir)
	} else {
		root.balance = -bal
		n.balance = bal
		root = rotate(root, dir)
		*done = 1
	}

	return root
} PrettyPrintBody:[{ n := root.children[takeOpposite(dir)].copy() root.children[takeOpposite(dir)] = n var bal int8 if dir == 0 { bal = -1 } else { bal = 1 } if n.balance == -bal { root.balance, n.balance = 0, 0 root = rotate(root, dir) } else if n.balance == bal { adjustBalance(root, takeOpposite(dir), int(-bal)) root = doubleRotate(root, dir) } else { root.balance = -bal n.balance = bal root = rotate(root, dir) *done = 1 } return root }]}
{Id:14 FileId:141 StartLine:374 StartColumn:1 EndLine:380 EndColumn:2 Name:intFromBool Params:[{Name:value Type:bool}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if value {
		return 1
	}

	return 0
} PrettyPrintBody:[{ if value { return 1 } return 0 }]}
{Id:15 FileId:141 StartLine:382 StartColumn:1 EndLine:384 EndColumn:2 Name:takeOpposite Params:[{Name:value Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	return 1 - value
} PrettyPrintBody:[{ return 1 - value }]}
{Id:16 FileId:141 StartLine:386 StartColumn:1 EndLine:400 EndColumn:2 Name:adjustBalance Params:[{Name:root Type:*node} {Name:dir Type:int}] Results:[] Receiver:<nil> Body:{
	n := root.children[dir]
	nn := n.children[takeOpposite(dir)]

	if nn.balance == 0 {
		root.balance, n.balance = 0, 0
	} else if int(nn.balance) == bal {
		root.balance = int8(-bal)
		n.balance = 0
	} else {
		root.balance = 0
		n.balance = int8(bal)
	}
	nn.balance = 0
} PrettyPrintBody:[{ n := root.children[dir] nn := n.children[takeOpposite(dir)] if nn.balance == 0 { root.balance, n.balance = 0, 0 } else if int(nn.balance) == bal { root.balance = int8(-bal) n.balance = 0 } else { root.balance = 0 n.balance = int8(bal) } nn.balance = 0 }]}
{Id:17 FileId:141 StartLine:402 StartColumn:1 EndLine:410 EndColumn:2 Name:rotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	child := parent.children[otherDir]
	parent.children[otherDir] = child.children[dir]
	child.children[dir] = parent

	return child
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) child := parent.children[otherDir] parent.children[otherDir] = child.children[dir] child.children[dir] = parent return child }]}
{Id:18 FileId:141 StartLine:412 StartColumn:1 EndLine:417 EndColumn:2 Name:doubleRotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	parent.children[otherDir] = rotate(parent.children[otherDir], otherDir)
	return rotate(parent, dir)
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) parent.children[otherDir] = rotate(parent.children[otherDir], otherDir) return rotate(parent, dir) }]}
{Id:19 FileId:141 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:normalizeComparison Params:[{Name:i Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if i < 0 {
		return 1
	}

	if i > 0 {
		return 0
	}

	return -1
} PrettyPrintBody:[{ if i < 0 { return 1 } if i > 0 { return 0 } return -1 }]}
{Id:20 FileId:141 StartLine:435 StartColumn:1 EndLine:439 EndColumn:2 Name:NewImmutable Params:[] Results:[{Name: Type:*Immutable}] Receiver:<nil> Body:{
	immutable := &Immutable{}
	immutable.init()
	return immutable
} PrettyPrintBody:[{ immutable := &Immutable{} immutable.init() return immutable }]}
{Id:3 FileId:132 StartLine:86 StartColumn:1 EndLine:91 EndColumn:2 Name:Int63 Params:[] Results:[{Name:n Type:int64}] Receiver:0xc000e7fd60 Body:{
	ls.mu.Lock()
	n = ls.src.Int63()
	ls.mu.Unlock()
	return
} PrettyPrintBody:[{ ls.mu.Lock() n = ls.src.Int63() ls.mu.Unlock() return }]}
{Id:4 FileId:132 StartLine:94 StartColumn:1 EndLine:98 EndColumn:2 Name:Seed Params:[{Name:seed Type:int64}] Results:[] Receiver:0xc00095a3a0 Body:{
	ls.mu.Lock()
	ls.src.Seed(seed)
	ls.mu.Unlock()
} PrettyPrintBody:[{ ls.mu.Lock() ls.src.Seed(seed) ls.mu.Unlock() }]}
{Id:6 FileId:132 StartLine:106 StartColumn:1 EndLine:116 EndColumn:2 Name:generateLevel Params:[{Name:maxLevel Type:uint8}] Results:[{Name: Type:uint8}] Receiver:<nil> Body:{
	var level uint8
	for level = uint8(1); level < maxLevel-1; level++ {
		if generator.Float64() >= p {

			return level
		}
	}

	return level
} PrettyPrintBody:[{ var level uint8 for level = uint8(1); level < maxLevel-1; level++ { if generator.Float64() >= p { return level } } return level }]}
{Id:7 FileId:132 StartLine:118 StartColumn:1 EndLine:158 EndColumn:2 Name:insertNode Params:[{Name:sl Type:*SkipList} {Name:n Type:*node} {Name:cmp Type:common.Comparator} {Name:pos Type:uint64} {Name:cache Type:nodes} {Name:posCache Type:widths} {Name:allowDuplicate Type:bool}] Results:[{Name: Type:common.Comparator}] Receiver:<nil> Body:{
	if !allowDuplicate && n != nil && n.Compare(cmp) == 0 {
		oldEntry := n.entry
		n.entry = cmp
		return oldEntry
	}
	atomic.AddUint64(&sl.num, 1)

	nodeLevel := generateLevel(sl.maxLevel)
	if nodeLevel > sl.level {
		for i := sl.level; i < nodeLevel; i++ {
			cache[i] = sl.head
		}
		sl.level = nodeLevel
	}

	nn := newNode(cmp, nodeLevel)
	for i := uint8(0); i < nodeLevel; i++ {
		nn.forward[i] = cache[i].forward[i]
		cache[i].forward[i] = nn
		formerWidth := cache[i].widths[i]
		if formerWidth == 0 {
			nn.widths[i] = 0
		} else {
			nn.widths[i] = posCache[i] + formerWidth + 1 - pos
		}

		if cache[i].forward[i] != nil {
			cache[i].widths[i] = pos - posCache[i]
		}

	}

	for i := nodeLevel; i < sl.level; i++ {
		if cache[i].forward[i] == nil {
			continue
		}
		cache[i].widths[i]++
	}
	return nil
} PrettyPrintBody:[{ if !allowDuplicate && n != nil && n.Compare(cmp) == 0 { oldEntry := n.entry n.entry = cmp return oldEntry } atomic.AddUint64(&sl.num, 1) nodeLevel := generateLevel(sl.maxLevel) if nodeLevel > sl.level { for i := sl.level; i < nodeLevel; i++ { cache[i] = sl.head } sl.level = nodeLevel } nn := newNode(cmp, nodeLevel) for i := uint8(0); i < nodeLevel; i++ { nn.forward[i] = cache[i].forward[i] cache[i].forward[i] = nn formerWidth := cache[i].widths[i] if formerWidth == 0 { nn.widths[i] = 0 } else { nn.widths[i] = posCache[i] + formerWidth + 1 - pos } if cache[i].forward[i] != nil { cache[i].widths[i] = pos - posCache[i] } } for i := nodeLevel; i < sl.level; i++ { if cache[i].forward[i] == nil { continue } cache[i].widths[i]++ } return nil }]}
{Id:8 FileId:132 StartLine:160 StartColumn:1 EndLine:185 EndColumn:2 Name:splitAt Params:[{Name:sl Type:*SkipList} {Name:index Type:uint64}] Results:[{Name: Type:*SkipList} {Name: Type:*SkipList}] Receiver:<nil> Body:{
	right := &SkipList{}
	right.maxLevel = sl.maxLevel
	right.level = sl.level
	right.cache = make(nodes, sl.maxLevel)
	right.posCache = make(widths, sl.maxLevel)
	right.head = newNode(nil, sl.maxLevel)
	sl.searchByPosition(index, sl.cache, sl.posCache)

	for i := uint8(0); i <= sl.level; i++ {
		right.head.forward[i] = sl.cache[i].forward[i]
		if sl.cache[i].forward[i] != nil {
			right.head.widths[i] = sl.cache[i].widths[i] - (index - sl.posCache[i])
		}
		sl.cache[i].widths[i] = 0
		sl.cache[i].forward[i] = nil
	}

	right.num = sl.Len() - index
	atomic.AddUint64(&sl.num, -right.num)

	sl.resetMaxLevel()
	right.resetMaxLevel()

	return sl, right
} PrettyPrintBody:[{ right := &SkipList{} right.maxLevel = sl.maxLevel right.level = sl.level right.cache = make(nodes, sl.maxLevel) right.posCache = make(widths, sl.maxLevel) right.head = newNode(nil, sl.maxLevel) sl.searchByPosition(index, sl.cache, sl.posCache) for i := uint8(0); i <= sl.level; i++ { right.head.forward[i] = sl.cache[i].forward[i] if sl.cache[i].forward[i] != nil { right.head.widths[i] = sl.cache[i].widths[i] - (index - sl.posCache[i]) } sl.cache[i].widths[i] = 0 sl.cache[i].forward[i] = nil } right.num = sl.Len() - index atomic.AddUint64(&sl.num, -right.num) sl.resetMaxLevel() right.resetMaxLevel() return sl, right }]}
{Id:10 FileId:132 StartLine:204 StartColumn:1 EndLine:218 EndColumn:2 Name:init Params:[{Name:ifc Type:interface{}}] Results:[] Receiver:0xc000993980 Body:{
	switch ifc.(type) {
	case uint8:
		sl.maxLevel = 8
	case uint16:
		sl.maxLevel = 16
	case uint32:
		sl.maxLevel = 32
	case uint64, uint:
		sl.maxLevel = 64
	}
	sl.cache = make(nodes, sl.maxLevel)
	sl.posCache = make(widths, sl.maxLevel)
	sl.head = newNode(nil, sl.maxLevel)
} PrettyPrintBody:[{ switch ifc.(type) { case uint8: sl.maxLevel = 8 case uint16: sl.maxLevel = 16 case uint32: sl.maxLevel = 32 case uint64, uint: sl.maxLevel = 64 } sl.cache = make(nodes, sl.maxLevel) sl.posCache = make(widths, sl.maxLevel) sl.head = newNode(nil, sl.maxLevel) }]}
{Id:11 FileId:132 StartLine:220 StartColumn:1 EndLine:244 EndColumn:2 Name:search Params:[{Name:cmp Type:common.Comparator} {Name:update Type:nodes} {Name:widths Type:widths}] Results:[{Name: Type:*node} {Name: Type:uint64}] Receiver:0xc001173ec0 Body:{
	if sl.Len() == 0 {
		return nil, 1
	}

	var pos uint64 = 0
	var offset uint8
	var alreadyChecked *node
	n := sl.head
	for i := uint8(0); i <= sl.level; i++ {
		offset = sl.level - i
		for n.forward[offset] != nil && n.forward[offset] != alreadyChecked && n.forward[offset].Compare(cmp) < 0 {
			pos += n.widths[offset]
			n = n.forward[offset]
		}

		alreadyChecked = n
		if update != nil {
			update[offset] = n
			widths[offset] = pos
		}
	}

	return n.forward[0], pos + 1
} PrettyPrintBody:[{ if sl.Len() == 0 { return nil, 1 } var pos uint64 = 0 var offset uint8 var alreadyChecked *node n := sl.head for i := uint8(0); i <= sl.level; i++ { offset = sl.level - i for n.forward[offset] != nil && n.forward[offset] != alreadyChecked && n.forward[offset].Compare(cmp) < 0 { pos += n.widths[offset] n = n.forward[offset] } alreadyChecked = n if update != nil { update[offset] = n widths[offset] = pos } } return n.forward[0], pos + 1 }]}
{Id:12 FileId:132 StartLine:246 StartColumn:1 EndLine:254 EndColumn:2 Name:resetMaxLevel Params:[] Results:[] Receiver:0xc000a8a8e0 Body:{
	if sl.level < 1 {
		sl.level = 1
		return
	}
	for sl.head.forward[sl.level-1] == nil && sl.level > 1 {
		sl.level--
	}
} PrettyPrintBody:[{ if sl.level < 1 { sl.level = 1 return } for sl.head.forward[sl.level-1] == nil && sl.level > 1 { sl.level-- } }]}
{Id:13 FileId:132 StartLine:256 StartColumn:1 EndLine:282 EndColumn:2 Name:searchByPosition Params:[{Name:position Type:uint64} {Name:update Type:nodes} {Name:widths Type:widths}] Results:[{Name: Type:*node} {Name: Type:uint64}] Receiver:0xc00019e340 Body:{
	if sl.Len() == 0 {
		return nil, 1
	}

	if position > sl.Len() {
		return nil, 1
	}

	var pos uint64 = 0
	var offset uint8
	n := sl.head
	for i := uint8(0); i <= sl.level; i++ {
		offset = sl.level - i
		for n.forward[offset] != nil && pos+n.widths[offset] <= position {
			pos += n.widths[offset]
			n = n.forward[offset]
		}

		if update != nil {
			update[offset] = n
			widths[offset] = pos
		}
	}

	return n, pos + 1
} PrettyPrintBody:[{ if sl.Len() == 0 { return nil, 1 } if position > sl.Len() { return nil, 1 } var pos uint64 = 0 var offset uint8 n := sl.head for i := uint8(0); i <= sl.level; i++ { offset = sl.level - i for n.forward[offset] != nil && pos+n.widths[offset] <= position { pos += n.widths[offset] n = n.forward[offset] } if update != nil { update[offset] = n widths[offset] = pos } } return n, pos + 1 }]}
{Id:14 FileId:132 StartLine:287 StartColumn:1 EndLine:301 EndColumn:2 Name:Get Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc000993ec0 Body:{
	result := make(common.Comparators, 0, len(comparators))

	var n *node
	for _, cmp := range comparators {
		n, _ = sl.search(cmp, nil, nil)
		if n != nil && n.Compare(cmp) == 0 {
			result = append(result, n.entry)
		} else {
			result = append(result, nil)
		}
	}

	return result
} PrettyPrintBody:[{ result := make(common.Comparators, 0, len(comparators)) var n *node for _, cmp := range comparators { n, _ = sl.search(cmp, nil, nil) if n != nil && n.Compare(cmp) == 0 { result = append(result, n.entry) } else { result = append(result, nil) } } return result }]}
{Id:15 FileId:132 StartLine:306 StartColumn:1 EndLine:313 EndColumn:2 Name:GetWithPosition Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc0003e5780 Body:{
	n, pos := sl.search(cmp, nil, nil)
	if n == nil {
		return nil, 0
	}

	return n.entry, pos - 1
} PrettyPrintBody:[{ n, pos := sl.search(cmp, nil, nil) if n == nil { return nil, 0 } return n.entry, pos - 1 }]}
{Id:16 FileId:132 StartLine:316 StartColumn:1 EndLine:323 EndColumn:2 Name:ByPosition Params:[{Name:position Type:uint64}] Results:[{Name: Type:common.Comparator}] Receiver:0xc0001e6840 Body:{
	n, _ := sl.searchByPosition(position+1, nil, nil)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(position+1, nil, nil) if n == nil { return nil } return n.entry }]}
{Id:17 FileId:132 StartLine:325 StartColumn:1 EndLine:328 EndColumn:2 Name:insert Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc000a8bc20 Body:{
	n, pos := sl.search(cmp, sl.cache, sl.posCache)
	return insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, false)
} PrettyPrintBody:[{ n, pos := sl.search(cmp, sl.cache, sl.posCache) return insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, false) }]}
{Id:18 FileId:132 StartLine:333 StartColumn:1 EndLine:340 EndColumn:2 Name:Insert Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0009928c0 Body:{
	overwritten := make(common.Comparators, 0, len(comparators))
	for _, cmp := range comparators {
		overwritten = append(overwritten, sl.insert(cmp))
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(common.Comparators, 0, len(comparators)) for _, cmp := range comparators { overwritten = append(overwritten, sl.insert(cmp)) } return overwritten }]}
{Id:19 FileId:132 StartLine:342 StartColumn:1 EndLine:348 EndColumn:2 Name:insertAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc0001e7060 Body:{
	if position > sl.Len() {
		position = sl.Len()
	}
	n, pos := sl.searchByPosition(position, sl.cache, sl.posCache)
	insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, true)
} PrettyPrintBody:[{ if position > sl.Len() { position = sl.Len() } n, pos := sl.searchByPosition(position, sl.cache, sl.posCache) insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, true) }]}
{Id:20 FileId:132 StartLine:354 StartColumn:1 EndLine:356 EndColumn:2 Name:InsertAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc0001e7400 Body:{
	sl.insertAtPosition(position, cmp)
} PrettyPrintBody:[{ sl.insertAtPosition(position, cmp) }]}
{Id:21 FileId:132 StartLine:358 StartColumn:1 EndLine:365 EndColumn:2 Name:replaceAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc00095b8e0 Body:{
	n, _ := sl.searchByPosition(position+1, nil, nil)
	if n == nil {
		return
	}

	n.entry = cmp
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(position+1, nil, nil) if n == nil { return } n.entry = cmp }]}
{Id:22 FileId:132 StartLine:370 StartColumn:1 EndLine:372 EndColumn:2 Name:ReplaceAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc000258880 Body:{
	sl.replaceAtPosition(position, cmp)
} PrettyPrintBody:[{ sl.replaceAtPosition(position, cmp) }]}
{Id:23 FileId:132 StartLine:374 StartColumn:1 EndLine:401 EndColumn:2 Name:delete Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc000258c00 Body:{
	n, _ := sl.search(cmp, sl.cache, sl.posCache)

	if n == nil || n.Compare(cmp) != 0 {
		return nil
	}

	atomic.AddUint64(&sl.num, ^uint64(0))

	for i := uint8(0); i <= sl.level; i++ {
		if sl.cache[i].forward[i] != n {
			if sl.cache[i].forward[i] != nil {
				sl.cache[i].widths[i]--
			}
			continue
		}

		sl.cache[i].widths[i] += n.widths[i] - 1
		sl.cache[i].forward[i] = n.forward[i]
	}

	for sl.level > 1 && sl.head.forward[sl.level-1] == nil {
		sl.head.widths[sl.level] = 0
		sl.level--
	}

	return n.entry
} PrettyPrintBody:[{ n, _ := sl.search(cmp, sl.cache, sl.posCache) if n == nil || n.Compare(cmp) != 0 { return nil } atomic.AddUint64(&sl.num, ^uint64(0)) for i := uint8(0); i <= sl.level; i++ { if sl.cache[i].forward[i] != n { if sl.cache[i].forward[i] != nil { sl.cache[i].widths[i]-- } continue } sl.cache[i].widths[i] += n.widths[i] - 1 sl.cache[i].forward[i] = n.forward[i] } for sl.level > 1 && sl.head.forward[sl.level-1] == nil { sl.head.widths[sl.level] = 0 sl.level-- } return n.entry }]}
{Id:24 FileId:132 StartLine:406 StartColumn:1 EndLine:414 EndColumn:2 Name:Delete Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0000edb80 Body:{
	deleted := make(common.Comparators, 0, len(comparators))

	for _, cmp := range comparators {
		deleted = append(deleted, sl.delete(cmp))
	}

	return deleted
} PrettyPrintBody:[{ deleted := make(common.Comparators, 0, len(comparators)) for _, cmp := range comparators { deleted = append(deleted, sl.delete(cmp)) } return deleted }]}
{Id:25 FileId:132 StartLine:417 StartColumn:1 EndLine:419 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001603b80 Body:{
	return atomic.LoadUint64(&sl.num)
} PrettyPrintBody:[{ return atomic.LoadUint64(&sl.num) }]}
{Id:26 FileId:132 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:iterAtPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*iterator}] Receiver:0xc0000edc20 Body:{
	n, _ := sl.searchByPosition(pos, nil, nil)
	if n == nil || n.entry == nil {
		return nilIterator()
	}

	return &iterator{
		first:	true,
		n:	n,
	}
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(pos, nil, nil) if n == nil || n.entry == nil { return nilIterator() } return &iterator{ first:	true, n:	n, } }]}
{Id:27 FileId:132 StartLine:435 StartColumn:1 EndLine:437 EndColumn:2 Name:IterAtPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:Iterator}] Receiver:0xc0000edd40 Body:{
	return sl.iterAtPosition(pos + 1)
} PrettyPrintBody:[{ return sl.iterAtPosition(pos + 1) }]}
{Id:28 FileId:132 StartLine:439 StartColumn:1 EndLine:449 EndColumn:2 Name:iter Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:*iterator}] Receiver:0xc00019ede0 Body:{
	n, _ := sl.search(cmp, nil, nil)
	if n == nil {
		return nilIterator()
	}

	return &iterator{
		first:	true,
		n:	n,
	}
} PrettyPrintBody:[{ n, _ := sl.search(cmp, nil, nil) if n == nil { return nilIterator() } return &iterator{ first:	true, n:	n, } }]}
{Id:29 FileId:132 StartLine:454 StartColumn:1 EndLine:456 EndColumn:2 Name:Iter Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:Iterator}] Receiver:0xc0000ede60 Body:{
	return sl.iter(cmp)
} PrettyPrintBody:[{ return sl.iter(cmp) }]}
{Id:30 FileId:132 StartLine:464 StartColumn:1 EndLine:470 EndColumn:2 Name:SplitAt Params:[{Name:index Type:uint64}] Results:[{Name: Type:*SkipList} {Name: Type:*SkipList}] Receiver:0xc0000edea0 Body:{
	index++
	if index >= sl.Len() {
		return sl, nil
	}
	return splitAt(sl, index)
} PrettyPrintBody:[{ index++ if index >= sl.Len() { return sl, nil } return splitAt(sl, index) }]}
{Id:31 FileId:132 StartLine:477 StartColumn:1 EndLine:481 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*SkipList}] Receiver:<nil> Body:{
	sl := &SkipList{}
	sl.init(ifc)
	return sl
} PrettyPrintBody:[{ sl := &SkipList{} sl.init(ifc) return sl }]}
{Id:1 FileId:44 StartLine:27 StartColumn:1 EndLine:36 EndColumn:2 Name:newID Params:[] Results:[{Name: Type:[]byte}] Receiver:<nil> Body:{
	id := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, id)
	if err != nil {

		panic("reading random: " + err.Error())
	}
	return id
} PrettyPrintBody:[{ id := make([]byte, 16) _, err := io.ReadFull(rand.Reader, id) if err != nil { panic("reading random: " + err.Error()) } return id }]}
{Id:4 FileId:44 StartLine:51 StartColumn:1 EndLine:53 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:[]byte}] Receiver:0xc001308ec0 Body:{
	return k.UUID[:16]
} PrettyPrintBody:[{ return k.UUID[:16] }]}
{Id:5 FileId:44 StartLine:55 StartColumn:1 EndLine:60 EndColumn:2 Name:ToItem Params:[] Results:[{Name: Type:*Item}] Receiver:0xc000e5b8a0 Body:{
	return &Item{
		Value:		k.Value,
		Payload:	k.Payload,
	}
} PrettyPrintBody:[{ return &Item{ Value:		k.Value, Payload:	k.Payload, } }]}
{Id:7 FileId:44 StartLine:64 StartColumn:1 EndLine:71 EndColumn:2 Name:toItems Params:[] Results:[{Name: Type:items}] Receiver:0xc000c56ca0 Body:{
	items := make(items, 0, len(k))
	for _, key := range k {
		items = append(items, key.ToItem())
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, len(k)) for _, key := range k { items = append(items, key.ToItem()) } return items }]}
{Id:8 FileId:44 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:sort Params:[{Name:comparator Type:Comparator}] Results:[{Name: Type:Keys}] Receiver:0xc0013090e0 Body:{
	return (&keySortWrapper{comparator, k}).sort()
} PrettyPrintBody:[{ return (&keySortWrapper{comparator, k}).sort() }]}
{Id:10 FileId:44 StartLine:82 StartColumn:1 EndLine:84 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0014082e0 Body:{
	return len(sw.keys)
} PrettyPrintBody:[{ return len(sw.keys) }]}
{Id:11 FileId:44 StartLine:86 StartColumn:1 EndLine:88 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001408660 Body:{
	sw.keys[i], sw.keys[j] = sw.keys[j], sw.keys[i]
} PrettyPrintBody:[{ sw.keys[i], sw.keys[j] = sw.keys[j], sw.keys[i] }]}
{Id:12 FileId:44 StartLine:90 StartColumn:1 EndLine:92 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc00123d480 Body:{
	return sw.comparator(sw.keys[i].Value, sw.keys[j].Value) < 0
} PrettyPrintBody:[{ return sw.comparator(sw.keys[i].Value, sw.keys[j].Value) < 0 }]}
{Id:13 FileId:44 StartLine:94 StartColumn:1 EndLine:97 EndColumn:2 Name:sort Params:[] Results:[{Name: Type:Keys}] Receiver:0xc000f53f60 Body:{
	sort.Sort(sw)
	return sw.keys
} PrettyPrintBody:[{ sort.Sort(sw) return sw.keys }]}
{Id:14 FileId:44 StartLine:99 StartColumn:1 EndLine:105 EndColumn:2 Name:splitKeys Params:[{Name:keys Type:Keys} {Name:numParts Type:int}] Results:[{Name: Type:[]Keys}] Receiver:<nil> Body:{
	parts := make([]Keys, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = keys[i*int64(len(keys))/int64(numParts) : (i+1)*int64(len(keys))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Keys, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = keys[i*int64(len(keys))/int64(numParts) : (i+1)*int64(len(keys))/int64(numParts)] } return parts }]}
{Id:16 FileId:44 StartLine:127 StartColumn:1 EndLine:139 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*Node}] Receiver:0xc001241e40 Body:{
	cpValues := make([]interface{}, len(n.ChildValues))
	copy(cpValues, n.ChildValues)
	cpKeys := make(Keys, len(n.ChildKeys))
	copy(cpKeys, n.ChildKeys)

	return &Node{
		ID:		newID(),
		IsLeaf:		n.IsLeaf,
		ChildValues:	cpValues,
		ChildKeys:	cpKeys,
	}
} PrettyPrintBody:[{ cpValues := make([]interface{}, len(n.ChildValues)) copy(cpValues, n.ChildValues) cpKeys := make(Keys, len(n.ChildKeys)) copy(cpKeys, n.ChildKeys) return &Node{ ID:		newID(), IsLeaf:		n.IsLeaf, ChildValues:	cpValues, ChildKeys:	cpKeys, } }]}
{Id:17 FileId:44 StartLine:145 StartColumn:1 EndLine:161 EndColumn:2 Name:searchKey Params:[{Name:comparator Type:Comparator} {Name:value Type:interface{}}] Results:[{Name: Type:*Key} {Name: Type:int}] Receiver:0xc00095a6e0 Body:{
	i := n.search(comparator, value)

	if n.IsLeaf && i == len(n.ChildValues) {
		return nil, i
	}

	if n.IsLeaf {
		return n.ChildKeys[i], i
	}

	if i == len(n.ChildValues) {
		return n.ChildKeys[len(n.ChildKeys)-1], i
	}

	return n.ChildKeys[i], i
} PrettyPrintBody:[{ i := n.search(comparator, value) if n.IsLeaf && i == len(n.ChildValues) { return nil, i } if n.IsLeaf { return n.ChildKeys[i], i } if i == len(n.ChildValues) { return n.ChildKeys[len(n.ChildKeys)-1], i } return n.ChildKeys[i], i }]}
{Id:18 FileId:44 StartLine:165 StartColumn:1 EndLine:191 EndColumn:2 Name:insert Params:[{Name:comparator Type:Comparator} {Name:key Type:*Key}] Results:[{Name: Type:*Key}] Receiver:0xc0003e4fc0 Body:{
	var overwrittenKey *Key
	i := n.search(comparator, key.Value)
	if i == len(n.ChildValues) {
		n.ChildValues = append(n.ChildValues, key.Value)
	} else {
		if n.ChildValues[i] == key.Value {
			overwrittenKey = n.ChildKeys[i]
			n.ChildKeys[i] = key
			return overwrittenKey
		} else {
			n.ChildValues = append(n.ChildValues, 0)
			copy(n.ChildValues[i+1:], n.ChildValues[i:])
			n.ChildValues[i] = key.Value
		}
	}

	if n.IsLeaf && i == len(n.ChildKeys) {
		n.ChildKeys = append(n.ChildKeys, key)
	} else {
		n.ChildKeys = append(n.ChildKeys, nil)
		copy(n.ChildKeys[i+1:], n.ChildKeys[i:])
		n.ChildKeys[i] = key
	}

	return overwrittenKey
} PrettyPrintBody:[{ var overwrittenKey *Key i := n.search(comparator, key.Value) if i == len(n.ChildValues) { n.ChildValues = append(n.ChildValues, key.Value) } else { if n.ChildValues[i] == key.Value { overwrittenKey = n.ChildKeys[i] n.ChildKeys[i] = key return overwrittenKey } else { n.ChildValues = append(n.ChildValues, 0) copy(n.ChildValues[i+1:], n.ChildValues[i:]) n.ChildValues[i] = key.Value } } if n.IsLeaf && i == len(n.ChildKeys) { n.ChildKeys = append(n.ChildKeys, key) } else { n.ChildKeys = append(n.ChildKeys, nil) copy(n.ChildKeys[i+1:], n.ChildKeys[i:]) n.ChildKeys[i] = key } return overwrittenKey }]}
{Id:19 FileId:44 StartLine:195 StartColumn:1 EndLine:205 EndColumn:2 Name:delete Params:[{Name:comparator Type:Comparator} {Name:key Type:*Key}] Results:[{Name: Type:*Key}] Receiver:0xc0001e6560 Body:{
	i := n.search(comparator, key.Value)
	if i == len(n.ChildValues) {
		return nil
	}

	n.deleteValueAt(i)
	n.deleteKeyAt(i)

	return key
} PrettyPrintBody:[{ i := n.search(comparator, key.Value) if i == len(n.ChildValues) { return nil } n.deleteValueAt(i) n.deleteKeyAt(i) return key }]}
{Id:20 FileId:44 StartLine:207 StartColumn:1 EndLine:241 EndColumn:2 Name:multiDelete Params:[{Name:comparator Type:Comparator} {Name:keys Type:...*Key}] Results:[] Receiver:0xc000a8ab00 Body:{
	indices := make([]int, 0, len(keys))
	for _, k := range keys {
		i := n.search(comparator, k.Value)
		if i < len(n.ChildValues) {
			indices = append(indices, i)
		}
	}

	for _, i := range indices {
		n.ChildValues[i] = nil
		n.ChildKeys[i] = nil
	}

	if len(indices) == len(n.ChildValues) {
		n.ChildKeys = n.ChildKeys[:0]
		n.ChildValues = n.ChildValues[:0]
		return
	}

	sort.Ints(indices)

	for i, j := range indices {
		index := j - i
		copy(n.ChildValues[index:], n.ChildValues[index+1:])
		copy(n.ChildKeys[index:], n.ChildKeys[index+1:])
	}

	n.ChildValues = n.ChildValues[:len(n.ChildValues)-len(indices)]
	n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-len(indices)]
} PrettyPrintBody:[{ indices := make([]int, 0, len(keys)) for _, k := range keys { i := n.search(comparator, k.Value) if i < len(n.ChildValues) { indices = append(indices, i) } } for _, i := range indices { n.ChildValues[i] = nil n.ChildKeys[i] = nil } if len(indices) == len(n.ChildValues) { n.ChildKeys = n.ChildKeys[:0] n.ChildValues = n.ChildValues[:0] return } sort.Ints(indices) for i, j := range indices { index := j - i copy(n.ChildValues[index:], n.ChildValues[index+1:]) copy(n.ChildKeys[index:], n.ChildKeys[index+1:]) } n.ChildValues = n.ChildValues[:len(n.ChildValues)-len(indices)] n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-len(indices)] }]}
{Id:21 FileId:44 StartLine:245 StartColumn:1 EndLine:247 EndColumn:2 Name:replaceKeyAt Params:[{Name:key Type:*Key} {Name:i Type:int}] Results:[] Receiver:0xc0016031e0 Body:{
	n.ChildKeys[i] = key
} PrettyPrintBody:[{ n.ChildKeys[i] = key }]}
{Id:22 FileId:44 StartLine:250 StartColumn:1 EndLine:252 EndColumn:2 Name:flatten Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:Keys}] Receiver:0xc00019e440 Body:{
	return n.ChildValues, n.ChildKeys
} PrettyPrintBody:[{ return n.ChildValues, n.ChildKeys }]}
{Id:23 FileId:44 StartLine:256 StartColumn:1 EndLine:265 EndColumn:2 Name:iter Params:[{Name:comparator Type:Comparator} {Name:start Type:interface{}}] Results:[{Name: Type:iterator}] Receiver:0xc001603260 Body:{
	pointer := n.search(comparator, start)
	pointer--
	return &sliceIterator{
		stop:		stop,
		n:		n,
		pointer:	pointer,
		comparator:	comparator,
	}
} PrettyPrintBody:[{ pointer := n.search(comparator, start) pointer-- return &sliceIterator{ stop:		stop, n:		n, pointer:	pointer, comparator:	comparator, } }]}
{Id:24 FileId:44 StartLine:267 StartColumn:1 EndLine:269 EndColumn:2 Name:valueAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}}] Receiver:0xc000a8b840 Body:{
	return n.ChildValues[i]
} PrettyPrintBody:[{ return n.ChildValues[i] }]}
{Id:25 FileId:44 StartLine:271 StartColumn:1 EndLine:273 EndColumn:2 Name:keyAt Params:[{Name:i Type:int}] Results:[{Name: Type:*Key}] Receiver:0xc001603560 Body:{
	return n.ChildKeys[i]
} PrettyPrintBody:[{ return n.ChildKeys[i] }]}
{Id:26 FileId:44 StartLine:275 StartColumn:1 EndLine:277 EndColumn:2 Name:needsSplit Params:[{Name:max Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0016035c0 Body:{
	return n.lenValues() > max
} PrettyPrintBody:[{ return n.lenValues() > max }]}
{Id:27 FileId:44 StartLine:279 StartColumn:1 EndLine:281 EndColumn:2 Name:lastValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0001e67a0 Body:{
	return n.ChildValues[len(n.ChildValues)-1]
} PrettyPrintBody:[{ return n.ChildValues[len(n.ChildValues)-1] }]}
{Id:28 FileId:44 StartLine:283 StartColumn:1 EndLine:285 EndColumn:2 Name:firstValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc00095b160 Body:{
	return n.ChildValues[0]
} PrettyPrintBody:[{ return n.ChildValues[0] }]}
{Id:29 FileId:44 StartLine:287 StartColumn:1 EndLine:290 EndColumn:2 Name:append Params:[{Name:other Type:*Node}] Results:[] Receiver:0xc001603660 Body:{
	n.ChildValues = append(n.ChildValues, other.ChildValues...)
	n.ChildKeys = append(n.ChildKeys, other.ChildKeys...)
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, other.ChildValues...) n.ChildKeys = append(n.ChildKeys, other.ChildKeys...) }]}
{Id:30 FileId:44 StartLine:292 StartColumn:1 EndLine:294 EndColumn:2 Name:replaceValueAt Params:[{Name:i Type:int} {Name:value Type:interface{}}] Results:[] Receiver:0xc00095b180 Body:{
	n.ChildValues[i] = value
} PrettyPrintBody:[{ n.ChildValues[i] = value }]}
{Id:31 FileId:44 StartLine:296 StartColumn:1 EndLine:300 EndColumn:2 Name:deleteValueAt Params:[{Name:i Type:int}] Results:[] Receiver:0xc0003e56a0 Body:{
	copy(n.ChildValues[i:], n.ChildValues[i+1:])
	n.ChildValues[len(n.ChildValues)-1] = 0
	n.ChildValues = n.ChildValues[:len(n.ChildValues)-1]
} PrettyPrintBody:[{ copy(n.ChildValues[i:], n.ChildValues[i+1:]) n.ChildValues[len(n.ChildValues)-1] = 0 n.ChildValues = n.ChildValues[:len(n.ChildValues)-1] }]}
{Id:32 FileId:44 StartLine:302 StartColumn:1 EndLine:306 EndColumn:2 Name:deleteKeyAt Params:[{Name:i Type:int}] Results:[] Receiver:0xc000a8ba40 Body:{
	copy(n.ChildKeys[i:], n.ChildKeys[i+1:])
	n.ChildKeys[len(n.ChildKeys)-1] = nil
	n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-1]
} PrettyPrintBody:[{ copy(n.ChildKeys[i:], n.ChildKeys[i+1:]) n.ChildKeys[len(n.ChildKeys)-1] = nil n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-1] }]}
{Id:33 FileId:44 StartLine:308 StartColumn:1 EndLine:326 EndColumn:2 Name:splitLeafAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc0003e5800 Body:{
	left := newNode()
	left.IsLeaf = n.IsLeaf
	left.ID = newID()

	value := n.ChildValues[i]
	leftValues := make([]interface{}, i+1)
	copy(leftValues, n.ChildValues[:i+1])
	n.ChildValues = n.ChildValues[i+1:]
	leftKeys := make(Keys, i+1)
	copy(leftKeys, n.ChildKeys[:i+1])
	for j := 0; j <= i; j++ {
		n.ChildKeys[j] = nil
	}
	n.ChildKeys = n.ChildKeys[i+1:]
	left.ChildValues = leftValues
	left.ChildKeys = leftKeys
	return value, left
} PrettyPrintBody:[{ left := newNode() left.IsLeaf = n.IsLeaf left.ID = newID() value := n.ChildValues[i] leftValues := make([]interface{}, i+1) copy(leftValues, n.ChildValues[:i+1]) n.ChildValues = n.ChildValues[i+1:] leftKeys := make(Keys, i+1) copy(leftKeys, n.ChildKeys[:i+1]) for j := 0; j <= i; j++ { n.ChildKeys[j] = nil } n.ChildKeys = n.ChildKeys[i+1:] left.ChildValues = leftValues left.ChildKeys = leftKeys return value, left }]}
{Id:34 FileId:44 StartLine:331 StartColumn:1 EndLine:348 EndColumn:2 Name:splitInternalAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc00095b3c0 Body:{
	left := newNode()
	left.IsLeaf = n.IsLeaf
	left.ID = newID()
	value := n.ChildValues[i]
	leftValues := make([]interface{}, i)
	copy(leftValues, n.ChildValues[:i])
	n.ChildValues = n.ChildValues[i+1:]
	leftKeys := make(Keys, i+1)
	copy(leftKeys, n.ChildKeys[:i+1])
	for j := 0; j <= i; j++ {
		n.ChildKeys[j] = nil
	}
	n.ChildKeys = n.ChildKeys[i+1:]
	left.ChildKeys = leftKeys
	left.ChildValues = leftValues
	return value, left
} PrettyPrintBody:[{ left := newNode() left.IsLeaf = n.IsLeaf left.ID = newID() value := n.ChildValues[i] leftValues := make([]interface{}, i) copy(leftValues, n.ChildValues[:i]) n.ChildValues = n.ChildValues[i+1:] leftKeys := make(Keys, i+1) copy(leftKeys, n.ChildKeys[:i+1]) for j := 0; j <= i; j++ { n.ChildKeys[j] = nil } n.ChildKeys = n.ChildKeys[i+1:] left.ChildKeys = leftKeys left.ChildValues = leftValues return value, left }]}
{Id:35 FileId:44 StartLine:352 StartColumn:1 EndLine:358 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc0001e6b00 Body:{
	if n.IsLeaf {
		return n.splitLeafAt(i)
	}

	return n.splitInternalAt(i)
} PrettyPrintBody:[{ if n.IsLeaf { return n.splitLeafAt(i) } return n.splitInternalAt(i) }]}
{Id:36 FileId:44 StartLine:360 StartColumn:1 EndLine:362 EndColumn:2 Name:lenKeys Params:[] Results:[{Name: Type:int}] Receiver:0xc00095b5e0 Body:{
	return len(n.ChildKeys)
} PrettyPrintBody:[{ return len(n.ChildKeys) }]}
{Id:37 FileId:44 StartLine:364 StartColumn:1 EndLine:366 EndColumn:2 Name:lenValues Params:[] Results:[{Name: Type:int}] Receiver:0xc00095b620 Body:{
	return len(n.ChildValues)
} PrettyPrintBody:[{ return len(n.ChildValues) }]}
{Id:38 FileId:44 StartLine:368 StartColumn:1 EndLine:370 EndColumn:2 Name:appendChild Params:[{Name:key Type:*Key}] Results:[] Receiver:0xc00095b6a0 Body:{
	n.ChildKeys = append(n.ChildKeys, key)
} PrettyPrintBody:[{ n.ChildKeys = append(n.ChildKeys, key) }]}
{Id:39 FileId:44 StartLine:372 StartColumn:1 EndLine:374 EndColumn:2 Name:appendValue Params:[{Name:value Type:interface{}}] Results:[] Receiver:0xc00095b6e0 Body:{
	n.ChildValues = append(n.ChildValues, value)
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, value) }]}
{Id:40 FileId:44 StartLine:376 StartColumn:1 EndLine:380 EndColumn:2 Name:popFirstKey Params:[] Results:[{Name: Type:*Key}] Receiver:0xc00095b720 Body:{
	key := n.ChildKeys[0]
	n.deleteKeyAt(0)
	return key
} PrettyPrintBody:[{ key := n.ChildKeys[0] n.deleteKeyAt(0) return key }]}
{Id:41 FileId:44 StartLine:382 StartColumn:1 EndLine:386 EndColumn:2 Name:popFirstValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000992420 Body:{
	value := n.ChildValues[0]
	n.deleteValueAt(0)
	return value
} PrettyPrintBody:[{ value := n.ChildValues[0] n.deleteValueAt(0) return value }]}
{Id:42 FileId:44 StartLine:388 StartColumn:1 EndLine:392 EndColumn:2 Name:popKey Params:[] Results:[{Name: Type:*Key}] Receiver:0xc00019e7a0 Body:{
	key := n.ChildKeys[len(n.ChildKeys)-1]
	n.deleteKeyAt(len(n.ChildKeys) - 1)
	return key
} PrettyPrintBody:[{ key := n.ChildKeys[len(n.ChildKeys)-1] n.deleteKeyAt(len(n.ChildKeys) - 1) return key }]}
{Id:43 FileId:44 StartLine:394 StartColumn:1 EndLine:398 EndColumn:2 Name:popValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000a8bd00 Body:{
	value := n.ChildValues[len(n.ChildValues)-1]
	n.deleteValueAt(len(n.ChildValues) - 1)
	return value
} PrettyPrintBody:[{ value := n.ChildValues[len(n.ChildValues)-1] n.deleteValueAt(len(n.ChildValues) - 1) return value }]}
{Id:44 FileId:44 StartLine:400 StartColumn:1 EndLine:404 EndColumn:2 Name:prependKey Params:[{Name:key Type:*Key}] Results:[] Receiver:0xc0000ed860 Body:{
	n.ChildKeys = append(n.ChildKeys, nil)
	copy(n.ChildKeys[1:], n.ChildKeys)
	n.ChildKeys[0] = key
} PrettyPrintBody:[{ n.ChildKeys = append(n.ChildKeys, nil) copy(n.ChildKeys[1:], n.ChildKeys) n.ChildKeys[0] = key }]}
{Id:45 FileId:44 StartLine:406 StartColumn:1 EndLine:410 EndColumn:2 Name:prependValue Params:[{Name:value Type:interface{}}] Results:[] Receiver:0xc00095b820 Body:{
	n.ChildValues = append(n.ChildValues, nil)
	copy(n.ChildValues[1:], n.ChildValues)
	n.ChildValues[0] = value
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, nil) copy(n.ChildValues[1:], n.ChildValues) n.ChildValues[0] = value }]}
{Id:46 FileId:44 StartLine:412 StartColumn:1 EndLine:416 EndColumn:2 Name:search Params:[{Name:comparator Type:Comparator} {Name:value Type:interface{}}] Results:[{Name: Type:int}] Receiver:0xc000992720 Body:{
	return sort.Search(len(n.ChildValues), func(i int) bool {
		return comparator(n.ChildValues[i], value) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(n.ChildValues), func(i int) bool { return comparator(n.ChildValues[i], value) >= 0 }) }]}
{Id:47 FileId:44 StartLine:420 StartColumn:1 EndLine:429 EndColumn:2 Name:nodeFromBytes Params:[{Name:t Type:*Tr} {Name:data Type:[]byte}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:<nil> Body:{
	n := &Node{}
	_, err := n.UnmarshalMsg(data)
	if err != nil {
		panic(err)
		return nil, err
	}

	return n, nil
} PrettyPrintBody:[{ n := &Node{} _, err := n.UnmarshalMsg(data) if err != nil { panic(err) return nil, err } return n, nil }]}
{Id:48 FileId:44 StartLine:433 StartColumn:1 EndLine:437 EndColumn:2 Name:newNode Params:[] Results:[{Name: Type:*Node}] Receiver:<nil> Body:{
	return &Node{
		ID: newID(),
	}
} PrettyPrintBody:[{ return &Node{ ID: newID(), } }]}
{Id:50 FileId:44 StartLine:446 StartColumn:1 EndLine:464 EndColumn:2 Name:next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001581720 Body:{
	s.pointer++
	if s.n.IsLeaf {
		return s.pointer < len(s.n.ChildValues) && s.comparator(s.stop, s.n.ChildValues[s.pointer]) >= 0
	} else {
		if s.pointer >= len(s.n.ChildKeys) {
			return false
		}
		if s.pointer == len(s.n.ChildValues) {
			return true
		}

		if s.comparator(s.stop, s.n.ChildValues[s.pointer]) < 0 {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ s.pointer++ if s.n.IsLeaf { return s.pointer < len(s.n.ChildValues) && s.comparator(s.stop, s.n.ChildValues[s.pointer]) >= 0 } else { if s.pointer >= len(s.n.ChildKeys) { return false } if s.pointer == len(s.n.ChildValues) { return true } if s.comparator(s.stop, s.n.ChildValues[s.pointer]) < 0 { return false } } return true }]}
{Id:51 FileId:44 StartLine:466 StartColumn:1 EndLine:468 EndColumn:2 Name:value Params:[] Results:[{Name: Type:*Key} {Name: Type:int}] Receiver:0xc0000edda0 Body:{
	return s.n.ChildKeys[s.pointer], s.pointer
} PrettyPrintBody:[{ return s.n.ChildKeys[s.pointer], s.pointer }]}
{Id:55 FileId:44 StartLine:486 StartColumn:1 EndLine:488 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0000edde0 Body:{
	return len(n.values)
} PrettyPrintBody:[{ return len(n.values) }]}
{Id:56 FileId:44 StartLine:490 StartColumn:1 EndLine:493 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc00019ee40 Body:{
	n.values[i], n.values[j] = n.values[j], n.values[i]
	n.keys[i], n.keys[j] = n.keys[j], n.keys[i]
} PrettyPrintBody:[{ n.values[i], n.values[j] = n.values[j], n.values[i] n.keys[i], n.keys[j] = n.keys[j], n.keys[i] }]}
{Id:57 FileId:44 StartLine:495 StartColumn:1 EndLine:497 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc00019f000 Body:{
	return n.comparator(n.values[i], n.values[j]) < 0
} PrettyPrintBody:[{ return n.comparator(n.values[i], n.values[j]) < 0 }]}
{Id:58 FileId:44 StartLine:499 StartColumn:1 EndLine:505 EndColumn:2 Name:splitValues Params:[{Name:values Type:[]interface{}} {Name:numParts Type:int}] Results:[{Name: Type:[][]interface{}}] Receiver:<nil> Body:{
	parts := make([][]interface{}, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = values[i*int64(len(values))/int64(numParts) : (i+1)*int64(len(values))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([][]interface{}, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = values[i*int64(len(values))/int64(numParts) : (i+1)*int64(len(values))/int64(numParts)] } return parts }]}
{Id:1 FileId:121 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]}
{Id:2 FileId:121 StartLine:35 StartColumn:1 EndLine:48 EndColumn:2 Name:print Params:[{Name:log Type:*log.Logger}] Results:[] Receiver:0xc00110bd40 Body:{
	log.Printf(`NODE: %+v, MBR: %+v, %p`, n, n.mbr, n)
	if n.isLeaf {
		for i, wh := range n.nodes.list {
			xlow, ylow := wh.LowerLeft()
			xhigh, yhigh := wh.UpperRight()
			log.Printf(`KEY: %+v, XLOW: %+v, YLOW: %+v, XHIGH: %+v, YHIGH: %+v`, n.keys.list[i], xlow, ylow, xhigh, yhigh)
		}
	} else {
		for _, wh := range n.nodes.list {
			wh.(*node).print(log)
		}
	}
} PrettyPrintBody:[{ log.Printf(`NODE: %+v, MBR: %+v, %p`, n, n.mbr, n) if n.isLeaf { for i, wh := range n.nodes.list { xlow, ylow := wh.LowerLeft() xhigh, yhigh := wh.UpperRight() log.Printf(`KEY: %+v, XLOW: %+v, YLOW: %+v, XHIGH: %+v, YHIGH: %+v`, n.keys.list[i], xlow, ylow, xhigh, yhigh) } } else { for _, wh := range n.nodes.list { wh.(*node).print(log) } } }]}
{Id:3 FileId:121 StartLine:50 StartColumn:1 EndLine:58 EndColumn:2 Name:print Params:[{Name:log Type:*log.Logger}] Results:[] Receiver:0xc001032d40 Body:{
	log.Println(`PRINTING TREE`)
	if t.root == nil {
		log.Println(`EMPTY TREE.`)
		return
	}

	t.root.print(log)
} PrettyPrintBody:[{ log.Println(`PRINTING TREE`) if t.root == nil { log.Println(`EMPTY TREE.`) return } t.root.print(log) }]}
{Id:4 FileId:121 StartLine:60 StartColumn:1 EndLine:66 EndColumn:2 Name:constructMockPoints Params:[{Name:num Type:int}] Results:[{Name: Type:rtree.Rectangles}] Receiver:<nil> Body:{
	rects := make(rtree.Rectangles, 0, num)
	for i := int32(0); i < int32(num); i++ {
		rects = append(rects, newMockRectangle(i, i, i, i))
	}
	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, num) for i := int32(0); i < int32(num); i++ { rects = append(rects, newMockRectangle(i, i, i, i)) } return rects }]}
{Id:5 FileId:121 StartLine:68 StartColumn:1 EndLine:76 EndColumn:2 Name:constructRandomMockPoints Params:[{Name:num Type:int}] Results:[{Name: Type:rtree.Rectangles}] Receiver:<nil> Body:{
	rects := make(rtree.Rectangles, 0, num)
	for i := 0; i < num; i++ {
		r := rand.Int31()
		rects = append(rects, newMockRectangle(r, r, r, r))
	}

	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, num) for i := 0; i < num; i++ { r := rand.Int31() rects = append(rects, newMockRectangle(r, r, r, r)) } return rects }]}
{Id:6 FileId:121 StartLine:78 StartColumn:1 EndLine:80 EndColumn:2 Name:constructInfiniteRect Params:[] Results:[{Name: Type:rtree.Rectangle}] Receiver:<nil> Body:{
	return newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
} PrettyPrintBody:[{ return newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) }]}
{Id:7 FileId:121 StartLine:82 StartColumn:1 EndLine:92 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	tree := newTree(3, 3)

	tree.Insert(r1)
	assert.Equal(t, uint64(1), tree.Len())

	q := newMockRectangle(5, 5, 15, 15)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) tree := newTree(3, 3) tree.Insert(r1) assert.Equal(t, uint64(1), tree.Len()) q := newMockRectangle(5, 5, 15, 15) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) }]}
{Id:8 FileId:121 StartLine:94 StartColumn:1 EndLine:104 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	tree := newTree(3, 3)
	tree.Insert(r1)

	tree.Delete(r1)
	assert.Equal(t, uint64(0), tree.Len())
	q := newMockRectangle(5, 5, 15, 15)
	result := tree.Search(q)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) tree := newTree(3, 3) tree.Insert(r1) tree.Delete(r1) assert.Equal(t, uint64(0), tree.Len()) q := newMockRectangle(5, 5, 15, 15) result := tree.Search(q) assert.Len(t, result, 0) }]}
{Id:9 FileId:121 StartLine:106 StartColumn:1 EndLine:121 EndColumn:2 Name:TestDeleteIdenticalHilbergNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)
	tree.Insert(r1)

	tree.Delete(r2)
	assert.Equal(t, uint64(1), tree.Len())
	result := tree.Search(r2)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	tree.Delete(r1)
	assert.Equal(t, uint64(0), tree.Len())
	result = tree.Search(r1)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1) tree.Delete(r2) assert.Equal(t, uint64(1), tree.Len()) result := tree.Search(r2) assert.Equal(t, rtree.Rectangles{r1}, result) tree.Delete(r1) assert.Equal(t, uint64(0), tree.Len()) result = tree.Search(r1) assert.Len(t, result, 0) }]}
{Id:10 FileId:121 StartLine:123 StartColumn:1 EndLine:133 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(3)
	tree := newTree(3, 3)
	tree.Insert(points...)
	assert.Equal(t, uint64(len(points)), tree.Len())

	tree.Delete(points...)
	assert.Equal(t, uint64(0), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ points := constructRandomMockPoints(3) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) tree.Delete(points...) assert.Equal(t, uint64(0), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Len(t, result, 0) }]}
{Id:11 FileId:121 StartLine:135 StartColumn:1 EndLine:154 EndColumn:2 Name:TestTwoInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)

	tree.Insert(r1, r2)
	assert.Equal(t, uint64(2), tree.Len())

	q := newMockRectangle(0, 0, 20, 20)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(0, 0, 4, 4)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(11, 11, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1, r2) assert.Equal(t, uint64(2), tree.Len()) q := newMockRectangle(0, 0, 20, 20) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(0, 0, 4, 4) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(11, 11, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) }]}
{Id:12 FileId:121 StartLine:156 StartColumn:1 EndLine:170 EndColumn:2 Name:TestInsertCausesRootSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	r3 := newMockRectangle(10, 10, 20, 20)
	tree := newTree(3, 3)

	tree.Insert(r1, r2, r3)
	assert.Equal(t, uint64(3), tree.Len())

	q := newMockRectangle(0, 0, 20, 20)
	result := tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) r3 := newMockRectangle(10, 10, 20, 20) tree := newTree(3, 3) tree.Insert(r1, r2, r3) assert.Equal(t, uint64(3), tree.Len()) q := newMockRectangle(0, 0, 20, 20) result := tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) }]}
{Id:13 FileId:121 StartLine:172 StartColumn:1 EndLine:188 EndColumn:2 Name:TestInsertCausesRootSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	r3 := newMockRectangle(10, 10, 20, 20)
	r4 := newMockRectangle(15, 15, 25, 25)
	tree := newTree(4, 4)

	tree.Insert(r1, r2, r3, r4)
	assert.Equal(t, uint64(4), tree.Len())

	q := newMockRectangle(0, 0, 25, 25)
	result := tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
	assert.Contains(t, result, r4)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) r3 := newMockRectangle(10, 10, 20, 20) r4 := newMockRectangle(15, 15, 25, 25) tree := newTree(4, 4) tree.Insert(r1, r2, r3, r4) assert.Equal(t, uint64(4), tree.Len()) q := newMockRectangle(0, 0, 25, 25) result := tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) assert.Contains(t, result, r4) }]}
{Id:14 FileId:121 StartLine:190 StartColumn:1 EndLine:235 EndColumn:2 Name:TestQueryWithLine Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)
	tree.Insert(r1, r2)

	q := newMockRectangle(5, 0, 5, 10)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(0, 5, 10, 5)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(15, 0, 15, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(0, 15, 20, 15)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(0, 0, 0, 10)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(0, 0, 10, 0)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(20, 0, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)

	q = newMockRectangle(0, 20, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1, r2) q := newMockRectangle(5, 0, 5, 10) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(0, 5, 10, 5) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(15, 0, 15, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(0, 15, 20, 15) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(0, 0, 0, 10) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(0, 0, 10, 0) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(20, 0, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) q = newMockRectangle(0, 20, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) }]}
{Id:15 FileId:121 StartLine:237 StartColumn:1 EndLine:259 EndColumn:2 Name:TestQueryForPoint Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(5, 5, 5, 5)
	r2 := newMockRectangle(10, 10, 10, 10)
	tree := newTree(3, 3)
	tree.Insert(r1, r2)

	q := newMockRectangle(0, 0, 5, 5)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(0, 0, 20, 20)
	result = tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)

	q = newMockRectangle(6, 6, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(20, 20, 30, 30)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(5, 5, 5, 5) r2 := newMockRectangle(10, 10, 10, 10) tree := newTree(3, 3) tree.Insert(r1, r2) q := newMockRectangle(0, 0, 5, 5) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(0, 0, 20, 20) result = tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) q = newMockRectangle(6, 6, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(20, 20, 30, 30) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) }]}
{Id:16 FileId:121 StartLine:261 StartColumn:1 EndLine:281 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructMockPoints(100)
	tree := newTree(3, 3)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, int32(len(points)), int32(len(points)))
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructMockPoints(100) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, int32(len(points)), int32(len(points))) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]}
{Id:17 FileId:121 StartLine:283 StartColumn:1 EndLine:303 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitOddAryRandomPoints Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(100)
	tree := newTree(3, 3)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructRandomMockPoints(100) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]}
{Id:18 FileId:121 StartLine:305 StartColumn:1 EndLine:325 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructMockPoints(100)
	tree := newTree(4, 4)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructMockPoints(100) tree := newTree(4, 4) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]}
{Id:19 FileId:121 StartLine:327 StartColumn:1 EndLine:347 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(100)
	tree := newTree(4, 4)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructRandomMockPoints(100) tree := newTree(4, 4) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]}
{Id:20 FileId:121 StartLine:349 StartColumn:1 EndLine:368 EndColumn:2 Name:TestInsertDuplicateHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(1, 1, 19, 19)
	r3 := newMockRectangle(2, 2, 18, 18)
	r4 := newMockRectangle(3, 3, 17, 17)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)
	tree.Insert(r3)
	tree.Insert(r4)

	assert.Equal(t, uint64(4), tree.Len())
	q := newMockRectangle(0, 0, 30, 30)
	result := tree.Search(q)
	assert.Len(t, result, 4)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
	assert.Contains(t, result, r4)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(1, 1, 19, 19) r3 := newMockRectangle(2, 2, 18, 18) r4 := newMockRectangle(3, 3, 17, 17) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) tree.Insert(r3) tree.Insert(r4) assert.Equal(t, uint64(4), tree.Len()) q := newMockRectangle(0, 0, 30, 30) result := tree.Search(q) assert.Len(t, result, 4) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) assert.Contains(t, result, r4) }]}
{Id:21 FileId:121 StartLine:370 StartColumn:1 EndLine:385 EndColumn:2 Name:TestDeleteAllDuplicateHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(1, 1, 19, 19)
	r3 := newMockRectangle(2, 2, 18, 18)
	r4 := newMockRectangle(3, 3, 17, 17)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)
	tree.Insert(r3)
	tree.Insert(r4)

	tree.Delete(r1, r2, r3, r4)
	assert.Equal(t, uint64(0), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(1, 1, 19, 19) r3 := newMockRectangle(2, 2, 18, 18) r4 := newMockRectangle(3, 3, 17, 17) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) tree.Insert(r3) tree.Insert(r4) tree.Delete(r1, r2, r3, r4) assert.Equal(t, uint64(0), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Len(t, result, 0) }]}
{Id:22 FileId:121 StartLine:387 StartColumn:1 EndLine:397 EndColumn:2 Name:TestInsertDuplicateRect Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(0, 0, 20, 20)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)

	assert.Equal(t, uint64(1), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Equal(t, rtree.Rectangles{r2}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(0, 0, 20, 20) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) assert.Equal(t, uint64(1), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Equal(t, rtree.Rectangles{r2}, result) }]}
{Id:23 FileId:121 StartLine:399 StartColumn:1 EndLine:409 EndColumn:2 Name:BenchmarkBulkAddPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	points := constructMockPoints(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newTree(8, 8)
		tree.Insert(points...)
	}
} PrettyPrintBody:[{ numItems := 1000 points := constructMockPoints(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newTree(8, 8) tree.Insert(points...) } }]}
{Id:24 FileId:121 StartLine:411 StartColumn:1 EndLine:422 EndColumn:2 Name:BenchmarkBulkUpdatePoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(points...)
	}
} PrettyPrintBody:[{ numItems := 1000 points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(points...) } }]}
{Id:25 FileId:121 StartLine:424 StartColumn:1 EndLine:434 EndColumn:2 Name:BenchmarkPointInsertion Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(points[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(points[i%numItems]) } }]}
{Id:26 FileId:121 StartLine:436 StartColumn:1 EndLine:447 EndColumn:2 Name:BenchmarkQueryPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := int32(0); i < int32(b.N); i++ {
		tree.Search(newMockRectangle(i, i, i+10, i+10))
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := int32(0); i < int32(b.N); i++ { tree.Search(newMockRectangle(i, i, i+10, i+10)) } }]}
{Id:27 FileId:121 StartLine:449 StartColumn:1 EndLine:460 EndColumn:2 Name:BenchmarkQueryBulkPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := int32(0); i < int32(b.N); i++ {
		tree.Search(newMockRectangle(i, i, int32(numItems), int32(numItems)))
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := int32(0); i < int32(b.N); i++ { tree.Search(newMockRectangle(i, i, int32(numItems), int32(numItems))) } }]}
{Id:28 FileId:121 StartLine:462 StartColumn:1 EndLine:473 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Delete(points[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Delete(points[i%numItems]) } }]}
{Id:3 FileId:90 StartLine:29 StartColumn:1 EndLine:82 EndColumn:2 Name:generateRandomVerticesFromGuess Params:[{Name:guess Type:*nmVertex} {Name:num Type:int}] Results:[{Name: Type:vertices}] Receiver:<nil> Body:{

	summed := make(map[float64]vertices, num)
	dimensions := len(guess.vars)
	vs := make(vertices, 0, num)
	i := 0
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

Guess:
	for i < num {
		sum := float64(0)
		vars := make([]float64, 0, dimensions)
		for j := 0; j < dimensions; j++ {
			v := r.Float64() * 1000

			if r.Float64() > .5 {
				v = -v
			}
			sum += v
			vars = append(vars, v)
		}

		guess := &nmVertex{
			vars: vars,
		}

		if vs, ok := summed[sum]; !ok {
			vs = make(vertices, 0, dimensions)
			vs = append(vs, guess)
			summed[sum] = vs
		} else {
			for _, vertex := range vs {

				if guess.equalToVertex(vertex) {
					continue Guess
				}
			}
			vs = append(vs, guess)
		}

		vs = append(vs, guess)
		i++
	}

	return vs
} PrettyPrintBody:[{ summed := make(map[float64]vertices, num) dimensions := len(guess.vars) vs := make(vertices, 0, num) i := 0 r := rand.New(rand.NewSource(time.Now().UnixNano())) Guess: for i < num { sum := float64(0) vars := make([]float64, 0, dimensions) for j := 0; j < dimensions; j++ { v := r.Float64() * 1000 if r.Float64() > .5 { v = -v } sum += v vars = append(vars, v) } guess := &nmVertex{ vars: vars, } if vs, ok := summed[sum]; !ok { vs = make(vertices, 0, dimensions) vs = append(vs, guess) summed[sum] = vs } else { for _, vertex := range vs { if guess.equalToVertex(vertex) { continue Guess } } vs = append(vs, guess) } vs = append(vs, guess) i++ } return vs }]}
{Id:4 FileId:90 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:isInf Params:[{Name:num Type:float64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return math.IsInf(num, -1) || math.IsInf(num, 1)
} PrettyPrintBody:[{ return math.IsInf(num, -1) || math.IsInf(num, 1) }]}
{Id:5 FileId:90 StartLine:88 StartColumn:1 EndLine:97 EndColumn:2 Name:findMin Params:[{Name:vertices Type:...*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:<nil> Body:{
	min := vertices[0]
	for _, v := range vertices[1:] {
		if v.distance < min.distance {
			min = v
		}
	}

	return min
} PrettyPrintBody:[{ min := vertices[0] for _, v := range vertices[1:] { if v.distance < min.distance { min = v } } return min }]}
{Id:6 FileId:90 StartLine:101 StartColumn:1 EndLine:116 EndColumn:2 Name:findMidpoint Params:[{Name:vertices Type:...*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:<nil> Body:{
	num := len(vertices)
	vars := make([]float64, 0, num)

	for i := 0; i < num; i++ {
		sum := float64(0)
		for _, v := range vertices {
			sum += v.vars[i]
		}
		vars = append(vars, sum/float64(num))
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ num := len(vertices) vars := make([]float64, 0, num) for i := 0; i < num; i++ { sum := float64(0) for _, v := range vertices { sum += v.vars[i] } vars = append(vars, sum/float64(num)) } return &nmVertex{ vars: vars, } }]}
{Id:7 FileId:90 StartLine:121 StartColumn:1 EndLine:129 EndColumn:2 Name:determineDistance Params:[{Name:value Type:float64}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	if math.IsInf(target, 1) {
		target = math.MaxFloat64
	} else if math.IsInf(target, -1) {
		target = -math.MaxFloat64
	}

	return math.Abs(target - value)
} PrettyPrintBody:[{ if math.IsInf(target, 1) { target = math.MaxFloat64 } else if math.IsInf(target, -1) { target = -math.MaxFloat64 } return math.Abs(target - value) }]}
{Id:9 FileId:90 StartLine:135 StartColumn:1 EndLine:141 EndColumn:2 Name:evaluate Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc000a8a6a0 Body:{
	for _, v := range vertices {
		v.evaluate(config)
	}

	vertices.sort(config)
} PrettyPrintBody:[{ for _, v := range vertices { v.evaluate(config) } vertices.sort(config) }]}
{Id:10 FileId:90 StartLine:143 StartColumn:1 EndLine:149 EndColumn:2 Name:sort Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc0001e6220 Body:{
	sorter := sorter{
		config:		config,
		vertices:	vertices,
	}
	sorter.sort()
} PrettyPrintBody:[{ sorter := sorter{ config:		config, vertices:	vertices, } sorter.sort() }]}
{Id:12 FileId:90 StartLine:156 StartColumn:1 EndLine:158 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc0001e6040 Body:{
	sort.Sort(sorter)
} PrettyPrintBody:[{ sort.Sort(sorter) }]}
{Id:13 FileId:90 StartLine:166 StartColumn:1 EndLine:168 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000993620 Body:{
	return sorter.vertices[i].less(sorter.config, sorter.vertices[j])
} PrettyPrintBody:[{ return sorter.vertices[i].less(sorter.config, sorter.vertices[j]) }]}
{Id:14 FileId:90 StartLine:170 StartColumn:1 EndLine:172 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a820 Body:{
	return len(sorter.vertices)
} PrettyPrintBody:[{ return len(sorter.vertices) }]}
{Id:15 FileId:90 StartLine:174 StartColumn:1 EndLine:176 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc00095a880 Body:{
	sorter.vertices[i], sorter.vertices[j] = sorter.vertices[j], sorter.vertices[i]
} PrettyPrintBody:[{ sorter.vertices[i], sorter.vertices[j] = sorter.vertices[j], sorter.vertices[i] }]}
{Id:16 FileId:90 StartLine:180 StartColumn:1 EndLine:188 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00095a9c0 Body:{
	result := ``
	for i, v := range vertices {
		result += fmt.Sprintf(`VERTEX INDEX: %+v, VERTEX: %+v`, i, v)
		result += fmt.Sprintln(``)
	}

	return result
} PrettyPrintBody:[{ result := `` for i, v := range vertices { result += fmt.Sprintf(`VERTEX INDEX: %+v, VERTEX: %+v`, i, v) result += fmt.Sprintln(``) } return result }]}
{Id:19 FileId:90 StartLine:231 StartColumn:1 EndLine:234 EndColumn:2 Name:evaluate Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc00095ad20 Body:{
	nm.result, nm.good = config.Fn(nm.vars)
	nm.distance = determineDistance(nm.result, config.Target)
} PrettyPrintBody:[{ nm.result, nm.good = config.Fn(nm.vars) nm.distance = determineDistance(nm.result, config.Target) }]}
{Id:20 FileId:90 StartLine:236 StartColumn:1 EndLine:245 EndColumn:2 Name:add Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0016030c0 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]+other.vars[i])
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]+other.vars[i]) } return &nmVertex{ vars: vars, } }]}
{Id:21 FileId:90 StartLine:247 StartColumn:1 EndLine:256 EndColumn:2 Name:multiply Params:[{Name:scalar Type:float64}] Results:[{Name: Type:*nmVertex}] Receiver:0xc001603700 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]*scalar)
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]*scalar) } return &nmVertex{ vars: vars, } }]}
{Id:22 FileId:90 StartLine:258 StartColumn:1 EndLine:267 EndColumn:2 Name:subtract Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0001e6920 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]-other.vars[i])
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]-other.vars[i]) } return &nmVertex{ vars: vars, } }]}
{Id:23 FileId:90 StartLine:279 StartColumn:1 EndLine:288 EndColumn:2 Name:less Params:[{Name:config Type:NelderMeadConfiguration} {Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc000a8bbc0 Body:{
	if config.Target == min {
		return nm.result < other.result
	}
	if config.Target == max {
		return nm.result > other.result
	}

	return nm.distance < other.distance
} PrettyPrintBody:[{ if config.Target == min { return nm.result < other.result } if config.Target == max { return nm.result > other.result } return nm.distance < other.distance }]}
{Id:24 FileId:90 StartLine:290 StartColumn:1 EndLine:298 EndColumn:2 Name:equal Params:[{Name:config Type:NelderMeadConfiguration} {Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc000a8bc60 Body:{
	if isInf(config.Target) {

		return nm.result == other.result
	}

	return nm.distance == other.distance
} PrettyPrintBody:[{ if isInf(config.Target) { return nm.result == other.result } return nm.distance == other.distance }]}
{Id:25 FileId:90 StartLine:301 StartColumn:1 EndLine:310 EndColumn:2 Name:euclideanDistance Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:float64}] Receiver:0xc00019e880 Body:{
	sum := float64(0)

	for i, otherPoint := range other.vars {

		sum += math.Pow(otherPoint-nm.vars[i], 2)
	}

	return math.Sqrt(sum)
} PrettyPrintBody:[{ sum := float64(0) for i, otherPoint := range other.vars { sum += math.Pow(otherPoint-nm.vars[i], 2) } return math.Sqrt(sum) }]}
{Id:26 FileId:90 StartLine:315 StartColumn:1 EndLine:323 EndColumn:2 Name:equalToVertex Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc001603920 Body:{
	for i, n := range nm.vars {
		if n != other.vars[i] {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, n := range nm.vars { if n != other.vars[i] { return false } } return true }]}
{Id:27 FileId:90 StartLine:331 StartColumn:1 EndLine:333 EndColumn:2 Name:approximatelyEqualToVertex Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc0001e6e40 Body:{
	return math.Abs(nm.result-other.result) < 2*delta
} PrettyPrintBody:[{ return math.Abs(nm.result-other.result) < 2*delta }]}
{Id:29 FileId:90 StartLine:346 StartColumn:1 EndLine:361 EndColumn:2 Name:evaluateWithConstraints Params:[{Name:vertices Type:vertices} {Name:vertex Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000ed8e0 Body:{
	vertex.evaluate(nm.config)
	return vertex
	if vertex.good {
		return vertex
	}
	best := vertices[0]
	for i := 0; i < 5; i++ {
		vertex = best.add((vertex.subtract(best).multiply(alpha)))
		if vertex.good {
			return vertex
		}
	}

	return best
} PrettyPrintBody:[{ vertex.evaluate(nm.config) return vertex if vertex.good { return vertex } best := vertices[0] for i := 0; i < 5; i++ { vertex = best.add((vertex.subtract(best).multiply(alpha))) if vertex.good { return vertex } } return best }]}
{Id:30 FileId:90 StartLine:365 StartColumn:1 EndLine:370 EndColumn:2 Name:reflect Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000ed940 Body:{
	toScalar := midpoint.subtract(nm.lastVertex(vertices))
	toScalar = toScalar.multiply(alpha)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := midpoint.subtract(nm.lastVertex(vertices)) toScalar = toScalar.multiply(alpha) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]}
{Id:31 FileId:90 StartLine:372 StartColumn:1 EndLine:377 EndColumn:2 Name:expand Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00019eb40 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(beta)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(beta) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]}
{Id:32 FileId:90 StartLine:382 StartColumn:1 EndLine:384 EndColumn:2 Name:lastDimensionVertex Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00095bb40 Body:{
	return vertices[len(vertices)-2]
} PrettyPrintBody:[{ return vertices[len(vertices)-2] }]}
{Id:33 FileId:90 StartLine:389 StartColumn:1 EndLine:391 EndColumn:2 Name:lastVertex Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00095bba0 Body:{
	return vertices[len(vertices)-1]
} PrettyPrintBody:[{ return vertices[len(vertices)-1] }]}
{Id:34 FileId:90 StartLine:393 StartColumn:1 EndLine:398 EndColumn:2 Name:outsideContract Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00019ed40 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(gamma)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(gamma) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]}
{Id:35 FileId:90 StartLine:400 StartColumn:1 EndLine:405 EndColumn:2 Name:insideContract Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000edd80 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(gamma)
	toScalar = midpoint.subtract(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(gamma) toScalar = midpoint.subtract(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]}
{Id:36 FileId:90 StartLine:407 StartColumn:1 EndLine:414 EndColumn:2 Name:shrink Params:[{Name:vertices Type:vertices}] Results:[] Receiver:0xc001603d00 Body:{
	one := vertices[0]
	for i := 1; i < len(vertices); i++ {
		toScalar := vertices[i].subtract(one)
		toScalar = toScalar.multiply(sigma)
		vertices[i] = one.add(toScalar)
	}
} PrettyPrintBody:[{ one := vertices[0] for i := 1; i < len(vertices); i++ { toScalar := vertices[i].subtract(one) toScalar = toScalar.multiply(sigma) vertices[i] = one.add(toScalar) } }]}
{Id:37 FileId:90 StartLine:419 StartColumn:1 EndLine:452 EndColumn:2 Name:checkIteration Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:bool}] Receiver:0xc001603d80 Body:{

	if math.Abs(vertices[0].result-nm.config.Target) < delta {
		return false
	}

	best := vertices[0]

	if !isInf(nm.config.Target) {
		for _, v := range vertices[1:] {
			if math.Abs(best.distance-v.distance) >= delta {
				return true
			}
		}
	}

	for _, v := range vertices[1:] {
		if best.euclideanDistance(v) >= delta {
			return true
		}
	}

	return false
} PrettyPrintBody:[{ if math.Abs(vertices[0].result-nm.config.Target) < delta { return false } best := vertices[0] if !isInf(nm.config.Target) { for _, v := range vertices[1:] { if math.Abs(best.distance-v.distance) >= delta { return true } } } for _, v := range vertices[1:] { if best.euclideanDistance(v) >= delta { return true } } return false }]}
{Id:38 FileId:90 StartLine:454 StartColumn:1 EndLine:540 EndColumn:2 Name:evaluate Params:[] Results:[] Receiver:0xc0006b8060 Body:{
	vertices := nm.results.grab(len(nm.config.Vars) + 1)

	vertices[0].evaluate(nm.config)
	if !vertices[0].good {
		nm.results.insert(vertices[0])
		return
	}

	for i := 0; i < maxIterations; i++ {

		for j := 0; j < maxRuns; j++ {

			vertices.evaluate(nm.config)
			best := vertices[0]
			if !nm.checkIteration(vertices) {
				break
			}

			midpoint := findMidpoint(vertices[:len(vertices)-1]...)

			reflection := nm.reflect(vertices, midpoint)

			if reflection == best {
				break
			}

			if reflection.less(nm.config, nm.lastDimensionVertex(vertices)) &&
				!vertices[0].less(nm.config, reflection) {

				vertices[len(vertices)-1] = reflection
			}

			if reflection.less(nm.config, vertices[0]) {
				expanded := nm.expand(vertices, midpoint, reflection)

				if expanded == best {
					break
				}

				if expanded.less(nm.config, reflection) {
					vertices[len(vertices)-1] = expanded
				} else {
					vertices[len(vertices)-1] = reflection
				}
				continue
			}

			if reflection.less(nm.config, nm.lastVertex(vertices)) {
				oc := nm.outsideContract(vertices, midpoint, reflection)
				if oc == best {
					break
				}
				if oc.less(nm.config, reflection) || oc.equal(nm.config, reflection) {
					vertices[len(vertices)-1] = oc
					continue
				}
			} else if !reflection.less(nm.config, nm.lastVertex(vertices)) {
				ic := nm.insideContract(vertices, midpoint, reflection)
				if ic == best {
					break
				}
				if ic.less(nm.config, nm.lastVertex(vertices)) {
					vertices[len(vertices)-1] = ic
					continue
				}
			}

			nm.shrink(vertices)
		}
		nm.results.reSort(vertices[0])
		vertices = nm.results.grab(len(nm.config.Vars) + 1)
	}
} PrettyPrintBody:[{ vertices := nm.results.grab(len(nm.config.Vars) + 1) vertices[0].evaluate(nm.config) if !vertices[0].good { nm.results.insert(vertices[0]) return } for i := 0; i < maxIterations; i++ { for j := 0; j < maxRuns; j++ { vertices.evaluate(nm.config) best := vertices[0] if !nm.checkIteration(vertices) { break } midpoint := findMidpoint(vertices[:len(vertices)-1]...) reflection := nm.reflect(vertices, midpoint) if reflection == best { break } if reflection.less(nm.config, nm.lastDimensionVertex(vertices)) && !vertices[0].less(nm.config, reflection) { vertices[len(vertices)-1] = reflection } if reflection.less(nm.config, vertices[0]) { expanded := nm.expand(vertices, midpoint, reflection) if expanded == best { break } if expanded.less(nm.config, reflection) { vertices[len(vertices)-1] = expanded } else { vertices[len(vertices)-1] = reflection } continue } if reflection.less(nm.config, nm.lastVertex(vertices)) { oc := nm.outsideContract(vertices, midpoint, reflection) if oc == best { break } if oc.less(nm.config, reflection) || oc.equal(nm.config, reflection) { vertices[len(vertices)-1] = oc continue } } else if !reflection.less(nm.config, nm.lastVertex(vertices)) { ic := nm.insideContract(vertices, midpoint, reflection) if ic == best { break } if ic.less(nm.config, nm.lastVertex(vertices)) { vertices[len(vertices)-1] = ic continue } } nm.shrink(vertices) } nm.results.reSort(vertices[0]) vertices = nm.results.grab(len(nm.config.Vars) + 1) } }]}
{Id:39 FileId:90 StartLine:542 StartColumn:1 EndLine:550 EndColumn:2 Name:newNelderMead Params:[{Name:config Type:NelderMeadConfiguration}] Results:[{Name: Type:*nelderMead}] Receiver:<nil> Body:{
	v := &nmVertex{vars: config.Vars}
	results := newResults(v, config, 1000)

	return &nelderMead{
		config:		config,
		results:	results,
	}
} PrettyPrintBody:[{ v := &nmVertex{vars: config.Vars} results := newResults(v, config, 1000) return &nelderMead{ config:		config, results:	results, } }]}
{Id:40 FileId:90 StartLine:555 StartColumn:1 EndLine:559 EndColumn:2 Name:NelderMead Params:[{Name:config Type:NelderMeadConfiguration}] Results:[{Name: Type:[]float64}] Receiver:<nil> Body:{
	nm := newNelderMead(config)
	nm.evaluate()
	return nm.results.vertices[0].vars
} PrettyPrintBody:[{ nm := newNelderMead(config) nm.evaluate() return nm.results.vertices[0].vars }]}
{Id:1 FileId:57 StartLine:31 StartColumn:1 EndLine:39 EndColumn:2 Name:checkTree Params:[{Name:t Type:testing.TB} {Name:tree Type:*ptree}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return true

	if tree.root == nil {
		return true
	}

	return checkNode(t, tree.root)
} PrettyPrintBody:[{ return true if tree.root == nil { return true } return checkNode(t, tree.root) }]}
{Id:2 FileId:57 StartLine:41 StartColumn:1 EndLine:84 EndColumn:2 Name:checkNode Params:[{Name:t Type:testing.TB} {Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n.keys.len() == 0 {
		assert.Equal(t, uint64(0), n.nodes.len())
		return false
	}

	if n.isLeaf {
		assert.Equal(t, uint64(0), n.nodes.len())
		return false
	}

	if !assert.Equal(t, n.keys.len()+1, n.nodes.len()) {
		return false
	}

	for i, k := range n.keys.list {
		nd := n.nodes.list[i]
		if !assert.NotNil(t, nd) {
			return false
		}

		if !assert.True(t, k.Compare(nd.key()) >= 0) {
			t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, k, nd)
			return false
		}
	}

	k := n.keys.last()
	nd := n.nodes.byPosition(n.nodes.len() - 1)
	if !assert.True(t, k.Compare(nd.key()) < 0) {
		t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, nd, k)
		return false
	}
	for _, child := range n.nodes.list {
		if !assert.NotNil(t, child) {
			return false
		}
		if !checkNode(t, child) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if n.keys.len() == 0 { assert.Equal(t, uint64(0), n.nodes.len()) return false } if n.isLeaf { assert.Equal(t, uint64(0), n.nodes.len()) return false } if !assert.Equal(t, n.keys.len()+1, n.nodes.len()) { return false } for i, k := range n.keys.list { nd := n.nodes.list[i] if !assert.NotNil(t, nd) { return false } if !assert.True(t, k.Compare(nd.key()) >= 0) { t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, k, nd) return false } } k := n.keys.last() nd := n.nodes.byPosition(n.nodes.len() - 1) if !assert.True(t, k.Compare(nd.key()) < 0) { t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, nd, k) return false } for _, child := range n.nodes.list { if !assert.NotNil(t, child) { return false } if !checkNode(t, child) { return false } } return true }]}
{Id:3 FileId:57 StartLine:86 StartColumn:1 EndLine:88 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]}
{Id:4 FileId:57 StartLine:90 StartColumn:1 EndLine:97 EndColumn:2 Name:generateRandomKeys Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	keys := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		m := rand.Int()
		keys = append(keys, mockKey(m%50))
	}
	return keys
} PrettyPrintBody:[{ keys := make(common.Comparators, 0, num) for i := 0; i < num; i++ { m := rand.Int() keys = append(keys, mockKey(m%50)) } return keys }]}
{Id:5 FileId:57 StartLine:99 StartColumn:1 EndLine:106 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	keys := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(common.Comparators, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(i)) } return keys }]}
{Id:6 FileId:57 StartLine:108 StartColumn:1 EndLine:117 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)

	tree.Insert(m1)
	assert.Equal(t, common.Comparators{m1}, tree.Get(m1))
	assert.Equal(t, uint64(1), tree.Len())
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) assert.Equal(t, common.Comparators{m1}, tree.Get(m1)) assert.Equal(t, uint64(1), tree.Len()) checkTree(t, tree) }]}
{Id:7 FileId:57 StartLine:119 StartColumn:1 EndLine:129 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(8, 8)
	defer tree.Dispose()
	m1 := mockKey(1)
	tree.Insert(m1)

	tree.Delete(m1)
	assert.Equal(t, uint64(0), tree.Len())
	assert.Equal(t, common.Comparators{nil}, tree.Get(m1))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(8, 8) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) tree.Delete(m1) assert.Equal(t, uint64(0), tree.Len()) assert.Equal(t, common.Comparators{nil}, tree.Get(m1)) checkTree(t, tree) }]}
{Id:8 FileId:57 StartLine:131 StartColumn:1 EndLine:143 EndColumn:2 Name:TestMultipleAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(10)

	tree.Insert(m1, m2)
	if !assert.Equal(t, common.Comparators{m1, m2}, tree.Get(m1, m2)) {
		tree.print(getConsoleLogger())
	}
	assert.Equal(t, uint64(2), tree.Len())
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(10) tree.Insert(m1, m2) if !assert.Equal(t, common.Comparators{m1, m2}, tree.Get(m1, m2)) { tree.print(getConsoleLogger()) } assert.Equal(t, uint64(2), tree.Len()) checkTree(t, tree) }]}
{Id:9 FileId:57 StartLine:145 StartColumn:1 EndLine:156 EndColumn:2 Name:TestMultipleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(10)
	tree.Insert(m1, m2)

	tree.Delete(m1, m2)
	assert.Equal(t, uint64(0), tree.Len())
	assert.Equal(t, common.Comparators{nil, nil}, tree.Get(m1, m2))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(10) tree.Insert(m1, m2) tree.Delete(m1, m2) assert.Equal(t, uint64(0), tree.Len()) assert.Equal(t, common.Comparators{nil, nil}, tree.Get(m1, m2)) checkTree(t, tree) }]}
{Id:10 FileId:57 StartLine:158 StartColumn:1 EndLine:169 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)

	tree.Insert(reversed...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:11 FileId:57 StartLine:171 StartColumn:1 EndLine:185 EndColumn:2 Name:TestMultipleDeleteOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)
	tree.Insert(reversed...)
	assert.Equal(t, uint64(100), tree.Len())

	tree.Delete(reversed...)
	assert.Equal(t, uint64(0), tree.Len())
	for _, k := range reversed {
		assert.Equal(t, common.Comparators{nil}, tree.Get(k))
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) assert.Equal(t, uint64(100), tree.Len()) tree.Delete(reversed...) assert.Equal(t, uint64(0), tree.Len()) for _, k := range reversed { assert.Equal(t, common.Comparators{nil}, tree.Get(k)) } checkTree(t, tree) }]}
{Id:12 FileId:57 StartLine:187 StartColumn:1 EndLine:197 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:13 FileId:57 StartLine:199 StartColumn:1 EndLine:209 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateRandomKeys(10)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateRandomKeys(10) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:14 FileId:57 StartLine:211 StartColumn:1 EndLine:229 EndColumn:2 Name:TestMultipleBulkInsertOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys1 := generateRandomKeys(100)
	keys2 := generateRandomKeys(100)

	tree.Insert(keys1...)

	if !assert.Equal(t, keys1, tree.Get(keys1...)) {
		tree.print(getConsoleLogger())
	}

	tree.Insert(keys2...)

	if !assert.Equal(t, keys2, tree.Get(keys2...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys1 := generateRandomKeys(100) keys2 := generateRandomKeys(100) tree.Insert(keys1...) if !assert.Equal(t, keys1, tree.Get(keys1...)) { tree.print(getConsoleLogger()) } tree.Insert(keys2...) if !assert.Equal(t, keys2, tree.Get(keys2...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:15 FileId:57 StartLine:231 StartColumn:1 EndLine:248 EndColumn:2 Name:TestMultipleBulkInsertEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys1 := generateRandomKeys(100)
	keys2 := generateRandomKeys(100)

	tree.Insert(keys1...)
	tree.Insert(keys2...)

	if !assert.Equal(t, keys1, tree.Get(keys1...)) {
		tree.print(getConsoleLogger())
	}

	if !assert.Equal(t, keys2, tree.Get(keys2...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys1 := generateRandomKeys(100) keys2 := generateRandomKeys(100) tree.Insert(keys1...) tree.Insert(keys2...) if !assert.Equal(t, keys1, tree.Get(keys1...)) { tree.print(getConsoleLogger()) } if !assert.Equal(t, keys2, tree.Get(keys2...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:16 FileId:57 StartLine:250 StartColumn:1 EndLine:261 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)

	tree.Insert(reversed...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:17 FileId:57 StartLine:263 StartColumn:1 EndLine:273 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:18 FileId:57 StartLine:275 StartColumn:1 EndLine:285 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateRandomKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateRandomKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]}
{Id:19 FileId:57 StartLine:287 StartColumn:1 EndLine:297 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(10)
	duplicate := mockKey(0)
	tree.Insert(keys...)

	tree.Insert(duplicate)
	assert.Equal(t, common.Comparators{duplicate}, tree.Get(duplicate))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(10) duplicate := mockKey(0) tree.Insert(keys...) tree.Insert(duplicate) assert.Equal(t, common.Comparators{duplicate}, tree.Get(duplicate)) checkTree(t, tree) }]}
{Id:20 FileId:57 StartLine:299 StartColumn:1 EndLine:324 EndColumn:2 Name:TestSimultaneousReadsAndWrites Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numLoops := 3
	keys := make([]common.Comparators, 0, numLoops)
	for i := 0; i < numLoops; i++ {
		keys = append(keys, generateRandomKeys(10))
	}

	tree := newTree(16, 16)
	defer tree.Dispose()
	var wg sync.WaitGroup
	wg.Add(numLoops)
	for i := 0; i < numLoops; i++ {
		go func(i int) {
			tree.Insert(keys[i]...)
			tree.Get(keys[i]...)
			wg.Done()
		}(i)
	}

	wg.Wait()

	for i := 0; i < numLoops; i++ {
		assert.Equal(t, keys[i], tree.Get(keys[i]...))
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ numLoops := 3 keys := make([]common.Comparators, 0, numLoops) for i := 0; i < numLoops; i++ { keys = append(keys, generateRandomKeys(10)) } tree := newTree(16, 16) defer tree.Dispose() var wg sync.WaitGroup wg.Add(numLoops) for i := 0; i < numLoops; i++ { go func(i int) { tree.Insert(keys[i]...) tree.Get(keys[i]...) wg.Done() }(i) } wg.Wait() for i := 0; i < numLoops; i++ { assert.Equal(t, keys[i], tree.Get(keys[i]...)) } checkTree(t, tree) }]}
{Id:21 FileId:57 StartLine:326 StartColumn:1 EndLine:352 EndColumn:2 Name:TestInsertAndDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1024, 1024)
	defer tree.Dispose()

	keys := generateKeys(100)
	keys1 := keys[:50]
	keys2 := keys[50:]
	tree.Insert(keys1...)
	assert.Equal(t, uint64(len(keys1)), tree.Len())
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		tree.Insert(keys2...)
		wg.Done()
	}()

	go func() {
		tree.Delete(keys1...)
		wg.Done()
	}()

	wg.Wait()

	assert.Equal(t, uint64(len(keys2)), tree.Len())
	assert.Equal(t, keys2, tree.Get(keys2...))
} PrettyPrintBody:[{ tree := newTree(1024, 1024) defer tree.Dispose() keys := generateKeys(100) keys1 := keys[:50] keys2 := keys[50:] tree.Insert(keys1...) assert.Equal(t, uint64(len(keys1)), tree.Len()) var wg sync.WaitGroup wg.Add(2) go func() { tree.Insert(keys2...) wg.Done() }() go func() { tree.Delete(keys1...) wg.Done() }() wg.Wait() assert.Equal(t, uint64(len(keys2)), tree.Len()) assert.Equal(t, keys2, tree.Get(keys2...)) }]}
{Id:22 FileId:57 StartLine:354 StartColumn:1 EndLine:380 EndColumn:2 Name:TestInsertAndDeletesWithSplits Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()

	keys := generateKeys(100)
	keys1 := keys[:50]
	keys2 := keys[50:]
	tree.Insert(keys1...)
	assert.Equal(t, uint64(len(keys1)), tree.Len())
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		tree.Insert(keys2...)
		wg.Done()
	}()

	go func() {
		tree.Delete(keys1...)
		wg.Done()
	}()

	wg.Wait()

	assert.Equal(t, uint64(len(keys2)), tree.Len())
	assert.Equal(t, keys2, tree.Get(keys2...))
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) keys1 := keys[:50] keys2 := keys[50:] tree.Insert(keys1...) assert.Equal(t, uint64(len(keys1)), tree.Len()) var wg sync.WaitGroup wg.Add(2) go func() { tree.Insert(keys2...) wg.Done() }() go func() { tree.Delete(keys1...) wg.Done() }() wg.Wait() assert.Equal(t, uint64(len(keys2)), tree.Len()) assert.Equal(t, keys2, tree.Get(keys2...)) }]}
{Id:23 FileId:57 StartLine:382 StartColumn:1 EndLine:399 EndColumn:2 Name:TestSimpleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	m1 := mockKey(1)
	tree.Insert(m1)

	result := tree.Query(mockKey(0), mockKey(5))
	assert.Equal(t, common.Comparators{m1}, result)

	result = tree.Query(mockKey(0), mockKey(1))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(2), mockKey(10))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(1), mockKey(10))
	assert.Equal(t, common.Comparators{m1}, result)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) result := tree.Query(mockKey(0), mockKey(5)) assert.Equal(t, common.Comparators{m1}, result) result = tree.Query(mockKey(0), mockKey(1)) assert.Len(t, result, 0) result = tree.Query(mockKey(2), mockKey(10)) assert.Len(t, result, 0) result = tree.Query(mockKey(1), mockKey(10)) assert.Equal(t, common.Comparators{m1}, result) }]}
{Id:24 FileId:57 StartLine:401 StartColumn:1 EndLine:419 EndColumn:2 Name:TestMultipleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(5)
	tree.Insert(m1, m2)

	result := tree.Query(mockKey(0), mockKey(10))
	assert.Equal(t, common.Comparators{m1, m2}, result)

	result = tree.Query(mockKey(1), mockKey(5))
	assert.Equal(t, common.Comparators{m1}, result)

	result = tree.Query(mockKey(6), mockKey(10))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(5), mockKey(10))
	assert.Equal(t, common.Comparators{m2}, result)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(5) tree.Insert(m1, m2) result := tree.Query(mockKey(0), mockKey(10)) assert.Equal(t, common.Comparators{m1, m2}, result) result = tree.Query(mockKey(1), mockKey(5)) assert.Equal(t, common.Comparators{m1}, result) result = tree.Query(mockKey(6), mockKey(10)) assert.Len(t, result, 0) result = tree.Query(mockKey(5), mockKey(10)) assert.Equal(t, common.Comparators{m2}, result) }]}
{Id:25 FileId:57 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:TestCrossNodeQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	tree.Insert(keys...)

	result := tree.Query(mockKey(0), mockKey(len(keys)))
	if !assert.Equal(t, keys, result) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) result := tree.Query(mockKey(0), mockKey(len(keys))) if !assert.Equal(t, keys, result) { tree.print(getConsoleLogger()) } }]}
{Id:26 FileId:57 StartLine:433 StartColumn:1 EndLine:447 EndColumn:2 Name:BenchmarkReadAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := make([]common.Comparators, 0, b.N)
	for i := 0; i < b.N; i++ {
		keys = append(keys, generateRandomKeys(numItems))
	}

	tree := newTree(8, 8)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i]...)
		tree.Get(keys[i]...)
	}
} PrettyPrintBody:[{ numItems := 1000 keys := make([]common.Comparators, 0, b.N) for i := 0; i < b.N; i++ { keys = append(keys, generateRandomKeys(numItems)) } tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i]...) tree.Get(keys[i]...) } }]}
{Id:27 FileId:57 StartLine:449 StartColumn:1 EndLine:475 EndColumn:2 Name:BenchmarkSimultaneousReadsAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	numRoutines := 8
	keys := generateRandomKeys(numItems)
	chunks := chunkKeys(keys, int64(numRoutines))

	trees := make([]*ptree, 0, numItems)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newTree(8, 8))
	}

	var wg sync.WaitGroup
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(numRoutines)
		for j := 0; j < numRoutines; j++ {
			go func(i, j int) {
				trees[i].Insert(chunks[j]...)
				trees[i].Get(chunks[j]...)
				wg.Done()
			}(i, j)
		}

		wg.Wait()
	}
} PrettyPrintBody:[{ numItems := 10000 numRoutines := 8 keys := generateRandomKeys(numItems) chunks := chunkKeys(keys, int64(numRoutines)) trees := make([]*ptree, 0, numItems) for i := 0; i < b.N; i++ { trees = append(trees, newTree(8, 8)) } var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(numRoutines) for j := 0; j < numRoutines; j++ { go func(i, j int) { trees[i].Insert(chunks[j]...) trees[i].Get(chunks[j]...) wg.Done() }(i, j) } wg.Wait() } }]}
{Id:28 FileId:57 StartLine:477 StartColumn:1 EndLine:490 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	trees := make([]*ptree, 0, b.N)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newTree(8, 8))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) trees := make([]*ptree, 0, b.N) for i := 0; i < b.N; i++ { trees = append(trees, newTree(8, 8)) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Insert(keys...) } }]}
{Id:29 FileId:57 StartLine:492 StartColumn:1 EndLine:502 EndColumn:2 Name:BenchmarkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]}
{Id:30 FileId:57 StartLine:504 StartColumn:1 EndLine:518 EndColumn:2 Name:BenchmarkBulkAddToExisting Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	keySet := make([]common.Comparators, 0, b.N)
	for i := 0; i < b.N; i++ {
		keySet = append(keySet, generateRandomKeys(numItems))
	}

	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keySet[i]...)
	}
} PrettyPrintBody:[{ numItems := 100000 keySet := make([]common.Comparators, 0, b.N) for i := 0; i < b.N; i++ { keySet = append(keySet, generateRandomKeys(numItems)) } tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keySet[i]...) } }]}
{Id:31 FileId:57 StartLine:520 StartColumn:1 EndLine:531 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]}
{Id:32 FileId:57 StartLine:533 StartColumn:1 EndLine:544 EndColumn:2 Name:BenchmarkBulkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys...)
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys...) } }]}
{Id:33 FileId:57 StartLine:546 StartColumn:1 EndLine:557 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Delete(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Delete(keys[i%numItems]) } }]}
{Id:34 FileId:57 StartLine:559 StartColumn:1 EndLine:574 EndColumn:2 Name:BenchmarkBulkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	trees := make([]*ptree, 0, b.N)
	for i := 0; i < b.N; i++ {
		tree := newTree(8, 8)
		tree.Insert(keys...)
		trees = append(trees, tree)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) trees := make([]*ptree, 0, b.N) for i := 0; i < b.N; i++ { tree := newTree(8, 8) tree.Insert(keys...) trees = append(trees, tree) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(keys...) } }]}
{Id:35 FileId:57 StartLine:576 StartColumn:1 EndLine:587 EndColumn:2 Name:BenchmarkFindQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(mockKey(numItems/2), mockKey(numItems/2+1))
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(mockKey(numItems/2), mockKey(numItems/2+1)) } }]}
{Id:36 FileId:57 StartLine:589 StartColumn:1 EndLine:600 EndColumn:2 Name:BenchmarkExecuteQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(mockKey(0), mockKey(numItems))
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(mockKey(0), mockKey(numItems)) } }]}
{Id:1 FileId:147 StartLine:30 StartColumn:1 EndLine:81 EndColumn:2 Name:TestCtrie Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)

	_, ok := ctrie.Lookup([]byte("foo"))
	assert.False(ok)

	ctrie.Insert([]byte("foo"), "bar")
	val, ok := ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)

	ctrie.Insert([]byte("fooooo"), "baz")
	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)
	val, ok = ctrie.Lookup([]byte("fooooo"))
	assert.True(ok)
	assert.Equal("baz", val)

	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), "blah")
	}
	for i := 0; i < 100; i++ {
		val, ok = ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal("blah", val)
	}

	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)
	ctrie.Insert([]byte("foo"), "qux")
	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("qux", val)

	val, ok = ctrie.Remove([]byte("foo"))
	assert.True(ok)
	assert.Equal("qux", val)

	_, ok = ctrie.Remove([]byte("foo"))
	assert.False(ok)

	val, ok = ctrie.Remove([]byte("fooooo"))
	assert.True(ok)
	assert.Equal("baz", val)

	for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) _, ok := ctrie.Lookup([]byte("foo")) assert.False(ok) ctrie.Insert([]byte("foo"), "bar") val, ok := ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) ctrie.Insert([]byte("fooooo"), "baz") val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) val, ok = ctrie.Lookup([]byte("fooooo")) assert.True(ok) assert.Equal("baz", val) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), "blah") } for i := 0; i < 100; i++ { val, ok = ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal("blah", val) } val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) ctrie.Insert([]byte("foo"), "qux") val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("qux", val) val, ok = ctrie.Remove([]byte("foo")) assert.True(ok) assert.Equal("qux", val) _, ok = ctrie.Remove([]byte("foo")) assert.False(ok) val, ok = ctrie.Remove([]byte("fooooo")) assert.True(ok) assert.Equal("baz", val) for i := 0; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } }]}
{Id:3 FileId:147 StartLine:87 StartColumn:1 EndLine:89 EndColumn:2 Name:Sum32 Params:[] Results:[{Name: Type:uint32}] Receiver:0xc000a8b7e0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:4 FileId:147 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:mockHashFactory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return &mockHash32{fnv.New32a()}
} PrettyPrintBody:[{ return &mockHash32{fnv.New32a()} }]}
{Id:5 FileId:147 StartLine:95 StartColumn:1 EndLine:116 EndColumn:2 Name:TestInsertLNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(mockHashFactory)

	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
	_, ok := ctrie.Lookup([]byte("11"))
	assert.False(ok)

	for i := 0; i < 10; i++ {
		val, ok := ctrie.Remove([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(mockHashFactory) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 10; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } _, ok := ctrie.Lookup([]byte("11")) assert.False(ok) for i := 0; i < 10; i++ { val, ok := ctrie.Remove([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } }]}
{Id:6 FileId:147 StartLine:118 StartColumn:1 EndLine:139 EndColumn:2 Name:TestInsertTNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 5000; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10000; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 5000; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } }]}
{Id:7 FileId:147 StartLine:141 StartColumn:1 EndLine:170 EndColumn:2 Name:TestConcurrency Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
				assert.Equal(i, val)
			}
		}
		wg.Done()
	}()

	for i := 0; i < 10000; i++ {
		time.Sleep(5)
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	wg.Wait()
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) var wg sync.WaitGroup wg.Add(2) go func() { for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } wg.Done() }() go func() { for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) if ok { assert.Equal(i, val) } } wg.Done() }() for i := 0; i < 10000; i++ { time.Sleep(5) ctrie.Remove([]byte(strconv.Itoa(i))) } wg.Wait() }]}
{Id:8 FileId:147 StartLine:172 StartColumn:1 EndLine:211 EndColumn:2 Name:TestConcurrency2 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	var wg sync.WaitGroup
	wg.Add(4)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
				assert.Equal(i, val)
			}
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Snapshot()
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.ReadOnlySnapshot()
		}
		wg.Done()
	}()

	wg.Wait()
	assert.Equal(uint(10000), ctrie.Size())
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) var wg sync.WaitGroup wg.Add(4) go func() { for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } wg.Done() }() go func() { for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) if ok { assert.Equal(i, val) } } wg.Done() }() go func() { for i := 0; i < 10000; i++ { ctrie.Snapshot() } wg.Done() }() go func() { for i := 0; i < 10000; i++ { ctrie.ReadOnlySnapshot() } wg.Done() }() wg.Wait() assert.Equal(uint(10000), ctrie.Size()) }]}
{Id:9 FileId:147 StartLine:213 StartColumn:1 EndLine:287 EndColumn:2 Name:TestSnapshot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	snapshot := ctrie.Snapshot()

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	ctrie = New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	snapshot = ctrie.Snapshot()

	for i := 0; i < 100; i++ {
		snapshot.Remove([]byte(strconv.Itoa(i)))
	}
	snapshot.Insert([]byte("bat"), "man")

	for i := 0; i < 100; i++ {
		_, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.False(ok)
	}
	val, ok := snapshot.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)

	for i := 0; i < 100; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
	_, ok = ctrie.Lookup([]byte("bat"))
	assert.False(ok)

	snapshot2 := snapshot.Snapshot()
	for i := 0; i < 100; i++ {
		_, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
		assert.False(ok)
	}
	val, ok = snapshot2.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)

	snapshot2.Remove([]byte("bat"))
	_, ok = snapshot2.Lookup([]byte("bat"))
	assert.False(ok)
	val, ok = snapshot.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot := ctrie.Snapshot() for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } for i := 0; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } ctrie = New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot = ctrie.Snapshot() for i := 0; i < 100; i++ { snapshot.Remove([]byte(strconv.Itoa(i))) } snapshot.Insert([]byte("bat"), "man") for i := 0; i < 100; i++ { _, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.False(ok) } val, ok := snapshot.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) for i := 0; i < 100; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } _, ok = ctrie.Lookup([]byte("bat")) assert.False(ok) snapshot2 := snapshot.Snapshot() for i := 0; i < 100; i++ { _, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))) assert.False(ok) } val, ok = snapshot2.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) snapshot2.Remove([]byte("bat")) _, ok = snapshot2.Lookup([]byte("bat")) assert.False(ok) val, ok = snapshot.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) }]}
{Id:10 FileId:147 StartLine:289 StartColumn:1 EndLine:342 EndColumn:2 Name:TestReadOnlySnapshot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	snapshot := ctrie.ReadOnlySnapshot()

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	for i := 0; i < 50; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	func() {
		defer func() {
			assert.NotNil(recover())
		}()
		snapshot.Remove([]byte("blah"))
	}()

	snapshot2 := snapshot.Snapshot()
	for i := 50; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
	for i := 0; i < 100; i++ {
		val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	func() {
		defer func() {
			assert.NotNil(recover())
		}()
		snapshot2.Remove([]byte("blah"))
	}()
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot := ctrie.ReadOnlySnapshot() for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } for i := 0; i < 50; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } func() { defer func() { assert.NotNil(recover()) }() snapshot.Remove([]byte("blah")) }() snapshot2 := snapshot.Snapshot() for i := 50; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } func() { defer func() { assert.NotNil(recover()) }() snapshot2.Remove([]byte("blah")) }() }]}
{Id:11 FileId:147 StartLine:344 StartColumn:1 EndLine:389 EndColumn:2 Name:TestIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	expected := map[string]int{
		"0":	0,
		"1":	1,
		"2":	2,
		"3":	3,
		"4":	4,
		"5":	5,
		"6":	6,
		"7":	7,
		"8":	8,
		"9":	9,
	}

	count := 0
	for entry := range ctrie.Iterator(nil) {
		exp, ok := expected[string(entry.Key)]
		if assert.True(ok) {
			assert.Equal(exp, entry.Value)
		}
		count++
	}
	assert.Equal(len(expected), count)

	cancel := make(chan struct{})
	iter := ctrie.Iterator(cancel)
	entry := <-iter
	exp, ok := expected[string(entry.Key)]
	if assert.True(ok) {
		assert.Equal(exp, entry.Value)
	}
	close(cancel)

	for _ = range expected {
		<-iter
	}
	_, ok = <-iter
	assert.False(ok)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } expected := map[string]int{ "0":	0, "1":	1, "2":	2, "3":	3, "4":	4, "5":	5, "6":	6, "7":	7, "8":	8, "9":	9, } count := 0 for entry := range ctrie.Iterator(nil) { exp, ok := expected[string(entry.Key)] if assert.True(ok) { assert.Equal(exp, entry.Value) } count++ } assert.Equal(len(expected), count) cancel := make(chan struct{}) iter := ctrie.Iterator(cancel) entry := <-iter exp, ok := expected[string(entry.Key)] if assert.True(ok) { assert.Equal(exp, entry.Value) } close(cancel) for _ = range expected { <-iter } _, ok = <-iter assert.False(ok) }]}
{Id:12 FileId:147 StartLine:392 StartColumn:1 EndLine:407 EndColumn:2 Name:TestIteratorCoversTNodes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(mockHashFactory)

	ctrie.Insert([]byte("a"), true)
	ctrie.Insert([]byte("b"), true)

	ctrie.Remove([]byte("b"))
	seenKeys := map[string]bool{}
	for entry := range ctrie.Iterator(nil) {
		seenKeys[string(entry.Key)] = true
	}
	assert.Contains(seenKeys, "a", "Iterator did not return 'a'.")
	assert.Len(seenKeys, 1)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(mockHashFactory) ctrie.Insert([]byte("a"), true) ctrie.Insert([]byte("b"), true) ctrie.Remove([]byte("b")) seenKeys := map[string]bool{} for entry := range ctrie.Iterator(nil) { seenKeys[string(entry.Key)] = true } assert.Contains(seenKeys, "a", "Iterator did not return 'a'.") assert.Len(seenKeys, 1) }]}
{Id:13 FileId:147 StartLine:409 StartColumn:1 EndLine:415 EndColumn:2 Name:TestSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	assert.Equal(t, uint(10), ctrie.Size())
} PrettyPrintBody:[{ ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } assert.Equal(t, uint(10), ctrie.Size()) }]}
{Id:14 FileId:147 StartLine:417 StartColumn:1 EndLine:430 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	assert.Equal(uint(10), ctrie.Size())
	snapshot := ctrie.Snapshot()

	ctrie.Clear()

	assert.Equal(uint(0), ctrie.Size())
	assert.Equal(uint(10), snapshot.Size())
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } assert.Equal(uint(10), ctrie.Size()) snapshot := ctrie.Snapshot() ctrie.Clear() assert.Equal(uint(0), ctrie.Size()) assert.Equal(uint(10), snapshot.Size()) }]}
{Id:16 FileId:147 StartLine:434 StartColumn:1 EndLine:436 EndColumn:2 Name:Sum32 Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00019f0e0 Body:{
	return 42
} PrettyPrintBody:[{ return 42 }]}
{Id:17 FileId:147 StartLine:438 StartColumn:1 EndLine:440 EndColumn:2 Name:Sum Params:[{Name:b Type:[]byte}] Results:[{Name: Type:[]byte}] Receiver:0xc00095bc60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]}
{Id:18 FileId:147 StartLine:442 StartColumn:1 EndLine:444 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:int}] Receiver:0xc00095bca0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:19 FileId:147 StartLine:446 StartColumn:1 EndLine:448 EndColumn:2 Name:BlockSize Params:[] Results:[{Name: Type:int}] Receiver:0xc00095bce0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]}
{Id:20 FileId:147 StartLine:450 StartColumn:1 EndLine:452 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0006b8020 Body:{

} PrettyPrintBody:[{ }]}
{Id:21 FileId:147 StartLine:454 StartColumn:1 EndLine:456 EndColumn:2 Name:Write Params:[{Name:b Type:[]byte}] Results:[{Name: Type:int} {Name: Type:error}] Receiver:0xc0006b8140 Body:{
	return 0, nil
} PrettyPrintBody:[{ return 0, nil }]}
{Id:22 FileId:147 StartLine:458 StartColumn:1 EndLine:460 EndColumn:2 Name:factory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return &fakehash{}
} PrettyPrintBody:[{ return &fakehash{} }]}
{Id:23 FileId:147 StartLine:462 StartColumn:1 EndLine:475 EndColumn:2 Name:TestHashCollision Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	trie := New(factory)
	trie.Insert([]byte("foobar"), 1)
	trie.Insert([]byte("zogzog"), 2)
	trie.Insert([]byte("foobar"), 3)
	val, exists := trie.Lookup([]byte("foobar"))
	assert.True(t, exists)
	assert.Equal(t, 3, val)

	trie.Remove([]byte("foobar"))

	_, exists = trie.Lookup([]byte("foobar"))
	assert.False(t, exists)
} PrettyPrintBody:[{ trie := New(factory) trie.Insert([]byte("foobar"), 1) trie.Insert([]byte("zogzog"), 2) trie.Insert([]byte("foobar"), 3) val, exists := trie.Lookup([]byte("foobar")) assert.True(t, exists) assert.Equal(t, 3, val) trie.Remove([]byte("foobar")) _, exists = trie.Lookup([]byte("foobar")) assert.False(t, exists) }]}
{Id:24 FileId:147 StartLine:477 StartColumn:1 EndLine:483 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ctrie := New(nil)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctrie.Insert([]byte("foo"), 0)
	}
} PrettyPrintBody:[{ ctrie := New(nil) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Insert([]byte("foo"), 0) } }]}
{Id:25 FileId:147 StartLine:485 StartColumn:1 EndLine:497 EndColumn:2 Name:BenchmarkLookup Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Lookup(key)
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } key := []byte(strconv.Itoa(numItems / 2)) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Lookup(key) } }]}
{Id:26 FileId:147 StartLine:499 StartColumn:1 EndLine:511 EndColumn:2 Name:BenchmarkRemove Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Remove(key)
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } key := []byte(strconv.Itoa(numItems / 2)) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Remove(key) } }]}
{Id:27 FileId:147 StartLine:513 StartColumn:1 EndLine:524 EndColumn:2 Name:BenchmarkSnapshot Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Snapshot()
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Snapshot() } }]}
{Id:28 FileId:147 StartLine:526 StartColumn:1 EndLine:537 EndColumn:2 Name:BenchmarkReadOnlySnapshot Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.ReadOnlySnapshot()
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.ReadOnlySnapshot() } }]}
{Id:1 FileId:133 StartLine:28 StartColumn:1 EndLine:35 EndColumn:2 Name:generateMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	entries := make(common.Comparators, 0, num)
	for i := uint64(0); i < uint64(num); i++ {
		entries = append(entries, newMockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, num) for i := uint64(0); i < uint64(num); i++ { entries = append(entries, newMockEntry(i)) } return entries }]}
{Id:2 FileId:133 StartLine:37 StartColumn:1 EndLine:44 EndColumn:2 Name:generateRandomMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	entries := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, newMockEntry(uint64(rand.Int())))
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, num) for i := 0; i < num; i++ { entries = append(entries, newMockEntry(uint64(rand.Int()))) } return entries }]}
{Id:3 FileId:133 StartLine:46 StartColumn:1 EndLine:59 EndColumn:2 Name:TestInsertByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	m3 := newMockEntry(2)
	sl := New(uint8(0))
	sl.InsertAtPosition(2, m1)
	sl.InsertAtPosition(0, m2)
	sl.InsertAtPosition(0, m3)

	assert.Equal(t, m3, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
	assert.Equal(t, m1, sl.ByPosition(2))
	assert.Nil(t, sl.ByPosition(3))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) m3 := newMockEntry(2) sl := New(uint8(0)) sl.InsertAtPosition(2, m1) sl.InsertAtPosition(0, m2) sl.InsertAtPosition(0, m3) assert.Equal(t, m3, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) assert.Equal(t, m1, sl.ByPosition(2)) assert.Nil(t, sl.ByPosition(3)) }]}
{Id:4 FileId:133 StartLine:61 StartColumn:1 EndLine:70 EndColumn:2 Name:TestGetByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	assert.Equal(t, m1, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
	assert.Nil(t, sl.ByPosition(2))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) assert.Equal(t, m1, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) assert.Nil(t, sl.ByPosition(2)) }]}
{Id:5 FileId:133 StartLine:72 StartColumn:1 EndLine:89 EndColumn:2 Name:TestSplitAt Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(3)
	m2 := newMockEntry(5)
	m3 := newMockEntry(7)
	sl := New(uint8(0))
	sl.Insert(m1, m2, m3)

	left, right := sl.SplitAt(1)
	assert.Equal(t, uint64(2), left.Len())
	assert.Equal(t, uint64(1), right.Len())
	assert.Equal(t, common.Comparators{m1, m2, nil}, left.Get(m1, m2, m3))
	assert.Equal(t, common.Comparators{nil, nil, m3}, right.Get(m1, m2, m3))
	assert.Equal(t, m1, left.ByPosition(0))
	assert.Equal(t, m2, left.ByPosition(1))
	assert.Equal(t, m3, right.ByPosition(0))
	assert.Equal(t, nil, left.ByPosition(2))
	assert.Equal(t, nil, right.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(3) m2 := newMockEntry(5) m3 := newMockEntry(7) sl := New(uint8(0)) sl.Insert(m1, m2, m3) left, right := sl.SplitAt(1) assert.Equal(t, uint64(2), left.Len()) assert.Equal(t, uint64(1), right.Len()) assert.Equal(t, common.Comparators{m1, m2, nil}, left.Get(m1, m2, m3)) assert.Equal(t, common.Comparators{nil, nil, m3}, right.Get(m1, m2, m3)) assert.Equal(t, m1, left.ByPosition(0)) assert.Equal(t, m2, left.ByPosition(1)) assert.Equal(t, m3, right.ByPosition(0)) assert.Equal(t, nil, left.ByPosition(2)) assert.Equal(t, nil, right.ByPosition(1)) }]}
{Id:6 FileId:133 StartLine:91 StartColumn:1 EndLine:112 EndColumn:2 Name:TestSplitLargeSkipList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(100)
	leftEntries := entries[:50]
	rightEntries := entries[50:]
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(49)
	assert.Equal(t, uint64(50), left.Len())
	for _, le := range leftEntries {
		result, index := left.GetWithPosition(le)
		assert.Equal(t, le, result)
		assert.Equal(t, le, left.ByPosition(index))
	}

	assert.Equal(t, uint64(50), right.Len())
	for _, re := range rightEntries {
		result, index := right.GetWithPosition(re)
		assert.Equal(t, re, result)
		assert.Equal(t, re, right.ByPosition(index))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(100) leftEntries := entries[:50] rightEntries := entries[50:] sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(49) assert.Equal(t, uint64(50), left.Len()) for _, le := range leftEntries { result, index := left.GetWithPosition(le) assert.Equal(t, le, result) assert.Equal(t, le, left.ByPosition(index)) } assert.Equal(t, uint64(50), right.Len()) for _, re := range rightEntries { result, index := right.GetWithPosition(re) assert.Equal(t, re, result) assert.Equal(t, re, right.ByPosition(index)) } }]}
{Id:7 FileId:133 StartLine:114 StartColumn:1 EndLine:135 EndColumn:2 Name:TestSplitLargeSkipListOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(99)
	leftEntries := entries[:50]
	rightEntries := entries[50:]
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(49)
	assert.Equal(t, uint64(50), left.Len())
	for _, le := range leftEntries {
		result, index := left.GetWithPosition(le)
		assert.Equal(t, le, result)
		assert.Equal(t, le, left.ByPosition(index))
	}

	assert.Equal(t, uint64(49), right.Len())
	for _, re := range rightEntries {
		result, index := right.GetWithPosition(re)
		assert.Equal(t, re, result)
		assert.Equal(t, re, right.ByPosition(index))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(99) leftEntries := entries[:50] rightEntries := entries[50:] sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(49) assert.Equal(t, uint64(50), left.Len()) for _, le := range leftEntries { result, index := left.GetWithPosition(le) assert.Equal(t, le, result) assert.Equal(t, le, left.ByPosition(index)) } assert.Equal(t, uint64(49), right.Len()) for _, re := range rightEntries { result, index := right.GetWithPosition(re) assert.Equal(t, re, result) assert.Equal(t, re, right.ByPosition(index)) } }]}
{Id:8 FileId:133 StartLine:137 StartColumn:1 EndLine:145 EndColumn:2 Name:TestSplitAtSkipListLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(5)
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(4)
	assert.Equal(t, sl, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ entries := generateMockEntries(5) sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(4) assert.Equal(t, sl, left) assert.Nil(t, right) }]}
{Id:9 FileId:133 StartLine:147 StartColumn:1 EndLine:160 EndColumn:2 Name:TestGetWithPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	e, pos := sl.GetWithPosition(m1)
	assert.Equal(t, m1, e)
	assert.Equal(t, uint64(0), pos)

	e, pos = sl.GetWithPosition(m2)
	assert.Equal(t, m2, e)
	assert.Equal(t, uint64(1), pos)
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) e, pos := sl.GetWithPosition(m1) assert.Equal(t, m1, e) assert.Equal(t, uint64(0), pos) e, pos = sl.GetWithPosition(m2) assert.Equal(t, m2, e) assert.Equal(t, uint64(1), pos) }]}
{Id:10 FileId:133 StartLine:162 StartColumn:1 EndLine:172 EndColumn:2 Name:TestReplaceAtPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))

	sl.Insert(m1, m2)
	m3 := newMockEntry(9)
	sl.ReplaceAtPosition(0, m3)
	assert.Equal(t, m3, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) m3 := newMockEntry(9) sl.ReplaceAtPosition(0, m3) assert.Equal(t, m3, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) }]}
{Id:11 FileId:133 StartLine:174 StartColumn:1 EndLine:183 EndColumn:2 Name:TestInsertRandomGetByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateRandomMockEntries(100)
	sl := New(uint64(0))
	sl.Insert(entries...)

	for _, e := range entries {
		_, pos := sl.GetWithPosition(e)
		assert.Equal(t, e, sl.ByPosition(pos))
	}
} PrettyPrintBody:[{ entries := generateRandomMockEntries(100) sl := New(uint64(0)) sl.Insert(entries...) for _, e := range entries { _, pos := sl.GetWithPosition(e) assert.Equal(t, e, sl.ByPosition(pos)) } }]}
{Id:12 FileId:133 StartLine:185 StartColumn:1 EndLine:193 EndColumn:2 Name:TestGetManyByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(10)
	sl := New(uint64(0))
	sl.Insert(entries...)

	for i, e := range entries {
		assert.Equal(t, e, sl.ByPosition(uint64(i)))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(10) sl := New(uint64(0)) sl.Insert(entries...) for i, e := range entries { assert.Equal(t, e, sl.ByPosition(uint64(i))) } }]}
{Id:13 FileId:133 StartLine:195 StartColumn:1 EndLine:208 EndColumn:2 Name:TestGetPositionAfterDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	sl.Delete(m1)
	assert.Equal(t, m2, sl.ByPosition(0))
	assert.Nil(t, sl.ByPosition(1))

	sl.Delete(m2)
	assert.Nil(t, sl.ByPosition(0))
	assert.Nil(t, sl.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) sl.Delete(m1) assert.Equal(t, m2, sl.ByPosition(0)) assert.Nil(t, sl.ByPosition(1)) sl.Delete(m2) assert.Nil(t, sl.ByPosition(0)) assert.Nil(t, sl.ByPosition(1)) }]}
{Id:14 FileId:133 StartLine:210 StartColumn:1 EndLine:224 EndColumn:2 Name:TestGetPositionBulkDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := generateMockEntries(20)
	e1 := es[:10]
	e2 := es[10:]
	sl := New(uint64(0))
	sl.Insert(e1...)
	sl.Insert(e2...)

	for _, e := range e1 {
		sl.Delete(e)
	}
	for i, e := range e2 {
		assert.Equal(t, e, sl.ByPosition(uint64(i)))
	}
} PrettyPrintBody:[{ es := generateMockEntries(20) e1 := es[:10] e2 := es[10:] sl := New(uint64(0)) sl.Insert(e1...) sl.Insert(e2...) for _, e := range e1 { sl.Delete(e) } for i, e := range e2 { assert.Equal(t, e, sl.ByPosition(uint64(i))) } }]}
{Id:15 FileId:133 StartLine:226 StartColumn:1 EndLine:243 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1)
	assert.Equal(t, common.Comparators{m1}, sl.Get(m1))
	assert.Equal(t, uint64(1), sl.Len())
	assert.Equal(t, common.Comparators{nil}, overwritten)
	assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(1)))

	overwritten = sl.Insert(m2)
	assert.Equal(t, common.Comparators{m2}, sl.Get(m2))
	assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(7)))
	assert.Equal(t, uint64(2), sl.Len())
	assert.Equal(t, common.Comparators{nil}, overwritten)
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) overwritten := sl.Insert(m1) assert.Equal(t, common.Comparators{m1}, sl.Get(m1)) assert.Equal(t, uint64(1), sl.Len()) assert.Equal(t, common.Comparators{nil}, overwritten) assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(1))) overwritten = sl.Insert(m2) assert.Equal(t, common.Comparators{m2}, sl.Get(m2)) assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(7))) assert.Equal(t, uint64(2), sl.Len()) assert.Equal(t, common.Comparators{nil}, overwritten) }]}
{Id:16 FileId:133 StartLine:245 StartColumn:1 EndLine:258 EndColumn:2 Name:TestSimpleOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(5)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1)
	assert.Equal(t, common.Comparators{nil}, overwritten)
	assert.Equal(t, uint64(1), sl.Len())

	overwritten = sl.Insert(m2)
	assert.Equal(t, common.Comparators{m1}, overwritten)
	assert.Equal(t, uint64(1), sl.Len())
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(5) sl := New(uint8(0)) overwritten := sl.Insert(m1) assert.Equal(t, common.Comparators{nil}, overwritten) assert.Equal(t, uint64(1), sl.Len()) overwritten = sl.Insert(m2) assert.Equal(t, common.Comparators{m1}, overwritten) assert.Equal(t, uint64(1), sl.Len()) }]}
{Id:17 FileId:133 StartLine:260 StartColumn:1 EndLine:270 EndColumn:2 Name:TestInsertOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(6)
	m2 := newMockEntry(5)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1, m2)
	assert.Equal(t, common.Comparators{nil, nil}, overwritten)

	assert.Equal(t, common.Comparators{m1, m2}, sl.Get(m1, m2))
} PrettyPrintBody:[{ m1 := newMockEntry(6) m2 := newMockEntry(5) sl := New(uint8(0)) overwritten := sl.Insert(m1, m2) assert.Equal(t, common.Comparators{nil, nil}, overwritten) assert.Equal(t, common.Comparators{m1, m2}, sl.Get(m1, m2)) }]}
{Id:18 FileId:133 StartLine:272 StartColumn:1 EndLine:284 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	sl := New(uint8(0))
	sl.Insert(m1)

	deleted := sl.Delete(m1)
	assert.Equal(t, common.Comparators{m1}, deleted)
	assert.Equal(t, uint64(0), sl.Len())
	assert.Equal(t, common.Comparators{nil}, sl.Get(m1))

	deleted = sl.Delete(m1)
	assert.Equal(t, common.Comparators{nil}, deleted)
} PrettyPrintBody:[{ m1 := newMockEntry(5) sl := New(uint8(0)) sl.Insert(m1) deleted := sl.Delete(m1) assert.Equal(t, common.Comparators{m1}, deleted) assert.Equal(t, uint64(0), sl.Len()) assert.Equal(t, common.Comparators{nil}, sl.Get(m1)) deleted = sl.Delete(m1) assert.Equal(t, common.Comparators{nil}, deleted) }]}
{Id:19 FileId:133 StartLine:286 StartColumn:1 EndLine:296 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	deleted := sl.Delete(m1, m2)
	assert.Equal(t, common.Comparators{m1, m2}, deleted)
	assert.Equal(t, uint64(0), sl.Len())
	assert.Equal(t, common.Comparators{nil, nil}, sl.Get(m1, m2))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) deleted := sl.Delete(m1, m2) assert.Equal(t, common.Comparators{m1, m2}, deleted) assert.Equal(t, uint64(0), sl.Len()) assert.Equal(t, common.Comparators{nil, nil}, sl.Get(m1, m2)) }]}
{Id:20 FileId:133 StartLine:298 StartColumn:1 EndLine:319 EndColumn:2 Name:TestIter Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sl := New(uint8(0))
	m1 := newMockEntry(5)
	m2 := newMockEntry(10)

	sl.Insert(m1, m2)

	iter := sl.Iter(mockEntry(0))
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(5))
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(6))
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(10))
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(11))
	assert.Equal(t, common.Comparators{}, iter.exhaust())
} PrettyPrintBody:[{ sl := New(uint8(0)) m1 := newMockEntry(5) m2 := newMockEntry(10) sl.Insert(m1, m2) iter := sl.Iter(mockEntry(0)) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.Iter(mockEntry(5)) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.Iter(mockEntry(6)) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.Iter(mockEntry(10)) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.Iter(mockEntry(11)) assert.Equal(t, common.Comparators{}, iter.exhaust()) }]}
{Id:21 FileId:133 StartLine:321 StartColumn:1 EndLine:336 EndColumn:2 Name:TestIterAtPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sl := New(uint8(0))
	m1 := newMockEntry(5)
	m2 := newMockEntry(10)

	sl.Insert(m1, m2)

	iter := sl.IterAtPosition(0)
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.IterAtPosition(1)
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.IterAtPosition(2)
	assert.Equal(t, common.Comparators{}, iter.exhaust())
} PrettyPrintBody:[{ sl := New(uint8(0)) m1 := newMockEntry(5) m2 := newMockEntry(10) sl.Insert(m1, m2) iter := sl.IterAtPosition(0) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.IterAtPosition(1) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.IterAtPosition(2) assert.Equal(t, common.Comparators{}, iter.exhaust()) }]}
{Id:22 FileId:133 StartLine:338 StartColumn:1 EndLine:349 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(entries[i%numItems]) } }]}
{Id:23 FileId:133 StartLine:351 StartColumn:1 EndLine:363 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Get(entries[i%numItems]) } }]}
{Id:24 FileId:133 StartLine:365 StartColumn:1 EndLine:377 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Delete(entries[i])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Delete(entries[i]) } }]}
{Id:25 FileId:133 StartLine:379 StartColumn:1 EndLine:395 EndColumn:2 Name:BenchmarkPrepend Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := make(common.Comparators, 0, numItems)
	for i := b.N; i < b.N+numItems; i++ {
		entries = append(entries, newMockEntry(uint64(i)))
	}

	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(newMockEntry(uint64(i)))
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := make(common.Comparators, 0, numItems) for i := b.N; i < b.N+numItems; i++ { entries = append(entries, newMockEntry(uint64(i))) } sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(newMockEntry(uint64(i))) } }]}
{Id:26 FileId:133 StartLine:397 StartColumn:1 EndLine:408 EndColumn:2 Name:BenchmarkByPosition Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))
	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.ByPosition(uint64(i % numItems))
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.ByPosition(uint64(i % numItems)) } }]}
{Id:27 FileId:133 StartLine:410 StartColumn:1 EndLine:420 EndColumn:2 Name:BenchmarkInsertAtPosition Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))
	entries := generateRandomMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.InsertAtPosition(0, entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateRandomMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.InsertAtPosition(0, entries[i%numItems]) } }]}
{Id:1 FileId:142 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:generateMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	entries := make(Entries, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, mockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, num) for i := 0; i < num; i++ { entries = append(entries, mockEntry(i)) } return entries }]}
{Id:2 FileId:142 StartLine:34 StartColumn:1 EndLine:54 EndColumn:2 Name:TestAVLSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(5)
	m2 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), i2.Len())
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, Entries{nil, nil}, i1.Get(m1, m2))
	assert.Equal(t, Entries{m1, m2}, i2.Get(m1, m2))

	m3 := mockEntry(1)

	i3, overwritten := i2.Insert(m3)
	assert.Equal(t, Entries{nil}, overwritten)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, uint64(2), i2.Len())
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(5) m2 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), i2.Len()) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, Entries{nil, nil}, i1.Get(m1, m2)) assert.Equal(t, Entries{m1, m2}, i2.Get(m1, m2)) m3 := mockEntry(1) i3, overwritten := i2.Insert(m3) assert.Equal(t, Entries{nil}, overwritten) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, uint64(2), i2.Len()) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3)) }]}
{Id:3 FileId:142 StartLine:56 StartColumn:1 EndLine:78 EndColumn:2 Name:TestAVLInsertRightLeaning Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))

	m4 := mockEntry(15)
	m5 := mockEntry(20)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) m4 := mockEntry(15) m5 := mockEntry(20) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]}
{Id:4 FileId:142 StartLine:80 StartColumn:1 EndLine:101 EndColumn:2 Name:TestAVLInsertRightLeaningDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(10)
	m3 := mockEntry(5)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(20)
	m5 := mockEntry(15)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(10) m3 := mockEntry(5) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(20) m5 := mockEntry(15) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]}
{Id:5 FileId:142 StartLine:103 StartColumn:1 EndLine:125 EndColumn:2 Name:TestAVLInsertLeftLeaning Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(15)
	m3 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(5)
	m5 := mockEntry(1)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(15) m3 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(5) m5 := mockEntry(1) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]}
{Id:6 FileId:142 StartLine:127 StartColumn:1 EndLine:150 EndColumn:2 Name:TestAVLInsertLeftLeaningDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(10)
	m3 := mockEntry(15)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(1)
	m5 := mockEntry(5)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
	assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(10) m3 := mockEntry(15) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(1) m5 := mockEntry(5) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3)) }]}
{Id:7 FileId:142 StartLine:152 StartColumn:1 EndLine:167 EndColumn:2 Name:TestAVLInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(10)
	m3 := mockEntry(15)

	i2, _ := i1.Insert(m1, m2, m3)
	m4 := mockEntry(15)

	i3, overwritten := i2.Insert(m4)
	assert.Equal(t, Entries{m3}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m4}, i3.Get(m4))
	assert.Equal(t, Entries{m3}, i2.Get(m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(10) m3 := mockEntry(15) i2, _ := i1.Insert(m1, m2, m3) m4 := mockEntry(15) i3, overwritten := i2.Insert(m4) assert.Equal(t, Entries{m3}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m4}, i3.Get(m4)) assert.Equal(t, Entries{m3}, i2.Get(m3)) }]}
{Id:8 FileId:142 StartLine:169 StartColumn:1 EndLine:197 EndColumn:2 Name:TestAVLSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(10)
	m2 := mockEntry(15)
	m3 := mockEntry(20)

	i2, _ := i1.Insert(m1, m2, m3)

	i3, deleted := i2.Delete(m3)
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(2), i3.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3))

	i4, deleted := i3.Delete(m2)
	assert.Equal(t, Entries{m2}, deleted)
	assert.Equal(t, uint64(2), i3.Len())
	assert.Equal(t, uint64(1), i4.Len())
	assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3))

	i5, deleted := i4.Delete(m1)
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, uint64(0), i5.Len())
	assert.Equal(t, uint64(1), i4.Len())
	assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3))
	assert.Equal(t, Entries{nil, nil, nil}, i5.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(10) m2 := mockEntry(15) m3 := mockEntry(20) i2, _ := i1.Insert(m1, m2, m3) i3, deleted := i2.Delete(m3) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(2), i3.Len()) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3)) i4, deleted := i3.Delete(m2) assert.Equal(t, Entries{m2}, deleted) assert.Equal(t, uint64(2), i3.Len()) assert.Equal(t, uint64(1), i4.Len()) assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3)) i5, deleted := i4.Delete(m1) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, uint64(0), i5.Len()) assert.Equal(t, uint64(1), i4.Len()) assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3)) assert.Equal(t, Entries{nil, nil, nil}, i5.Get(m1, m2, m3)) }]}
{Id:9 FileId:142 StartLine:199 StartColumn:1 EndLine:215 EndColumn:2 Name:TestAVLDeleteWithRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)
	m5 := mockEntry(20)

	i2, _ := i1.Insert(m1, m2, m3, m4, m5)
	assert.Equal(t, uint64(5), i2.Len())

	i3, deleted := i2.Delete(m1)
	assert.Equal(t, uint64(4), i3.Len())
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, Entries{m1, m2, m3, m4, m5}, i2.Get(m1, m2, m3, m4, m5))
	assert.Equal(t, Entries{nil, m2, m3, m4, m5}, i3.Get(m1, m2, m3, m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) m5 := mockEntry(20) i2, _ := i1.Insert(m1, m2, m3, m4, m5) assert.Equal(t, uint64(5), i2.Len()) i3, deleted := i2.Delete(m1) assert.Equal(t, uint64(4), i3.Len()) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, Entries{m1, m2, m3, m4, m5}, i2.Get(m1, m2, m3, m4, m5)) assert.Equal(t, Entries{nil, m2, m3, m4, m5}, i3.Get(m1, m2, m3, m4, m5)) }]}
{Id:10 FileId:142 StartLine:217 StartColumn:1 EndLine:232 EndColumn:2 Name:TestAVLDeleteWithDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted := i2.Delete(m1)
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4))
	assert.Equal(t, Entries{nil, m2, m3, m4}, i3.Get(m1, m2, m3, m4))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) assert.Equal(t, uint64(4), i2.Len()) i3, deleted := i2.Delete(m1) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4)) assert.Equal(t, Entries{nil, m2, m3, m4}, i3.Get(m1, m2, m3, m4)) }]}
{Id:11 FileId:142 StartLine:234 StartColumn:1 EndLine:249 EndColumn:2 Name:TestAVLDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted := i2.Delete(m1, m2, m3, m4)
	assert.Equal(t, Entries{m1, m2, m3, m4}, deleted)
	assert.Equal(t, uint64(0), i3.Len())
	assert.Equal(t, Entries{nil, nil, nil, nil}, i3.Get(m1, m2, m3, m4))
	assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) assert.Equal(t, uint64(4), i2.Len()) i3, deleted := i2.Delete(m1, m2, m3, m4) assert.Equal(t, Entries{m1, m2, m3, m4}, deleted) assert.Equal(t, uint64(0), i3.Len()) assert.Equal(t, Entries{nil, nil, nil, nil}, i3.Get(m1, m2, m3, m4)) assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4)) }]}
{Id:12 FileId:142 StartLine:251 StartColumn:1 EndLine:262 EndColumn:2 Name:TestAVLDeleteNotLeaf Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	i3, deleted := i2.Delete(m3)
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(3), i3.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) i3, deleted := i2.Delete(m3) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(3), i3.Len()) }]}
{Id:13 FileId:142 StartLine:264 StartColumn:1 EndLine:276 EndColumn:2 Name:TestAVLBulkDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	entries := generateMockEntries(5)
	i2, _ := i1.Insert(entries...)

	i3, deleted := i2.Delete(entries...)
	assert.Equal(t, entries, deleted)
	assert.Equal(t, uint64(0), i3.Len())

	i3, deleted = i2.Delete(entries...)
	assert.Equal(t, entries, deleted)
	assert.Equal(t, uint64(0), i3.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() entries := generateMockEntries(5) i2, _ := i1.Insert(entries...) i3, deleted := i2.Delete(entries...) assert.Equal(t, entries, deleted) assert.Equal(t, uint64(0), i3.Len()) i3, deleted = i2.Delete(entries...) assert.Equal(t, entries, deleted) assert.Equal(t, uint64(0), i3.Len()) }]}
{Id:14 FileId:142 StartLine:278 StartColumn:1 EndLine:296 EndColumn:2 Name:TestAVLDeleteReplay Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)

	i3, deleted := i2.Delete(m3)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted = i2.Delete(m3)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(4), i2.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) i3, deleted := i2.Delete(m3) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(4), i2.Len()) i3, deleted = i2.Delete(m3) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(4), i2.Len()) }]}
{Id:15 FileId:142 StartLine:298 StartColumn:1 EndLine:319 EndColumn:2 Name:TestAVLFails Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := []mockEntry{
		mockEntry(0),
		mockEntry(1),
		mockEntry(3),
		mockEntry(4),
		mockEntry(5),
		mockEntry(6),
		mockEntry(7),
		mockEntry(2),
	}
	i1 := NewImmutable()
	for _, k := range keys {
		i1, _ = i1.Insert(k)
	}

	for _, k := range keys {
		var deleted Entries
		i1, deleted = i1.Delete(k)
		assert.Equal(t, Entries{k}, deleted)
	}
} PrettyPrintBody:[{ keys := []mockEntry{ mockEntry(0), mockEntry(1), mockEntry(3), mockEntry(4), mockEntry(5), mockEntry(6), mockEntry(7), mockEntry(2), } i1 := NewImmutable() for _, k := range keys { i1, _ = i1.Insert(k) } for _, k := range keys { var deleted Entries i1, deleted = i1.Delete(k) assert.Equal(t, Entries{k}, deleted) } }]}
{Id:16 FileId:142 StartLine:321 StartColumn:1 EndLine:333 EndColumn:2 Name:BenchmarkImmutableInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl, _ = sl.Insert(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl, _ = sl.Insert(entries[i%numItems]) } }]}
{Id:17 FileId:142 StartLine:335 StartColumn:1 EndLine:347 EndColumn:2 Name:BenchmarkImmutableGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Get(entries[i%numItems]) } }]}
{Id:18 FileId:142 StartLine:349 StartColumn:1 EndLine:360 EndColumn:2 Name:BenchmarkImmutableBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(entries...)
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(entries...) } }]}
{Id:19 FileId:142 StartLine:362 StartColumn:1 EndLine:374 EndColumn:2 Name:BenchmarkImmutableDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl, _ = sl.Delete(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl, _ = sl.Delete(entries[i%numItems]) } }]}
{Id:20 FileId:142 StartLine:376 StartColumn:1 EndLine:388 EndColumn:2 Name:BenchmarkImmutableBulkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Delete(entries...)
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Delete(entries...) } }]}
{Id:1 FileId:114 StartLine:29 StartColumn:1 EndLine:36 EndColumn:2 Name:generateMultiDimensionalEntries Params:[{Name:num Type:int}] Results:[{Name: Type:rangetree.Entries}] Receiver:<nil> Body:{
	entries := make(rangetree.Entries, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, newMockEntry(int64(i), int64(i)))
	}

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, num) for i := 0; i < num; i++ { entries = append(entries, newMockEntry(int64(i), int64(i))) } return entries }]}
{Id:2 FileId:114 StartLine:38 StartColumn:1 EndLine:46 EndColumn:2 Name:generateRandomMultiDimensionalEntries Params:[{Name:num Type:int}] Results:[{Name: Type:rangetree.Entries}] Receiver:<nil> Body:{
	entries := make(rangetree.Entries, 0, num)
	for i := 0; i < num; i++ {
		value := rand.Int63()
		entries = append(entries, newMockEntry(value, value))
	}

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, num) for i := 0; i < num; i++ { value := rand.Int63() entries = append(entries, newMockEntry(value, value)) } return entries }]}
{Id:3 FileId:114 StartLine:48 StartColumn:1 EndLine:57 EndColumn:2 Name:TestRTSingleDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(5)

	overwritten := rt.Add(m1, m2)
	assert.Equal(t, rangetree.Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(5) overwritten := rt.Add(m1, m2) assert.Equal(t, rangetree.Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2)) }]}
{Id:4 FileId:114 StartLine:59 StartColumn:1 EndLine:68 EndColumn:2 Name:TestRTMultiDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 5)
	m2 := newMockEntry(4, 6)

	overwritten := rt.Add(m1, m2)
	assert.Equal(t, rangetree.Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 5) m2 := newMockEntry(4, 6) overwritten := rt.Add(m1, m2) assert.Equal(t, rangetree.Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2)) }]}
{Id:5 FileId:114 StartLine:70 StartColumn:1 EndLine:83 EndColumn:2 Name:TestRTSingleDimensionOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(5)
	m2 := newMockEntry(5)

	overwritten := rt.Add(m1)
	assert.Equal(t, rangetree.Entries{nil}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())

	overwritten = rt.Add(m2)
	assert.Equal(t, rangetree.Entries{m1}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())
	assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(5) m2 := newMockEntry(5) overwritten := rt.Add(m1) assert.Equal(t, rangetree.Entries{nil}, overwritten) assert.Equal(t, uint64(1), rt.Len()) overwritten = rt.Add(m2) assert.Equal(t, rangetree.Entries{m1}, overwritten) assert.Equal(t, uint64(1), rt.Len()) assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2)) }]}
{Id:6 FileId:114 StartLine:85 StartColumn:1 EndLine:98 EndColumn:2 Name:TestRTMultiDimensionOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(5, 6)
	m2 := newMockEntry(5, 6)

	overwritten := rt.Add(m1)
	assert.Equal(t, rangetree.Entries{nil}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())

	overwritten = rt.Add(m2)
	assert.Equal(t, rangetree.Entries{m1}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())
	assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(5, 6) m2 := newMockEntry(5, 6) overwritten := rt.Add(m1) assert.Equal(t, rangetree.Entries{nil}, overwritten) assert.Equal(t, uint64(1), rt.Len()) overwritten = rt.Add(m2) assert.Equal(t, rangetree.Entries{m1}, overwritten) assert.Equal(t, uint64(1), rt.Len()) assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2)) }]}
{Id:7 FileId:114 StartLine:100 StartColumn:1 EndLine:110 EndColumn:2 Name:TestRTSingleDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(5)
	m2 := newMockEntry(2)
	rt.Add(m1, m2)

	deleted := rt.Delete(m1, newMockEntry(10), m2)
	assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted)
	assert.Equal(t, uint64(0), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(5) m2 := newMockEntry(2) rt.Add(m1, m2) deleted := rt.Delete(m1, newMockEntry(10), m2) assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted) assert.Equal(t, uint64(0), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2)) }]}
{Id:8 FileId:114 StartLine:112 StartColumn:1 EndLine:122 EndColumn:2 Name:TestRTMultiDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 5)
	m2 := newMockEntry(4, 6)
	rt.Add(m1, m2)

	deleted := rt.Delete(m1, newMockEntry(10, 10), m2)
	assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted)
	assert.Equal(t, uint64(0), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 5) m2 := newMockEntry(4, 6) rt.Add(m1, m2) deleted := rt.Delete(m1, newMockEntry(10, 10), m2) assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted) assert.Equal(t, uint64(0), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2)) }]}
{Id:9 FileId:114 StartLine:124 StartColumn:1 EndLine:145 EndColumn:2 Name:TestRTSingleDimensionQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	result := rt.Query(newMockInterval([]int64{1}, []int64{7}))
	assert.Equal(t, rangetree.Entries{m1, m2}, result)

	result = rt.Query(newMockInterval([]int64{6}, []int64{10}))
	assert.Equal(t, rangetree.Entries{m2, m3}, result)

	result = rt.Query(newMockInterval([]int64{9}, []int64{11}))
	assert.Equal(t, rangetree.Entries{m3}, result)

	result = rt.Query(newMockInterval([]int64{0}, []int64{3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{10}, []int64{13}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) result := rt.Query(newMockInterval([]int64{1}, []int64{7})) assert.Equal(t, rangetree.Entries{m1, m2}, result) result = rt.Query(newMockInterval([]int64{6}, []int64{10})) assert.Equal(t, rangetree.Entries{m2, m3}, result) result = rt.Query(newMockInterval([]int64{9}, []int64{11})) assert.Equal(t, rangetree.Entries{m3}, result) result = rt.Query(newMockInterval([]int64{0}, []int64{3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{10}, []int64{13})) assert.Len(t, result, 0) }]}
{Id:10 FileId:114 StartLine:147 StartColumn:1 EndLine:177 EndColumn:2 Name:TestRTMultiDimensionQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	result := rt.Query(newMockInterval([]int64{1, 1}, []int64{7, 7}))
	assert.Equal(t, rangetree.Entries{m1, m2}, result)

	result = rt.Query(newMockInterval([]int64{6, 6}, []int64{10, 10}))
	assert.Equal(t, rangetree.Entries{m2, m3}, result)

	result = rt.Query(newMockInterval([]int64{9, 9}, []int64{11, 11}))
	assert.Equal(t, rangetree.Entries{m3}, result)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{10, 10}, []int64{13, 13}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{6, 1}, []int64{7, 6}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{7, 4}))
	assert.Equal(t, rangetree.Entries{m1}, result)
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) result := rt.Query(newMockInterval([]int64{1, 1}, []int64{7, 7})) assert.Equal(t, rangetree.Entries{m1, m2}, result) result = rt.Query(newMockInterval([]int64{6, 6}, []int64{10, 10})) assert.Equal(t, rangetree.Entries{m2, m3}, result) result = rt.Query(newMockInterval([]int64{9, 9}, []int64{11, 11})) assert.Equal(t, rangetree.Entries{m3}, result) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{10, 10}, []int64{13, 13})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{6, 1}, []int64{7, 6})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{7, 4})) assert.Equal(t, rangetree.Entries{m1}, result) }]}
{Id:11 FileId:114 StartLine:179 StartColumn:1 EndLine:195 EndColumn:2 Name:TestRTSingleDimensionInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 0, 1)
	assert.Equal(t, rangetree.Entries{m1, m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil, nil}, rt.Get(m1, m2, m3))
	e1 := newMockEntry(4)
	e2 := newMockEntry(7)
	e3 := newMockEntry(10)
	assert.Equal(t, rangetree.Entries{m1, m2, m3}, rt.Get(e1, e2, e3))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 0, 1) assert.Equal(t, rangetree.Entries{m1, m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil, nil}, rt.Get(m1, m2, m3)) e1 := newMockEntry(4) e2 := newMockEntry(7) e3 := newMockEntry(10) assert.Equal(t, rangetree.Entries{m1, m2, m3}, rt.Get(e1, e2, e3)) }]}
{Id:12 FileId:114 StartLine:197 StartColumn:1 EndLine:213 EndColumn:2 Name:TestRTSingleDimensionInsertNegative Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil}, rt.Get(m1, m2))

	e2 := newMockEntry(4)
	e3 := newMockEntry(7)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil}, rt.Get(m1, m2)) e2 := newMockEntry(4) e3 := newMockEntry(7) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]}
{Id:13 FileId:114 StartLine:215 StartColumn:1 EndLine:231 EndColumn:2 Name:TestRTMultiDimensionInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(1, 4, 2)
	assert.Equal(t, rangetree.Entries{m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())

	e2 := newMockEntry(6, 8)
	e3 := newMockEntry(9, 11)
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))
	assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(1, 4, 2) assert.Equal(t, rangetree.Entries{m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) e2 := newMockEntry(6, 8) e3 := newMockEntry(9, 11) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3)) }]}
{Id:14 FileId:114 StartLine:233 StartColumn:1 EndLine:249 EndColumn:2 Name:TestRTMultiDimensionInsertNegative Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(1, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(6, 4)
	e3 := newMockEntry(9, 7)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(1, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(6, 4) e3 := newMockEntry(9, 7) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]}
{Id:15 FileId:114 StartLine:251 StartColumn:1 EndLine:267 EndColumn:2 Name:TestRTInsertInZeroDimensionMultiDimensionList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 4, 2)
	assert.Equal(t, rangetree.Entries{m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(8, 6)
	e3 := newMockEntry(11, 9)
	assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 4, 2) assert.Equal(t, rangetree.Entries{m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(8, 6) e3 := newMockEntry(11, 9) assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3)) }]}
{Id:16 FileId:114 StartLine:269 StartColumn:1 EndLine:285 EndColumn:2 Name:TestRTInsertNegativeInZeroDimensionMultiDimensionList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(4, 6)
	e3 := newMockEntry(7, 9)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(4, 6) e3 := newMockEntry(7, 9) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]}
{Id:17 FileId:114 StartLine:287 StartColumn:1 EndLine:296 EndColumn:2 Name:TestRTInsertBeyondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	rt.Add(m1)

	affected, deleted := rt.InsertAtDimension(4, 0, 1)
	assert.Len(t, affected, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) rt.Add(m1) affected, deleted := rt.InsertAtDimension(4, 0, 1) assert.Len(t, affected, 0) assert.Len(t, deleted, 0) assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1)) }]}
{Id:18 FileId:114 StartLine:298 StartColumn:1 EndLine:307 EndColumn:2 Name:TestRTInsertZero Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	rt.Add(m1)

	affected, deleted := rt.InsertAtDimension(1, 0, 0)
	assert.Len(t, affected, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) rt.Add(m1) affected, deleted := rt.InsertAtDimension(1, 0, 0) assert.Len(t, affected, 0) assert.Len(t, deleted, 0) assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1)) }]}
{Id:19 FileId:114 StartLine:309 StartColumn:1 EndLine:319 EndColumn:2 Name:BenchmarkMultiDimensionInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]}
{Id:20 FileId:114 StartLine:321 StartColumn:1 EndLine:332 EndColumn:2 Name:BenchmarkMultiDimensionInsertReverse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		index := numItems - (i % numItems) - 1
		rt.Add(entries[index])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { index := numItems - (i % numItems) - 1 rt.Add(entries[index]) } }]}
{Id:21 FileId:114 StartLine:334 StartColumn:1 EndLine:344 EndColumn:2 Name:BenchmarkMultiDimensionRandomInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]}
{Id:22 FileId:114 StartLine:346 StartColumn:1 EndLine:357 EndColumn:2 Name:BenchmarkMultiDimensionalGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Get(entries[i%numItems]) } }]}
{Id:23 FileId:114 StartLine:359 StartColumn:1 EndLine:370 EndColumn:2 Name:BenchmarkMultiDimensionDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Delete(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Delete(entries[i%numItems]) } }]}
{Id:24 FileId:114 StartLine:372 StartColumn:1 EndLine:387 EndColumn:2 Name:BenchmarkMultiDimensionQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)
	iv := newMockInterval([]int64{0, 0}, []int64{math.MaxInt64, math.MaxInt64})
	var result rangetree.Entries

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		result = rt.Query(iv)
	}

	assert.Len(b, result, numItems)
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) iv := newMockInterval([]int64{0, 0}, []int64{math.MaxInt64, math.MaxInt64}) var result rangetree.Entries b.ResetTimer() for i := 0; i < b.N; i++ { result = rt.Query(iv) } assert.Len(b, result, numItems) }]}
{Id:25 FileId:114 StartLine:389 StartColumn:1 EndLine:400 EndColumn:2 Name:BenchmarkMultiDimensionInsertAtZeroDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.InsertAtDimension(0, 0, 1)
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.InsertAtDimension(0, 0, 1) } }]}
{Id:26 FileId:114 StartLine:402 StartColumn:1 EndLine:413 EndColumn:2 Name:BenchmarkMultiDimensionInsertNegativeAtZeroDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.InsertAtDimension(0, 0, -1)
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.InsertAtDimension(0, 0, -1) } }]}
{Id:1 FileId:2 StartLine:25 StartColumn:1 EndLine:39 EndColumn:2 Name:min Params:[{Name:one Type:int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	if one == -1 {
		return two
	}

	if two == -1 {
		return one
	}

	if one > two {
		return two
	}

	return one
} PrettyPrintBody:[{ if one == -1 { return two } if two == -1 { return one } if one > two { return two } return one }]}
{Id:2 FileId:2 StartLine:41 StartColumn:1 EndLine:55 EndColumn:2 Name:max Params:[{Name:one Type:int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	if one == -1 {
		return two
	}

	if two == -1 {
		return one
	}

	if one > two {
		return one
	}

	return two
} PrettyPrintBody:[{ if one == -1 { return two } if two == -1 { return one } if one > two { return one } return two }]}
{Id:3 FileId:2 StartLine:57 StartColumn:1 EndLine:113 EndColumn:2 Name:checkRedBlack Params:[{Name:tb Type:testing.TB} {Name:node Type:*node} {Name:dimension Type:int}] Results:[{Name: Type:int64} {Name: Type:int64} {Name: Type:int64}] Receiver:<nil> Body:{
	lh, rh := 0, 0
	if node == nil {
		return 1, -1, -1
	}

	if isRed(node) {
		if isRed(node.children[0]) || isRed(node.children[1]) {
			tb.Errorf(`Node is red and has red children: %+v`, node)
		}
	}

	fn := func(min, max int64) {
		if min != -1 && min < node.min {
			tb.Errorf(`Min not set correctly: %+v, node: %+v`, min, node)
		}

		if max != -1 && max > node.max {
			tb.Errorf(`Max not set correctly: %+v, node: %+v`, max, node)
		}
	}

	left, minL, maxL := checkRedBlack(tb, node.children[0], dimension)
	fn(minL, maxL)
	right, minR, maxR := checkRedBlack(tb, node.children[1], dimension)
	fn(minR, maxR)

	min := min(minL, minR)
	if min == -1 && node.min != node.interval.LowAtDimension(1) {
		tb.Errorf(`Min not set correctly, node: %+v`, node)
	} else if min != -1 && node.children[0] != nil && node.children[0].min != node.min {
		tb.Errorf(`Min not set correctly: node: %+v, child: %+v`, node, node.children[0])
	} else if min != -1 && node.children[0] == nil && node.min != node.interval.LowAtDimension(1) {
		tb.Errorf(`Min not set correctly: %+v`, node)
	}

	max := max(maxL, maxR)
	if max == -1 && node.max != node.interval.HighAtDimension(1) {
		tb.Errorf(`Max not set correctly, node: %+v`, node)
	} else if max > node.interval.HighAtDimension(1) && max != node.max {
		tb.Errorf(`Max not set correctly, max: %+v, node: %+v`, max, node)
	}

	if left != 0 && right != 0 && lh != rh {
		tb.Errorf(`Black violation: left: %d, right: %d`, left, right)
	}

	if left != 0 && right != 0 {
		if isRed(node) {
			return left, node.min, node.max
		}

		return left + 1, node.min, node.max
	}

	return 0, node.min, node.max
} PrettyPrintBody:[{ lh, rh := 0, 0 if node == nil { return 1, -1, -1 } if isRed(node) { if isRed(node.children[0]) || isRed(node.children[1]) { tb.Errorf(`Node is red and has red children: %+v`, node) } } fn := func(min, max int64) { if min != -1 && min < node.min { tb.Errorf(`Min not set correctly: %+v, node: %+v`, min, node) } if max != -1 && max > node.max { tb.Errorf(`Max not set correctly: %+v, node: %+v`, max, node) } } left, minL, maxL := checkRedBlack(tb, node.children[0], dimension) fn(minL, maxL) right, minR, maxR := checkRedBlack(tb, node.children[1], dimension) fn(minR, maxR) min := min(minL, minR) if min == -1 && node.min != node.interval.LowAtDimension(1) { tb.Errorf(`Min not set correctly, node: %+v`, node) } else if min != -1 && node.children[0] != nil && node.children[0].min != node.min { tb.Errorf(`Min not set correctly: node: %+v, child: %+v`, node, node.children[0]) } else if min != -1 && node.children[0] == nil && node.min != node.interval.LowAtDimension(1) { tb.Errorf(`Min not set correctly: %+v`, node) } max := max(maxL, maxR) if max == -1 && node.max != node.interval.HighAtDimension(1) { tb.Errorf(`Max not set correctly, node: %+v`, node) } else if max > node.interval.HighAtDimension(1) && max != node.max { tb.Errorf(`Max not set correctly, max: %+v, node: %+v`, max, node) } if left != 0 && right != 0 && lh != rh { tb.Errorf(`Black violation: left: %d, right: %d`, left, right) } if left != 0 && right != 0 { if isRed(node) { return left, node.min, node.max } return left + 1, node.min, node.max } return 0, node.min, node.max }]}
{Id:4 FileId:2 StartLine:115 StartColumn:1 EndLine:126 EndColumn:2 Name:constructSingleDimensionTestTree Params:[{Name:number Type:int}] Results:[{Name: Type:*tree} {Name: Type:Intervals}] Receiver:<nil> Body:{
	tree := newTree(1)

	ivs := make(Intervals, 0, number)
	for i := 0; i < number; i++ {
		iv := constructSingleDimensionInterval(int64(i), int64(i)+10, uint64(i))
		ivs = append(ivs, iv)
	}

	tree.Add(ivs...)
	return tree, ivs
} PrettyPrintBody:[{ tree := newTree(1) ivs := make(Intervals, 0, number) for i := 0; i < number; i++ { iv := constructSingleDimensionInterval(int64(i), int64(i)+10, uint64(i)) ivs = append(ivs, iv) } tree.Add(ivs...) return tree, ivs }]}
{Id:5 FileId:2 StartLine:128 StartColumn:1 EndLine:141 EndColumn:2 Name:TestSimpleAddNilRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)

	it.Add(iv)

	expected := newNode(iv, 5, 10, 1)
	expected.red = false

	assert.Equal(t, expected, it.root)
	assert.Equal(t, uint64(1), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expected := newNode(iv, 5, 10, 1) expected.red = false assert.Equal(t, expected, it.root) assert.Equal(t, uint64(1), it.Len()) checkRedBlack(t, it.root, 1) }]}
{Id:6 FileId:2 StartLine:143 StartColumn:1 EndLine:161 EndColumn:2 Name:TestSimpleAddRootLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 4, 11, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(4, 11, 1)
	it.Add(iv)

	expectedChild := newNode(iv, 4, 11, 1)
	expectedRoot.children[0] = expectedChild

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(2), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 4, 11, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(4, 11, 1) it.Add(iv) expectedChild := newNode(iv, 4, 11, 1) expectedRoot.children[0] = expectedChild assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(2), it.Len()) checkRedBlack(t, it.root, 1) }]}
{Id:7 FileId:2 StartLine:163 StartColumn:1 EndLine:181 EndColumn:2 Name:TestSimpleAddRootRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 5, 11, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(7, 11, 1)
	it.Add(iv)

	expectedChild := newNode(iv, 7, 11, 1)
	expectedRoot.children[1] = expectedChild

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(2), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 5, 11, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(7, 11, 1) it.Add(iv) expectedChild := newNode(iv, 7, 11, 1) expectedRoot.children[1] = expectedChild assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(2), it.Len()) checkRedBlack(t, it.root, 1) }]}
{Id:8 FileId:2 StartLine:183 StartColumn:1 EndLine:207 EndColumn:2 Name:TestAddRootLeftAndRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 4, 12, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(4, 11, 1)
	it.Add(iv)

	expectedLeft := newNode(iv, 4, 11, 1)
	expectedRoot.children[0] = expectedLeft

	iv = constructSingleDimensionInterval(7, 12, 1)
	it.Add(iv)

	expectedRight := newNode(iv, 7, 12, 1)
	expectedRoot.children[1] = expectedRight

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(3), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 4, 12, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(4, 11, 1) it.Add(iv) expectedLeft := newNode(iv, 4, 11, 1) expectedRoot.children[0] = expectedLeft iv = constructSingleDimensionInterval(7, 12, 1) it.Add(iv) expectedRight := newNode(iv, 7, 12, 1) expectedRoot.children[1] = expectedRight assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(3), it.Len()) checkRedBlack(t, it.root, 1) }]}
{Id:9 FileId:2 StartLine:209 StartColumn:1 EndLine:221 EndColumn:2 Name:TestAddRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	for i := int64(0); i < 10; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(1) for i := int64(0); i < 10; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]}
{Id:10 FileId:2 StartLine:223 StartColumn:1 EndLine:235 EndColumn:2 Name:TestAddRebalanceOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	for i := int64(9); i >= 0; i-- {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(1) for i := int64(9); i >= 0; i-- { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]}
{Id:11 FileId:2 StartLine:237 StartColumn:1 EndLine:251 EndColumn:2 Name:TestAddRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int64{0, 4, 2, 1, 3}

	for _, start := range starts {
		iv := constructSingleDimensionInterval(start, start+1, uint64(start))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int64{0, 4, 2, 1, 3} for _, start := range starts { iv := constructSingleDimensionInterval(start, start+1, uint64(start)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 5) assert.Equal(t, uint64(5), it.Len()) }]}
{Id:12 FileId:2 StartLine:253 StartColumn:1 EndLine:266 EndColumn:2 Name:TestAddLargeNumberOfItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	it := newTree(1)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, numItems, 0))
	assert.Len(t, result, int(numItems))
	assert.Equal(t, uint64(numItems), it.Len())
} PrettyPrintBody:[{ numItems := int64(1000) it := newTree(1) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, numItems, 0)) assert.Len(t, result, int(numItems)) assert.Equal(t, uint64(numItems), it.Len()) }]}
{Id:13 FileId:2 StartLine:268 StartColumn:1 EndLine:283 EndColumn:2 Name:BenchmarkAddItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		it := newTree(1)
		it.Add(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } b.ResetTimer() for i := 0; i < b.N; i++ { it := newTree(1) it.Add(intervals...) } }]}
{Id:14 FileId:2 StartLine:285 StartColumn:1 EndLine:301 EndColumn:2 Name:BenchmarkQueryItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	it := newTree(1)
	it.Add(intervals...)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		it.Query(constructSingleDimensionInterval(0, numItems, 0))
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } it := newTree(1) it.Add(intervals...) b.ResetTimer() for i := 0; i < b.N; i++ { it.Query(constructSingleDimensionInterval(0, numItems, 0)) } }]}
{Id:15 FileId:2 StartLine:303 StartColumn:1 EndLine:318 EndColumn:2 Name:constructSingleDimensionQueryTestTree Params:[] Results:[{Name: Type:*tree} {Name: Type:Interval} {Name: Type:Interval} {Name: Type:Interval}] Receiver:<nil> Body:{

	it := newTree(1)

	iv1 := constructSingleDimensionInterval(6, 10, 0)
	it.Add(iv1)

	iv2 := constructSingleDimensionInterval(4, 5, 1)
	it.Add(iv2)

	iv3 := constructSingleDimensionInterval(7, 12, 2)
	it.Add(iv3)

	return it, iv1, iv2, iv3
} PrettyPrintBody:[{ it := newTree(1) iv1 := constructSingleDimensionInterval(6, 10, 0) it.Add(iv1) iv2 := constructSingleDimensionInterval(4, 5, 1) it.Add(iv2) iv3 := constructSingleDimensionInterval(7, 12, 2) it.Add(iv3) return it, iv1, iv2, iv3 }]}
{Id:16 FileId:2 StartLine:320 StartColumn:1 EndLine:327 EndColumn:2 Name:TestSimpleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(3, 6, 0))

	expected := Intervals{iv2, iv1}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(3, 6, 0)) expected := Intervals{iv2, iv1} assert.Equal(t, expected, result) }]}
{Id:17 FileId:2 StartLine:329 StartColumn:1 EndLine:336 EndColumn:2 Name:TestRightQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, _, iv3 := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(6, 8, 0))

	expected := Intervals{iv1, iv3}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, _, iv3 := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(6, 8, 0)) expected := Intervals{iv1, iv3} assert.Equal(t, expected, result) }]}
{Id:18 FileId:2 StartLine:338 StartColumn:1 EndLine:345 EndColumn:2 Name:TestLeftQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(3, 5, 0))

	expected := Intervals{iv2}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(3, 5, 0)) expected := Intervals{iv2} assert.Equal(t, expected, result) }]}
{Id:19 FileId:2 StartLine:347 StartColumn:1 EndLine:354 EndColumn:2 Name:TestMatchingQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(4, 5, 0))

	expected := Intervals{iv2}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(4, 5, 0)) expected := Intervals{iv2} assert.Equal(t, expected, result) }]}
{Id:20 FileId:2 StartLine:356 StartColumn:1 EndLine:363 EndColumn:2 Name:TestNoMatchLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, _, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(1, 3, 0))

	expected := Intervals{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, _, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(1, 3, 0)) expected := Intervals{} assert.Equal(t, expected, result) }]}
{Id:21 FileId:2 StartLine:365 StartColumn:1 EndLine:372 EndColumn:2 Name:TestNoMatchRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, _, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(13, 13, 0))

	expected := Intervals{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, _, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(13, 13, 0)) expected := Intervals{} assert.Equal(t, expected, result) }]}
{Id:22 FileId:2 StartLine:374 StartColumn:1 EndLine:381 EndColumn:2 Name:TestAllQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(1, 14, 0))

	expected := Intervals{iv2, iv1, iv3}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(1, 14, 0)) expected := Intervals{iv2, iv1, iv3} assert.Equal(t, expected, result) }]}
{Id:23 FileId:2 StartLine:383 StartColumn:1 EndLine:392 EndColumn:2 Name:TestQueryDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()
	iv4 := constructSingleDimensionInterval(4, 5, 3)
	it.Add(iv4)

	result := it.Query(constructSingleDimensionInterval(4, 5, 0))

	expected := Intervals{iv2, iv4}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() iv4 := constructSingleDimensionInterval(4, 5, 3) it.Add(iv4) result := it.Query(constructSingleDimensionInterval(4, 5, 0)) expected := Intervals{iv2, iv4} assert.Equal(t, expected, result) }]}
{Id:24 FileId:2 StartLine:394 StartColumn:1 EndLine:405 EndColumn:2 Name:TestRootDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)
	iv := constructSingleDimensionInterval(1, 5, 1)
	it.add(iv)

	it.Delete(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(1, 10, 0))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(1, 5, 1) it.add(iv) it.Delete(iv) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(1, 10, 0)) assert.Len(t, result, 0) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:25 FileId:2 StartLine:407 StartColumn:1 EndLine:418 EndColumn:2 Name:TestDeleteLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv2)

	expected := Intervals{iv1, iv3}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv2) expected := Intervals{iv1, iv3} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]}
{Id:26 FileId:2 StartLine:420 StartColumn:1 EndLine:431 EndColumn:2 Name:TestDeleteRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv3)

	expected := Intervals{iv2, iv1}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv3) expected := Intervals{iv2, iv1} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]}
{Id:27 FileId:2 StartLine:433 StartColumn:1 EndLine:444 EndColumn:2 Name:TestDeleteCenter Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv1)

	expected := Intervals{iv2, iv3}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv1) expected := Intervals{iv2, iv3} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]}
{Id:28 FileId:2 StartLine:446 StartColumn:1 EndLine:465 EndColumn:2 Name:TestDeleteRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	var toDelete *mockInterval

	for i := int64(0); i < 10; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(1) var toDelete *mockInterval for i := int64(0); i < 10; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]}
{Id:29 FileId:2 StartLine:467 StartColumn:1 EndLine:485 EndColumn:2 Name:TestDeleteRebalanceOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	var toDelete *mockInterval
	for i := int64(9); i >= 0; i-- {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(1) var toDelete *mockInterval for i := int64(9); i >= 0; i-- { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]}
{Id:30 FileId:2 StartLine:487 StartColumn:1 EndLine:507 EndColumn:2 Name:TestDeleteRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int64{0, 4, 2, 1, 3}

	var toDelete *mockInterval
	for _, start := range starts {
		iv := constructSingleDimensionInterval(start, start+1, uint64(start))
		it.add(iv)
		if start == 1 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int64{0, 4, 2, 1, 3} var toDelete *mockInterval for _, start := range starts { iv := constructSingleDimensionInterval(start, start+1, uint64(start)) it.add(iv) if start == 1 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 4) assert.Equal(t, uint64(4), it.Len()) }]}
{Id:31 FileId:2 StartLine:509 StartColumn:1 EndLine:515 EndColumn:2 Name:TestDeleteEmptyTree Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	it.Delete(constructSingleDimensionInterval(0, 1, 1))

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) it.Delete(constructSingleDimensionInterval(0, 1, 1)) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:32 FileId:2 StartLine:517 StartColumn:1 EndLine:538 EndColumn:2 Name:BenchmarkDeleteItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	intervals := make(Intervals, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	trees := make([]*tree, 0, b.N)
	for i := 0; i < b.N; i++ {
		it := newTree(1)
		it.Add(intervals...)
		trees = append(trees, it)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } trees := make([]*tree, 0, b.N) for i := 0; i < b.N; i++ { it := newTree(1) it.Add(intervals...) trees = append(trees, it) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(intervals...) } }]}
{Id:33 FileId:2 StartLine:540 StartColumn:1 EndLine:550 EndColumn:2 Name:TestAddDuplicateRanges Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)
	iv1 := constructSingleDimensionInterval(0, 10, 1)
	iv2 := constructSingleDimensionInterval(0, 10, 2)
	iv3 := constructSingleDimensionInterval(0, 10, 3)

	it.Add(iv1, iv2, iv3)
	it.Delete(iv1, iv2, iv3)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) iv1 := constructSingleDimensionInterval(0, 10, 1) iv2 := constructSingleDimensionInterval(0, 10, 2) iv3 := constructSingleDimensionInterval(0, 10, 3) it.Add(iv1, iv2, iv3) it.Delete(iv1, iv2, iv3) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:34 FileId:2 StartLine:552 StartColumn:1 EndLine:566 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	intervals := make(Intervals, 0, 10)

	for i := 0; i < 10; i++ {
		iv := constructSingleDimensionInterval(0, 10, uint64(i))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) intervals := make(Intervals, 0, 10) for i := 0; i < 10; i++ { iv := constructSingleDimensionInterval(0, 10, uint64(i)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:35 FileId:2 StartLine:568 StartColumn:1 EndLine:582 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	intervals := make(Intervals, 0, 10)

	for i := 9; i >= 0; i-- {
		iv := constructSingleDimensionInterval(0, 10, uint64(i))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) intervals := make(Intervals, 0, 10) for i := 9; i >= 0; i-- { iv := constructSingleDimensionInterval(0, 10, uint64(i)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:36 FileId:2 StartLine:584 StartColumn:1 EndLine:599 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int{0, 4, 2, 1, 3}
	intervals := make(Intervals, 0, 5)

	for _, start := range starts {
		iv := constructSingleDimensionInterval(0, 10, uint64(start))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int{0, 4, 2, 1, 3} intervals := make(Intervals, 0, 5) for _, start := range starts { iv := constructSingleDimensionInterval(0, 10, uint64(start)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:37 FileId:2 StartLine:601 StartColumn:1 EndLine:610 EndColumn:2 Name:TestInsertDuplicateIntervalsToRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1)
	iv1 := constructSingleDimensionInterval(0, 10, 1)
	iv2 := constructSingleDimensionInterval(0, 10, 1)
	iv3 := constructSingleDimensionInterval(0, 10, 1)

	tree.Add(iv1, iv2, iv3)

	checkRedBlack(t, tree.root, 1)
} PrettyPrintBody:[{ tree := newTree(1) iv1 := constructSingleDimensionInterval(0, 10, 1) iv2 := constructSingleDimensionInterval(0, 10, 1) iv3 := constructSingleDimensionInterval(0, 10, 1) tree.Add(iv1, iv2, iv3) checkRedBlack(t, tree.root, 1) }]}
{Id:38 FileId:2 StartLine:612 StartColumn:1 EndLine:624 EndColumn:2 Name:TestInsertDuplicateIntervalChildren Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructSingleDimensionTestTree(20)

	iv1 := constructSingleDimensionInterval(0, 10, 21)
	iv2 := constructSingleDimensionInterval(0, 10, 21)

	tree.Add(iv1, iv2)

	checkRedBlack(t, tree.root, 1)

	result := tree.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Contains(t, result, iv1)
} PrettyPrintBody:[{ tree, _ := constructSingleDimensionTestTree(20) iv1 := constructSingleDimensionInterval(0, 10, 21) iv2 := constructSingleDimensionInterval(0, 10, 21) tree.Add(iv1, iv2) checkRedBlack(t, tree.root, 1) result := tree.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Contains(t, result, iv1) }]}
{Id:39 FileId:2 StartLine:626 StartColumn:1 EndLine:646 EndColumn:2 Name:TestTraverse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1)

	tree.Traverse(func(i Interval) {
		assert.Fail(t, `traverse should not be called for empty tree`)
	})

	top := 30
	for i := 0; i <= top; i++ {
		tree.Add(constructSingleDimensionInterval(int64(i*10), int64((i+1)*10), uint64(i)))
	}
	found := map[uint64]bool{}
	tree.Traverse(func(id Interval) {
		found[id.ID()] = true
	})
	for i := 0; i <= top; i++ {
		if found, _ := found[uint64(i)]; !found {
			t.Errorf("could not find expected interval %d", i)
		}
	}
} PrettyPrintBody:[{ tree := newTree(1) tree.Traverse(func(i Interval) { assert.Fail(t, `traverse should not be called for empty tree`) }) top := 30 for i := 0; i <= top; i++ { tree.Add(constructSingleDimensionInterval(int64(i*10), int64((i+1)*10), uint64(i))) } found := map[uint64]bool{} tree.Traverse(func(id Interval) { found[id.ID()] = true }) for i := 0; i <= top; i++ { if found, _ := found[uint64(i)]; !found { t.Errorf("could not find expected interval %d", i) } } }]}
{Id:1 FileId:156 StartLine:29 StartColumn:1 EndLine:33 EndColumn:2 Name:checkTrie Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	checkSuccessor(t, xft)
	checkPredecessor(t, xft)
	checkNodes(t, xft)
} PrettyPrintBody:[{ checkSuccessor(t, xft) checkPredecessor(t, xft) checkNodes(t, xft) }]}
{Id:2 FileId:156 StartLine:35 StartColumn:1 EndLine:66 EndColumn:2 Name:checkSuccessor Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	n := xft.min
	var side int
	var successor *node
	for n != nil {
		successor = n.children[1]
		hasSuccesor := successor != nil
		immediateSuccessor := false
		if hasSuccesor {
			assert.Equal(t, n, successor.children[0])
			if n.parent == successor.parent {
				immediateSuccessor = true
			}
		}

		for n.parent != nil {
			side = whichSide(n, n.parent)
			if isInternal(n.parent.children[1]) && isInternal(n.parent.children[0]) {
				break
			}
			if immediateSuccessor && n.parent == successor.parent {
				assert.Equal(t, successor, n.parent.children[1])
				break
			}
			if side == 0 && !isInternal(n.parent.children[1]) && hasSuccesor {
				assert.Equal(t, successor, n.parent.children[1])
			}
			n = n.parent
		}
		n = successor
	}
} PrettyPrintBody:[{ n := xft.min var side int var successor *node for n != nil { successor = n.children[1] hasSuccesor := successor != nil immediateSuccessor := false if hasSuccesor { assert.Equal(t, n, successor.children[0]) if n.parent == successor.parent { immediateSuccessor = true } } for n.parent != nil { side = whichSide(n, n.parent) if isInternal(n.parent.children[1]) && isInternal(n.parent.children[0]) { break } if immediateSuccessor && n.parent == successor.parent { assert.Equal(t, successor, n.parent.children[1]) break } if side == 0 && !isInternal(n.parent.children[1]) && hasSuccesor { assert.Equal(t, successor, n.parent.children[1]) } n = n.parent } n = successor } }]}
{Id:3 FileId:156 StartLine:68 StartColumn:1 EndLine:98 EndColumn:2 Name:checkPredecessor Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	n := xft.max
	var side int
	var predecessor *node
	for n != nil {
		predecessor = n.children[0]
		hasPredecessor := predecessor != nil
		immediatePredecessor := false
		if hasPredecessor {
			assert.Equal(t, n, predecessor.children[1])
			if n.parent == predecessor.parent {
				immediatePredecessor = true
			}
		}
		for n.parent != nil {
			side = whichSide(n, n.parent)
			if isInternal(n.parent.children[0]) && isInternal(n.parent.children[1]) {
				break
			}
			if immediatePredecessor && n.parent == predecessor.parent {
				assert.Equal(t, predecessor, n.parent.children[0])
				break
			}
			if side == 1 && !isInternal(n.parent.children[0]) && hasPredecessor {
				assert.Equal(t, predecessor, n.parent.children[0])
			}
			n = n.parent
		}
		n = predecessor
	}
} PrettyPrintBody:[{ n := xft.max var side int var predecessor *node for n != nil { predecessor = n.children[0] hasPredecessor := predecessor != nil immediatePredecessor := false if hasPredecessor { assert.Equal(t, n, predecessor.children[1]) if n.parent == predecessor.parent { immediatePredecessor = true } } for n.parent != nil { side = whichSide(n, n.parent) if isInternal(n.parent.children[0]) && isInternal(n.parent.children[1]) { break } if immediatePredecessor && n.parent == predecessor.parent { assert.Equal(t, predecessor, n.parent.children[0]) break } if side == 1 && !isInternal(n.parent.children[0]) && hasPredecessor { assert.Equal(t, predecessor, n.parent.children[0]) } n = n.parent } n = predecessor } }]}
{Id:4 FileId:156 StartLine:100 StartColumn:1 EndLine:110 EndColumn:2 Name:checkNodes Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	count := uint64(0)
	n := xft.min
	for n != nil {
		count++
		checkNode(t, xft, n)
		n = n.children[1]
	}

	assert.Equal(t, count, xft.Len())
} PrettyPrintBody:[{ count := uint64(0) n := xft.min for n != nil { count++ checkNode(t, xft, n) n = n.children[1] } assert.Equal(t, count, xft.Len()) }]}
{Id:5 FileId:156 StartLine:112 StartColumn:1 EndLine:125 EndColumn:2 Name:checkNode Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie} {Name:n Type:*node}] Results:[] Receiver:<nil> Body:{
	if n.entry == nil {
		assert.Fail(t, `Expected non-nil entry`)
		return
	}
	key := n.entry.Key()
	bits := make([]int, 0, xft.bits)
	for i := uint8(0); i < xft.bits; i++ {
		leftOrRight := (key & positions[xft.diff+i]) >> (xft.bits - 1 - i)
		bits = append(bits, int(leftOrRight))
	}

	checkPattern(t, n, bits)
} PrettyPrintBody:[{ if n.entry == nil { assert.Fail(t, `Expected non-nil entry`) return } key := n.entry.Key() bits := make([]int, 0, xft.bits) for i := uint8(0); i < xft.bits; i++ { leftOrRight := (key & positions[xft.diff+i]) >> (xft.bits - 1 - i) bits = append(bits, int(leftOrRight)) } checkPattern(t, n, bits) }]}
{Id:6 FileId:156 StartLine:127 StartColumn:1 EndLine:132 EndColumn:2 Name:dumpNode Params:[{Name:t Type:*testing.T} {Name:n Type:*node}] Results:[] Receiver:<nil> Body:{
	for n != nil {
		t.Logf(`NODE: %+v, %p`, n, n)
		n = n.parent
	}
} PrettyPrintBody:[{ for n != nil { t.Logf(`NODE: %+v, %p`, n, n) n = n.parent } }]}
{Id:7 FileId:156 StartLine:134 StartColumn:1 EndLine:148 EndColumn:2 Name:checkPattern Params:[{Name:t Type:*testing.T} {Name:n Type:*node} {Name:pattern Type:[]int}] Results:[] Receiver:<nil> Body:{
	i := len(pattern) - 1
	bottomNode := n
	for n.parent != nil {
		if !assert.False(t, i < 0, fmt.Sprintf(`Too many parents. NODE: %+v, PATTERN: %+v`, bottomNode, pattern)) {
			dumpNode(t, bottomNode)
			break
		}
		assert.Equal(t, pattern[i], whichSide(n, n.parent))
		i--
		n = n.parent
	}

	assert.Equal(t, -1, i)
} PrettyPrintBody:[{ i := len(pattern) - 1 bottomNode := n for n.parent != nil { if !assert.False(t, i < 0, fmt.Sprintf(`Too many parents. NODE: %+v, PATTERN: %+v`, bottomNode, pattern)) { dumpNode(t, bottomNode) break } assert.Equal(t, pattern[i], whichSide(n, n.parent)) i-- n = n.parent } assert.Equal(t, -1, i) }]}
{Id:8 FileId:156 StartLine:150 StartColumn:1 EndLine:155 EndColumn:2 Name:TestEmptyMinMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))

	assert.Nil(t, xft.Min())
	assert.Nil(t, xft.Max())
} PrettyPrintBody:[{ xft := New(uint8(0)) assert.Nil(t, xft.Min()) assert.Nil(t, xft.Max()) }]}
{Id:9 FileId:156 StartLine:157 StartColumn:1 EndLine:159 EndColumn:2 Name:TestMask Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert.Equal(t, uint64(math.MaxUint64), masks[63])
} PrettyPrintBody:[{ assert.Equal(t, uint64(math.MaxUint64), masks[63]) }]}
{Id:10 FileId:156 StartLine:161 StartColumn:1 EndLine:179 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	assert.True(t, xft.Exists(5))
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	assert.True(t, xft.Exists(20))
	assert.Equal(t, uint64(2), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) assert.True(t, xft.Exists(5)) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) e2 := newMockEntry(20) xft.Insert(e2) assert.True(t, xft.Exists(20)) assert.Equal(t, uint64(2), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) }]}
{Id:11 FileId:156 StartLine:181 StartColumn:1 EndLine:188 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	assert.Equal(t, e1, xft.Get(5))
	assert.Nil(t, xft.Get(6))
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) assert.Equal(t, e1, xft.Get(5)) assert.Nil(t, xft.Get(6)) }]}
{Id:12 FileId:156 StartLine:190 StartColumn:1 EndLine:201 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	e2 := newMockEntry(5)
	xft.Insert(e2)
	checkTrie(t, xft)

	iter := xft.Iter(5)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) e2 := newMockEntry(5) xft.Insert(e2) checkTrie(t, xft) iter := xft.Iter(5) assert.Equal(t, Entries{e2}, iter.exhaust()) }]}
{Id:13 FileId:156 StartLine:203 StartColumn:1 EndLine:244 EndColumn:2 Name:TestInsertBetween Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	assert.True(t, xft.Exists(10))
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	e2 := newMockEntry(20)
	xft.Insert(e2)
	checkTrie(t, xft)

	assert.True(t, xft.Exists(20))
	assert.Equal(t, uint64(2), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())

	assert.Equal(t, e2, xft.Successor(15))

	e3 := newMockEntry(15)
	xft.Insert(e3)

	assert.True(t, xft.Exists(15))
	assert.Equal(t, uint64(3), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	entries := iter.exhaust()
	assert.Equal(t, Entries{e1, e3, e2}, entries)

	iter = xft.Iter(11)
	entries = iter.exhaust()
	assert.Equal(t, Entries{e3, e2}, entries)

	iter = xft.Iter(16)
	entries = iter.exhaust()
	assert.Equal(t, Entries{e2}, entries)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) assert.True(t, xft.Exists(10)) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) e2 := newMockEntry(20) xft.Insert(e2) checkTrie(t, xft) assert.True(t, xft.Exists(20)) assert.Equal(t, uint64(2), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) assert.Equal(t, e2, xft.Successor(15)) e3 := newMockEntry(15) xft.Insert(e3) assert.True(t, xft.Exists(15)) assert.Equal(t, uint64(3), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) entries := iter.exhaust() assert.Equal(t, Entries{e1, e3, e2}, entries) iter = xft.Iter(11) entries = iter.exhaust() assert.Equal(t, Entries{e3, e2}, entries) iter = xft.Iter(16) entries = iter.exhaust() assert.Equal(t, Entries{e2}, entries) }]}
{Id:14 FileId:156 StartLine:246 StartColumn:1 EndLine:253 EndColumn:2 Name:TestSuccessorDoesNotExist Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Successor(6)
	assert.Nil(t, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Successor(6) assert.Nil(t, result) }]}
{Id:15 FileId:156 StartLine:255 StartColumn:1 EndLine:262 EndColumn:2 Name:TestSuccessorIsExactValue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]}
{Id:16 FileId:156 StartLine:264 StartColumn:1 EndLine:271 EndColumn:2 Name:TestSuccessorGreaterThanKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(math.MaxUint8)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(math.MaxUint8) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]}
{Id:17 FileId:156 StartLine:273 StartColumn:1 EndLine:280 EndColumn:2 Name:TestSuccessorCloseToKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]}
{Id:18 FileId:156 StartLine:282 StartColumn:1 EndLine:299 EndColumn:2 Name:TestSuccessorBetweenTwoKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	for i := uint64(11); i < 20; i++ {
		result := xft.Successor(i)
		assert.Equal(t, e2, result)
	}

	for i := uint64(21); i < 100; i++ {
		result := xft.Successor(i)
		assert.Nil(t, result)
	}
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(20) xft.Insert(e2) for i := uint64(11); i < 20; i++ { result := xft.Successor(i) assert.Equal(t, e2, result) } for i := uint64(21); i < 100; i++ { result := xft.Successor(i) assert.Nil(t, result) } }]}
{Id:19 FileId:156 StartLine:301 StartColumn:1 EndLine:308 EndColumn:2 Name:TestPredecessorDoesNotExist Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(4)
	assert.Nil(t, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(4) assert.Nil(t, result) }]}
{Id:20 FileId:156 StartLine:310 StartColumn:1 EndLine:317 EndColumn:2 Name:TestPredecessorIsExactValue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(5) assert.Equal(t, e1, result) }]}
{Id:21 FileId:156 StartLine:319 StartColumn:1 EndLine:326 EndColumn:2 Name:TestPredecessorLessThanKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	xft.Insert(e1)

	result := xft.Predecessor(math.MaxUint64)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) xft.Insert(e1) result := xft.Predecessor(math.MaxUint64) assert.Equal(t, e1, result) }]}
{Id:22 FileId:156 StartLine:328 StartColumn:1 EndLine:335 EndColumn:2 Name:TestPredecessorCloseToKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(10)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(10) assert.Equal(t, e1, result) }]}
{Id:23 FileId:156 StartLine:337 StartColumn:1 EndLine:354 EndColumn:2 Name:TestPredecessorBetweenTwoKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	for i := uint64(11); i < 20; i++ {
		result := xft.Predecessor(i)
		assert.Equal(t, e1, result)
	}

	for i := uint64(0); i < 10; i++ {
		result := xft.Predecessor(i)
		assert.Nil(t, result)
	}
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(20) xft.Insert(e2) for i := uint64(11); i < 20; i++ { result := xft.Predecessor(i) assert.Equal(t, e1, result) } for i := uint64(0); i < 10; i++ { result := xft.Predecessor(i) assert.Nil(t, result) } }]}
{Id:24 FileId:156 StartLine:356 StartColumn:1 EndLine:379 EndColumn:2 Name:TestInsertPredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(5)
	xft.Insert(e2)
	checkTrie(t, xft)

	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e1, xft.Max())

	iter := xft.Iter(2)
	assert.Equal(t, Entries{e2, e1}, iter.exhaust())

	iter = xft.Iter(5)
	assert.Equal(t, Entries{e2, e1}, iter.exhaust())

	iter = xft.Iter(6)
	assert.Equal(t, Entries{e1}, iter.exhaust())

	iter = xft.Iter(11)
	assert.Equal(t, Entries{}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(5) xft.Insert(e2) checkTrie(t, xft) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e1, xft.Max()) iter := xft.Iter(2) assert.Equal(t, Entries{e2, e1}, iter.exhaust()) iter = xft.Iter(5) assert.Equal(t, Entries{e2, e1}, iter.exhaust()) iter = xft.Iter(6) assert.Equal(t, Entries{e1}, iter.exhaust()) iter = xft.Iter(11) assert.Equal(t, Entries{}, iter.exhaust()) }]}
{Id:25 FileId:156 StartLine:381 StartColumn:1 EndLine:401 EndColumn:2 Name:TestDeleteOnlyBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	xft.Delete(10)
	checkTrie(t, xft)
	assert.Equal(t, uint64(0), xft.Len())
	assert.Nil(t, xft.Min())
	assert.Nil(t, xft.Max())
	for _, hm := range xft.layers {
		assert.Len(t, hm, 0)
	}

	assert.NotNil(t, xft.root)
	assert.Nil(t, xft.root.children[0])
	assert.Nil(t, xft.root.children[1])

	iter := xft.Iter(0)
	assert.False(t, iter.Next())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) xft.Delete(10) checkTrie(t, xft) assert.Equal(t, uint64(0), xft.Len()) assert.Nil(t, xft.Min()) assert.Nil(t, xft.Max()) for _, hm := range xft.layers { assert.Len(t, hm, 0) } assert.NotNil(t, xft.root) assert.Nil(t, xft.root.children[0]) assert.Nil(t, xft.root.children[1]) iter := xft.Iter(0) assert.False(t, iter.Next()) }]}
{Id:26 FileId:156 StartLine:403 StartColumn:1 EndLine:426 EndColumn:2 Name:TestDeleteLargeBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(0)
	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	assert.Nil(t, xft.root.children[0])

	n := xft.max
	for n != nil {
		assert.Nil(t, n.children[0])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(0) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) assert.Nil(t, xft.root.children[0]) n := xft.max for n != nil { assert.Nil(t, n.children[0]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e2}, iter.exhaust()) }]}
{Id:27 FileId:156 StartLine:428 StartColumn:1 EndLine:449 EndColumn:2 Name:TestDeleteLateBranching Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(1)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(1)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	n := xft.min
	for n != nil {
		assert.Nil(t, n.children[1])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(1) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(1) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) n := xft.min for n != nil { assert.Nil(t, n.children[1]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e1}, iter.exhaust()) }]}
{Id:28 FileId:156 StartLine:451 StartColumn:1 EndLine:475 EndColumn:2 Name:TestDeleteLateBranchingMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(1)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(0)
	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	assert.Nil(t, xft.min.children[0])
	n := xft.min.parent
	assert.Nil(t, n.children[0])
	n = n.parent
	for n != nil {
		assert.Nil(t, n.children[1])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(1) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(0) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) assert.Nil(t, xft.min.children[0]) n := xft.min.parent assert.Nil(t, n.children[0]) n = n.parent for n != nil { assert.Nil(t, n.children[1]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e2}, iter.exhaust()) }]}
{Id:29 FileId:156 StartLine:477 StartColumn:1 EndLine:493 EndColumn:2 Name:TestDeleteMiddleBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)
	e3 := newMockEntry(64)

	xft.Insert(e1, e2, e3)
	checkTrie(t, xft)

	xft.Delete(64)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) e3 := newMockEntry(64) xft.Insert(e1, e2, e3) checkTrie(t, xft) xft.Delete(64) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) }]}
{Id:30 FileId:156 StartLine:495 StartColumn:1 EndLine:511 EndColumn:2 Name:TestDeleteMiddleBranchOtherSide Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)
	e3 := newMockEntry(128)

	xft.Insert(e1, e2, e3)
	checkTrie(t, xft)

	xft.Delete(128)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) e3 := newMockEntry(128) xft.Insert(e1, e2, e3) checkTrie(t, xft) xft.Delete(128) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) }]}
{Id:31 FileId:156 StartLine:513 StartColumn:1 EndLine:523 EndColumn:2 Name:TestDeleteNotFound Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(64)
	xft.Insert(e1)
	checkTrie(t, xft)

	xft.Delete(128)
	assert.Equal(t, e1, xft.Max())
	assert.Equal(t, e1, xft.Min())
	checkTrie(t, xft)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(64) xft.Insert(e1) checkTrie(t, xft) xft.Delete(128) assert.Equal(t, e1, xft.Max()) assert.Equal(t, e1, xft.Min()) checkTrie(t, xft) }]}
{Id:32 FileId:156 StartLine:525 StartColumn:1 EndLine:538 EndColumn:2 Name:BenchmarkSuccessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	xft := New(uint64(0))

	for i := uint64(0); i < uint64(numItems); i++ {
		xft.Insert(newMockEntry(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		xft.Successor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 10000 xft := New(uint64(0)) for i := uint64(0); i < uint64(numItems); i++ { xft.Insert(newMockEntry(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { xft.Successor(uint64(i)) } }]}
{Id:33 FileId:156 StartLine:540 StartColumn:1 EndLine:556 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	xs := make([]*XFastTrie, 0, b.N)

	for i := 0; i < b.N; i++ {
		x := New(uint8(0))
		x.Insert(newMockEntry(0))
		xs = append(xs, x)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		xs[i].Delete(0)
	}
} PrettyPrintBody:[{ xs := make([]*XFastTrie, 0, b.N) for i := 0; i < b.N; i++ { x := New(uint8(0)) x.Insert(newMockEntry(0)) xs = append(xs, x) } b.ResetTimer() for i := 0; i < b.N; i++ { xs[i].Delete(0) } }]}
{Id:34 FileId:156 StartLine:558 StartColumn:1 EndLine:564 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		xft := New(uint64(0))
		e := newMockEntry(uint64(i))
		xft.Insert(e)
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { xft := New(uint64(0)) e := newMockEntry(uint64(i)) xft.Insert(e) } }]}
{Id:35 FileId:156 StartLine:567 StartColumn:1 EndLine:580 EndColumn:2 Name:BenchmarkListInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	s := make(slice.Int64Slice, 0, numItems)
	for j := int64(0); j < int64(numItems); j++ {
		s = append(s, j)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		s.Insert(int64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 s := make(slice.Int64Slice, 0, numItems) for j := int64(0); j < int64(numItems); j++ { s = append(s, j) } b.ResetTimer() for i := 0; i < b.N; i++ { s.Insert(int64(i)) } }]}
{Id:36 FileId:156 StartLine:582 StartColumn:1 EndLine:595 EndColumn:2 Name:BenchmarkListSearch Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000000

	s := make(slice.Int64Slice, 0, numItems)
	for j := int64(0); j < int64(numItems); j++ {
		s = append(s, j)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		s.Search(int64(i))
	}
} PrettyPrintBody:[{ numItems := 1000000 s := make(slice.Int64Slice, 0, numItems) for j := int64(0); j < int64(numItems); j++ { s = append(s, j) } b.ResetTimer() for i := 0; i < b.N; i++ { s.Search(int64(i)) } }]}
{Id:1 FileId:97 StartLine:28 StartColumn:1 EndLine:50 EndColumn:2 Name:TestPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	assert.Equal(t, int64(1), q.Len())

	results, err := q.Get(1)
	assert.Nil(t, err)

	result := results[0]
	assert.Equal(t, `test`, result)
	assert.True(t, q.Empty())

	q.Put(`test2`)
	assert.Equal(t, int64(1), q.Len())

	results, err = q.Get(1)
	assert.Nil(t, err)

	result = results[0]
	assert.Equal(t, `test2`, result)
	assert.True(t, q.Empty())
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) assert.Equal(t, int64(1), q.Len()) results, err := q.Get(1) assert.Nil(t, err) result := results[0] assert.Equal(t, `test`, result) assert.True(t, q.Empty()) q.Put(`test2`) assert.Equal(t, int64(1), q.Len()) results, err = q.Get(1) assert.Nil(t, err) result = results[0] assert.Equal(t, `test2`, result) assert.True(t, q.Empty()) }]}
{Id:2 FileId:97 StartLine:52 StartColumn:1 EndLine:83 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `test`, result[0])
	assert.Equal(t, int64(0), q.Len())

	q.Put(`1`)
	q.Put(`2`)

	result, err = q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `1`, result[0])
	assert.Equal(t, int64(1), q.Len())

	result, err = q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result[0])
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) result, err := q.Get(2) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `test`, result[0]) assert.Equal(t, int64(0), q.Len()) q.Put(`1`) q.Put(`2`) result, err = q.Get(1) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `1`, result[0]) assert.Equal(t, int64(1), q.Len()) result, err = q.Get(2) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result[0]) }]}
{Id:3 FileId:97 StartLine:85 StartColumn:1 EndLine:126 EndColumn:2 Name:TestPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Poll(1, time.Millisecond)

	q.Put(`test`)
	result, err := q.Poll(2, 0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `test`, result[0])
	assert.Equal(t, int64(0), q.Len())

	q.Put(`1`)
	q.Put(`2`)

	result, err = q.Poll(1, time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `1`, result[0])
	assert.Equal(t, int64(1), q.Len())

	result, err = q.Poll(2, time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result[0])

	before := time.Now()
	_, err = q.Poll(1, 5*time.Millisecond)

	assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ q := New(10) q.Poll(1, time.Millisecond) q.Put(`test`) result, err := q.Poll(2, 0) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `test`, result[0]) assert.Equal(t, int64(0), q.Len()) q.Put(`1`) q.Put(`2`) result, err = q.Poll(1, time.Millisecond) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `1`, result[0]) assert.Equal(t, int64(1), q.Len()) result, err = q.Poll(2, time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result[0]) before := time.Now() _, err = q.Poll(1, 5*time.Millisecond) assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10) assert.Equal(t, ErrTimeout, err) }]}
{Id:4 FileId:97 StartLine:128 StartColumn:1 EndLine:138 EndColumn:2 Name:TestPollNoMemoryLeak Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(0)

	assert.Len(t, q.waiters, 0)

	for i := 0; i < 10; i++ {

		q.Poll(1, time.Nanosecond)
		assert.Len(t, q.waiters, 0)
	}
} PrettyPrintBody:[{ q := New(0) assert.Len(t, q.waiters, 0) for i := 0; i < 10; i++ { q.Poll(1, time.Nanosecond) assert.Len(t, q.waiters, 0) } }]}
{Id:5 FileId:97 StartLine:140 StartColumn:1 EndLine:148 EndColumn:2 Name:TestAddEmptyPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put()

	if q.Len() != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, q.Len())
	}
} PrettyPrintBody:[{ q := New(10) q.Put() if q.Len() != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, q.Len()) } }]}
{Id:6 FileId:97 StartLine:150 StartColumn:1 EndLine:162 EndColumn:2 Name:TestGetNonPositiveNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	result, err := q.Get(0)
	if !assert.Nil(t, err) {
		return
	}

	if len(result) != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, len(result))
	}
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) result, err := q.Get(0) if !assert.Nil(t, err) { return } if len(result) != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, len(result)) } }]}
{Id:7 FileId:97 StartLine:164 StartColumn:1 EndLine:175 EndColumn:2 Name:TestEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	if !q.Empty() {
		t.Errorf(`Expected empty queue.`)
	}

	q.Put(`test`)
	if q.Empty() {
		t.Errorf(`Expected non-empty queue.`)
	}
} PrettyPrintBody:[{ q := New(10) if !q.Empty() { t.Errorf(`Expected empty queue.`) } q.Put(`test`) if q.Empty() { t.Errorf(`Expected non-empty queue.`) } }]}
{Id:8 FileId:97 StartLine:177 StartColumn:1 EndLine:191 EndColumn:2 Name:TestGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	go func() {
		q.Put(`a`)
	}()

	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `a`, result[0])
} PrettyPrintBody:[{ q := New(10) go func() { q.Put(`a`) }() result, err := q.Get(2) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `a`, result[0]) }]}
{Id:9 FileId:97 StartLine:193 StartColumn:1 EndLine:226 EndColumn:2 Name:TestMultipleGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	var wg sync.WaitGroup
	wg.Add(2)
	results := make([][]interface{}, 2)

	go func() {
		wg.Done()
		local, err := q.Get(1)
		assert.Nil(t, err)
		results[0] = local
		wg.Done()
	}()

	go func() {
		wg.Done()
		local, err := q.Get(1)
		assert.Nil(t, err)
		results[1] = local
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	q.Put(`a`, `b`, `c`)
	wg.Wait()

	if assert.Len(t, results[0], 1) && assert.Len(t, results[1], 1) {
		assert.True(t, (results[0][0] == `a` && results[1][0] == `b`) ||
			(results[0][0] == `b` && results[1][0] == `a`),
			`The array should be a, b or b, a`)
	}
} PrettyPrintBody:[{ q := New(10) var wg sync.WaitGroup wg.Add(2) results := make([][]interface{}, 2) go func() { wg.Done() local, err := q.Get(1) assert.Nil(t, err) results[0] = local wg.Done() }() go func() { wg.Done() local, err := q.Get(1) assert.Nil(t, err) results[1] = local wg.Done() }() wg.Wait() wg.Add(2) q.Put(`a`, `b`, `c`) wg.Wait() if assert.Len(t, results[0], 1) && assert.Len(t, results[1], 1) { assert.True(t, (results[0][0] == `a` && results[1][0] == `b`) || (results[0][0] == `b` && results[1][0] == `a`), `The array should be a, b or b, a`) } }]}
{Id:10 FileId:97 StartLine:228 StartColumn:1 EndLine:246 EndColumn:2 Name:TestDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{

	q := New(10)
	itemsDisposed := q.Dispose()

	assert.Empty(t, itemsDisposed)

	q = New(10)
	q.Put(`1`)
	itemsDisposed = q.Dispose()

	expected := []interface{}{`1`}
	assert.Equal(t, expected, itemsDisposed)

	itemsDisposed = q.Dispose()
	assert.Nil(t, itemsDisposed)
} PrettyPrintBody:[{ q := New(10) itemsDisposed := q.Dispose() assert.Empty(t, itemsDisposed) q = New(10) q.Put(`1`) itemsDisposed = q.Dispose() expected := []interface{}{`1`} assert.Equal(t, expected, itemsDisposed) itemsDisposed = q.Dispose() assert.Nil(t, itemsDisposed) }]}
{Id:11 FileId:97 StartLine:248 StartColumn:1 EndLine:269 EndColumn:2 Name:TestEmptyGetWithDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	var wg sync.WaitGroup
	wg.Add(1)

	var err error

	go func() {
		wg.Done()
		_, err = q.Get(1)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)

	q.Dispose()

	wg.Wait()

	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) var wg sync.WaitGroup wg.Add(1) var err error go func() { wg.Done() _, err = q.Get(1) wg.Done() }() wg.Wait() wg.Add(1) q.Dispose() wg.Wait() assert.IsType(t, ErrDisposed, err) }]}
{Id:12 FileId:97 StartLine:271 StartColumn:1 EndLine:282 EndColumn:2 Name:TestDisposeAfterEmptyPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	_, err := q.Poll(1, time.Millisecond)
	assert.IsType(t, ErrTimeout, err)

	q.Dispose()

	_, err = q.Poll(1, time.Millisecond)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) _, err := q.Poll(1, time.Millisecond) assert.IsType(t, ErrTimeout, err) q.Dispose() _, err = q.Poll(1, time.Millisecond) assert.IsType(t, ErrDisposed, err) }]}
{Id:13 FileId:97 StartLine:284 StartColumn:1 EndLine:294 EndColumn:2 Name:TestGetPutDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Dispose()

	_, err := q.Get(1)
	assert.IsType(t, ErrDisposed, err)

	err = q.Put(`a`)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() _, err := q.Get(1) assert.IsType(t, ErrDisposed, err) err = q.Put(`a`) assert.IsType(t, ErrDisposed, err) }]}
{Id:14 FileId:97 StartLine:296 StartColumn:1 EndLine:318 EndColumn:2 Name:BenchmarkQueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	q := New(int64(b.N))
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			q.Get(1)
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		q.Put(`a`)
	}

	wg.Wait()
} PrettyPrintBody:[{ q := New(int64(b.N)) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { q.Get(1) i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { q.Put(`a`) } wg.Wait() }]}
{Id:15 FileId:97 StartLine:320 StartColumn:1 EndLine:342 EndColumn:2 Name:BenchmarkChannel Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ch := make(chan interface{}, 1)
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			<-ch
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		ch <- `a`
	}

	wg.Wait()
} PrettyPrintBody:[{ ch := make(chan interface{}, 1) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { <-ch i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { ch <- `a` } wg.Wait() }]}
{Id:16 FileId:97 StartLine:344 StartColumn:1 EndLine:359 EndColumn:2 Name:TestPeek Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`)
	q.Put(`b`)
	q.Put(`c`)
	peekResult, err := q.Peek()
	peekExpected := `a`
	assert.Nil(t, err)
	assert.Equal(t, q.Len(), int64(3))
	assert.Equal(t, peekExpected, peekResult)

	popResult, err := q.Get(1)
	assert.Nil(t, err)
	assert.Equal(t, peekResult, popResult[0])
	assert.Equal(t, q.Len(), int64(2))
} PrettyPrintBody:[{ q := New(10) q.Put(`a`) q.Put(`b`) q.Put(`c`) peekResult, err := q.Peek() peekExpected := `a` assert.Nil(t, err) assert.Equal(t, q.Len(), int64(3)) assert.Equal(t, peekExpected, peekResult) popResult, err := q.Get(1) assert.Nil(t, err) assert.Equal(t, peekResult, popResult[0]) assert.Equal(t, q.Len(), int64(2)) }]}
{Id:17 FileId:97 StartLine:361 StartColumn:1 EndLine:368 EndColumn:2 Name:TestPeekOnDisposedQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Dispose()
	result, err := q.Peek()

	assert.Nil(t, result)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() result, err := q.Peek() assert.Nil(t, result) assert.IsType(t, ErrDisposed, err) }]}
{Id:18 FileId:97 StartLine:370 StartColumn:1 EndLine:383 EndColumn:2 Name:TestTakeUntil Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	result, err := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	if !assert.Nil(t, err) {
		return
	}

	expected := []interface{}{`a`, `b`}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) result, err := q.TakeUntil(func(item interface{}) bool { return item != `c` }) if !assert.Nil(t, err) { return } expected := []interface{}{`a`, `b`} assert.Equal(t, expected, result) }]}
{Id:19 FileId:97 StartLine:385 StartColumn:1 EndLine:397 EndColumn:2 Name:TestTakeUntilEmptyQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	result, err := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	if !assert.Nil(t, err) {
		return
	}

	expected := []interface{}{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ q := New(10) result, err := q.TakeUntil(func(item interface{}) bool { return item != `c` }) if !assert.Nil(t, err) { return } expected := []interface{}{} assert.Equal(t, expected, result) }]}
{Id:20 FileId:97 StartLine:399 StartColumn:1 EndLine:409 EndColumn:2 Name:TestTakeUntilThenGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	takeItems, _ := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	restItems, _ := q.Get(3)
	assert.Equal(t, []interface{}{`a`, `b`}, takeItems)
	assert.Equal(t, []interface{}{`c`}, restItems)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) takeItems, _ := q.TakeUntil(func(item interface{}) bool { return item != `c` }) restItems, _ := q.Get(3) assert.Equal(t, []interface{}{`a`, `b`}, takeItems) assert.Equal(t, []interface{}{`c`}, restItems) }]}
{Id:21 FileId:97 StartLine:411 StartColumn:1 EndLine:421 EndColumn:2 Name:TestTakeUntilNoMatches Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	takeItems, _ := q.TakeUntil(func(item interface{}) bool {
		return item != `a`
	})

	restItems, _ := q.Get(3)
	assert.Equal(t, []interface{}{}, takeItems)
	assert.Equal(t, []interface{}{`a`, `b`, `c`}, restItems)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) takeItems, _ := q.TakeUntil(func(item interface{}) bool { return item != `a` }) restItems, _ := q.Get(3) assert.Equal(t, []interface{}{}, takeItems) assert.Equal(t, []interface{}{`a`, `b`, `c`}, restItems) }]}
{Id:22 FileId:97 StartLine:423 StartColumn:1 EndLine:432 EndColumn:2 Name:TestTakeUntilOnDisposedQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Dispose()
	result, err := q.TakeUntil(func(item interface{}) bool {
		return true
	})

	assert.Nil(t, result)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() result, err := q.TakeUntil(func(item interface{}) bool { return true }) assert.Nil(t, result) assert.IsType(t, ErrDisposed, err) }]}
{Id:23 FileId:97 StartLine:434 StartColumn:1 EndLine:494 EndColumn:2 Name:TestWaiters Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s1, s2, s3, s4 := newSema(), newSema(), newSema(), newSema()

	w := waiters{}
	assert.Len(t, w, 0)

	w.put(s1)
	assert.Equal(t, waiters{s1}, w)

	w.put(s2)
	w.put(s3)
	w.put(s4)
	assert.Equal(t, waiters{s1, s2, s3, s4}, w)

	w.remove(s2)
	assert.Equal(t, waiters{s1, s3, s4}, w)

	w.remove(s2)
	assert.Equal(t, waiters{s1, s3, s4}, w)

	w.remove(s1)
	assert.Equal(t, waiters{s3, s4}, w)

	w.remove(s4)
	assert.Equal(t, waiters{s3}, w)

	w.remove(s3)
	assert.Empty(t, w)

	w.remove(s3)
	assert.Empty(t, w)

	w.put(s1)
	w.put(s2)
	w.put(s3)
	assert.Equal(t, waiters{s1, s2, s3}, w)

	assert.Equal(t, s1, w.get())
	assert.Equal(t, s2, w.get())
	w.put(s4)
	assert.Equal(t, s3, w.get())
	assert.Equal(t, s4, w.get())
	assert.Empty(t, w)
	assert.Nil(t, w.get())
} PrettyPrintBody:[{ s1, s2, s3, s4 := newSema(), newSema(), newSema(), newSema() w := waiters{} assert.Len(t, w, 0) w.put(s1) assert.Equal(t, waiters{s1}, w) w.put(s2) w.put(s3) w.put(s4) assert.Equal(t, waiters{s1, s2, s3, s4}, w) w.remove(s2) assert.Equal(t, waiters{s1, s3, s4}, w) w.remove(s2) assert.Equal(t, waiters{s1, s3, s4}, w) w.remove(s1) assert.Equal(t, waiters{s3, s4}, w) w.remove(s4) assert.Equal(t, waiters{s3}, w) w.remove(s3) assert.Empty(t, w) w.remove(s3) assert.Empty(t, w) w.put(s1) w.put(s2) w.put(s3) assert.Equal(t, waiters{s1, s2, s3}, w) assert.Equal(t, s1, w.get()) assert.Equal(t, s2, w.get()) w.put(s4) assert.Equal(t, s3, w.get()) assert.Equal(t, s4, w.get()) assert.Empty(t, w) assert.Nil(t, w.get()) }]}
{Id:24 FileId:97 StartLine:496 StartColumn:1 EndLine:511 EndColumn:2 Name:TestExecuteInParallel Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	for i := 0; i < 10; i++ {
		q.Put(i)
	}

	numCalls := uint64(0)

	ExecuteInParallel(q, func(item interface{}) {
		t.Logf("ExecuteInParallel called us with %+v", item)
		atomic.AddUint64(&numCalls, 1)
	})

	assert.Equal(t, uint64(10), numCalls)
	assert.True(t, q.Disposed())
} PrettyPrintBody:[{ q := New(10) for i := 0; i < 10; i++ { q.Put(i) } numCalls := uint64(0) ExecuteInParallel(q, func(item interface{}) { t.Logf("ExecuteInParallel called us with %+v", item) atomic.AddUint64(&numCalls, 1) }) assert.Equal(t, uint64(10), numCalls) assert.True(t, q.Disposed()) }]}
{Id:25 FileId:97 StartLine:513 StartColumn:1 EndLine:520 EndColumn:2 Name:TestExecuteInParallelEmptyQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(1)

	ExecuteInParallel(q, func(interface{}) {
		t.Fail()
	})
} PrettyPrintBody:[{ q := New(1) ExecuteInParallel(q, func(interface{}) { t.Fail() }) }]}
{Id:26 FileId:97 StartLine:522 StartColumn:1 EndLine:539 EndColumn:2 Name:BenchmarkQueuePut Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(10)
		qs = append(qs, q)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		q := qs[i]
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(10) qs = append(qs, q) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] for j := int64(0); j < numItems; j++ { q.Put(j) } } }]}
{Id:27 FileId:97 StartLine:541 StartColumn:1 EndLine:562 EndColumn:2 Name:BenchmarkQueueGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		q := qs[i]
		for j := int64(0); j < numItems; j++ {
			q.Get(1)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] for j := int64(0); j < numItems; j++ { q.Get(1) } } }]}
{Id:28 FileId:97 StartLine:564 StartColumn:1 EndLine:584 EndColumn:2 Name:BenchmarkQueuePoll Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	b.ResetTimer()

	for _, q := range qs {
		for j := int64(0); j < numItems; j++ {
			q.Poll(1, time.Millisecond)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } b.ResetTimer() for _, q := range qs { for j := int64(0); j < numItems; j++ { q.Poll(1, time.Millisecond) } } }]}
{Id:29 FileId:97 StartLine:586 StartColumn:1 EndLine:611 EndColumn:2 Name:BenchmarkExecuteInParallel Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	var counter int64
	fn := func(ifc interface{}) {
		c := ifc.(int64)
		atomic.AddInt64(&counter, c)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		q := qs[i]
		ExecuteInParallel(q, fn)
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } var counter int64 fn := func(ifc interface{}) { c := ifc.(int64) atomic.AddInt64(&counter, c) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] ExecuteInParallel(q, fn) } }]}
{Id:1 FileId:7 StartLine:25 StartColumn:1 EndLine:46 EndColumn:2 Name:constructMultiDimensionQueryTestTree Params:[] Results:[{Name: Type:*tree} {Name: Type:Interval} {Name: Type:Interval} {Name: Type:Interval}] Receiver:<nil> Body:{

	it := newTree(2)

	iv1 := constructMultiDimensionInterval(
		0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10},
	)
	it.Add(iv1)

	iv2 := constructMultiDimensionInterval(
		1, &dimension{low: 4, high: 5}, &dimension{low: 4, high: 5},
	)
	it.Add(iv2)

	iv3 := constructMultiDimensionInterval(
		2, &dimension{low: 7, high: 12}, &dimension{low: 7, high: 12},
	)
	it.Add(iv3)

	return it, iv1, iv2, iv3
} PrettyPrintBody:[{ it := newTree(2) iv1 := constructMultiDimensionInterval( 0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10}, ) it.Add(iv1) iv2 := constructMultiDimensionInterval( 1, &dimension{low: 4, high: 5}, &dimension{low: 4, high: 5}, ) it.Add(iv2) iv3 := constructMultiDimensionInterval( 2, &dimension{low: 7, high: 12}, &dimension{low: 7, high: 12}, ) it.Add(iv3) return it, iv1, iv2, iv3 }]}
{Id:2 FileId:7 StartLine:48 StartColumn:1 EndLine:70 EndColumn:2 Name:TestRootAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)
	iv := constructMultiDimensionInterval(
		1, &dimension{low: 0, high: 5}, &dimension{low: 1, high: 6},
	)

	it.Add(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Equal(t, Intervals{iv}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{100, 200}, &dimension{100, 200},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it := newTree(2) iv := constructMultiDimensionInterval( 1, &dimension{low: 0, high: 5}, &dimension{low: 1, high: 6}, ) it.Add(iv) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Equal(t, Intervals{iv}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{100, 200}, &dimension{100, 200}, ), ) assert.Len(t, result, 0) }]}
{Id:3 FileId:7 StartLine:72 StartColumn:1 EndLine:111 EndColumn:2 Name:TestMultipleAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree()

	checkRedBlack(t, it.root, 1)

	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Equal(t, Intervals{iv2, iv1, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{3, 5}, &dimension{3, 5},
		),
	)
	assert.Equal(t, Intervals{iv2}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{5, 8}, &dimension{5, 8},
		),
	)
	assert.Equal(t, Intervals{iv1, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{11, 15}, &dimension{11, 15},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{15, 20}, &dimension{15, 20},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree() checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Equal(t, Intervals{iv2, iv1, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{3, 5}, &dimension{3, 5}, ), ) assert.Equal(t, Intervals{iv2}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{5, 8}, &dimension{5, 8}, ), ) assert.Equal(t, Intervals{iv1, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{11, 15}, &dimension{11, 15}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{15, 20}, &dimension{15, 20}, ), ) assert.Len(t, result, 0) }]}
{Id:4 FileId:7 StartLine:113 StartColumn:1 EndLine:131 EndColumn:2 Name:TestAddRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	for i := int64(0); i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(2) for i := int64(0); i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]}
{Id:5 FileId:7 StartLine:133 StartColumn:1 EndLine:151 EndColumn:2 Name:TestAddRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	for i := int64(9); i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(2) for i := int64(9); i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]}
{Id:6 FileId:7 StartLine:153 StartColumn:1 EndLine:173 EndColumn:2 Name:TestAddRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	starts := []int64{0, 4, 2, 1, 3}

	for i, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), it.Len())
} PrettyPrintBody:[{ it := newTree(2) starts := []int64{0, 4, 2, 1, 3} for i, start := range starts { iv := constructMultiDimensionInterval( uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 5) assert.Equal(t, uint64(5), it.Len()) }]}
{Id:7 FileId:7 StartLine:175 StartColumn:1 EndLine:194 EndColumn:2 Name:TestAddLargeNumbersMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	it := newTree(2)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, numItems}, &dimension{0, numItems},
		),
	)
	assert.Len(t, result, int(numItems))
	assert.Equal(t, uint64(numItems), it.Len())
} PrettyPrintBody:[{ numItems := int64(1000) it := newTree(2) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, numItems}, &dimension{0, numItems}, ), ) assert.Len(t, result, int(numItems)) assert.Equal(t, uint64(numItems), it.Len()) }]}
{Id:8 FileId:7 StartLine:196 StartColumn:1 EndLine:213 EndColumn:2 Name:BenchmarkAddItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(b.N)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	it := newTree(2)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		it.Add(intervals[int64(i)%numItems])
	}
} PrettyPrintBody:[{ numItems := int64(b.N) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } it := newTree(2) b.ResetTimer() for i := 0; i < b.N; i++ { it.Add(intervals[int64(i)%numItems]) } }]}
{Id:9 FileId:7 StartLine:215 StartColumn:1 EndLine:237 EndColumn:2 Name:BenchmarkQueryItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	it := newTree(2)
	it.Add(intervals...)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		it.Query(
			constructMultiDimensionInterval(
				0, &dimension{0, numItems}, &dimension{0, numItems},
			),
		)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } it := newTree(2) it.Add(intervals...) b.ResetTimer() for i := 0; i < b.N; i++ { it.Query( constructMultiDimensionInterval( 0, &dimension{0, numItems}, &dimension{0, numItems}, ), ) } }]}
{Id:10 FileId:7 StartLine:239 StartColumn:1 EndLine:256 EndColumn:2 Name:TestRootDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)
	iv := constructMultiDimensionInterval(
		0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10},
	)
	it.Add(iv)

	it.Delete(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) iv := constructMultiDimensionInterval( 0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10}, ) it.Add(iv) it.Delete(iv) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Len(t, result, 0) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:11 FileId:7 StartLine:258 StartColumn:1 EndLine:299 EndColumn:2 Name:TestDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree()

	checkRedBlack(t, it.root, 1)

	it.Delete(iv1)

	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Equal(t, Intervals{iv2, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{3, 5}, &dimension{3, 5},
		),
	)
	assert.Equal(t, Intervals{iv2}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{5, 8}, &dimension{5, 8},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{11, 15}, &dimension{11, 15},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{15, 20}, &dimension{15, 20},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree() checkRedBlack(t, it.root, 1) it.Delete(iv1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Equal(t, Intervals{iv2, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{3, 5}, &dimension{3, 5}, ), ) assert.Equal(t, Intervals{iv2}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{5, 8}, &dimension{5, 8}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{11, 15}, &dimension{11, 15}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{15, 20}, &dimension{15, 20}, ), ) assert.Len(t, result, 0) }]}
{Id:12 FileId:7 StartLine:301 StartColumn:1 EndLine:326 EndColumn:2 Name:TestDeleteRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	var toDelete *mockInterval

	for i := int64(0); i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(2) var toDelete *mockInterval for i := int64(0); i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]}
{Id:13 FileId:7 StartLine:328 StartColumn:1 EndLine:353 EndColumn:2 Name:TestDeleteRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	var toDelete *mockInterval

	for i := int64(9); i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(2) var toDelete *mockInterval for i := int64(9); i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]}
{Id:14 FileId:7 StartLine:355 StartColumn:1 EndLine:382 EndColumn:2 Name:TestDeleteRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	starts := []int64{0, 4, 2, 1, 3}

	var toDelete *mockInterval

	for i, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1},
		)
		it.Add(iv)
		if start == 1 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), it.Len())
} PrettyPrintBody:[{ it := newTree(2) starts := []int64{0, 4, 2, 1, 3} var toDelete *mockInterval for i, start := range starts { iv := constructMultiDimensionInterval( uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1}, ) it.Add(iv) if start == 1 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 4) assert.Equal(t, uint64(4), it.Len()) }]}
{Id:15 FileId:7 StartLine:384 StartColumn:1 EndLine:393 EndColumn:2 Name:TestDeleteEmptyTreeMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	it.Delete(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) it.Delete( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:16 FileId:7 StartLine:395 StartColumn:1 EndLine:418 EndColumn:2 Name:BenchmarkDeleteItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	trees := make([]*tree, 0, b.N)
	for i := 0; i < b.N; i++ {
		it := newTree(2)
		it.Add(intervals...)
		trees = append(trees, it)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } trees := make([]*tree, 0, b.N) for i := 0; i < b.N; i++ { it := newTree(2) it.Add(intervals...) trees = append(trees, it) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(intervals...) } }]}
{Id:17 FileId:7 StartLine:420 StartColumn:1 EndLine:435 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 10)

	for i := 0; i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 10) for i := 0; i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:18 FileId:7 StartLine:437 StartColumn:1 EndLine:452 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 10)

	for i := 9; i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 10) for i := 9; i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:19 FileId:7 StartLine:454 StartColumn:1 EndLine:470 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 5)
	starts := []int{0, 4, 2, 1, 3}

	for _, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(start), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 5) starts := []int{0, 4, 2, 1, 3} for _, start := range starts { iv := constructMultiDimensionInterval( uint64(start), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]}
{Id:1 FileId:111 StartLine:26 StartColumn:1 EndLine:39 EndColumn:2 Name:constructMultiDimensionalOrderedTree Params:[{Name:number Type:uint64}] Results:[{Name: Type:*orderedTree} {Name: Type:Entries}] Receiver:<nil> Body:{

	tree := newOrderedTree(2)

	entries := make(Entries, 0, number)
	for i := uint64(0); i < number; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree.Add(entries...)

	return tree, entries
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := make(Entries, 0, number) for i := uint64(0); i < number; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree.Add(entries...) return tree, entries }]}
{Id:2 FileId:111 StartLine:41 StartColumn:1 EndLine:48 EndColumn:2 Name:TestOTRootAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(1)

	assert.Equal(t, uint64(1), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(1) assert.Equal(t, uint64(1), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) }]}
{Id:3 FileId:111 StartLine:50 StartColumn:1 EndLine:78 EndColumn:2 Name:TestOTMultipleAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(4)

	assert.Equal(t, uint64(4), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)

	result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4}))
	assert.Equal(t, Entries{entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4}))
	assert.Equal(t, entries, result)

	result = tree.Query(constructMockInterval(dimension{1, 2}, dimension{1, 2}))
	assert.Equal(t, Entries{entries[1], entries[2]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{10, 20}))
	assert.Len(t, result, 0)

	result = tree.Query(constructMockInterval(dimension{10, 20}, dimension{0, 2}))
	assert.Len(t, result, 0)

	result = tree.Query(constructMockInterval(dimension{0, 1}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 1}))
	assert.Equal(t, Entries{entries[0]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(4) assert.Equal(t, uint64(4), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4})) assert.Equal(t, Entries{entries[3]}, result) result = tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})) assert.Equal(t, entries, result) result = tree.Query(constructMockInterval(dimension{1, 2}, dimension{1, 2})) assert.Equal(t, Entries{entries[1], entries[2]}, result) result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{10, 20})) assert.Len(t, result, 0) result = tree.Query(constructMockInterval(dimension{10, 20}, dimension{0, 2})) assert.Len(t, result, 0) result = tree.Query(constructMockInterval(dimension{0, 1}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) result = tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 1})) assert.Equal(t, Entries{entries[0]}, result) }]}
{Id:4 FileId:111 StartLine:80 StartColumn:1 EndLine:87 EndColumn:2 Name:TestOTAddInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(10)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, uint64(10), tree.Len())
	assert.Len(t, result, 10)
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(10) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, uint64(10), tree.Len()) assert.Len(t, result, 10) assert.Equal(t, entries, result) }]}
{Id:5 FileId:111 StartLine:89 StartColumn:1 EndLine:99 EndColumn:2 Name:TestOTAddReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	for i := uint64(10); i > 0; i-- {
		tree.Add(constructMockEntry(i, int64(i), int64(i)))
	}

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) for i := uint64(10); i > 0; i-- { tree.Add(constructMockEntry(i, int64(i), int64(i))) } result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 10) assert.Equal(t, uint64(10), tree.Len()) }]}
{Id:6 FileId:111 StartLine:101 StartColumn:1 EndLine:113 EndColumn:2 Name:TestOTAddRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	starts := []uint64{0, 4, 2, 1, 3}

	for _, start := range starts {
		tree.Add(constructMockEntry(start, int64(start), int64(start)))
	}

	result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5}))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { tree.Add(constructMockEntry(start, int64(start), int64(start))) } result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5})) assert.Len(t, result, 5) assert.Equal(t, uint64(5), tree.Len()) }]}
{Id:7 FileId:111 StartLine:115 StartColumn:1 EndLine:131 EndColumn:2 Name:TestOTAddLargeNumbersMultiDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	tree := newOrderedTree(2)

	for i := uint64(0); i < numItems; i++ {
		tree.Add(constructMockEntry(i, int64(i), int64(i)))
	}

	result := tree.Query(
		constructMockInterval(
			dimension{0, int64(numItems)},
			dimension{0, int64(numItems)},
		),
	)
	assert.Equal(t, numItems, tree.Len())
	assert.Len(t, result, int(numItems))
} PrettyPrintBody:[{ numItems := uint64(1000) tree := newOrderedTree(2) for i := uint64(0); i < numItems; i++ { tree.Add(constructMockEntry(i, int64(i), int64(i))) } result := tree.Query( constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ), ) assert.Equal(t, numItems, tree.Len()) assert.Len(t, result, int(numItems)) }]}
{Id:8 FileId:111 StartLine:133 StartColumn:1 EndLine:157 EndColumn:2 Name:TestOTAddReturnsOverwritten Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	starts := []uint64{0, 4, 2, 1, 3}

	entries := make(Entries, 0, len(starts))
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	overwritten := tree.Add(entries...)

	assert.Equal(t, Entries{nil, nil, nil, nil, nil}, overwritten)

	oldEntry := entries[2]
	newEntry := constructMockEntry(10, oldEntry.ValueAtDimension(1),
		oldEntry.ValueAtDimension(2))
	overwritten = tree.Add(newEntry)

	assert.Equal(t, Entries{oldEntry}, overwritten)

	result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5}))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) starts := []uint64{0, 4, 2, 1, 3} entries := make(Entries, 0, len(starts)) for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } overwritten := tree.Add(entries...) assert.Equal(t, Entries{nil, nil, nil, nil, nil}, overwritten) oldEntry := entries[2] newEntry := constructMockEntry(10, oldEntry.ValueAtDimension(1), oldEntry.ValueAtDimension(2)) overwritten = tree.Add(newEntry) assert.Equal(t, Entries{oldEntry}, overwritten) result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5})) assert.Len(t, result, 5) assert.Equal(t, uint64(5), tree.Len()) }]}
{Id:9 FileId:111 StartLine:159 StartColumn:1 EndLine:174 EndColumn:2 Name:BenchmarkOTAddItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < uint64(numItems); i++ {
		value := rand.Int63()
		entries = append(entries, constructMockEntry(i, value, value))
	}

	rt := newOrderedTree(2)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { value := rand.Int63() entries = append(entries, constructMockEntry(i, value, value)) } rt := newOrderedTree(2) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]}
{Id:10 FileId:111 StartLine:176 StartColumn:1 EndLine:196 EndColumn:2 Name:BenchmarkOTQueryItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < numItems; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree := newOrderedTree(2)
	tree.Add(entries...)
	iv := constructMockInterval(
		dimension{0, int64(numItems)},
		dimension{0, int64(numItems)},
	)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(iv)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) entries := make(Entries, 0, numItems) for i := uint64(0); i < numItems; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree := newOrderedTree(2) tree.Add(entries...) iv := constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(iv) } }]}
{Id:11 FileId:111 StartLine:198 StartColumn:1 EndLine:206 EndColumn:2 Name:TestOTRootDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(1)
	tree.Delete(entries...)

	assert.Equal(t, uint64(0), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 100}, dimension{0, 100}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(1) tree.Delete(entries...) assert.Equal(t, uint64(0), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 100}, dimension{0, 100})) assert.Len(t, result, 0) }]}
{Id:12 FileId:111 StartLine:208 StartColumn:1 EndLine:223 EndColumn:2 Name:TestOTDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(4)

	tree.Delete(entries[2])

	assert.Equal(t, uint64(3), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4}))
	assert.Equal(t, Entries{entries[0], entries[1], entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4}))
	assert.Equal(t, Entries{entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{0, 2}))
	assert.Equal(t, Entries{entries[0], entries[1]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(4) tree.Delete(entries[2]) assert.Equal(t, uint64(3), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})) assert.Equal(t, Entries{entries[0], entries[1], entries[3]}, result) result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4})) assert.Equal(t, Entries{entries[3]}, result) result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{0, 2})) assert.Equal(t, Entries{entries[0], entries[1]}, result) }]}
{Id:13 FileId:111 StartLine:225 StartColumn:1 EndLine:235 EndColumn:2 Name:TestOTDeleteInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(10)

	tree.Delete(entries[5])

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), tree.Len())

	assert.NotContains(t, result, entries[5])
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(10) tree.Delete(entries[5]) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Len(t, result, 9) assert.Equal(t, uint64(9), tree.Len()) assert.NotContains(t, result, entries[5]) }]}
{Id:14 FileId:111 StartLine:237 StartColumn:1 EndLine:254 EndColumn:2 Name:TestOTDeleteReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	for i := uint64(10); i > 0; i-- {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree.Add(entries...)

	tree.Delete(entries[5])

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), tree.Len())

	assert.NotContains(t, result, entries[5])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() for i := uint64(10); i > 0; i-- { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree.Add(entries...) tree.Delete(entries[5]) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 9) assert.Equal(t, uint64(9), tree.Len()) assert.NotContains(t, result, entries[5]) }]}
{Id:15 FileId:111 StartLine:256 StartColumn:1 EndLine:275 EndColumn:2 Name:TestOTDeleteRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	starts := []uint64{0, 4, 2, 1, 3}
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	tree.Add(entries...)

	tree.Delete(entries[2])

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))

	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), tree.Len())

	assert.NotContains(t, result, entries[2])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } tree.Add(entries...) tree.Delete(entries[2]) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 4) assert.Equal(t, uint64(4), tree.Len()) assert.NotContains(t, result, entries[2]) }]}
{Id:16 FileId:111 StartLine:277 StartColumn:1 EndLine:283 EndColumn:2 Name:TestOTDeleteEmptyTreeMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	tree.Delete(constructMockEntry(0, 0, 0))

	assert.Equal(t, uint64(0), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) tree.Delete(constructMockEntry(0, 0, 0)) assert.Equal(t, uint64(0), tree.Len()) }]}
{Id:17 FileId:111 StartLine:285 StartColumn:1 EndLine:306 EndColumn:2 Name:TestOTDeleteReturnsDeleted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	starts := []uint64{0, 4, 2, 1, 3}
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	tree.Add(entries...)

	deleted := tree.Delete(entries[2], constructMockEntry(10, 10, 10))

	assert.Equal(t, Entries{entries[2], nil}, deleted)

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))

	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), tree.Len())

	assert.NotContains(t, result, entries[2])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } tree.Add(entries...) deleted := tree.Delete(entries[2], constructMockEntry(10, 10, 10)) assert.Equal(t, Entries{entries[2], nil}, deleted) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 4) assert.Equal(t, uint64(4), tree.Len()) assert.NotContains(t, result, entries[2]) }]}
{Id:18 FileId:111 StartLine:308 StartColumn:1 EndLine:328 EndColumn:2 Name:BenchmarkOTDeleteItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < numItems; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	trees := make([]*orderedTree, 0, b.N)
	for i := 0; i < b.N; i++ {
		tree := newOrderedTree(2)
		tree.Add(entries...)
		trees = append(trees, tree)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(entries...)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) entries := make(Entries, 0, numItems) for i := uint64(0); i < numItems; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } trees := make([]*orderedTree, 0, b.N) for i := 0; i < b.N; i++ { tree := newOrderedTree(2) tree.Add(entries...) trees = append(trees, tree) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(entries...) } }]}
{Id:19 FileId:111 StartLine:330 StartColumn:1 EndLine:347 EndColumn:2 Name:TestOverwrites Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalOrderedTree(1)

	entry := constructMockEntry(10, 10, 10)

	overwritten := tree.Add(entry)
	assert.Equal(t, Entries{nil}, overwritten)

	results := tree.Query(constructMockInterval(dimension{10, 11}, dimension{10, 11}))

	assert.Equal(t, Entries{entry}, results)
	assert.Equal(t, uint64(2), tree.Len())

	newEntry := constructMockEntry(10, 10, 10)

	overwritten = tree.Add(newEntry)
	assert.Equal(t, Entries{entry}, overwritten)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalOrderedTree(1) entry := constructMockEntry(10, 10, 10) overwritten := tree.Add(entry) assert.Equal(t, Entries{nil}, overwritten) results := tree.Query(constructMockInterval(dimension{10, 11}, dimension{10, 11})) assert.Equal(t, Entries{entry}, results) assert.Equal(t, uint64(2), tree.Len()) newEntry := constructMockEntry(10, 10, 10) overwritten = tree.Add(newEntry) assert.Equal(t, Entries{entry}, overwritten) }]}
{Id:20 FileId:111 StartLine:349 StartColumn:1 EndLine:357 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := tree.Get(entries...)
	assert.Equal(t, entries, result)

	result = tree.Get(constructMockEntry(10000, 5000, 5000))
	assert.Equal(t, Entries{nil}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := tree.Get(entries...) assert.Equal(t, entries, result) result = tree.Get(constructMockEntry(10000, 5000, 5000)) assert.Equal(t, Entries{nil}, result) }]}
{Id:21 FileId:111 StartLine:359 StartColumn:1 EndLine:372 EndColumn:2 Name:TestTreeApply Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := make(Entries, 0, len(entries))

	tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}),
		func(e Entry) bool {
			result = append(result, e)
			return true
		},
	)

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := make(Entries, 0, len(entries)) tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}), func(e Entry) bool { result = append(result, e) return true }, ) assert.Equal(t, entries, result) }]}
{Id:22 FileId:111 StartLine:374 StartColumn:1 EndLine:387 EndColumn:2 Name:TestApplyWithBail Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := make(Entries, 0, 1)

	tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}),
		func(e Entry) bool {
			result = append(result, e)
			return false
		},
	)

	assert.Equal(t, entries[:1], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := make(Entries, 0, 1) tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}), func(e Entry) bool { result = append(result, e) return false }, ) assert.Equal(t, entries[:1], result) }]}
{Id:23 FileId:111 StartLine:389 StartColumn:1 EndLine:404 EndColumn:2 Name:BenchmarkApply Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000

	tree, _ := constructMultiDimensionalOrderedTree(uint64(numItems))

	iv := constructMockInterval(
		dimension{0, int64(numItems)}, dimension{0, int64(numItems)},
	)
	fn := func(Entry) bool { return true }

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Apply(iv, fn)
	}
} PrettyPrintBody:[{ numItems := 1000 tree, _ := constructMultiDimensionalOrderedTree(uint64(numItems)) iv := constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ) fn := func(Entry) bool { return true } b.ResetTimer() for i := 0; i < b.N; i++ { tree.Apply(iv, fn) } }]}
{Id:24 FileId:111 StartLine:406 StartColumn:1 EndLine:415 EndColumn:2 Name:TestInsertPositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	modified, deleted := tree.InsertAtDimension(1, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) modified, deleted := tree.InsertAtDimension(1, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:25 FileId:111 StartLine:417 StartColumn:1 EndLine:426 EndColumn:2 Name:TestInsertPositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:26 FileId:111 StartLine:428 StartColumn:1 EndLine:438 EndColumn:2 Name:TestInsertPositiveIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]}
{Id:27 FileId:111 StartLine:440 StartColumn:1 EndLine:450 EndColumn:2 Name:TestInsertPositiveIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]}
{Id:28 FileId:111 StartLine:452 StartColumn:1 EndLine:461 EndColumn:2 Name:TestInsertMultiplePositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:29 FileId:111 StartLine:463 StartColumn:1 EndLine:472 EndColumn:2 Name:TestInsertMultiplePositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:30 FileId:111 StartLine:474 StartColumn:1 EndLine:487 EndColumn:2 Name:TestInsertNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree.Len()) }]}
{Id:31 FileId:111 StartLine:489 StartColumn:1 EndLine:502 EndColumn:2 Name:TestInsertNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree.Len()) }]}
{Id:32 FileId:111 StartLine:504 StartColumn:1 EndLine:515 EndColumn:2 Name:TestInsertNegativeIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree.Len()) }]}
{Id:33 FileId:111 StartLine:517 StartColumn:1 EndLine:528 EndColumn:2 Name:TestInsertNegativeIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree.Len()) }]}
{Id:34 FileId:111 StartLine:530 StartColumn:1 EndLine:540 EndColumn:2 Name:TestInsertMultipleNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree.Len()) }]}
{Id:35 FileId:111 StartLine:542 StartColumn:1 EndLine:552 EndColumn:2 Name:TestInsertMultipleNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree.Len()) }]}
{Id:36 FileId:111 StartLine:554 StartColumn:1 EndLine:563 EndColumn:2 Name:TestInsertInvalidDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(3, 1, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(3, 1, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]}
{Id:37 FileId:111 StartLine:565 StartColumn:1 EndLine:574 EndColumn:2 Name:TestInsertInvalidNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, 0)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, 0) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]}
{Id:38 FileId:111 StartLine:576 StartColumn:1 EndLine:586 EndColumn:2 Name:BenchmarkInsertFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, 1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, 1) } }]}
{Id:39 FileId:111 StartLine:588 StartColumn:1 EndLine:598 EndColumn:2 Name:BenchmarkInsertSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, 1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, 1) } }]}
{Id:40 FileId:111 StartLine:600 StartColumn:1 EndLine:610 EndColumn:2 Name:BenchmarkDeleteFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, -1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, -1) } }]}
{Id:41 FileId:111 StartLine:612 StartColumn:1 EndLine:622 EndColumn:2 Name:BenchmarkDeleteSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, -1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, -1) } }]}
{Id:42 FileId:111 StartLine:624 StartColumn:1 EndLine:644 EndColumn:2 Name:BenchmarkGetMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItemsX := 10000
	numItemsY := 100

	tree := newOrderedTree(2)
	entries := make(Entries, 0, numItemsY*numItemsX)

	for i := 0; i < numItemsX; i++ {
		for j := 0; j < numItemsY; j++ {
			e := constructMockEntry(uint64(j*numItemsY+i), int64(i), int64(j))
			entries = append(entries, e)
		}
	}

	tree.Add(entries...)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(entries[i%len(entries)])
	}
} PrettyPrintBody:[{ numItemsX := 10000 numItemsY := 100 tree := newOrderedTree(2) entries := make(Entries, 0, numItemsY*numItemsX) for i := 0; i < numItemsX; i++ { for j := 0; j < numItemsY; j++ { e := constructMockEntry(uint64(j*numItemsY+i), int64(i), int64(j)) entries = append(entries, e) } } tree.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(entries[i%len(entries)]) } }]}
{Id:1 FileId:104 StartLine:25 StartColumn:1 EndLine:39 EndColumn:2 Name:TestImmutableSingleDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)

	result := tree.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Len(t, result, 0)

	result = tree2.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Equal(t, Entries{entry}, result)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) result := tree.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Len(t, result, 0) result = tree2.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Equal(t, Entries{entry}, result) }]}
{Id:2 FileId:104 StartLine:41 StartColumn:1 EndLine:64 EndColumn:2 Name:TestImmutableSingleDimensionMultipleAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree1.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree2.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree2.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree1.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree1.Len()) result = tree2.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree2.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) }]}
{Id:3 FileId:104 StartLine:66 StartColumn:1 EndLine:79 EndColumn:2 Name:TestImmutableSingleDimensionBulkAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	entries := Entries{e1, e2, e3}

	tree1 := tree.Add(entries...)

	result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree1.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) entries := Entries{e1, e2, e3} tree1 := tree.Add(entries...) result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree1.Len()) }]}
{Id:4 FileId:104 StartLine:81 StartColumn:1 EndLine:95 EndColumn:2 Name:TestImmutableMultiDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)

	result := tree.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Len(t, result, 0)

	result = tree2.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Equal(t, Entries{entry}, result)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) result := tree.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Len(t, result, 0) result = tree2.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Equal(t, Entries{entry}, result) }]}
{Id:5 FileId:104 StartLine:97 StartColumn:1 EndLine:120 EndColumn:2 Name:TestImmutableMultiDimensionMultipleAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree1.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree2.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree2.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree1.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree1.Len()) result = tree2.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree2.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) }]}
{Id:6 FileId:104 StartLine:122 StartColumn:1 EndLine:135 EndColumn:2 Name:TestImmutableMultiDimensionBulkAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	entries := Entries{e1, e2, e3}

	tree1 := tree.Add(entries...)

	result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree1.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) entries := Entries{e1, e2, e3} tree1 := tree.Add(entries...) result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree1.Len()) }]}
{Id:7 FileId:104 StartLine:137 StartColumn:1 EndLine:154 EndColumn:2 Name:BenchmarkImmutableMultiDimensionInserts Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newImmutableRangeTree(2)
		for _, e := range entries {
			tree = tree.Add(e)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newImmutableRangeTree(2) for _, e := range entries { tree = tree.Add(e) } } }]}
{Id:8 FileId:104 StartLine:156 StartColumn:1 EndLine:171 EndColumn:2 Name:BenchmarkImmutableMultiDimensionBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newImmutableRangeTree(2)
		tree.Add(entries...)
	}
} PrettyPrintBody:[{ numItems := int64(100000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newImmutableRangeTree(2) tree.Add(entries...) } }]}
{Id:9 FileId:104 StartLine:173 StartColumn:1 EndLine:188 EndColumn:2 Name:BenchmarkMultiDimensionBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newOrderedTree(2)
		tree.Add(entries...)
	}
} PrettyPrintBody:[{ numItems := int64(100000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newOrderedTree(2) tree.Add(entries...) } }]}
{Id:10 FileId:104 StartLine:190 StartColumn:1 EndLine:200 EndColumn:2 Name:TestImmutableSingleDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)
	tree3 := tree2.Delete(entry)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree3.Query(iv)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) tree3 := tree2.Delete(entry) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree3.Query(iv) assert.Len(t, result, 0) }]}
{Id:11 FileId:104 StartLine:202 StartColumn:1 EndLine:235 EndColumn:2 Name:TestImmutableSingleDimensionMultipleDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	tree4 := tree3.Delete(e3)
	result := tree4.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree4.Len())

	tree5 := tree4.Delete(e2)
	result = tree5.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree5.Len())

	tree6 := tree5.Delete(e1)
	result = tree6.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree6.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())

	tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3)))
	assert.Equal(t, tree3, tree7)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) tree4 := tree3.Delete(e3) result := tree4.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree4.Len()) tree5 := tree4.Delete(e2) result = tree5.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree5.Len()) tree6 := tree5.Delete(e1) result = tree6.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree6.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3))) assert.Equal(t, tree3, tree7) }]}
{Id:12 FileId:104 StartLine:237 StartColumn:1 EndLine:257 EndColumn:2 Name:TestImmutableSingleDimensionBulkDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1, e2, e3)
	tree2 := tree1.Delete(e2, e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree2.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree2.Len())

	tree3 := tree2.Delete(e1)

	result = tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1, e2, e3) tree2 := tree1.Delete(e2, e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree2.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree2.Len()) tree3 := tree2.Delete(e1) result = tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]}
{Id:13 FileId:104 StartLine:259 StartColumn:1 EndLine:270 EndColumn:2 Name:TestImmutableMultiDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)
	tree3 := tree2.Delete(entry)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) tree3 := tree2.Delete(entry) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]}
{Id:14 FileId:104 StartLine:272 StartColumn:1 EndLine:305 EndColumn:2 Name:TestImmutableMultiDimensionMultipleDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})
	tree4 := tree3.Delete(e3)

	result := tree4.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree4.Len())

	tree5 := tree4.Delete(e2)
	result = tree5.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree5.Len())

	tree6 := tree5.Delete(e1)
	result = tree6.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree6.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())

	tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3)))
	assert.Equal(t, tree3, tree7)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) tree4 := tree3.Delete(e3) result := tree4.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree4.Len()) tree5 := tree4.Delete(e2) result = tree5.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree5.Len()) tree6 := tree5.Delete(e1) result = tree6.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree6.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3))) assert.Equal(t, tree3, tree7) }]}
{Id:15 FileId:104 StartLine:307 StartColumn:1 EndLine:327 EndColumn:2 Name:TestImmutableMultiDimensionBulkDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1, e2, e3)
	tree2 := tree1.Delete(e2, e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree2.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree2.Len())

	tree3 := tree2.Delete(e1)

	result = tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1, e2, e3) tree2 := tree1.Delete(e2, e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree2.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree2.Len()) tree3 := tree2.Delete(e1) result = tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]}
{Id:16 FileId:104 StartLine:329 StartColumn:1 EndLine:337 EndColumn:2 Name:constructMultiDimensionalImmutableTree Params:[{Name:number Type:int64}] Results:[{Name: Type:*immutableRangeTree} {Name: Type:Entries}] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entries := make(Entries, 0, number)
	for i := int64(0); i < number; i++ {
		entries = append(entries, constructMockEntry(uint64(i), i, i))
	}

	return tree.Add(entries...), entries
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entries := make(Entries, 0, number) for i := int64(0); i < number; i++ { entries = append(entries, constructMockEntry(uint64(i), i, i)) } return tree.Add(entries...), entries }]}
{Id:17 FileId:104 StartLine:339 StartColumn:1 EndLine:351 EndColumn:2 Name:TestImmutableInsertPositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(2)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{0, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(2) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{0, 10})) assert.Len(t, result, 0) }]}
{Id:18 FileId:104 StartLine:353 StartColumn:1 EndLine:365 EndColumn:2 Name:TestImmutableInsertPositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[2:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[2:], result) }]}
{Id:19 FileId:104 StartLine:367 StartColumn:1 EndLine:374 EndColumn:2 Name:TestImmutableInsertPositiveIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:20 FileId:104 StartLine:376 StartColumn:1 EndLine:383 EndColumn:2 Name:TestImmutableInsertPositiveIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:21 FileId:104 StartLine:385 StartColumn:1 EndLine:397 EndColumn:2 Name:TestImmutableInsertMultiplePositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Len(t, result, 0) }]}
{Id:22 FileId:104 StartLine:399 StartColumn:1 EndLine:411 EndColumn:2 Name:TestImmutableInsertMultiplePositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Len(t, result, 0) }]}
{Id:23 FileId:104 StartLine:413 StartColumn:1 EndLine:430 EndColumn:2 Name:TestImmutableInsertNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree1.Len()) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) assert.Equal(t, uint64(3), tree.Len()) }]}
{Id:24 FileId:104 StartLine:432 StartColumn:1 EndLine:449 EndColumn:2 Name:TestImmutableInsertNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[2:], result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[2:], result) assert.Equal(t, uint64(3), tree.Len()) }]}
{Id:25 FileId:104 StartLine:451 StartColumn:1 EndLine:458 EndColumn:2 Name:TestImmutableInsertNegativeIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:26 FileId:104 StartLine:460 StartColumn:1 EndLine:467 EndColumn:2 Name:TestImmutableInsertNegativeIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:27 FileId:104 StartLine:469 StartColumn:1 EndLine:482 EndColumn:2 Name:TestImmutableInsertMultipleNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:28 FileId:104 StartLine:484 StartColumn:1 EndLine:497 EndColumn:2 Name:TestImmutableInsertMultipleNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]}
{Id:29 FileId:104 StartLine:499 StartColumn:1 EndLine:506 EndColumn:2 Name:TestImmutableInsertInvalidDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(3, 1, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(3, 1, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:30 FileId:104 StartLine:508 StartColumn:1 EndLine:515 EndColumn:2 Name:TestImmutableInsertInvalidNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 0)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 0) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]}
{Id:31 FileId:104 StartLine:517 StartColumn:1 EndLine:525 EndColumn:2 Name:TestImmutableGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(2)

	result := tree.Get(entries...)
	assert.Equal(t, entries, result)

	result = tree.Get(constructMockEntry(10000, 5000, 5000))
	assert.Equal(t, Entries{nil}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(2) result := tree.Get(entries...) assert.Equal(t, entries, result) result = tree.Get(constructMockEntry(10000, 5000, 5000)) assert.Equal(t, Entries{nil}, result) }]}
{Id:32 FileId:104 StartLine:527 StartColumn:1 EndLine:537 EndColumn:2 Name:BenchmarkImmutableInsertFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	tree, _ := constructMultiDimensionalImmutableTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, 1)
	}
} PrettyPrintBody:[{ numItems := int64(100000) tree, _ := constructMultiDimensionalImmutableTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, 1) } }]}
{Id:33 FileId:104 StartLine:539 StartColumn:1 EndLine:549 EndColumn:2 Name:BenchmarkImmutableInsertSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	tree, _ := constructMultiDimensionalImmutableTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, 1)
	}
} PrettyPrintBody:[{ numItems := int64(100000) tree, _ := constructMultiDimensionalImmutableTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, 1) } }]}
{Id:3 FileId:146 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:defaultHashFactory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return fnv.New32a()
} PrettyPrintBody:[{ return fnv.New32a() }]}
{Id:7 FileId:146 StartLine:80 StartColumn:1 EndLine:86 EndColumn:2 Name:copyToGen Params:[{Name:gen Type:*generation} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*iNode}] Receiver:0xc0012901c0 Body:{
	nin := &iNode{gen: gen}
	main := gcasRead(i, ctrie)
	atomic.StorePointer(
		(*unsafe.Pointer)(unsafe.Pointer(&nin.main)), unsafe.Pointer(main))
	return nin
} PrettyPrintBody:[{ nin := &iNode{gen: gen} main := gcasRead(i, ctrie) atomic.StorePointer( (*unsafe.Pointer)(unsafe.Pointer(&nin.main)), unsafe.Pointer(main)) return nin }]}
{Id:10 FileId:146 StartLine:116 StartColumn:1 EndLine:135 EndColumn:2 Name:newMainNode Params:[{Name:x Type:*sNode} {Name:xhc Type:uint32} {Name:y Type:*sNode} {Name:yhc Type:uint32} {Name:lev Type:uint} {Name:gen Type:*generation}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := newMainNode(x, xhc, y, yhc, lev+w, gen)
			iNode := &iNode{main: main, gen: gen}
			return &mainNode{cNode: &cNode{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &mainNode{cNode: &cNode{bmp, []branch{x, y}, gen}}
		}
		return &mainNode{cNode: &cNode{bmp, []branch{y, x}, gen}}
	}
	l := list.Empty.Add(x).Add(y)
	return &mainNode{lNode: &lNode{l}}
} PrettyPrintBody:[{ if lev < exp2 { xidx := (xhc >> lev) & 0x1f yidx := (yhc >> lev) & 0x1f bmp := uint32((1 << xidx) | (1 << yidx)) if xidx == yidx { main := newMainNode(x, xhc, y, yhc, lev+w, gen) iNode := &iNode{main: main, gen: gen} return &mainNode{cNode: &cNode{bmp, []branch{iNode}, gen}} } if xidx < yidx { return &mainNode{cNode: &cNode{bmp, []branch{x, y}, gen}} } return &mainNode{cNode: &cNode{bmp, []branch{y, x}, gen}} } l := list.Empty.Add(x).Add(y) return &mainNode{lNode: &lNode{l}} }]}
{Id:11 FileId:146 StartLine:139 StartColumn:1 EndLine:151 EndColumn:2 Name:inserted Params:[{Name:pos Type:uint32} {Name:br Type:branch} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc00095a600 Body:{
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &cNode{bmp: bmp | flag, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ length := uint32(len(c.array)) bmp := c.bmp array := make([]branch, length+1) copy(array, c.array) array[pos] = br for i, x := pos, uint32(0); x < length-pos; i++ { array[i+1] = c.array[i] x++ } ncn := &cNode{bmp: bmp | flag, array: array, gen: gen} return ncn }]}
{Id:12 FileId:146 StartLine:155 StartColumn:1 EndLine:161 EndColumn:2 Name:updated Params:[{Name:pos Type:uint32} {Name:br Type:branch} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc0009922a0 Body:{
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &cNode{bmp: c.bmp, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ array := make([]branch, len(c.array)) copy(array, c.array) array[pos] = br ncn := &cNode{bmp: c.bmp, array: array, gen: gen} return ncn }]}
{Id:13 FileId:146 StartLine:165 StartColumn:1 EndLine:178 EndColumn:2 Name:removed Params:[{Name:pos Type:uint32} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc0001e61e0 Body:{
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &cNode{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ length := uint32(len(c.array)) bmp := c.bmp array := make([]branch, length-1) for i := uint32(0); i < pos; i++ { array[i] = c.array[i] } for i, x := pos, uint32(0); x < length-pos-1; i++ { array[i] = c.array[i+1] x++ } ncn := &cNode{bmp: bmp ^ flag, array: array, gen: gen} return ncn }]}
{Id:14 FileId:146 StartLine:182 StartColumn:1 EndLine:193 EndColumn:2 Name:renewed Params:[{Name:gen Type:*generation} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*cNode}] Receiver:0xc0003e5220 Body:{
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *iNode:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &cNode{bmp: c.bmp, array: array, gen: gen}
} PrettyPrintBody:[{ array := make([]branch, len(c.array)) for i, br := range c.array { switch t := br.(type) { case *iNode: array[i] = t.copyToGen(gen, ctrie) default: array[i] = br } } return &cNode{bmp: c.bmp, array: array, gen: gen} }]}
{Id:16 FileId:146 StartLine:202 StartColumn:1 EndLine:204 EndColumn:2 Name:untombed Params:[] Results:[{Name: Type:*sNode}] Receiver:0xc001603060 Body:{
	return &sNode{&Entry{Key: t.Key, hash: t.hash, Value: t.Value}}
} PrettyPrintBody:[{ return &sNode{&Entry{Key: t.Key, hash: t.hash, Value: t.Value}} }]}
{Id:18 FileId:146 StartLine:213 StartColumn:1 EndLine:216 EndColumn:2 Name:entry Params:[] Results:[{Name: Type:*sNode}] Receiver:0xc0016032e0 Body:{
	head, _ := l.Head()
	return head.(*sNode)
} PrettyPrintBody:[{ head, _ := l.Head() return head.(*sNode) }]}
{Id:19 FileId:146 StartLine:220 StartColumn:1 EndLine:228 EndColumn:2 Name:lookup Params:[{Name:e Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc00095af40 Body:{
	found, ok := l.Find(func(sn interface{}) bool {
		return bytes.Equal(e.Key, sn.(*sNode).Key)
	})
	if !ok {
		return nil, false
	}
	return found.(*sNode).Value, true
} PrettyPrintBody:[{ found, ok := l.Find(func(sn interface{}) bool { return bytes.Equal(e.Key, sn.(*sNode).Key) }) if !ok { return nil, false } return found.(*sNode).Value, true }]}
{Id:20 FileId:146 StartLine:231 StartColumn:1 EndLine:233 EndColumn:2 Name:inserted Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:*lNode}] Receiver:0xc0001e66a0 Body:{
	return &lNode{l.removed(entry).Add(&sNode{entry})}
} PrettyPrintBody:[{ return &lNode{l.removed(entry).Add(&sNode{entry})} }]}
{Id:21 FileId:146 StartLine:236 StartColumn:1 EndLine:245 EndColumn:2 Name:removed Params:[{Name:e Type:*Entry}] Results:[{Name: Type:*lNode}] Receiver:0xc00095b0a0 Body:{
	idx := l.FindIndex(func(sn interface{}) bool {
		return bytes.Equal(e.Key, sn.(*sNode).Key)
	})
	if idx < 0 {
		return l
	}
	nl, _ := l.Remove(uint(idx))
	return &lNode{nl}
} PrettyPrintBody:[{ idx := l.FindIndex(func(sn interface{}) bool { return bytes.Equal(e.Key, sn.(*sNode).Key) }) if idx < 0 { return l } nl, _ := l.Remove(uint(idx)) return &lNode{nl} }]}
{Id:22 FileId:146 StartLine:248 StartColumn:1 EndLine:250 EndColumn:2 Name:length Params:[] Results:[{Name: Type:uint}] Receiver:0xc001603600 Body:{
	return l.Length()
} PrettyPrintBody:[{ return l.Length() }]}
{Id:26 FileId:146 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:New Params:[{Name:hashFactory Type:HashFactory}] Results:[{Name: Type:*Ctrie}] Receiver:<nil> Body:{
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &iNode{main: &mainNode{cNode: &cNode{}}}
	return newCtrie(root, hashFactory, false)
} PrettyPrintBody:[{ if hashFactory == nil { hashFactory = defaultHashFactory } root := &iNode{main: &mainNode{cNode: &cNode{}}} return newCtrie(root, hashFactory, false) }]}
{Id:27 FileId:146 StartLine:277 StartColumn:1 EndLine:283 EndColumn:2 Name:newCtrie Params:[{Name:root Type:*iNode} {Name:hashFactory Type:HashFactory} {Name:readOnly Type:bool}] Results:[{Name: Type:*Ctrie}] Receiver:<nil> Body:{
	return &Ctrie{
		root:		root,
		hashFactory:	hashFactory,
		readOnly:	readOnly,
	}
} PrettyPrintBody:[{ return &Ctrie{ root:		root, hashFactory:	hashFactory, readOnly:	readOnly, } }]}
{Id:28 FileId:146 StartLine:287 StartColumn:1 EndLine:294 EndColumn:2 Name:Insert Params:[{Name:key Type:[]byte} {Name:value Type:interface{}}] Results:[] Receiver:0xc001603740 Body:{
	c.assertReadWrite()
	c.insert(&Entry{
		Key:	key,
		Value:	value,
		hash:	c.hash(key),
	})
} PrettyPrintBody:[{ c.assertReadWrite() c.insert(&Entry{ Key:	key, Value:	value, hash:	c.hash(key), }) }]}
{Id:29 FileId:146 StartLine:298 StartColumn:1 EndLine:300 EndColumn:2 Name:Lookup Params:[{Name:key Type:[]byte}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000a8b9a0 Body:{
	return c.lookup(&Entry{Key: key, hash: c.hash(key)})
} PrettyPrintBody:[{ return c.lookup(&Entry{Key: key, hash: c.hash(key)}) }]}
{Id:30 FileId:146 StartLine:304 StartColumn:1 EndLine:307 EndColumn:2 Name:Remove Params:[{Name:key Type:[]byte}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000a8bb40 Body:{
	c.assertReadWrite()
	return c.remove(&Entry{Key: key, hash: c.hash(key)})
} PrettyPrintBody:[{ c.assertReadWrite() return c.remove(&Entry{Key: key, hash: c.hash(key)}) }]}
{Id:31 FileId:146 StartLine:311 StartColumn:1 EndLine:313 EndColumn:2 Name:Snapshot Params:[] Results:[{Name: Type:*Ctrie}] Receiver:0xc00095b440 Body:{
	return c.snapshot(c.readOnly)
} PrettyPrintBody:[{ return c.snapshot(c.readOnly) }]}
{Id:32 FileId:146 StartLine:317 StartColumn:1 EndLine:319 EndColumn:2 Name:ReadOnlySnapshot Params:[] Results:[{Name: Type:*Ctrie}] Receiver:0xc000992480 Body:{
	return c.snapshot(true)
} PrettyPrintBody:[{ return c.snapshot(true) }]}
{Id:33 FileId:146 StartLine:322 StartColumn:1 EndLine:340 EndColumn:2 Name:snapshot Params:[{Name:readOnly Type:bool}] Results:[{Name: Type:*Ctrie}] Receiver:0xc0001e6ce0 Body:{
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := gcasRead(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return newCtrie(root, c.hashFactory, readOnly)
			}

			return newCtrie(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
} PrettyPrintBody:[{ if readOnly && c.readOnly { return c } for { root := c.readRoot() main := gcasRead(root, c) if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) { if readOnly { return newCtrie(root, c.hashFactory, readOnly) } return newCtrie(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly) } } }]}
{Id:34 FileId:146 StartLine:343 StartColumn:1 EndLine:355 EndColumn:2 Name:Clear Params:[] Results:[] Receiver:0xc000258280 Body:{
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &iNode{
			main:	&mainNode{cNode: &cNode{array: make([]branch, 0), gen: gen}},
			gen:	gen,
		}
		if c.rdcssRoot(root, gcasRead(root, c), newRoot) {
			return
		}
	}
} PrettyPrintBody:[{ for { root := c.readRoot() gen := &generation{} newRoot := &iNode{ main:	&mainNode{cNode: &cNode{array: make([]branch, 0), gen: gen}}, gen:	gen, } if c.rdcssRoot(root, gcasRead(root, c), newRoot) { return } } }]}
{Id:35 FileId:146 StartLine:361 StartColumn:1 EndLine:369 EndColumn:2 Name:Iterator Params:[{Name:cancel Type:<-chan struct{}}] Results:[{Name: Type:<-chan *Entry}] Receiver:0xc0000edaa0 Body:{
	ch := make(chan *Entry)
	snapshot := c.ReadOnlySnapshot()
	go func() {
		snapshot.traverse(snapshot.readRoot(), ch, cancel)
		close(ch)
	}()
	return ch
} PrettyPrintBody:[{ ch := make(chan *Entry) snapshot := c.ReadOnlySnapshot() go func() { snapshot.traverse(snapshot.readRoot(), ch, cancel) close(ch) }() return ch }]}
{Id:36 FileId:146 StartLine:372 StartColumn:1 EndLine:383 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint}] Receiver:0xc000259380 Body:{

	size := uint(0)
	for _ = range c.Iterator(nil) {
		size++
	}
	return size
} PrettyPrintBody:[{ size := uint(0) for _ = range c.Iterator(nil) { size++ } return size }]}
{Id:38 FileId:146 StartLine:387 StartColumn:1 EndLine:423 EndColumn:2 Name:traverse Params:[{Name:i Type:*iNode} {Name:ch Type:chan<- *Entry} {Name:cancel Type:<-chan struct{}}] Results:[{Name: Type:error}] Receiver:0xc000259720 Body:{
	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		for _, br := range main.cNode.array {
			switch b := br.(type) {
			case *iNode:
				if err := c.traverse(b, ch, cancel); err != nil {
					return err
				}
			case *sNode:
				select {
				case ch <- b.Entry:
				case <-cancel:
					return errCanceled
				}
			}
		}
	case main.lNode != nil:
		for _, e := range main.lNode.Map(func(sn interface{}) interface{} {
			return sn.(*sNode).Entry
		}) {
			select {
			case ch <- e.(*Entry):
			case <-cancel:
				return errCanceled
			}
		}
	case main.tNode != nil:
		select {
		case ch <- main.tNode.Entry:
		case <-cancel:
			return errCanceled
		}
	}
	return nil
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: for _, br := range main.cNode.array { switch b := br.(type) { case *iNode: if err := c.traverse(b, ch, cancel); err != nil { return err } case *sNode: select { case ch <- b.Entry: case <-cancel: return errCanceled } } } case main.lNode != nil: for _, e := range main.lNode.Map(func(sn interface{}) interface{} { return sn.(*sNode).Entry }) { select { case ch <- e.(*Entry): case <-cancel: return errCanceled } } case main.tNode != nil: select { case ch <- main.tNode.Entry: case <-cancel: return errCanceled } } return nil }]}
{Id:39 FileId:146 StartLine:425 StartColumn:1 EndLine:429 EndColumn:2 Name:assertReadWrite Params:[] Results:[] Receiver:0xc000259d40 Body:{
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
} PrettyPrintBody:[{ if c.readOnly { panic("Cannot modify read-only snapshot") } }]}
{Id:40 FileId:146 StartLine:431 StartColumn:1 EndLine:436 EndColumn:2 Name:insert Params:[{Name:entry Type:*Entry}] Results:[] Receiver:0xc00095bac0 Body:{
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
} PrettyPrintBody:[{ root := c.readRoot() if !c.iinsert(root, entry, 0, nil, root.gen) { c.insert(entry) } }]}
{Id:41 FileId:146 StartLine:438 StartColumn:1 EndLine:445 EndColumn:2 Name:lookup Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc00019ec80 Body:{
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
} PrettyPrintBody:[{ root := c.readRoot() result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen) for !ok { return c.lookup(entry) } return result, exists }]}
{Id:42 FileId:146 StartLine:447 StartColumn:1 EndLine:454 EndColumn:2 Name:remove Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0000edf40 Body:{
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
} PrettyPrintBody:[{ root := c.readRoot() result, exists, ok := c.iremove(root, entry, 0, nil, root.gen) for !ok { return c.remove(entry) } return result, exists }]}
{Id:43 FileId:146 StartLine:456 StartColumn:1 EndLine:460 EndColumn:2 Name:hash Params:[{Name:k Type:[]byte}] Results:[{Name: Type:uint32}] Receiver:0xc0000edfa0 Body:{
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
} PrettyPrintBody:[{ hasher := c.hashFactory() hasher.Write(k) return hasher.Sum32() }]}
{Id:44 FileId:146 StartLine:464 StartColumn:1 EndLine:532 EndColumn:2 Name:iinsert Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:bool}] Receiver:0xc001603f60 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &mainNode{cNode: rn.inserted(pos, flag, &sNode{entry}, i.gen)}
			return gcas(i, main, ncn, c)
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if startGen == in.gen {
				return c.iinsert(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *sNode:
			sn := branch.(*sNode)
			if !bytes.Equal(sn.Key, entry.Key) {

				rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &sNode{entry}
				nin := &iNode{main: newMainNode(sn, sn.hash, nsn, nsn.hash, lev+w, i.gen), gen: i.gen}
				ncn := &mainNode{cNode: rn.updated(pos, nin, i.gen)}
				return gcas(i, main, ncn, c)
			}

			ncn := &mainNode{cNode: cn.updated(pos, &sNode{entry}, i.gen)}
			return gcas(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		clean(parent, lev-w, c)
		return false
	case main.lNode != nil:
		nln := &mainNode{lNode: main.lNode.inserted(entry)}
		return gcas(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { rn := cn if cn.gen != i.gen { rn = cn.renewed(i.gen, c) } ncn := &mainNode{cNode: rn.inserted(pos, flag, &sNode{entry}, i.gen)} return gcas(i, main, ncn, c) } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if startGen == in.gen { return c.iinsert(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.iinsert(i, entry, lev, parent, startGen) } return false case *sNode: sn := branch.(*sNode) if !bytes.Equal(sn.Key, entry.Key) { rn := cn if cn.gen != i.gen { rn = cn.renewed(i.gen, c) } nsn := &sNode{entry} nin := &iNode{main: newMainNode(sn, sn.hash, nsn, nsn.hash, lev+w, i.gen), gen: i.gen} ncn := &mainNode{cNode: rn.updated(pos, nin, i.gen)} return gcas(i, main, ncn, c) } ncn := &mainNode{cNode: cn.updated(pos, &sNode{entry}, i.gen)} return gcas(i, main, ncn, c) default: panic("Ctrie is in an invalid state") } case main.tNode != nil: clean(parent, lev-w, c) return false case main.lNode != nil: nln := &mainNode{lNode: main.lNode.inserted(entry)} return gcas(i, main, nln, c) default: panic("Ctrie is in an invalid state") } }]}
{Id:45 FileId:146 StartLine:538 StartColumn:1 EndLine:588 EndColumn:2 Name:ilookup Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:interface{}} {Name: Type:bool} {Name: Type:bool}] Receiver:0xc000a8ac20 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			return nil, false, true
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return nil, false, false
		case *sNode:

			sn := branch.(*sNode)
			if bytes.Equal(sn.Key, entry.Key) {
				return sn.Value, true, true
			}
			return nil, false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return cleanReadOnly(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

		val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { return nil, false, true } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if c.readOnly || startGen == in.gen { return c.ilookup(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.ilookup(i, entry, lev, parent, startGen) } return nil, false, false case *sNode: sn := branch.(*sNode) if bytes.Equal(sn.Key, entry.Key) { return sn.Value, true, true } return nil, false, true default: panic("Ctrie is in an invalid state") } case main.tNode != nil: return cleanReadOnly(main.tNode, lev, parent, c, entry) case main.lNode != nil: val, ok := main.lNode.lookup(entry) return val, ok, true default: panic("Ctrie is in an invalid state") } }]}
{Id:46 FileId:146 StartLine:594 StartColumn:1 EndLine:665 EndColumn:2 Name:iremove Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:interface{}} {Name: Type:bool} {Name: Type:bool}] Receiver:0xc0006b8280 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			return nil, false, true
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return nil, false, false
		case *sNode:

			sn := branch.(*sNode)
			if !bytes.Equal(sn.Key, entry.Key) {

				return nil, false, true
			}

			ncn := cn.removed(pos, flag, i.gen)
			cntr := toContracted(ncn, lev)
			if gcas(i, main, cntr, c) {
				if parent != nil {
					main = gcasRead(i, c)
					if main.tNode != nil {
						cleanParent(parent, i, entry.hash, lev-w, c, startGen)
					}
				}
				return sn.Value, true, true
			}
			return nil, false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		clean(parent, lev-w, c)
		return nil, false, false
	case main.lNode != nil:
		nln := &mainNode{lNode: main.lNode.removed(entry)}
		if nln.lNode.length() == 1 {
			nln = entomb(nln.lNode.entry())
		}
		if gcas(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return nil, false, true
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { return nil, false, true } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if startGen == in.gen { return c.iremove(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.iremove(i, entry, lev, parent, startGen) } return nil, false, false case *sNode: sn := branch.(*sNode) if !bytes.Equal(sn.Key, entry.Key) { return nil, false, true } ncn := cn.removed(pos, flag, i.gen) cntr := toContracted(ncn, lev) if gcas(i, main, cntr, c) { if parent != nil { main = gcasRead(i, c) if main.tNode != nil { cleanParent(parent, i, entry.hash, lev-w, c, startGen) } } return sn.Value, true, true } return nil, false, false default: panic("Ctrie is in an invalid state") } case main.tNode != nil: clean(parent, lev-w, c) return nil, false, false case main.lNode != nil: nln := &mainNode{lNode: main.lNode.removed(entry)} if nln.lNode.length() == 1 { nln = entomb(nln.lNode.entry()) } if gcas(i, main, nln, c) { val, ok := main.lNode.lookup(entry) return val, ok, true } return nil, false, true default: panic("Ctrie is in an invalid state") } }]}
{Id:47 FileId:146 StartLine:671 StartColumn:1 EndLine:682 EndColumn:2 Name:toContracted Params:[{Name:cn Type:*cNode} {Name:lev Type:uint}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	if lev > 0 && len(cn.array) == 1 {
		branch := cn.array[0]
		switch branch.(type) {
		case *sNode:
			return entomb(branch.(*sNode))
		default:
			return &mainNode{cNode: cn}
		}
	}
	return &mainNode{cNode: cn}
} PrettyPrintBody:[{ if lev > 0 && len(cn.array) == 1 { branch := cn.array[0] switch branch.(type) { case *sNode: return entomb(branch.(*sNode)) default: return &mainNode{cNode: cn} } } return &mainNode{cNode: cn} }]}
{Id:48 FileId:146 StartLine:685 StartColumn:1 EndLine:702 EndColumn:2 Name:toCompressed Params:[{Name:cn Type:*cNode} {Name:lev Type:uint}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub.(type) {
		case *iNode:
			inode := sub.(*iNode)
			mainPtr := (*unsafe.Pointer)(unsafe.Pointer(&inode.main))
			main := (*mainNode)(atomic.LoadPointer(mainPtr))
			tmpArray[i] = resurrect(inode, main)
		case *sNode:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return toContracted(&cNode{bmp: cn.bmp, array: tmpArray}, lev)
} PrettyPrintBody:[{ tmpArray := make([]branch, len(cn.array)) for i, sub := range cn.array { switch sub.(type) { case *iNode: inode := sub.(*iNode) mainPtr := (*unsafe.Pointer)(unsafe.Pointer(&inode.main)) main := (*mainNode)(atomic.LoadPointer(mainPtr)) tmpArray[i] = resurrect(inode, main) case *sNode: tmpArray[i] = sub default: panic("Ctrie is in an invalid state") } } return toContracted(&cNode{bmp: cn.bmp, array: tmpArray}, lev) }]}
{Id:49 FileId:146 StartLine:704 StartColumn:1 EndLine:706 EndColumn:2 Name:entomb Params:[{Name:m Type:*sNode}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	return &mainNode{tNode: &tNode{m}}
} PrettyPrintBody:[{ return &mainNode{tNode: &tNode{m}} }]}
{Id:50 FileId:146 StartLine:708 StartColumn:1 EndLine:713 EndColumn:2 Name:resurrect Params:[{Name:iNode Type:*iNode} {Name:main Type:*mainNode}] Results:[{Name: Type:branch}] Receiver:<nil> Body:{
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
} PrettyPrintBody:[{ if main.tNode != nil { return main.tNode.untombed() } return iNode }]}
{Id:51 FileId:146 StartLine:715 StartColumn:1 EndLine:721 EndColumn:2 Name:clean Params:[{Name:i Type:*iNode} {Name:lev Type:uint} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	main := gcasRead(i, ctrie)
	if main.cNode != nil {
		return gcas(i, main, toCompressed(main.cNode, lev), ctrie)
	}
	return true
} PrettyPrintBody:[{ main := gcasRead(i, ctrie) if main.cNode != nil { return gcas(i, main, toCompressed(main.cNode, lev), ctrie) } return true }]}
{Id:52 FileId:146 StartLine:723 StartColumn:1 EndLine:732 EndColumn:2 Name:cleanReadOnly Params:[{Name:tn Type:*tNode} {Name:lev Type:uint} {Name:p Type:*iNode} {Name:ctrie Type:*Ctrie} {Name:entry Type:*Entry}] Results:[{Name:val Type:interface{}} {Name:exists Type:bool} {Name:ok Type:bool}] Receiver:<nil> Body:{
	if !ctrie.readOnly {
		clean(p, lev-5, ctrie)
		return nil, false, false
	}
	if tn.hash == entry.hash && bytes.Equal(tn.Key, entry.Key) {
		return tn.Value, true, true
	}
	return nil, false, true
} PrettyPrintBody:[{ if !ctrie.readOnly { clean(p, lev-5, ctrie) return nil, false, false } if tn.hash == entry.hash && bytes.Equal(tn.Key, entry.Key) { return tn.Value, true, true } return nil, false, true }]}
{Id:53 FileId:146 StartLine:734 StartColumn:1 EndLine:753 EndColumn:2 Name:cleanParent Params:[{Name:p Type:*iNode} {Name:hc Type:uint32} {Name:lev Type:uint} {Name:ctrie Type:*Ctrie} {Name:startGen Type:*generation}] Results:[] Receiver:<nil> Body:{
	var (
		mainPtr		= (*unsafe.Pointer)(unsafe.Pointer(&i.main))
		main		= (*mainNode)(atomic.LoadPointer(mainPtr))
		pMainPtr	= (*unsafe.Pointer)(unsafe.Pointer(&p.main))
		pMain		= (*mainNode)(atomic.LoadPointer(pMainPtr))
	)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, resurrect(i, main), i.gen)
				if !gcas(p, pMain, toContracted(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
					cleanParent(p, i, hc, lev, ctrie, startGen)
				}
			}
		}
	}
} PrettyPrintBody:[{ var ( mainPtr		= (*unsafe.Pointer)(unsafe.Pointer(&i.main)) main		= (*mainNode)(atomic.LoadPointer(mainPtr)) pMainPtr	= (*unsafe.Pointer)(unsafe.Pointer(&p.main)) pMain		= (*mainNode)(atomic.LoadPointer(pMainPtr)) ) if pMain.cNode != nil { flag, pos := flagPos(hc, lev, pMain.cNode.bmp) if pMain.cNode.bmp&flag != 0 { sub := pMain.cNode.array[pos] if sub == i && main.tNode != nil { ncn := pMain.cNode.updated(pos, resurrect(i, main), i.gen) if !gcas(p, pMain, toContracted(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen { cleanParent(p, i, hc, lev, ctrie, startGen) } } } } }]}
{Id:54 FileId:146 StartLine:755 StartColumn:1 EndLine:761 EndColumn:2 Name:flagPos Params:[{Name:hashcode Type:uint32} {Name:lev Type:uint} {Name:bmp Type:uint32}] Results:[{Name: Type:uint32} {Name: Type:uint32}] Receiver:<nil> Body:{
	idx := (hashcode >> lev) & 0x1f
	flag := uint32(1) << uint32(idx)
	mask := uint32(flag - 1)
	pos := bitCount(bmp & mask)
	return flag, pos
} PrettyPrintBody:[{ idx := (hashcode >> lev) & 0x1f flag := uint32(1) << uint32(idx) mask := uint32(flag - 1) pos := bitCount(bmp & mask) return flag, pos }]}
{Id:55 FileId:146 StartLine:763 StartColumn:1 EndLine:769 EndColumn:2 Name:bitCount Params:[{Name:x Type:uint32}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	x -= (x >> 1) & 0x55555555
	x = ((x >> 2) & 0x33333333) + (x & 0x33333333)
	x = ((x >> 4) + x) & 0x0f0f0f0f
	x *= 0x01010101
	return x >> 24
} PrettyPrintBody:[{ x -= (x >> 1) & 0x55555555 x = ((x >> 2) & 0x33333333) + (x & 0x33333333) x = ((x >> 4) + x) & 0x0f0f0f0f x *= 0x01010101 return x >> 24 }]}
{Id:56 FileId:146 StartLine:776 StartColumn:1 EndLine:786 EndColumn:2 Name:gcas Params:[{Name:in Type:*iNode} {Name:old Type:*mainNode} {Name:ct Type:*Ctrie}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	prevPtr := (*unsafe.Pointer)(unsafe.Pointer(&n.prev))
	atomic.StorePointer(prevPtr, unsafe.Pointer(old))
	if atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&in.main)),
		unsafe.Pointer(old), unsafe.Pointer(n)) {
		gcasComplete(in, n, ct)
		return atomic.LoadPointer(prevPtr) == nil
	}
	return false
} PrettyPrintBody:[{ prevPtr := (*unsafe.Pointer)(unsafe.Pointer(&n.prev)) atomic.StorePointer(prevPtr, unsafe.Pointer(old)) if atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&in.main)), unsafe.Pointer(old), unsafe.Pointer(n)) { gcasComplete(in, n, ct) return atomic.LoadPointer(prevPtr) == nil } return false }]}
{Id:57 FileId:146 StartLine:789 StartColumn:1 EndLine:796 EndColumn:2 Name:gcasRead Params:[{Name:in Type:*iNode} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	m := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&in.main))))
	prev := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&m.prev))))
	if prev == nil {
		return m
	}
	return gcasComplete(in, m, ctrie)
} PrettyPrintBody:[{ m := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&in.main)))) prev := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&m.prev)))) if prev == nil { return m } return gcasComplete(in, m, ctrie) }]}
{Id:58 FileId:146 StartLine:799 StartColumn:1 EndLine:841 EndColumn:2 Name:gcasComplete Params:[{Name:i Type:*iNode} {Name:m Type:*mainNode} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	for {
		if m == nil {
			return nil
		}
		prev := (*mainNode)(atomic.LoadPointer(
			(*unsafe.Pointer)(unsafe.Pointer(&m.prev))))
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)),
				unsafe.Pointer(m), unsafe.Pointer(fn)) {
				return fn
			}
			m = (*mainNode)(atomic.LoadPointer(
				(*unsafe.Pointer)(unsafe.Pointer(&i.main))))
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if atomic.CompareAndSwapPointer(
				(*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), nil) {
				return m
			}
			continue
		}

		atomic.CompareAndSwapPointer(
			(*unsafe.Pointer)(unsafe.Pointer(&m.prev)),
			unsafe.Pointer(prev),
			unsafe.Pointer(&mainNode{failed: prev}))
		m = (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main))))
		return gcasComplete(i, m, ctrie)
	}
} PrettyPrintBody:[{ for { if m == nil { return nil } prev := (*mainNode)(atomic.LoadPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)))) root := ctrie.rdcssReadRoot(true) if prev == nil { return m } if prev.failed != nil { fn := prev.failed if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)), unsafe.Pointer(m), unsafe.Pointer(fn)) { return fn } m = (*mainNode)(atomic.LoadPointer( (*unsafe.Pointer)(unsafe.Pointer(&i.main)))) continue } if root.gen == i.gen && !ctrie.readOnly { if atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), nil) { return m } continue } atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), unsafe.Pointer(&mainNode{failed: prev})) m = (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)))) return gcasComplete(i, m, ctrie) } }]}
{Id:60 FileId:146 StartLine:856 StartColumn:1 EndLine:858 EndColumn:2 Name:readRoot Params:[] Results:[{Name: Type:*iNode}] Receiver:0xc00019f540 Body:{
	return c.rdcssReadRoot(false)
} PrettyPrintBody:[{ return c.rdcssReadRoot(false) }]}
{Id:61 FileId:146 StartLine:862 StartColumn:1 EndLine:868 EndColumn:2 Name:rdcssReadRoot Params:[{Name:abort Type:bool}] Results:[{Name: Type:*iNode}] Receiver:0xc00019f5a0 Body:{
	r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root))))
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
} PrettyPrintBody:[{ r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root)))) if r.rdcss != nil { return c.rdcssComplete(abort) } return r }]}
{Id:62 FileId:146 StartLine:873 StartColumn:1 EndLine:886 EndColumn:2 Name:rdcssRoot Params:[{Name:old Type:*iNode} {Name:expected Type:*mainNode} {Name:nv Type:*iNode}] Results:[{Name: Type:bool}] Receiver:0xc00019f5e0 Body:{
	desc := &iNode{
		rdcss: &rdcssDescriptor{
			old:		old,
			expected:	expected,
			nv:		nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return atomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
} PrettyPrintBody:[{ desc := &iNode{ rdcss: &rdcssDescriptor{ old:		old, expected:	expected, nv:		nv, }, } if c.casRoot(old, desc) { c.rdcssComplete(false) return atomic.LoadInt32(&desc.rdcss.committed) == 1 } return false }]}
{Id:63 FileId:146 StartLine:889 StartColumn:1 EndLine:924 EndColumn:2 Name:rdcssComplete Params:[{Name:abort Type:bool}] Results:[{Name: Type:*iNode}] Receiver:0xc0003e4100 Body:{
	for {
		r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root))))
		if r.rdcss == nil {
			return r
		}

		var (
			desc	= r.rdcss
			ov	= desc.old
			exp	= desc.expected
			nv	= desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := gcasRead(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				atomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
} PrettyPrintBody:[{ for { r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root)))) if r.rdcss == nil { return r } var ( desc	= r.rdcss ov	= desc.old exp	= desc.expected nv	= desc.nv ) if abort { if c.casRoot(r, ov) { return ov } continue } oldeMain := gcasRead(ov, c) if oldeMain == exp { if c.casRoot(r, nv) { atomic.StoreInt32(&desc.committed, 1) return nv } continue } if c.casRoot(r, ov) { return ov } continue } }]}
{Id:64 FileId:146 StartLine:927 StartColumn:1 EndLine:931 EndColumn:2 Name:casRoot Params:[{Name:ov Type:*iNode}] Results:[{Name: Type:bool}] Receiver:0xc000a8b060 Body:{
	c.assertReadWrite()
	return atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&c.root)), unsafe.Pointer(ov), unsafe.Pointer(nv))
} PrettyPrintBody:[{ c.assertReadWrite() return atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&c.root)), unsafe.Pointer(ov), unsafe.Pointer(nv)) }]}
{Id:2 FileId:50 StartLine:36 StartColumn:1 EndLine:49 EndColumn:2 Name:Save Params:[{Name:items Type:...*Payload}] Results:[{Name: Type:error}] Receiver:0xc00129bb20 Body:{
	e.lock.Lock()
	defer e.lock.Unlock()

	if len(items) == 0 {
		return nil
	}

	for _, item := range items {
		e.mp[string(item.Key)] = item
	}

	return nil
} PrettyPrintBody:[{ e.lock.Lock() defer e.lock.Unlock() if len(items) == 0 { return nil } for _, item := range items { e.mp[string(item.Key)] = item } return nil }]}
{Id:3 FileId:50 StartLine:51 StartColumn:1 EndLine:65 EndColumn:2 Name:Load Params:[{Name:keys Type:...[]byte}] Results:[{Name: Type:[]*Payload} {Name: Type:error}] Receiver:0xc001308c40 Body:{
	e.lock.RLock()
	defer e.lock.RUnlock()

	if len(keys) == 0 {
		return nil, nil
	}

	items := make([]*Payload, 0, len(keys))
	for _, k := range keys {
		items = append(items, e.mp[string(k)])
	}

	return items, nil
} PrettyPrintBody:[{ e.lock.RLock() defer e.lock.RUnlock() if len(keys) == 0 { return nil, nil } items := make([]*Payload, 0, len(keys)) for _, k := range keys { items = append(items, e.mp[string(k)]) } return items, nil }]}
{Id:5 FileId:50 StartLine:71 StartColumn:1 EndLine:73 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	rand.Seed(time.Now().Unix())
} PrettyPrintBody:[{ rand.Seed(time.Now().Unix()) }]}
{Id:7 FileId:50 StartLine:80 StartColumn:1 EndLine:82 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001308c80 Body:{
	return len(v.values)
} PrettyPrintBody:[{ return len(v.values) }]}
{Id:8 FileId:50 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001308cc0 Body:{
	v.values[i], v.values[j] = v.values[j], v.values[i]
} PrettyPrintBody:[{ v.values[i], v.values[j] = v.values[j], v.values[i] }]}
{Id:9 FileId:50 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc001602240 Body:{
	return v.comparator(v.values[i], v.values[j]) < 0
} PrettyPrintBody:[{ return v.comparator(v.values[i], v.values[j]) < 0 }]}
{Id:10 FileId:50 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc0012401a0 Body:{
	sort.Sort(v)
} PrettyPrintBody:[{ sort.Sort(v) }]}
{Id:11 FileId:50 StartLine:96 StartColumn:1 EndLine:102 EndColumn:2 Name:reverse Params:[{Name:items Type:items}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	for i := 0; i < len(items)/2; i++ {
		items[i], items[len(items)-1-i] = items[len(items)-1-i], items[i]
	}

	return items
} PrettyPrintBody:[{ for i := 0; i < len(items)/2; i++ { items[i], items[len(items)-1-i] = items[len(items)-1-i], items[i] } return items }]}
{Id:14 FileId:50 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001309580 Body:{
	return len(o)
} PrettyPrintBody:[{ return len(o) }]}
{Id:15 FileId:50 StartLine:127 StartColumn:1 EndLine:129 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc000a237c0 Body:{
	o[i], o[j] = o[j], o[i]
} PrettyPrintBody:[{ o[i], o[j] = o[j], o[i] }]}
{Id:16 FileId:50 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0010337a0 Body:{
	return comparator(o[i].Value, o[j].Value) < 0
} PrettyPrintBody:[{ return comparator(o[i].Value, o[j].Value) < 0 }]}
{Id:17 FileId:50 StartLine:135 StartColumn:1 EndLine:137 EndColumn:2 Name:equal Params:[{Name:item1 Type:*Item}] Results:[{Name: Type:bool}] Receiver:0xc000a8b880 Body:{
	return comparator(item1.Value, item2.Value) == 0
} PrettyPrintBody:[{ return comparator(item1.Value, item2.Value) == 0 }]}
{Id:18 FileId:50 StartLine:139 StartColumn:1 EndLine:143 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:orderedItems}] Receiver:0xc000a8a300 Body:{
	cp := make(orderedItems, len(o))
	copy(cp, o)
	return cp
} PrettyPrintBody:[{ cp := make(orderedItems, len(o)) copy(cp, o) return cp }]}
{Id:19 FileId:50 StartLine:145 StartColumn:1 EndLine:149 EndColumn:2 Name:search Params:[{Name:value Type:interface{}}] Results:[{Name: Type:int}] Receiver:0xc0010338e0 Body:{
	return sort.Search(len(o), func(i int) bool {
		return comparator(o[i].Value, value) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(o), func(i int) bool { return comparator(o[i].Value, value) >= 0 }) }]}
{Id:20 FileId:50 StartLine:151 StartColumn:1 EndLine:169 EndColumn:2 Name:add Params:[{Name:item Type:*Item}] Results:[{Name: Type:orderedItems}] Receiver:0xc000a8a5e0 Body:{
	cp := make(orderedItems, len(o))
	copy(cp, o)
	i := cp.search(item.Value)
	if i < len(o) && o.equal(o[i], item) {
		cp[i] = item
		return cp
	}

	if i == len(cp) {
		cp = append(cp, item)
		return cp
	}

	cp = append(cp, nil)
	copy(cp[i+1:], cp[i:])
	cp[i] = item
	return cp
} PrettyPrintBody:[{ cp := make(orderedItems, len(o)) copy(cp, o) i := cp.search(item.Value) if i < len(o) && o.equal(o[i], item) { cp[i] = item return cp } if i == len(cp) { cp = append(cp, item) return cp } cp = append(cp, nil) copy(cp[i+1:], cp[i:]) cp[i] = item return cp }]}
{Id:21 FileId:50 StartLine:171 StartColumn:1 EndLine:188 EndColumn:2 Name:delete Params:[{Name:item Type:*Item}] Results:[{Name: Type:orderedItems}] Receiver:0xc001602980 Body:{
	i := o.search(item.Value)
	if i == len(o) {
		return o
	}

	if !o.equal(o[i], item) {
		return o
	}

	cp := make(orderedItems, len(o))
	copy(cp, o)

	copy(cp[i:], cp[i+1:])
	cp[len(cp)-1] = nil
	cp = cp[:len(cp)-1]
	return cp
} PrettyPrintBody:[{ i := o.search(item.Value) if i == len(o) { return o } if !o.equal(o[i], item) { return o } cp := make(orderedItems, len(o)) copy(cp, o) copy(cp[i:], cp[i+1:]) cp[len(cp)-1] = nil cp = cp[:len(cp)-1] return cp }]}
{Id:22 FileId:50 StartLine:190 StartColumn:1 EndLine:197 EndColumn:2 Name:toItems Params:[] Results:[{Name: Type:items}] Receiver:0xc00019e060 Body:{
	cp := make(items, 0, len(o))
	for _, item := range o {
		cp = append(cp, item)
	}

	return cp
} PrettyPrintBody:[{ cp := make(items, 0, len(o)) for _, item := range o { cp = append(cp, item) } return cp }]}
{Id:23 FileId:50 StartLine:199 StartColumn:1 EndLine:211 EndColumn:2 Name:query Params:[{Name:start Type:interface{}}] Results:[{Name: Type:items}] Receiver:0xc0003e5180 Body:{
	items := make(items, 0, len(o))

	for i := o.search(start); i < len(o); i++ {
		if comparator(o[i], stop) > 0 {
			break
		}

		items = append(items, o[i])
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, len(o)) for i := o.search(start); i < len(o); i++ { if comparator(o[i], stop) > 0 { break } items = append(items, o[i]) } return items }]}
{Id:24 FileId:50 StartLine:213 StartColumn:1 EndLine:217 EndColumn:2 Name:generateRandomQuery Params:[] Results:[{Name: Type:interface{}} {Name: Type:interface{}}] Receiver:<nil> Body:{
	start := int64(rand.Intn(int(maxValue)))
	offset := int64(rand.Intn(100))
	return start, start + offset
} PrettyPrintBody:[{ start := int64(rand.Intn(int(maxValue))) offset := int64(rand.Intn(100)) return start, start + offset }]}
{Id:25 FileId:50 StartLine:219 StartColumn:1 EndLine:224 EndColumn:2 Name:newItem Params:[{Name:value Type:interface{}}] Results:[{Name: Type:*Item}] Receiver:<nil> Body:{
	return &Item{
		Value:		value,
		Payload:	newID(),
	}
} PrettyPrintBody:[{ return &Item{ Value:		value, Payload:	newID(), } }]}
{Id:26 FileId:50 StartLine:226 StartColumn:1 EndLine:230 EndColumn:2 Name:newEphemeral Params:[] Results:[{Name: Type:Persister}] Receiver:<nil> Body:{
	return &ephemeral{
		mp: make(map[string]*Payload),
	}
} PrettyPrintBody:[{ return &ephemeral{ mp: make(map[string]*Payload), } }]}
{Id:28 FileId:50 StartLine:236 StartColumn:1 EndLine:239 EndColumn:2 Name:Load Params:[{Name:keys Type:...[]byte}] Results:[{Name: Type:[]*Payload} {Name: Type:error}] Receiver:0xc000993c00 Body:{
	time.Sleep(5 * time.Millisecond)
	return d.Persister.Load(keys...)
} PrettyPrintBody:[{ time.Sleep(5 * time.Millisecond) return d.Persister.Load(keys...) }]}
{Id:29 FileId:50 StartLine:241 StartColumn:1 EndLine:243 EndColumn:2 Name:newDelayed Params:[] Results:[{Name: Type:Persister}] Receiver:<nil> Body:{
	return &delayedPersister{newEphemeral()}
} PrettyPrintBody:[{ return &delayedPersister{newEphemeral()} }]}
{Id:30 FileId:50 StartLine:245 StartColumn:1 EndLine:251 EndColumn:2 Name:defaultConfig Params:[] Results:[{Name: Type:Config}] Receiver:<nil> Body:{
	return Config{
		NodeWidth:	10,
		Persister:	newEphemeral(),
		Comparator:	comparator,
	}
} PrettyPrintBody:[{ return Config{ NodeWidth:	10, Persister:	newEphemeral(), Comparator:	comparator, } }]}
{Id:31 FileId:50 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:generateRandomItem Params:[] Results:[{Name: Type:*Item}] Receiver:<nil> Body:{
	return newItem(int64(rand.Intn(int(maxValue))))
} PrettyPrintBody:[{ return newItem(int64(rand.Intn(int(maxValue)))) }]}
{Id:32 FileId:50 StartLine:259 StartColumn:1 EndLine:272 EndColumn:2 Name:generateRandomItems Params:[{Name:num Type:int}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	items := make(items, 0, num)
	mp := make(map[interface{}]struct{}, num)
	for len(items) < num {
		c := generateRandomItem()
		if _, ok := mp[c.Value]; ok {
			continue
		}
		mp[c.Value] = struct{}{}
		items = append(items, c)
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, num) mp := make(map[interface{}]struct{}, num) for len(items) < num { c := generateRandomItem() if _, ok := mp[c.Value]; ok { continue } mp[c.Value] = struct{}{} items = append(items, c) } return items }]}
{Id:33 FileId:50 StartLine:276 StartColumn:1 EndLine:284 EndColumn:2 Name:generateLinearItems Params:[{Name:num Type:int}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	items := make(items, 0, num)
	for i := 0; i < num; i++ {
		c := newItem(int64(i))
		items = append(items, c)
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, num) for i := 0; i < num; i++ { c := newItem(int64(i)) items = append(items, c) } return items }]}
{Id:34 FileId:50 StartLine:286 StartColumn:1 EndLine:293 EndColumn:2 Name:toOrdered Params:[{Name:items Type:items}] Results:[{Name: Type:orderedItems}] Receiver:<nil> Body:{
	oc := make(orderedItems, 0, len(items))
	for _, item := range items {
		oc = oc.add(item)
	}

	return oc
} PrettyPrintBody:[{ oc := make(orderedItems, 0, len(items)) for _, item := range items { oc = oc.add(item) } return oc }]}
{Id:35 FileId:50 StartLine:297 StartColumn:1 EndLine:304 EndColumn:2 Name:toList Params:[{Name:values Type:...interface{}}] Results:[{Name: Type:items} {Name: Type:error}] Receiver:0xc0001e65a0 Body:{
	items := make(items, 0, t.Count)
	err := t.Apply(func(item *Item) {
		items = append(items, item)
	}, values...)

	return items, err
} PrettyPrintBody:[{ items := make(items, 0, t.Count) err := t.Apply(func(item *Item) { items = append(items, item) }, values...) return items, err }]}
{Id:36 FileId:50 StartLine:306 StartColumn:1 EndLine:328 EndColumn:2 Name:pprint Params:[{Name:id Type:ID}] Results:[] Receiver:0xc000a8b960 Body:{
	n, _ := t.contextOrCachedNode(id, true)
	if n == nil {
		log.Printf(`NODE: %+v`, n)
		return
	}
	log.Printf(`NODE: %+v, LEN(ids): %+v, LEN(values): %+v`, n, n.lenKeys(), n.lenValues())
	for i, key := range n.ChildKeys {
		child, _ := t.contextOrCachedNode(key.ID(), true)
		if child == nil {
			continue
		}
		log.Printf(`CHILD %d: %+v`, i, child)
	}

	for _, key := range n.ChildKeys {
		child, _ := t.contextOrCachedNode(key.ID(), true)
		if child == nil {
			continue
		}
		t.pprint(key.ID())
	}
} PrettyPrintBody:[{ n, _ := t.contextOrCachedNode(id, true) if n == nil { log.Printf(`NODE: %+v`, n) return } log.Printf(`NODE: %+v, LEN(ids): %+v, LEN(values): %+v`, n, n.lenKeys(), n.lenValues()) for i, key := range n.ChildKeys { child, _ := t.contextOrCachedNode(key.ID(), true) if child == nil { continue } log.Printf(`CHILD %d: %+v`, i, child) } for _, key := range n.ChildKeys { child, _ := t.contextOrCachedNode(key.ID(), true) if child == nil { continue } t.pprint(key.ID()) } }]}
{Id:37 FileId:50 StartLine:330 StartColumn:1 EndLine:369 EndColumn:2 Name:verify Params:[{Name:id Type:ID} {Name:tb Type:testing.TB}] Results:[{Name: Type:interface{}} {Name: Type:interface{}}] Receiver:0xc0001e67e0 Body:{
	n, err := t.contextOrCachedNode(id, true)
	require.NoError(tb, err)

	cp := n.copy()
	cpValues := cp.ChildValues

	(&valueSortWrapper{comparator: comparator, values: cpValues}).sort()
	assert.Equal(tb, cpValues, n.ChildValues)

	if !assert.False(tb, n.needsSplit(t.config.NodeWidth)) {
		tb.Logf(`NODE NEEDS SPLIT: NODE: %+v`, n)
	}
	if string(t.Root) != string(n.ID) {
		assert.True(tb, n.lenValues() >= t.config.NodeWidth/2)
	}

	if n.IsLeaf {
		assert.Equal(tb, n.lenValues(), n.lenKeys())
		return n.firstValue(), n.lastValue()
	} else {
		for _, key := range n.ChildKeys {
			assert.Empty(tb, key.Payload)
		}
	}

	for i, key := range n.ChildKeys {
		min, max := t.verify(key.ID(), tb)
		if i == 0 {
			assert.True(tb, comparator(max, n.valueAt(i)) <= 0)
		} else if i == n.lenValues() {
			assert.True(tb, comparator(min, n.lastValue()) > 0)
		} else {
			assert.True(tb, comparator(max, n.valueAt(i)) <= 0)
			assert.True(tb, comparator(min, n.valueAt(i-1)) > 0)
		}
	}

	return n.firstValue(), n.lastValue()
} PrettyPrintBody:[{ n, err := t.contextOrCachedNode(id, true) require.NoError(tb, err) cp := n.copy() cpValues := cp.ChildValues (&valueSortWrapper{comparator: comparator, values: cpValues}).sort() assert.Equal(tb, cpValues, n.ChildValues) if !assert.False(tb, n.needsSplit(t.config.NodeWidth)) { tb.Logf(`NODE NEEDS SPLIT: NODE: %+v`, n) } if string(t.Root) != string(n.ID) { assert.True(tb, n.lenValues() >= t.config.NodeWidth/2) } if n.IsLeaf { assert.Equal(tb, n.lenValues(), n.lenKeys()) return n.firstValue(), n.lastValue() } else { for _, key := range n.ChildKeys { assert.Empty(tb, key.Payload) } } for i, key := range n.ChildKeys { min, max := t.verify(key.ID(), tb) if i == 0 { assert.True(tb, comparator(max, n.valueAt(i)) <= 0) } else if i == n.lenValues() { assert.True(tb, comparator(min, n.lastValue()) > 0) } else { assert.True(tb, comparator(max, n.valueAt(i)) <= 0) assert.True(tb, comparator(min, n.valueAt(i-1)) > 0) } } return n.firstValue(), n.lastValue() }]}
{Id:38 FileId:50 StartLine:371 StartColumn:1 EndLine:378 EndColumn:2 Name:itemsToValues Params:[{Name:items Type:...*Item}] Results:[{Name: Type:[]interface{}}] Receiver:<nil> Body:{
	values := make([]interface{}, 0, len(items))
	for _, item := range items {
		values = append(values, item.Value)
	}

	return values
} PrettyPrintBody:[{ values := make([]interface{}, 0, len(items)) for _, item := range items { values = append(values, item.Value) } return values }]}
{Id:39 FileId:50 StartLine:380 StartColumn:1 EndLine:421 EndColumn:2 Name:TestNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 100
	items := generateLinearItems(number)
	cfg := defaultConfig()

	rt := New(cfg)
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)
	assert.Equal(t, number, mutable.Len())
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err := mutable.(*Tr).toList(itemsToValues(items[5:10]...)...)
	require.NoError(t, err)
	if !assert.Equal(t, items[5:10], result) {
		mutable.(*Tr).pprint(mutable.(*Tr).Root)
		for i, c := range items[5:10] {
			t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i])
		}
		t.FailNow()
	}

	mutable = rt.AsMutable()
	for _, c := range items {
		_, err := mutable.AddItems(c)
		require.NoError(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	rt, err = mutable.Commit()
	require.NoError(t, err)
	rt, err = Load(cfg.Persister, rt.ID(), comparator)

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 100 items := generateLinearItems(number) cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) assert.Equal(t, number, mutable.Len()) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(items[5:10]...)...) require.NoError(t, err) if !assert.Equal(t, items[5:10], result) { mutable.(*Tr).pprint(mutable.(*Tr).Root) for i, c := range items[5:10] { t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i]) } t.FailNow() } mutable = rt.AsMutable() for _, c := range items { _, err := mutable.AddItems(c) require.NoError(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, rt.ID(), comparator) result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]}
{Id:40 FileId:50 StartLine:423 StartColumn:1 EndLine:453 EndColumn:2 Name:TestReverseNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 400
	items := generateLinearItems(number)

	reversed := make([]*Item, len(items))
	copy(reversed, items)
	reversed = reverse(reversed)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(reversed...)
	require.NoError(t, err)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	if !assert.Equal(t, items, result) {
		for _, c := range result {
			t.Logf(`RESULT: %+v`, c)
		}
	}

	mutable = rt.AsMutable()
	for _, c := range reversed {
		_, err := mutable.AddItems(c)
		require.NoError(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 400 items := generateLinearItems(number) reversed := make([]*Item, len(items)) copy(reversed, items) reversed = reverse(reversed) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(reversed...) require.NoError(t, err) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) if !assert.Equal(t, items, result) { for _, c := range result { t.Logf(`RESULT: %+v`, c) } } mutable = rt.AsMutable() for _, c := range reversed { _, err := mutable.AddItems(c) require.NoError(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]}
{Id:41 FileId:50 StartLine:455 StartColumn:1 EndLine:472 EndColumn:2 Name:TestDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	item1 := newItem(int64(1))
	item2 := newItem(int64(1))

	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(item1)
	require.NoError(t, err)
	_, err = mutable.AddItems(item2)
	require.NoError(t, err)

	assert.Equal(t, 1, mutable.Len())
	result, err := mutable.(*Tr).toList(int64(1))
	require.NoError(t, err)

	assert.Equal(t, items{item2}, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ item1 := newItem(int64(1)) item2 := newItem(int64(1)) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(item1) require.NoError(t, err) _, err = mutable.AddItems(item2) require.NoError(t, err) assert.Equal(t, 1, mutable.Len()) result, err := mutable.(*Tr).toList(int64(1)) require.NoError(t, err) assert.Equal(t, items{item2}, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]}
{Id:42 FileId:50 StartLine:474 StartColumn:1 EndLine:496 EndColumn:2 Name:TestCommit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	items := generateRandomItems(5)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.Nil(t, err)

	rt, err = mutable.Commit()
	require.NoError(t, err)
	expected := toOrdered(items).toItems()
	result, err := rt.(*Tr).toList(itemsToValues(expected...)...)
	require.NoError(t, err)
	if !assert.Equal(t, expected, result) {
		require.Equal(t, len(expected), len(result))
		for i, c := range expected {
			if !assert.Equal(t, c, result[i]) {
				t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i])
			}
		}
	}

	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ items := generateRandomItems(5) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) rt, err = mutable.Commit() require.NoError(t, err) expected := toOrdered(items).toItems() result, err := rt.(*Tr).toList(itemsToValues(expected...)...) require.NoError(t, err) if !assert.Equal(t, expected, result) { require.Equal(t, len(expected), len(result)) for i, c := range expected { if !assert.Equal(t, c, result[i]) { t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i]) } } } rt.(*Tr).verify(rt.(*Tr).Root, t) }]}
{Id:43 FileId:50 StartLine:498 StartColumn:1 EndLine:515 EndColumn:2 Name:TestRandom Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	items := generateRandomItems(1000)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.Nil(t, err)

	require.NoError(t, err)
	expected := toOrdered(items).toItems()
	result, err := mutable.(*Tr).toList(itemsToValues(expected...)...)
	if !assert.Equal(t, expected, result) {
		assert.Equal(t, len(expected), len(result))
		for i, c := range expected {
			assert.Equal(t, c, result[i])
		}
	}
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ items := generateRandomItems(1000) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) require.NoError(t, err) expected := toOrdered(items).toItems() result, err := mutable.(*Tr).toList(itemsToValues(expected...)...) if !assert.Equal(t, expected, result) { assert.Equal(t, len(expected), len(result)) for i, c := range expected { assert.Equal(t, c, result[i]) } } mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]}
{Id:44 FileId:50 StartLine:517 StartColumn:1 EndLine:536 EndColumn:2 Name:TestLoad Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(1000)
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	id := mutable.ID()
	_, err = mutable.Commit()
	require.NoError(t, err)

	rt, err = Load(cfg.Persister, id, comparator)
	require.NoError(t, err)
	sort.Sort(orderedItems(items))
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(1000) _, err := mutable.AddItems(items...) require.NoError(t, err) id := mutable.ID() _, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, id, comparator) require.NoError(t, err) sort.Sort(orderedItems(items)) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]}
{Id:45 FileId:50 StartLine:538 StartColumn:1 EndLine:554 EndColumn:2 Name:TestDeleteFromRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 5
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(number)

	mutable.AddItems(items...)
	mutable.DeleteItems(items[0].Value, items[1].Value, items[2].Value)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[3:], result)
	assert.Equal(t, 2, mutable.Len())

	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 5 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(number) mutable.AddItems(items...) mutable.DeleteItems(items[0].Value, items[1].Value, items[2].Value) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[3:], result) assert.Equal(t, 2, mutable.Len()) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]}
{Id:46 FileId:50 StartLine:556 StartColumn:1 EndLine:570 EndColumn:2 Name:TestDeleteAllFromRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 5
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	mutable.DeleteItems(itemsToValues(items...)...)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Empty(t, result)
	assert.Equal(t, 0, mutable.Len())
} PrettyPrintBody:[{ num := 5 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) mutable.DeleteItems(itemsToValues(items...)...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Empty(t, result) assert.Equal(t, 0, mutable.Len()) }]}
{Id:47 FileId:50 StartLine:572 StartColumn:1 EndLine:587 EndColumn:2 Name:TestDeleteAfterSplitIncreasing Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 11
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	for i := 0; i < num-1; i++ {
		mutable.DeleteItems(itemsToValues(items[i])...)
		result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
		require.Nil(t, err)
		assert.Equal(t, items[i+1:], result)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	}
} PrettyPrintBody:[{ num := 11 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) for i := 0; i < num-1; i++ { mutable.DeleteItems(itemsToValues(items[i])...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[i+1:], result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) } }]}
{Id:48 FileId:50 StartLine:589 StartColumn:1 EndLine:599 EndColumn:2 Name:TestDeleteMultipleLevelsRandomlyBulk Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 200
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	mutable.DeleteItems(itemsToValues(items[:100]...)...)
	result, _ := mutable.(*Tr).toList(itemsToValues(items...)...)
	assert.Len(t, result, 100)
} PrettyPrintBody:[{ num := 200 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) mutable.DeleteItems(itemsToValues(items[:100]...)...) result, _ := mutable.(*Tr).toList(itemsToValues(items...)...) assert.Len(t, result, 100) }]}
{Id:49 FileId:50 StartLine:601 StartColumn:1 EndLine:618 EndColumn:2 Name:TestDeleteAfterSplitDecreasing Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 11
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	for i := num - 1; i >= 0; i-- {
		mutable.DeleteItems(itemsToValues(items[i])...)
		result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
		require.Nil(t, err)
		assert.Equal(t, items[:i], result)
		if i > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}
} PrettyPrintBody:[{ num := 11 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) for i := num - 1; i >= 0; i-- { mutable.DeleteItems(itemsToValues(items[i])...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[:i], result) if i > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } }]}
{Id:50 FileId:50 StartLine:620 StartColumn:1 EndLine:652 EndColumn:2 Name:TestDeleteMultipleLevels Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 20
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	ordered := toOrdered(items)

	for i, c := range ordered {
		_, err := mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...)
		require.NoError(t, err)
		if !assert.Equal(t, ordered[i+1:].toItems(), result) {
			log.Printf(`LEN EXPECTED: %+v, RESULT: %+v`, len(ordered[i+1:]), len(result))
			mutable.(*Tr).pprint(mutable.(*Tr).Root)
			assert.Equal(t, len(ordered[i+1:]), len(result))
			for i, c := range ordered[i+1:] {
				log.Printf(`EXPECTED: %+v`, c)
				if i < len(result) {
					log.Printf(`RECEIVED: %+v`, result[i])
				}
			}
			break
		}
		if len(ordered[i+1:]) > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}

	assert.Nil(t, mutable.(*Tr).Root)
} PrettyPrintBody:[{ num := 20 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) ordered := toOrdered(items) for i, c := range ordered { _, err := mutable.DeleteItems(c.Value) require.NoError(t, err) result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...) require.NoError(t, err) if !assert.Equal(t, ordered[i+1:].toItems(), result) { log.Printf(`LEN EXPECTED: %+v, RESULT: %+v`, len(ordered[i+1:]), len(result)) mutable.(*Tr).pprint(mutable.(*Tr).Root) assert.Equal(t, len(ordered[i+1:]), len(result)) for i, c := range ordered[i+1:] { log.Printf(`EXPECTED: %+v`, c) if i < len(result) { log.Printf(`RECEIVED: %+v`, result[i]) } } break } if len(ordered[i+1:]) > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } assert.Nil(t, mutable.(*Tr).Root) }]}
{Id:51 FileId:50 StartLine:654 StartColumn:1 EndLine:677 EndColumn:2 Name:TestDeleteMultipleLevelsRandomly Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 200
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	ordered := toOrdered(items)

	for _, c := range items {
		_, err := mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		ordered = ordered.delete(c)

		result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...)
		require.NoError(t, err)
		assert.Equal(t, ordered.toItems(), result)
		if len(ordered) > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}

	assert.Nil(t, mutable.(*Tr).Root)
} PrettyPrintBody:[{ num := 200 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) ordered := toOrdered(items) for _, c := range items { _, err := mutable.DeleteItems(c.Value) require.NoError(t, err) ordered = ordered.delete(c) result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...) require.NoError(t, err) assert.Equal(t, ordered.toItems(), result) if len(ordered) > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } assert.Nil(t, mutable.(*Tr).Root) }]}
{Id:52 FileId:50 StartLine:679 StartColumn:1 EndLine:708 EndColumn:2 Name:TestDeleteMultipleLevelsWithCommit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 20
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	rt, _ = mutable.Commit()

	rt, _ = Load(cfg.Persister, rt.ID(), comparator)
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable = rt.AsMutable()

	for _, c := range items[:10] {
		_, err := mutable.DeleteItems(c.Value)
		require.Nil(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items[10:]...)...)
	require.Nil(t, err)
	assert.Equal(t, items[10:], result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err = rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ num := 20 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) rt, _ = mutable.Commit() rt, _ = Load(cfg.Persister, rt.ID(), comparator) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable = rt.AsMutable() for _, c := range items[:10] { _, err := mutable.DeleteItems(c.Value) require.Nil(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items[10:]...)...) require.Nil(t, err) assert.Equal(t, items[10:], result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]}
{Id:53 FileId:50 StartLine:710 StartColumn:1 EndLine:729 EndColumn:2 Name:TestCommitAfterDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 15
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	for _, c := range items[:5] {
		mutable.DeleteItems(c.Value)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	}

	rt, err := mutable.Commit()
	require.Nil(t, err)
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[5:], result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)

} PrettyPrintBody:[{ num := 15 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) for _, c := range items[:5] { mutable.DeleteItems(c.Value) mutable.(*Tr).verify(mutable.(*Tr).Root, t) } rt, err := mutable.Commit() require.Nil(t, err) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[5:], result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]}
{Id:54 FileId:50 StartLine:731 StartColumn:1 EndLine:754 EndColumn:2 Name:TestSecondCommitSplitsRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 15
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateLinearItems(number)

	mutable := rt.AsMutable()
	mutable.AddItems(items[:10]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, _ = mutable.Commit()
	rt.(*Tr).verify(rt.(*Tr).Root, t)
	mutable = rt.AsMutable()
	mutable.AddItems(items[10:]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)

	if !assert.Equal(t, items, result) {
		for i, c := range items {
			log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i])
		}
	}
} PrettyPrintBody:[{ number := 15 cfg := defaultConfig() rt := New(cfg) items := generateLinearItems(number) mutable := rt.AsMutable() mutable.AddItems(items[:10]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, _ = mutable.Commit() rt.(*Tr).verify(rt.(*Tr).Root, t) mutable = rt.AsMutable() mutable.AddItems(items[10:]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) if !assert.Equal(t, items, result) { for i, c := range items { log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i]) } } }]}
{Id:55 FileId:50 StartLine:756 StartColumn:1 EndLine:782 EndColumn:2 Name:TestSecondCommitMultipleSplits Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 50
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateRandomItems(num)

	mutable := rt.AsMutable()
	mutable.AddItems(items[:25]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, err := mutable.Commit()
	rt.(*Tr).verify(rt.(*Tr).Root, t)

	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[:25], result)

	mutable = rt.AsMutable()
	mutable.AddItems(items[25:]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	sort.Sort(orderedItems(items))
	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	if !assert.Equal(t, items, result) {
		mutable.(*Tr).pprint(mutable.(*Tr).Root)
	}
} PrettyPrintBody:[{ num := 50 cfg := defaultConfig() rt := New(cfg) items := generateRandomItems(num) mutable := rt.AsMutable() mutable.AddItems(items[:25]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err := mutable.Commit() rt.(*Tr).verify(rt.(*Tr).Root, t) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[:25], result) mutable = rt.AsMutable() mutable.AddItems(items[25:]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) sort.Sort(orderedItems(items)) result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) if !assert.Equal(t, items, result) { mutable.(*Tr).pprint(mutable.(*Tr).Root) } }]}
{Id:56 FileId:50 StartLine:784 StartColumn:1 EndLine:807 EndColumn:2 Name:TestLargeAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	number := cfg.NodeWidth * 5
	rt := New(cfg)
	items := generateLinearItems(number)

	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	id := mutable.ID()
	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)

	_, err = mutable.Commit()
	require.NoError(t, err)

	rt, err = Load(cfg.Persister, id, comparator)
	require.NoError(t, err)
	result, err = rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
} PrettyPrintBody:[{ cfg := defaultConfig() number := cfg.NodeWidth * 5 rt := New(cfg) items := generateLinearItems(number) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) id := mutable.ID() result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) _, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, id, comparator) require.NoError(t, err) result, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) }]}
{Id:57 FileId:50 StartLine:809 StartColumn:1 EndLine:821 EndColumn:2 Name:TestNodeInfiniteLoop Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateLinearItems(3)

	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	result, err := mutable.DeleteItems(items[1].Value, items[2].Value)
	require.NoError(t, err)
	assert.Len(t, result, 2)
} PrettyPrintBody:[{ cfg := defaultConfig() rt := New(cfg) items := generateLinearItems(3) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) result, err := mutable.DeleteItems(items[1].Value, items[2].Value) require.NoError(t, err) assert.Len(t, result, 2) }]}
{Id:58 FileId:50 StartLine:826 StartColumn:1 EndLine:876 EndColumn:2 Name:TestGenerativeAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative add`)
		return
	}

	number := 100
	cfg := defaultConfig()
	rt := New(cfg)
	oc := make(orderedItems, 0)
	for i := 0; i < number; i++ {
		num := int(rand.Int31n(100))
		if num == 0 {
			num++
		}

		items := generateRandomItems(num)
		mutated := oc.copy()
		for _, c := range items {
			mutated = mutated.add(c)
		}

		mutable := rt.AsMutable()
		_, err := mutable.AddItems(items...)
		require.Nil(t, err)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)

		rtMutated, err := mutable.Commit()
		require.Nil(t, err)
		rtMutated.(*Tr).verify(rtMutated.(*Tr).Root, t)

		result, err := rtMutated.(*Tr).toList(itemsToValues(mutated.toItems()...)...)
		require.Nil(t, err)
		if !assert.Equal(t, mutated.toItems(), result) {
			rtMutated.(*Tr).pprint(rtMutated.(*Tr).Root)
			if len(mutated) == len(result) {
				for i, c := range mutated.toItems() {
					log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i])
				}
			}
		}
		assert.Equal(t, len(mutated), rtMutated.Len())

		result, err = rt.(*Tr).toList(itemsToValues(oc.toItems()...)...)
		require.Nil(t, err)
		assert.Equal(t, oc.toItems(), result)

		oc = mutated
		rt = rtMutated
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative add`) return } number := 100 cfg := defaultConfig() rt := New(cfg) oc := make(orderedItems, 0) for i := 0; i < number; i++ { num := int(rand.Int31n(100)) if num == 0 { num++ } items := generateRandomItems(num) mutated := oc.copy() for _, c := range items { mutated = mutated.add(c) } mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rtMutated, err := mutable.Commit() require.Nil(t, err) rtMutated.(*Tr).verify(rtMutated.(*Tr).Root, t) result, err := rtMutated.(*Tr).toList(itemsToValues(mutated.toItems()...)...) require.Nil(t, err) if !assert.Equal(t, mutated.toItems(), result) { rtMutated.(*Tr).pprint(rtMutated.(*Tr).Root) if len(mutated) == len(result) { for i, c := range mutated.toItems() { log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i]) } } } assert.Equal(t, len(mutated), rtMutated.Len()) result, err = rt.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.Nil(t, err) assert.Equal(t, oc.toItems(), result) oc = mutated rt = rtMutated } }]}
{Id:59 FileId:50 StartLine:878 StartColumn:1 EndLine:916 EndColumn:2 Name:TestGenerativeDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative delete`)
		return
	}

	number := 100
	var err error
	cfg := defaultConfig()
	rt := New(cfg)
	oc := toOrdered(generateRandomItems(1000))
	mutable := rt.AsMutable()
	mutable.AddItems(oc.toItems()...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, err = mutable.Commit()
	require.NoError(t, err)
	for i := 0; i < number; i++ {
		mutable = rt.AsMutable()
		index := rand.Intn(len(oc))
		c := oc[index]
		mutated := oc.delete(c)

		result, err := rt.(*Tr).toList(itemsToValues(oc.toItems()...)...)
		require.NoError(t, err)
		assert.Equal(t, oc.toItems(), result)
		assert.Equal(t, len(oc), rt.Len())

		_, err = mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		result, err = mutable.(*Tr).toList(itemsToValues(mutated.toItems()...)...)
		require.NoError(t, err)
		assert.Equal(t, len(mutated), len(result))
		require.Equal(t, mutated.toItems(), result)
		oc = mutated
		rt, err = mutable.Commit()
		require.NoError(t, err)
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative delete`) return } number := 100 var err error cfg := defaultConfig() rt := New(cfg) oc := toOrdered(generateRandomItems(1000)) mutable := rt.AsMutable() mutable.AddItems(oc.toItems()...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err = mutable.Commit() require.NoError(t, err) for i := 0; i < number; i++ { mutable = rt.AsMutable() index := rand.Intn(len(oc)) c := oc[index] mutated := oc.delete(c) result, err := rt.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) assert.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), rt.Len()) _, err = mutable.DeleteItems(c.Value) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = mutable.(*Tr).toList(itemsToValues(mutated.toItems()...)...) require.NoError(t, err) assert.Equal(t, len(mutated), len(result)) require.Equal(t, mutated.toItems(), result) oc = mutated rt, err = mutable.Commit() require.NoError(t, err) } }]}
{Id:60 FileId:50 StartLine:918 StartColumn:1 EndLine:969 EndColumn:2 Name:TestGenerativeOperations Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative operations`)
		return
	}

	number := 100
	cfg := defaultConfig()
	rt := New(cfg)

	items := generateRandomItems(1000)
	oc := toOrdered(items)

	mutable := rt.AsMutable()
	mutable.AddItems(items...)

	result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
	require.NoError(t, err)
	require.Equal(t, oc.toItems(), result)

	rt, err = mutable.Commit()
	require.NoError(t, err)

	for i := 0; i < number; i++ {
		mutable = rt.AsMutable()
		if rand.Float64() < .5 && len(oc) > 0 {
			c := oc[rand.Intn(len(oc))]
			oc = oc.delete(c)
			_, err = mutable.DeleteItems(c.Value)
			require.NoError(t, err)
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
			result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
			require.NoError(t, err)
			require.Equal(t, oc.toItems(), result)
			assert.Equal(t, len(oc), mutable.Len())
		} else {
			c := generateRandomItem()
			oc = oc.add(c)
			_, err = mutable.AddItems(c)
			require.NoError(t, err)
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
			result, err = mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
			require.NoError(t, err)
			require.Equal(t, oc.toItems(), result)
			assert.Equal(t, len(oc), mutable.Len())
		}

		rt, err = mutable.Commit()
		require.NoError(t, err)
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative operations`) return } number := 100 cfg := defaultConfig() rt := New(cfg) items := generateRandomItems(1000) oc := toOrdered(items) mutable := rt.AsMutable() mutable.AddItems(items...) result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) rt, err = mutable.Commit() require.NoError(t, err) for i := 0; i < number; i++ { mutable = rt.AsMutable() if rand.Float64() < .5 && len(oc) > 0 { c := oc[rand.Intn(len(oc))] oc = oc.delete(c) _, err = mutable.DeleteItems(c.Value) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), mutable.Len()) } else { c := generateRandomItem() oc = oc.add(c) _, err = mutable.AddItems(c) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), mutable.Len()) } rt, err = mutable.Commit() require.NoError(t, err) } }]}
{Id:61 FileId:50 StartLine:971 StartColumn:1 EndLine:994 EndColumn:2 Name:BenchmarkGetitems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	number := 100
	cfg := defaultConfig()
	cfg.Persister = newDelayed()
	rt := New(cfg)

	items := generateRandomItems(number)
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(b, err)

	rt, err = mutable.Commit()
	require.NoError(b, err)
	id := rt.ID()

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt, err = Load(cfg.Persister, id, comparator)
		require.NoError(b, err)
		_, err = rt.(*Tr).toList(itemsToValues(items...)...)
		require.NoError(b, err)
	}
} PrettyPrintBody:[{ number := 100 cfg := defaultConfig() cfg.Persister = newDelayed() rt := New(cfg) items := generateRandomItems(number) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(b, err) rt, err = mutable.Commit() require.NoError(b, err) id := rt.ID() b.ResetTimer() for i := 0; i < b.N; i++ { rt, err = Load(cfg.Persister, id, comparator) require.NoError(b, err) _, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(b, err) } }]}
{Id:62 FileId:50 StartLine:996 StartColumn:1 EndLine:1006 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	number := 1000000
	items := generateLinearItems(number)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		tr := New(defaultConfig())
		mutable := tr.AsMutable()
		mutable.AddItems(items...)
	}
} PrettyPrintBody:[{ number := 1000000 items := generateLinearItems(number) b.ResetTimer() for i := 0; i < b.N; i++ { tr := New(defaultConfig()) mutable := tr.AsMutable() mutable.AddItems(items...) } }]}
&{FileSet:0xc00011e680 Files:[{Id:1 Path:example/go-datastructures/augmentedtree/atree.go} {Id:2 Path:example/go-datastructures/augmentedtree/atree_test.go} {Id:3 Path:example/go-datastructures/augmentedtree/interface.go} {Id:4 Path:example/go-datastructures/augmentedtree/intervals.go} {Id:5 Path:example/go-datastructures/augmentedtree/intervals_test.go} {Id:6 Path:example/go-datastructures/augmentedtree/mock_test.go} {Id:7 Path:example/go-datastructures/augmentedtree/multidimensional_test.go} {Id:8 Path:example/go-datastructures/batcher/batcher.go} {Id:9 Path:example/go-datastructures/batcher/batcher_test.go} {Id:10 Path:example/go-datastructures/bitarray/and.go} {Id:11 Path:example/go-datastructures/bitarray/and_test.go} {Id:12 Path:example/go-datastructures/bitarray/bitarray.go} {Id:13 Path:example/go-datastructures/bitarray/bitarray_test.go} {Id:14 Path:example/go-datastructures/bitarray/bitmap.go} {Id:15 Path:example/go-datastructures/bitarray/bitmap_test.go} {Id:16 Path:example/go-datastructures/bitarray/block.go} {Id:17 Path:example/go-datastructures/bitarray/block_test.go} {Id:18 Path:example/go-datastructures/bitarray/encoding.go} {Id:19 Path:example/go-datastructures/bitarray/encoding_test.go} {Id:20 Path:example/go-datastructures/bitarray/error.go} {Id:21 Path:example/go-datastructures/bitarray/interface.go} {Id:22 Path:example/go-datastructures/bitarray/iterator.go} {Id:23 Path:example/go-datastructures/bitarray/nand.go} {Id:24 Path:example/go-datastructures/bitarray/nand_test.go} {Id:25 Path:example/go-datastructures/bitarray/or.go} {Id:26 Path:example/go-datastructures/bitarray/or_test.go} {Id:27 Path:example/go-datastructures/bitarray/sparse_bitarray.go} {Id:28 Path:example/go-datastructures/bitarray/sparse_bitarray_test.go} {Id:29 Path:example/go-datastructures/bitarray/util.go} {Id:30 Path:example/go-datastructures/btree/_link/interface.go} {Id:31 Path:example/go-datastructures/btree/_link/key.go} {Id:32 Path:example/go-datastructures/btree/_link/mock_test.go} {Id:33 Path:example/go-datastructures/btree/_link/node.go} {Id:34 Path:example/go-datastructures/btree/_link/node_test.go} {Id:35 Path:example/go-datastructures/btree/_link/tree.go} {Id:36 Path:example/go-datastructures/btree/_link/tree_test.go} {Id:37 Path:example/go-datastructures/btree/immutable/add.go} {Id:38 Path:example/go-datastructures/btree/immutable/cacher.go} {Id:39 Path:example/go-datastructures/btree/immutable/config.go} {Id:40 Path:example/go-datastructures/btree/immutable/delete.go} {Id:41 Path:example/go-datastructures/btree/immutable/error.go} {Id:42 Path:example/go-datastructures/btree/immutable/interface.go} {Id:43 Path:example/go-datastructures/btree/immutable/item.go} {Id:44 Path:example/go-datastructures/btree/immutable/node.go} {Id:45 Path:example/go-datastructures/btree/immutable/node_gen.go} {Id:46 Path:example/go-datastructures/btree/immutable/path.go} {Id:47 Path:example/go-datastructures/btree/immutable/query.go} {Id:48 Path:example/go-datastructures/btree/immutable/rt.go} {Id:49 Path:example/go-datastructures/btree/immutable/rt_gen.go} {Id:50 Path:example/go-datastructures/btree/immutable/rt_test.go} {Id:51 Path:example/go-datastructures/btree/palm/action.go} {Id:52 Path:example/go-datastructures/btree/palm/interface.go} {Id:53 Path:example/go-datastructures/btree/palm/key.go} {Id:54 Path:example/go-datastructures/btree/palm/mock_test.go} {Id:55 Path:example/go-datastructures/btree/palm/node.go} {Id:56 Path:example/go-datastructures/btree/palm/tree.go} {Id:57 Path:example/go-datastructures/btree/palm/tree_test.go} {Id:58 Path:example/go-datastructures/btree/plus/btree.go} {Id:59 Path:example/go-datastructures/btree/plus/btree_test.go} {Id:60 Path:example/go-datastructures/btree/plus/interface.go} {Id:61 Path:example/go-datastructures/btree/plus/iterator.go} {Id:62 Path:example/go-datastructures/btree/plus/mock_test.go} {Id:63 Path:example/go-datastructures/btree/plus/node.go} {Id:64 Path:example/go-datastructures/btree/plus/node_test.go} {Id:65 Path:example/go-datastructures/cache/cache.go} {Id:66 Path:example/go-datastructures/cache/cache_test.go} {Id:67 Path:example/go-datastructures/common/interface.go} {Id:68 Path:example/go-datastructures/datastructures.go} {Id:69 Path:example/go-datastructures/fibheap/fibheap.go} {Id:70 Path:example/go-datastructures/fibheap/fibheap_examples_test.go} {Id:71 Path:example/go-datastructures/fibheap/fibheap_single_example_test.go} {Id:72 Path:example/go-datastructures/fibheap/fibheap_test.go} {Id:73 Path:example/go-datastructures/futures/futures.go} {Id:74 Path:example/go-datastructures/futures/futures_test.go} {Id:75 Path:example/go-datastructures/futures/selectable.go} {Id:76 Path:example/go-datastructures/futures/selectable_test.go} {Id:77 Path:example/go-datastructures/graph/simple.go} {Id:78 Path:example/go-datastructures/graph/simple_test.go} {Id:79 Path:example/go-datastructures/hashmap/fastinteger/hash.go} {Id:80 Path:example/go-datastructures/hashmap/fastinteger/hash_test.go} {Id:81 Path:example/go-datastructures/hashmap/fastinteger/hashmap.go} {Id:82 Path:example/go-datastructures/hashmap/fastinteger/hashmap_test.go} {Id:83 Path:example/go-datastructures/list/persistent.go} {Id:84 Path:example/go-datastructures/list/persistent_test.go} {Id:85 Path:example/go-datastructures/mock/batcher.go} {Id:86 Path:example/go-datastructures/mock/rangetree.go} {Id:87 Path:example/go-datastructures/numerics/hilbert/hilbert.go} {Id:88 Path:example/go-datastructures/numerics/hilbert/hilbert_test.go} {Id:89 Path:example/go-datastructures/numerics/optimization/global.go} {Id:90 Path:example/go-datastructures/numerics/optimization/nelder_mead.go} {Id:91 Path:example/go-datastructures/numerics/optimization/nelder_mead_test.go} {Id:92 Path:example/go-datastructures/queue/error.go} {Id:93 Path:example/go-datastructures/queue/mock_test.go} {Id:94 Path:example/go-datastructures/queue/priority_queue.go} {Id:95 Path:example/go-datastructures/queue/priority_queue_test.go} {Id:96 Path:example/go-datastructures/queue/queue.go} {Id:97 Path:example/go-datastructures/queue/queue_test.go} {Id:98 Path:example/go-datastructures/queue/ring.go} {Id:99 Path:example/go-datastructures/queue/ring_test.go} {Id:100 Path:example/go-datastructures/rangetree/entries.go} {Id:101 Path:example/go-datastructures/rangetree/entries_test.go} {Id:102 Path:example/go-datastructures/rangetree/error.go} {Id:103 Path:example/go-datastructures/rangetree/immutable.go} {Id:104 Path:example/go-datastructures/rangetree/immutable_test.go} {Id:105 Path:example/go-datastructures/rangetree/interface.go} {Id:106 Path:example/go-datastructures/rangetree/mock_test.go} {Id:107 Path:example/go-datastructures/rangetree/node.go} {Id:108 Path:example/go-datastructures/rangetree/ordered.go} {Id:109 Path:example/go-datastructures/rangetree/ordered_test.go} {Id:110 Path:example/go-datastructures/rangetree/orderedtree.go} {Id:111 Path:example/go-datastructures/rangetree/orderedtree_test.go} {Id:112 Path:example/go-datastructures/rangetree/skiplist/mock_test.go} {Id:113 Path:example/go-datastructures/rangetree/skiplist/skiplist.go} {Id:114 Path:example/go-datastructures/rangetree/skiplist/skiplist_test.go} {Id:115 Path:example/go-datastructures/rtree/hilbert/action.go} {Id:116 Path:example/go-datastructures/rtree/hilbert/hilbert.go} {Id:117 Path:example/go-datastructures/rtree/hilbert/mock_test.go} {Id:118 Path:example/go-datastructures/rtree/hilbert/node.go} {Id:119 Path:example/go-datastructures/rtree/hilbert/rectangle.go} {Id:120 Path:example/go-datastructures/rtree/hilbert/tree.go} {Id:121 Path:example/go-datastructures/rtree/hilbert/tree_test.go} {Id:122 Path:example/go-datastructures/rtree/interface.go} {Id:123 Path:example/go-datastructures/set/dict.go} {Id:124 Path:example/go-datastructures/set/dict_test.go} {Id:125 Path:example/go-datastructures/slice/int64.go} {Id:126 Path:example/go-datastructures/slice/int64_test.go} {Id:127 Path:example/go-datastructures/slice/skip/interface.go} {Id:128 Path:example/go-datastructures/slice/skip/iterator.go} {Id:129 Path:example/go-datastructures/slice/skip/iterator_test.go} {Id:130 Path:example/go-datastructures/slice/skip/mock_test.go} {Id:131 Path:example/go-datastructures/slice/skip/node.go} {Id:132 Path:example/go-datastructures/slice/skip/skip.go} {Id:133 Path:example/go-datastructures/slice/skip/skip_test.go} {Id:134 Path:example/go-datastructures/sort/interface.go} {Id:135 Path:example/go-datastructures/sort/sort.go} {Id:136 Path:example/go-datastructures/sort/sort_test.go} {Id:137 Path:example/go-datastructures/sort/symmerge.go} {Id:138 Path:example/go-datastructures/sort/symmerge_test.go} {Id:139 Path:example/go-datastructures/threadsafe/err/error.go} {Id:140 Path:example/go-datastructures/threadsafe/err/error_test.go} {Id:141 Path:example/go-datastructures/tree/avl/avl.go} {Id:142 Path:example/go-datastructures/tree/avl/avl_test.go} {Id:143 Path:example/go-datastructures/tree/avl/interface.go} {Id:144 Path:example/go-datastructures/tree/avl/mock_test.go} {Id:145 Path:example/go-datastructures/tree/avl/node.go} {Id:146 Path:example/go-datastructures/trie/ctrie/ctrie.go} {Id:147 Path:example/go-datastructures/trie/ctrie/ctrie_test.go} {Id:148 Path:example/go-datastructures/trie/dtrie/dtrie.go} {Id:149 Path:example/go-datastructures/trie/dtrie/dtrie_test.go} {Id:150 Path:example/go-datastructures/trie/dtrie/node.go} {Id:151 Path:example/go-datastructures/trie/dtrie/util.go} {Id:152 Path:example/go-datastructures/trie/xfast/iterator.go} {Id:153 Path:example/go-datastructures/trie/xfast/iterator_test.go} {Id:154 Path:example/go-datastructures/trie/xfast/mock_test.go} {Id:155 Path:example/go-datastructures/trie/xfast/xfast.go} {Id:156 Path:example/go-datastructures/trie/xfast/xfast_test.go} {Id:157 Path:example/go-datastructures/trie/yfast/entries.go} {Id:158 Path:example/go-datastructures/trie/yfast/entries_test.go} {Id:159 Path:example/go-datastructures/trie/yfast/interface.go} {Id:160 Path:example/go-datastructures/trie/yfast/iterator.go} {Id:161 Path:example/go-datastructures/trie/yfast/mock_test.go} {Id:162 Path:example/go-datastructures/trie/yfast/yfast.go} {Id:163 Path:example/go-datastructures/trie/yfast/yfast_test.go}] Functions:[{Id:1 FileId:32 StartLine:21 StartColumn:1 EndLine:32 EndColumn:2 Name:Compare Params:[{Name:other Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000879a60 Body:{
	otherK := other.(mockKey)
	if mk < otherK {
		return -1
	}

	if mk > otherK {
		return 1
	}

	return 0
} PrettyPrintBody:[{ otherK := other.(mockKey) if mk < otherK { return -1 } if mk > otherK { return 1 } return 0 }]} {Id:2 FileId:107 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:newNode Params:[{Name:value Type:int64} {Name:entry Type:Entry} {Name:needNextDimension Type:bool}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := &node{}
	n.value = value
	if needNextDimension {
		n.orderedNodes = make(orderedNodes, 0, 10)
	} else {
		n.entry = entry
	}

	return n
} PrettyPrintBody:[{ n := &node{} n.value = value if needNextDimension { n.orderedNodes = make(orderedNodes, 0, 10) } else { n.entry = entry } return n }]} {Id:1 FileId:161 StartLine:24 StartColumn:1 EndLine:26 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0012622a0 Body:{
	return me.key
} PrettyPrintBody:[{ return me.key }]} {Id:2 FileId:161 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{key}
} PrettyPrintBody:[{ return &mockEntry{key} }]} {Id:1 FileId:140 StartLine:26 StartColumn:1 EndLine:34 EndColumn:2 Name:TestGetSetError Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	e := New()
	assert.Nil(t, e.Get())

	err := fmt.Errorf(`test`)
	e.Set(err)

	assert.Equal(t, err, e.Get())
} PrettyPrintBody:[{ e := New() assert.Nil(t, e.Get()) err := fmt.Errorf(`test`) e.Set(err) assert.Equal(t, err, e.Get()) }]} {Id:2 FileId:20 StartLine:26 StartColumn:1 EndLine:28 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc000c7cfe0 Body:{
	return fmt.Sprintf(`Index %d is out of range.`, err)
} PrettyPrintBody:[{ return fmt.Sprintf(`Index %d is out of range.`, err) }]} {Id:2 FileId:102 StartLine:25 StartColumn:1 EndLine:27 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc00113ea20 Body:{
	return `No entries in this tree.`
} PrettyPrintBody:[{ return `No entries in this tree.` }]} {Id:4 FileId:102 StartLine:35 StartColumn:1 EndLine:40 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc00113ea60 Body:{
	return fmt.Sprintf(`Provided dimension: %d is 
		greater than max dimension: %d`,
		oode.provided, oode.max,
	)
} PrettyPrintBody:[{ return fmt.Sprintf(`Provided dimension: %d is greater than max dimension: %d`, oode.provided, oode.max, ) }]} {Id:1 FileId:93 StartLine:21 StartColumn:1 EndLine:29 EndColumn:2 Name:Compare Params:[{Name:other Type:Item}] Results:[{Name: Type:int}] Receiver:0xc00129b9a0 Body:{
	omi := other.(mockItem)
	if mi > omi {
		return 1
	} else if mi == omi {
		return 0
	}
	return -1
} PrettyPrintBody:[{ omi := other.(mockItem) if mi > omi { return 1 } else if mi == omi { return 0 } return -1 }]} {Id:2 FileId:43 StartLine:26 StartColumn:1 EndLine:32 EndColumn:2 Name:split Params:[{Name:numParts Type:int}] Results:[{Name: Type:[]items}] Receiver:0xc0013089c0 Body:{
	parts := make([]items, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = its[i*int64(len(its))/int64(numParts) : (i+1)*int64(len(its))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]items, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = its[i*int64(len(its))/int64(numParts) : (i+1)*int64(len(its))/int64(numParts)] } return parts }]} {Id:1 FileId:106 StartLine:24 StartColumn:1 EndLine:26 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00111ec60 Body:{
	return me.id
} PrettyPrintBody:[{ return me.id }]} {Id:2 FileId:106 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:ValueAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00111ecc0 Body:{
	return me.dimensions[dimension-1]
} PrettyPrintBody:[{ return me.dimensions[dimension-1] }]} {Id:3 FileId:106 StartLine:32 StartColumn:1 EndLine:37 EndColumn:2 Name:constructMockEntry Params:[{Name:id Type:uint64} {Name:values Type:...int64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{
		id:		id,
		dimensions:	values,
	}
} PrettyPrintBody:[{ return &mockEntry{ id:		id, dimensions:	values, } }]} {Id:6 FileId:106 StartLine:47 StartColumn:1 EndLine:49 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000e8df80 Body:{
	return mi.dimensions[dimension-1].low
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].low }]} {Id:7 FileId:106 StartLine:51 StartColumn:1 EndLine:53 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000e8dfe0 Body:{
	return mi.dimensions[dimension-1].high
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].high }]} {Id:8 FileId:106 StartLine:55 StartColumn:1 EndLine:59 EndColumn:2 Name:constructMockInterval Params:[{Name:dimensions Type:...dimension}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{
		dimensions: dimensions,
	}
} PrettyPrintBody:[{ return &mockInterval{ dimensions: dimensions, } }]} {Id:1 FileId:129 StartLine:25 StartColumn:1 EndLine:57 EndColumn:2 Name:TestIterate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	e1 := newMockEntry(1)
	n1 := newNode(e1, 8)
	iter := &iterator{
		n:	n1,
		first:	true,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e2 := newMockEntry(2)
	n2 := newNode(e2, 8)
	n1.forward[0] = n2

	iter = &iterator{
		n:	n1,
		first:	true,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.True(t, iter.Next())
	assert.Equal(t, e2, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	iter = nilIterator()
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())
} PrettyPrintBody:[{ e1 := newMockEntry(1) n1 := newNode(e1, 8) iter := &iterator{ n:	n1, first:	true, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e2 := newMockEntry(2) n2 := newNode(e2, 8) n1.forward[0] = n2 iter = &iterator{ n:	n1, first:	true, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.True(t, iter.Next()) assert.Equal(t, e2, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) iter = nilIterator() assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) }]} {Id:1 FileId:101 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:TestDisposeEntries Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := NewEntries()
	entries = append(entries, constructMockEntry(0, 0))

	entries.Dispose()

	assert.Len(t, entries, 0)
} PrettyPrintBody:[{ entries := NewEntries() entries = append(entries, constructMockEntry(0, 0)) entries.Dispose() assert.Len(t, entries, 0) }]} {Id:2 FileId:54 StartLine:22 StartColumn:1 EndLine:34 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc0010323c0 Body:{
	otherKey := other.(mockKey)

	if mk == otherKey {
		return 0
	}

	if mk > otherKey {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherKey := other.(mockKey) if mk == otherKey { return 0 } if mk > otherKey { return 1 } return -1 }]} {Id:1 FileId:53 StartLine:21 StartColumn:1 EndLine:28 EndColumn:2 Name:reverseKeys Params:[{Name:cmps Type:common.Comparators}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	reversed := make(common.Comparators, len(cmps))
	for i := len(cmps) - 1; i >= 0; i-- {
		reversed[len(cmps)-1-i] = cmps[i]
	}

	return reversed
} PrettyPrintBody:[{ reversed := make(common.Comparators, len(cmps)) for i := len(cmps) - 1; i >= 0; i-- { reversed[len(cmps)-1-i] = cmps[i] } return reversed }]} {Id:2 FileId:53 StartLine:30 StartColumn:1 EndLine:36 EndColumn:2 Name:chunkKeys Params:[{Name:keys Type:common.Comparators} {Name:numParts Type:int64}] Results:[{Name: Type:[]common.Comparators}] Receiver:<nil> Body:{
	parts := make([]common.Comparators, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]common.Comparators, numParts) for i := int64(0); i < numParts; i++ { parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts] } return parts }]} {Id:2 FileId:139 StartLine:36 StartColumn:1 EndLine:41 EndColumn:2 Name:Set Params:[{Name:err Type:error}] Results:[] Receiver:0xc0014093c0 Body:{
	e.lock.Lock()
	defer e.lock.Unlock()

	e.err = err
} PrettyPrintBody:[{ e.lock.Lock() defer e.lock.Unlock() e.err = err }]} {Id:3 FileId:139 StartLine:44 StartColumn:1 EndLine:49 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:error}] Receiver:0xc001308d00 Body:{
	e.lock.RLock()
	defer e.lock.RUnlock()

	return e.err
} PrettyPrintBody:[{ e.lock.RLock() defer e.lock.RUnlock() return e.err }]} {Id:4 FileId:139 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:New Params:[] Results:[{Name: Type:*Error}] Receiver:<nil> Body:{
	return &Error{}
} PrettyPrintBody:[{ return &Error{} }]} {Id:4 FileId:131 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc0009f8a60 Body:{
	return n.entry.Compare(e)
} PrettyPrintBody:[{ return n.entry.Compare(e) }]} {Id:5 FileId:131 StartLine:44 StartColumn:1 EndLine:50 EndColumn:2 Name:newNode Params:[{Name:cmp Type:common.Comparator} {Name:maxLevels Type:uint8}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		entry:		cmp,
		forward:	make(nodes, maxLevels),
		widths:		make(widths, maxLevels),
	}
} PrettyPrintBody:[{ return &node{ entry:		cmp, forward:	make(nodes, maxLevels), widths:		make(widths, maxLevels), } }]} {Id:2 FileId:152 StartLine:30 StartColumn:1 EndLine:38 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001602040 Body:{
	if iter.first {
		iter.first = false
		return iter.n != nil
	}

	iter.n = iter.n.children[1]
	return iter.n != nil
} PrettyPrintBody:[{ if iter.first { iter.first = false return iter.n != nil } iter.n = iter.n.children[1] return iter.n != nil }]} {Id:3 FileId:152 StartLine:43 StartColumn:1 EndLine:49 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001308880 Body:{
	if iter.n == nil {
		return nil
	}

	return iter.n.entry
} PrettyPrintBody:[{ if iter.n == nil { return nil } return iter.n.entry }]} {Id:4 FileId:152 StartLine:53 StartColumn:1 EndLine:60 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:Entries}] Receiver:0xc0010bc360 Body:{
	entries := make(Entries, 0, 100)
	for it := iter; it.Next(); {
		entries = append(entries, it.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, 100) for it := iter; it.Next(); { entries = append(entries, it.Value()) } return entries }]} {Id:1 FileId:144 StartLine:21 StartColumn:1 EndLine:32 EndColumn:2 Name:Compare Params:[{Name:other Type:Entry}] Results:[{Name: Type:int}] Receiver:0xc001291560 Body:{
	otherMe := other.(mockEntry)
	if me > otherMe {
		return 1
	}

	if me < otherMe {
		return -1
	}

	return 0
} PrettyPrintBody:[{ otherMe := other.(mockEntry) if me > otherMe { return 1 } if me < otherMe { return -1 } return 0 }]} {Id:3 FileId:4 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc00095ab20 Body:{
	for i := 0; i < len(*ivs); i++ {
		(*ivs)[i] = nil
	}

	*ivs = (*ivs)[:0]
	intervalsPool.Put(*ivs)
} PrettyPrintBody:[{ for i := 0; i < len(*ivs); i++ { (*ivs)[i] = nil } *ivs = (*ivs)[:0] intervalsPool.Put(*ivs) }]} {Id:2 FileId:154 StartLine:25 StartColumn:1 EndLine:28 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0009f94a0 Body:{
	args := me.Called()
	return args.Get(0).(uint64)
} PrettyPrintBody:[{ args := me.Called() return args.Get(0).(uint64) }]} {Id:3 FileId:154 StartLine:30 StartColumn:1 EndLine:34 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	me := new(mockEntry)
	me.On(`Key`).Return(key)
	return me
} PrettyPrintBody:[{ me := new(mockEntry) me.On(`Key`).Return(key) return me }]} {Id:1 FileId:126 StartLine:25 StartColumn:1 EndLine:30 EndColumn:2 Name:TestSort Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{3, 6, 1, 0, -1}
	s.Sort()

	assert.Equal(t, Int64Slice{-1, 0, 1, 3, 6}, s)
} PrettyPrintBody:[{ s := Int64Slice{3, 6, 1, 0, -1} s.Sort() assert.Equal(t, Int64Slice{-1, 0, 1, 3, 6}, s) }]} {Id:2 FileId:126 StartLine:32 StartColumn:1 EndLine:38 EndColumn:2 Name:TestSearch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}

	assert.Equal(t, 1, s.Search(3))
	assert.Equal(t, 1, s.Search(2))
	assert.Equal(t, 3, s.Search(7))
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} assert.Equal(t, 1, s.Search(3)) assert.Equal(t, 1, s.Search(2)) assert.Equal(t, 3, s.Search(7)) }]} {Id:3 FileId:126 StartLine:40 StartColumn:1 EndLine:45 EndColumn:2 Name:TestExists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}

	assert.True(t, s.Exists(3))
	assert.False(t, s.Exists(4))
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} assert.True(t, s.Exists(3)) assert.False(t, s.Exists(4)) }]} {Id:4 FileId:126 StartLine:47 StartColumn:1 EndLine:54 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s := Int64Slice{1, 3, 6}
	s = s.Insert(2)
	assert.Equal(t, Int64Slice{1, 2, 3, 6}, s)

	s = s.Insert(7)
	assert.Equal(t, Int64Slice{1, 2, 3, 6, 7}, s)
} PrettyPrintBody:[{ s := Int64Slice{1, 3, 6} s = s.Insert(2) assert.Equal(t, Int64Slice{1, 2, 3, 6}, s) s = s.Insert(7) assert.Equal(t, Int64Slice{1, 2, 3, 6, 7}, s) }]} {Id:1 FileId:5 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:TestIntervalsDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	intervals := intervalsPool.Get().(Intervals)
	intervals = append(intervals, constructSingleDimensionInterval(0, 1, 0))

	intervals.Dispose()

	assert.Len(t, intervals, 0)
} PrettyPrintBody:[{ intervals := intervalsPool.Get().(Intervals) intervals = append(intervals, constructSingleDimensionInterval(0, 1, 0)) intervals.Dispose() assert.Len(t, intervals, 0) }]} {Id:0 FileId:79 StartLine:6 StartColumn:1 EndLine:13 EndColumn:2 Name:hash Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	key ^= key >> 33
	key *= 0xff51afd7ed558ccd
	key ^= key >> 33
	key *= 0xc4ceb9fe1a85ec53
	key ^= key >> 33
	return key
} PrettyPrintBody:[{ key ^= key >> 33 key *= 0xff51afd7ed558ccd key ^= key >> 33 key *= 0xc4ceb9fe1a85ec53 key ^= key >> 33 return key }]} {Id:4 FileId:16 StartLine:38 StartColumn:1 EndLine:44 EndColumn:2 Name:toNums Params:[{Name:offset Type:uint64} {Name:nums Type:*[]uint64}] Results:[] Receiver:0xc000d604e0 Body:{
	for i := uint64(0); i < s; i++ {
		if b&block(1<<i) > 0 {
			*nums = append(*nums, i+offset)
		}
	}
} PrettyPrintBody:[{ for i := uint64(0); i < s; i++ { if b&block(1<<i) > 0 { *nums = append(*nums, i+offset) } } }]} {Id:5 FileId:16 StartLine:46 StartColumn:1 EndLine:55 EndColumn:2 Name:findLeftPosition Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000e8cba0 Body:{
	for i := s - 1; i < s; i-- {
		test := block(1 << i)
		if b&test == test {
			return i
		}
	}

	return s
} PrettyPrintBody:[{ for i := s - 1; i < s; i-- { test := block(1 << i) if b&test == test { return i } } return s }]} {Id:6 FileId:16 StartLine:57 StartColumn:1 EndLine:66 EndColumn:2 Name:findRightPosition Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001290180 Body:{
	for i := uint64(0); i < s; i++ {
		test := block(1 << i)
		if b&test == test {
			return i
		}
	}

	return s
} PrettyPrintBody:[{ for i := uint64(0); i < s; i++ { test := block(1 << i) if b&test == test { return i } } return s }]} {Id:7 FileId:16 StartLine:68 StartColumn:1 EndLine:70 EndColumn:2 Name:insert Params:[{Name:position Type:uint64}] Results:[{Name: Type:block}] Receiver:0xc0012267a0 Body:{
	return b | block(1<<position)
} PrettyPrintBody:[{ return b | block(1<<position) }]} {Id:8 FileId:16 StartLine:72 StartColumn:1 EndLine:74 EndColumn:2 Name:remove Params:[{Name:position Type:uint64}] Results:[{Name: Type:block}] Receiver:0xc0012909c0 Body:{
	return b & ^block(1<<position)
} PrettyPrintBody:[{ return b & ^block(1<<position) }]} {Id:9 FileId:16 StartLine:76 StartColumn:1 EndLine:78 EndColumn:2 Name:or Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc0014093a0 Body:{
	return b | other
} PrettyPrintBody:[{ return b | other }]} {Id:10 FileId:16 StartLine:80 StartColumn:1 EndLine:82 EndColumn:2 Name:and Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc001239240 Body:{
	return b & other
} PrettyPrintBody:[{ return b & other }]} {Id:11 FileId:16 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:nand Params:[{Name:other Type:block}] Results:[{Name: Type:block}] Receiver:0xc0012278e0 Body:{
	return b &^ other
} PrettyPrintBody:[{ return b &^ other }]} {Id:12 FileId:16 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:get Params:[{Name:position Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000e7ff60 Body:{
	return b&block(1<<position) != 0
} PrettyPrintBody:[{ return b&block(1<<position) != 0 }]} {Id:13 FileId:16 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:equals Params:[{Name:other Type:block}] Results:[{Name: Type:bool}] Receiver:0xc001032ec0 Body:{
	return b == other
} PrettyPrintBody:[{ return b == other }]} {Id:14 FileId:16 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:intersects Params:[{Name:other Type:block}] Results:[{Name: Type:bool}] Receiver:0xc001032f20 Body:{
	return b&other == other
} PrettyPrintBody:[{ return b&other == other }]} {Id:15 FileId:16 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00095a020 Body:{
	return fmt.Sprintf(fmt.Sprintf("%%0%db", s), uint64(b))
} PrettyPrintBody:[{ return fmt.Sprintf(fmt.Sprintf("%%0%db", s), uint64(b)) }]} {Id:3 FileId:128 StartLine:33 StartColumn:1 EndLine:45 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001013040 Body:{
	if iter.first {
		iter.first = false
		return iter.n != nil
	}

	if iter.n == nil {
		return false
	}

	iter.n = iter.n.forward[0]
	return iter.n != nil
} PrettyPrintBody:[{ if iter.first { iter.first = false return iter.n != nil } if iter.n == nil { return false } iter.n = iter.n.forward[0] return iter.n != nil }]} {Id:4 FileId:128 StartLine:49 StartColumn:1 EndLine:55 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc001032d00 Body:{
	if iter.n == nil {
		return nil
	}

	return iter.n.entry
} PrettyPrintBody:[{ if iter.n == nil { return nil } return iter.n.entry }]} {Id:5 FileId:128 StartLine:59 StartColumn:1 EndLine:66 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc000e57400 Body:{
	entries := make(common.Comparators, 0, 10)
	for i := iter; i.Next(); {
		entries = append(entries, i.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, 10) for i := iter; i.Next(); { entries = append(entries, i.Value()) } return entries }]} {Id:6 FileId:128 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*iterator}] Receiver:<nil> Body:{
	return &iterator{}
} PrettyPrintBody:[{ return &iterator{} }]} {Id:3 FileId:100 StartLine:33 StartColumn:1 EndLine:40 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0011550e0 Body:{
	for i := 0; i < len(*entries); i++ {
		(*entries)[i] = nil
	}

	*entries = (*entries)[:0]
	entriesPool.Put(*entries)
} PrettyPrintBody:[{ for i := 0; i < len(*entries); i++ { (*entries)[i] = nil } *entries = (*entries)[:0] entriesPool.Put(*entries) }]} {Id:4 FileId:100 StartLine:43 StartColumn:1 EndLine:45 EndColumn:2 Name:NewEntries Params:[] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	return entriesPool.Get().(Entries)
} PrettyPrintBody:[{ return entriesPool.Get().(Entries) }]} {Id:1 FileId:134 StartLine:8 StartColumn:1 EndLine:10 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0003d21a0 Body:{
	return c[i].Compare(c[j]) < 0
} PrettyPrintBody:[{ return c[i].Compare(c[j]) < 0 }]} {Id:2 FileId:134 StartLine:14 StartColumn:1 EndLine:16 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a0a0 Body:{
	return len(c)
} PrettyPrintBody:[{ return len(c) }]} {Id:3 FileId:134 StartLine:19 StartColumn:1 EndLine:21 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001309060 Body:{
	c[j], c[i] = c[i], c[j]
} PrettyPrintBody:[{ c[j], c[i] = c[i], c[j] }]} {Id:3 FileId:6 StartLine:30 StartColumn:1 EndLine:34 EndColumn:2 Name:checkDimension Params:[{Name:dimension Type:uint64}] Results:[] Receiver:0xc00019eea0 Body:{
	if dimension > uint64(len(mi.dimensions)) {
		panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension))
	}
} PrettyPrintBody:[{ if dimension > uint64(len(mi.dimensions)) { panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension)) } }]} {Id:4 FileId:6 StartLine:36 StartColumn:1 EndLine:38 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00019ef00 Body:{
	return mi.dimensions[dimension-1].low
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].low }]} {Id:5 FileId:6 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00019ef60 Body:{
	return mi.dimensions[dimension-1].high
} PrettyPrintBody:[{ return mi.dimensions[dimension-1].high }]} {Id:6 FileId:6 StartLine:44 StartColumn:1 EndLine:47 EndColumn:2 Name:OverlapsAtDimension Params:[{Name:iv Type:Interval} {Name:dimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000fa6e20 Body:{
	return mi.HighAtDimension(dimension) > iv.LowAtDimension(dimension) &&
		mi.LowAtDimension(dimension) < iv.HighAtDimension(dimension)
} PrettyPrintBody:[{ return mi.HighAtDimension(dimension) > iv.LowAtDimension(dimension) && mi.LowAtDimension(dimension) < iv.HighAtDimension(dimension) }]} {Id:7 FileId:6 StartLine:49 StartColumn:1 EndLine:51 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0010bc900 Body:{
	return mi.id
} PrettyPrintBody:[{ return mi.id }]} {Id:8 FileId:6 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:constructSingleDimensionInterval Params:[{Name:low Type:int64} {Name:id Type:uint64}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{[]*dimension{&dimension{low: low, high: high}}, id}
} PrettyPrintBody:[{ return &mockInterval{[]*dimension{&dimension{low: low, high: high}}, id} }]} {Id:9 FileId:6 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:constructMultiDimensionInterval Params:[{Name:id Type:uint64} {Name:dimensions Type:...*dimension}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{dimensions: dimensions, id: id}
} PrettyPrintBody:[{ return &mockInterval{dimensions: dimensions, id: id} }]} {Id:1 FileId:31 StartLine:21 StartColumn:1 EndLine:25 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0009f8940 Body:{
	return sort.Search(len(keys), func(i int) bool {
		return keys[i].Compare(key) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(keys), func(i int) bool { return keys[i].Compare(key) >= 0 }) }]} {Id:2 FileId:31 StartLine:27 StartColumn:1 EndLine:30 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc0011b3cc0 Body:{
	i := keys.search(key)
	return keys.insertAt(key, i)
} PrettyPrintBody:[{ i := keys.search(key) return keys.insertAt(key, i) }]} {Id:3 FileId:31 StartLine:32 StartColumn:1 EndLine:48 EndColumn:2 Name:insertAt Params:[{Name:key Type:Key} {Name:i Type:int}] Results:[{Name: Type:Key}] Receiver:0xc000e600c0 Body:{
	if i == len(*keys) {
		*keys = append(*keys, key)
		return nil
	}

	if (*keys)[i].Compare(key) == 0 {
		oldKey := (*keys)[i]
		(*keys)[i] = key
		return oldKey
	}

	*keys = append(*keys, nil)
	copy((*keys)[i+1:], (*keys)[i:])
	(*keys)[i] = key
	return nil
} PrettyPrintBody:[{ if i == len(*keys) { *keys = append(*keys, key) return nil } if (*keys)[i].Compare(key) == 0 { oldKey := (*keys)[i] (*keys)[i] = key return oldKey } *keys = append(*keys, nil) copy((*keys)[i+1:], (*keys)[i:]) (*keys)[i] = key return nil }]} {Id:4 FileId:31 StartLine:50 StartColumn:1 EndLine:56 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:Keys} {Name: Type:Keys}] Receiver:0xc000e60120 Body:{
	i := (len(*keys) / 2) - 1
	middle := (*keys)[i]

	left, right := keys.splitAt(i)
	return middle, left, right
} PrettyPrintBody:[{ i := (len(*keys) / 2) - 1 middle := (*keys)[i] left, right := keys.splitAt(i) return middle, left, right }]} {Id:5 FileId:31 StartLine:58 StartColumn:1 EndLine:67 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:Keys} {Name: Type:Keys}] Receiver:0xc000e604c0 Body:{
	right := make(Keys, len(*keys)-i-1, cap(*keys))
	copy(right, (*keys)[i+1:])
	for j := i + 1; j < len(*keys); j++ {
		(*keys)[j] = nil
	}
	*keys = (*keys)[:i+1]

	return *keys, right
} PrettyPrintBody:[{ right := make(Keys, len(*keys)-i-1, cap(*keys)) copy(right, (*keys)[i+1:]) for j := i + 1; j < len(*keys); j++ { (*keys)[j] = nil } *keys = (*keys)[:i+1] return *keys, right }]} {Id:6 FileId:31 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:last Params:[] Results:[{Name: Type:Key}] Receiver:0xc000e60600 Body:{
	return keys[len(keys)-1]
} PrettyPrintBody:[{ return keys[len(keys)-1] }]} {Id:7 FileId:31 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:first Params:[] Results:[{Name: Type:Key}] Receiver:0xc000e60f60 Body:{
	return keys[0]
} PrettyPrintBody:[{ return keys[0] }]} {Id:8 FileId:31 StartLine:77 StartColumn:1 EndLine:79 EndColumn:2 Name:needsSplit Params:[] Results:[{Name: Type:bool}] Receiver:0xc000e61460 Body:{
	return cap(keys) == len(keys)
} PrettyPrintBody:[{ return cap(keys) == len(keys) }]} {Id:9 FileId:31 StartLine:81 StartColumn:1 EndLine:88 EndColumn:2 Name:reverse Params:[] Results:[{Name: Type:Keys}] Receiver:0xc000e615e0 Body:{
	reversed := make(Keys, len(keys))
	for i := len(keys) - 1; i >= 0; i-- {
		reversed[len(keys)-1-i] = keys[i]
	}

	return reversed
} PrettyPrintBody:[{ reversed := make(Keys, len(keys)) for i := len(keys) - 1; i >= 0; i-- { reversed[len(keys)-1-i] = keys[i] } return reversed }]} {Id:10 FileId:31 StartLine:90 StartColumn:1 EndLine:96 EndColumn:2 Name:chunkKeys Params:[{Name:keys Type:Keys} {Name:numParts Type:int64}] Results:[{Name: Type:[]Keys}] Receiver:<nil> Body:{
	parts := make([]Keys, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Keys, numParts) for i := int64(0); i < numParts; i++ { parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts] } return parts }]} {Id:1 FileId:135 StartLine:9 StartColumn:1 EndLine:11 EndColumn:2 Name:sortBucket Params:[{Name:comparators Type:Comparators}] Results:[] Receiver:<nil> Body:{
	sort.Sort(comparators)
} PrettyPrintBody:[{ sort.Sort(comparators) }]} {Id:2 FileId:135 StartLine:13 StartColumn:1 EndLine:17 EndColumn:2 Name:copyChunk Params:[{Name:chunk Type:[]Comparators}] Results:[{Name: Type:[]Comparators}] Receiver:<nil> Body:{
	cp := make([]Comparators, len(chunk))
	copy(cp, chunk)
	return cp
} PrettyPrintBody:[{ cp := make([]Comparators, len(chunk)) copy(cp, chunk) return cp }]} {Id:3 FileId:135 StartLine:23 StartColumn:1 EndLine:64 EndColumn:2 Name:MultithreadedSortComparators Params:[{Name:comparators Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	toBeSorted := make(Comparators, len(comparators))
	copy(toBeSorted, comparators)

	var wg sync.WaitGroup

	numCPU := int64(runtime.NumCPU())
	if numCPU%2 == 1 {
		numCPU++
	}

	chunks := chunk(toBeSorted, numCPU)
	wg.Add(len(chunks))
	for i := 0; i < len(chunks); i++ {
		go func(i int) {
			sortBucket(chunks[i])
			wg.Done()
		}(i)
	}

	wg.Wait()
	todo := make([]Comparators, len(chunks)/2)
	for {
		todo = todo[:len(chunks)/2]
		wg.Add(len(chunks) / 2)
		for i := 0; i < len(chunks); i += 2 {
			go func(i int) {
				todo[i/2] = SymMerge(chunks[i], chunks[i+1])
				wg.Done()
			}(i)
		}

		wg.Wait()

		chunks = copyChunk(todo)
		if len(chunks) == 1 {
			break
		}
	}

	return chunks[0]
} PrettyPrintBody:[{ toBeSorted := make(Comparators, len(comparators)) copy(toBeSorted, comparators) var wg sync.WaitGroup numCPU := int64(runtime.NumCPU()) if numCPU%2 == 1 { numCPU++ } chunks := chunk(toBeSorted, numCPU) wg.Add(len(chunks)) for i := 0; i < len(chunks); i++ { go func(i int) { sortBucket(chunks[i]) wg.Done() }(i) } wg.Wait() todo := make([]Comparators, len(chunks)/2) for { todo = todo[:len(chunks)/2] wg.Add(len(chunks) / 2) for i := 0; i < len(chunks); i += 2 { go func(i int) { todo[i/2] = SymMerge(chunks[i], chunks[i+1]) wg.Done() }(i) } wg.Wait() chunks = copyChunk(todo) if len(chunks) == 1 { break } } return chunks[0] }]} {Id:4 FileId:135 StartLine:66 StartColumn:1 EndLine:72 EndColumn:2 Name:chunk Params:[{Name:comparators Type:Comparators} {Name:numParts Type:int64}] Results:[{Name: Type:[]Comparators}] Receiver:<nil> Body:{
	parts := make([]Comparators, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = comparators[i*int64(len(comparators))/numParts : (i+1)*int64(len(comparators))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Comparators, numParts) for i := int64(0); i < numParts; i++ { parts[i] = comparators[i*int64(len(comparators))/numParts : (i+1)*int64(len(comparators))/numParts] } return parts }]} {Id:3 FileId:85 StartLine:32 StartColumn:1 EndLine:38 EndColumn:2 Name:Put Params:[{Name:items Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc00095aa40 Body:{
	args := m.Called(items)
	if m.PutChan != nil {
		m.PutChan <- true
	}
	return args.Error(0)
} PrettyPrintBody:[{ args := m.Called(items) if m.PutChan != nil { m.PutChan <- true } return args.Error(0) }]} {Id:4 FileId:85 StartLine:40 StartColumn:1 EndLine:43 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc001580920 Body:{
	args := m.Called()
	return args.Get(0).([]interface{}), args.Error(1)
} PrettyPrintBody:[{ args := m.Called() return args.Get(0).([]interface{}), args.Error(1) }]} {Id:5 FileId:85 StartLine:45 StartColumn:1 EndLine:48 EndColumn:2 Name:Flush Params:[] Results:[{Name: Type:error}] Receiver:0xc001238080 Body:{
	args := m.Called()
	return args.Error(0)
} PrettyPrintBody:[{ args := m.Called() return args.Error(0) }]} {Id:6 FileId:85 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc000e5b200 Body:{
	m.Called()
} PrettyPrintBody:[{ m.Called() }]} {Id:7 FileId:85 StartLine:54 StartColumn:1 EndLine:57 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc001032fe0 Body:{
	args := m.Called()
	return args.Bool(0)
} PrettyPrintBody:[{ args := m.Called() return args.Bool(0) }]} {Id:1 FileId:112 StartLine:23 StartColumn:1 EndLine:25 EndColumn:2 Name:ValueAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc000b76a00 Body:{
	return me.values[dimension]
} PrettyPrintBody:[{ return me.values[dimension] }]} {Id:2 FileId:112 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:newMockEntry Params:[{Name:values Type:...int64}] Results:[{Name: Type:*mockEntry}] Receiver:<nil> Body:{
	return &mockEntry{values: values}
} PrettyPrintBody:[{ return &mockEntry{values: values} }]} {Id:4 FileId:112 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:LowAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc001291040 Body:{
	return mi.lows[dimension]
} PrettyPrintBody:[{ return mi.lows[dimension] }]} {Id:5 FileId:112 StartLine:39 StartColumn:1 EndLine:41 EndColumn:2 Name:HighAtDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc001291620 Body:{
	return mi.highs[dimension]
} PrettyPrintBody:[{ return mi.highs[dimension] }]} {Id:6 FileId:112 StartLine:43 StartColumn:1 EndLine:48 EndColumn:2 Name:newMockInterval Params:[{Name:lows Type:[]int64}] Results:[{Name: Type:*mockInterval}] Receiver:<nil> Body:{
	return &mockInterval{
		lows:	lows,
		highs:	highs,
	}
} PrettyPrintBody:[{ return &mockInterval{ lows:	lows, highs:	highs, } }]} {Id:1 FileId:39 StartLine:37 StartColumn:1 EndLine:43 EndColumn:2 Name:DefaultConfig Params:[{Name:persister Type:Persister} {Name:comparator Type:Comparator}] Results:[{Name: Type:Config}] Receiver:<nil> Body:{
	return Config{
		NodeWidth:	10000,
		Persister:	persister,
		Comparator:	comparator,
	}
} PrettyPrintBody:[{ return Config{ NodeWidth:	10000, Persister:	persister, Comparator:	comparator, } }]} {Id:2 FileId:125 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc000fa7e40 Body:{
	return len(s)
} PrettyPrintBody:[{ return len(s) }]} {Id:3 FileId:125 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000f52980 Body:{
	return s[i] < s[j]
} PrettyPrintBody:[{ return s[i] < s[j] }]} {Id:4 FileId:125 StartLine:45 StartColumn:1 EndLine:49 EndColumn:2 Name:Search Params:[{Name:x Type:int64}] Results:[{Name: Type:int}] Receiver:0xc000dde000 Body:{
	return sort.Search(len(s), func(i int) bool {
		return s[i] >= x
	})
} PrettyPrintBody:[{ return sort.Search(len(s), func(i int) bool { return s[i] >= x }) }]} {Id:5 FileId:125 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:Sort Params:[] Results:[] Receiver:0xc001309000 Body:{
	sort.Sort(s)
} PrettyPrintBody:[{ sort.Sort(s) }]} {Id:6 FileId:125 StartLine:58 StartColumn:1 EndLine:60 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0010bc7c0 Body:{
	s[i], s[j] = s[j], s[i]
} PrettyPrintBody:[{ s[i], s[j] = s[j], s[i] }]} {Id:7 FileId:125 StartLine:65 StartColumn:1 EndLine:72 EndColumn:2 Name:Exists Params:[{Name:x Type:int64}] Results:[{Name: Type:bool}] Receiver:0xc000e617e0 Body:{
	i := s.Search(x)
	if i == len(s) {
		return false
	}

	return s[i] == x
} PrettyPrintBody:[{ i := s.Search(x) if i == len(s) { return false } return s[i] == x }]} {Id:8 FileId:125 StartLine:77 StartColumn:1 EndLine:91 EndColumn:2 Name:Insert Params:[{Name:x Type:int64}] Results:[{Name: Type:Int64Slice}] Receiver:0xc001309280 Body:{
	i := s.Search(x)
	if i == len(s) {
		return append(s, x)
	}

	if s[i] == x {
		return s
	}

	s = append(s, 0)
	copy(s[i+1:], s[i:])
	s[i] = x
	return s
} PrettyPrintBody:[{ i := s.Search(x) if i == len(s) { return append(s, x) } if s[i] == x { return s } s = append(s, 0) copy(s[i+1:], s[i:]) s[i] = x return s }]} {Id:5 FileId:71 StartLine:14 StartColumn:1 EndLine:73 EndColumn:2 Name:Example Params:[] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	fmt.Println("Created heap 1.")
	nodeh1_1 := heap1.Enqueue(SomeLargerNumberAround15)
	fmt.Printf("Heap 1 insert: %v\n", nodeh1_1.Priority)

	heap2 := NewFloatFibHeap()
	fmt.Println("Created heap 2.")
	fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty())
	nodeh2_1 := heap2.Enqueue(SomeNumberAroundMinus1000)
	fmt.Printf("Heap 2 insert: %v\n", nodeh2_1.Priority)
	nodeh2_2 := heap2.Enqueue(SomeNumberAround0)
	fmt.Printf("Heap 2 insert: %v\n", nodeh2_2.Priority)
	fmt.Printf("Heap 1 size: %v\n", heap1.Size())
	fmt.Printf("Heap 2 size: %v\n", heap2.Size())
	fmt.Printf("Heap 1 is empty? %v\n", heap1.IsEmpty())
	fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty())

	fmt.Printf("\nMerge Heap 1 and Heap 2.\n")
	mergedHeap, _ := heap1.Merge(&heap2)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())
	fmt.Printf("Set node with priority %v to new priority %v\n", SomeNumberAroundMinus1000, SomeNumberAroundMinus1003)

	mergedHeap.DecreaseKey(nodeh2_1, SomeNumberAroundMinus1003)
	min, _ := mergedHeap.DequeueMin()
	fmt.Printf("Dequeue minimum of merged heap: %v\n", min.Priority)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())

	fmt.Printf("Delete from merged heap: %v\n", SomeNumberAround0)
	mergedHeap.Delete(nodeh2_2)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())

	min, _ = mergedHeap.DequeueMin()
	fmt.Printf("Extracting minimum of merged heap: %v\n", min.Priority)
	fmt.Printf("Merged heap size: %v\n", mergedHeap.Size())
	fmt.Printf("Merged heap is empty? %v\n", mergedHeap.IsEmpty())

} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() fmt.Println("Created heap 1.") nodeh1_1 := heap1.Enqueue(SomeLargerNumberAround15) fmt.Printf("Heap 1 insert: %v\n", nodeh1_1.Priority) heap2 := NewFloatFibHeap() fmt.Println("Created heap 2.") fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty()) nodeh2_1 := heap2.Enqueue(SomeNumberAroundMinus1000) fmt.Printf("Heap 2 insert: %v\n", nodeh2_1.Priority) nodeh2_2 := heap2.Enqueue(SomeNumberAround0) fmt.Printf("Heap 2 insert: %v\n", nodeh2_2.Priority) fmt.Printf("Heap 1 size: %v\n", heap1.Size()) fmt.Printf("Heap 2 size: %v\n", heap2.Size()) fmt.Printf("Heap 1 is empty? %v\n", heap1.IsEmpty()) fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty()) fmt.Printf("\nMerge Heap 1 and Heap 2.\n") mergedHeap, _ := heap1.Merge(&heap2) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Set node with priority %v to new priority %v\n", SomeNumberAroundMinus1000, SomeNumberAroundMinus1003) mergedHeap.DecreaseKey(nodeh2_1, SomeNumberAroundMinus1003) min, _ := mergedHeap.DequeueMin() fmt.Printf("Dequeue minimum of merged heap: %v\n", min.Priority) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Delete from merged heap: %v\n", SomeNumberAround0) mergedHeap.Delete(nodeh2_2) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) min, _ = mergedHeap.DequeueMin() fmt.Printf("Extracting minimum of merged heap: %v\n", min.Priority) fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()) fmt.Printf("Merged heap is empty? %v\n", mergedHeap.IsEmpty()) }]} {Id:1 FileId:151 StartLine:34 StartColumn:1 EndLine:36 EndColumn:2 Name:mask Params:[{Name:hash Type:uint32} {Name:level Type:uint8}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	return (hash >> (5 * level)) & 0x01f
} PrettyPrintBody:[{ return (hash >> (5 * level)) & 0x01f }]} {Id:2 FileId:151 StartLine:38 StartColumn:1 EndLine:70 EndColumn:2 Name:defaultHasher Params:[{Name:value Type:interface{}}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	switch v := value.(type) {
	case uint8:
		return uint32(v)
	case uint16:
		return uint32(v)
	case uint32:
		return v
	case uint64:
		return uint32(v)
	case int8:
		return uint32(v)
	case int16:
		return uint32(v)
	case int32:
		return uint32(v)
	case int64:
		return uint32(v)
	case uint:
		return uint32(v)
	case int:
		return uint32(v)
	case uintptr:
		return uint32(v)
	case float32:
		return uint32(v)
	case float64:
		return uint32(v)
	}
	hasher := fnv.New32a()
	hasher.Write([]byte(fmt.Sprintf("%#v", value)))
	return hasher.Sum32()
} PrettyPrintBody:[{ switch v := value.(type) { case uint8: return uint32(v) case uint16: return uint32(v) case uint32: return v case uint64: return uint32(v) case int8: return uint32(v) case int16: return uint32(v) case int32: return uint32(v) case int64: return uint32(v) case uint: return uint32(v) case int: return uint32(v) case uintptr: return uint32(v) case float32: return uint32(v) case float64: return uint32(v) } hasher := fnv.New32a() hasher.Write([]byte(fmt.Sprintf("%#v", value))) return hasher.Sum32() }]} {Id:2 FileId:130 StartLine:27 StartColumn:1 EndLine:38 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000dceb00 Body:{
	otherU := other.(mockEntry)
	if me == otherU {
		return 0
	}

	if me > otherU {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherU := other.(mockEntry) if me == otherU { return 0 } if me > otherU { return 1 } return -1 }]} {Id:3 FileId:130 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:newMockEntry Params:[{Name:key Type:uint64}] Results:[{Name: Type:mockEntry}] Receiver:<nil> Body:{
	return mockEntry(key)
} PrettyPrintBody:[{ return mockEntry(key) }]} {Id:5 FileId:130 StartLine:48 StartColumn:1 EndLine:51 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001238600 Body:{
	args := mi.Called()
	return args.Bool(0)
} PrettyPrintBody:[{ args := mi.Called() return args.Bool(0) }]} {Id:6 FileId:130 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc0012388c0 Body:{
	args := mi.Called()
	result, ok := args.Get(0).(common.Comparator)
	if !ok {
		return nil
	}

	return result
} PrettyPrintBody:[{ args := mi.Called() result, ok := args.Get(0).(common.Comparator) if !ok { return nil } return result }]} {Id:7 FileId:130 StartLine:63 StartColumn:1 EndLine:65 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001409580 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:2 FileId:61 StartLine:26 StartColumn:1 EndLine:42 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095ab40 Body:{
	if iter.index == iteratorExhausted {
		return false
	}

	iter.index++
	if iter.index >= len(iter.node.keys) {
		iter.node = iter.node.pointer
		if iter.node == nil {
			iter.index = iteratorExhausted
			return false
		}
		iter.index = 0
	}

	return true
} PrettyPrintBody:[{ if iter.index == iteratorExhausted { return false } iter.index++ if iter.index >= len(iter.node.keys) { iter.node = iter.node.pointer if iter.node == nil { iter.index = iteratorExhausted return false } iter.index = 0 } return true }]} {Id:3 FileId:61 StartLine:44 StartColumn:1 EndLine:52 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Key}] Receiver:0xc001032dc0 Body:{
	if iter.index == iteratorExhausted ||
		iter.index < 0 || iter.index >= len(iter.node.keys) {

		return nil
	}

	return iter.node.keys[iter.index]
} PrettyPrintBody:[{ if iter.index == iteratorExhausted || iter.index < 0 || iter.index >= len(iter.node.keys) { return nil } return iter.node.keys[iter.index] }]} {Id:4 FileId:61 StartLine:55 StartColumn:1 EndLine:62 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:keys}] Receiver:0xc000e7eea0 Body:{
	keys := make(keys, 0, 10)
	for iter := iter; iter.Next(); {
		keys = append(keys, iter.Value())
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, 10) for iter := iter; iter.Next(); { keys = append(keys, iter.Value()) } return keys }]} {Id:5 FileId:61 StartLine:64 StartColumn:1 EndLine:68 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*iterator}] Receiver:<nil> Body:{
	return &iterator{
		index: iteratorExhausted,
	}
} PrettyPrintBody:[{ return &iterator{ index: iteratorExhausted, } }]} {Id:2 FileId:46 StartLine:39 StartColumn:1 EndLine:48 EndColumn:2 Name:append Params:[{Name:pb Type:*pathBundle}] Results:[] Receiver:0xc001602020 Body:{
	if p.head == nil {
		p.head = pb
		p.tail = pb
		return
	}

	pb.prev = p.tail
	p.tail = pb
} PrettyPrintBody:[{ if p.head == nil { p.head = pb p.tail = pb return } pb.prev = p.tail p.tail = pb }]} {Id:3 FileId:46 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:*pathBundle}] Receiver:0xc000e7e140 Body:{
	if pb := p.tail; pb != nil {
		p.tail = pb.prev
		pb.prev = nil
		return pb
	}

	return nil
} PrettyPrintBody:[{ if pb := p.tail; pb != nil { p.tail = pb.prev pb.prev = nil return pb } return nil }]} {Id:4 FileId:46 StartLine:63 StartColumn:1 EndLine:65 EndColumn:2 Name:peek Params:[] Results:[{Name: Type:*pathBundle}] Receiver:0xc0012469c0 Body:{
	return p.tail
} PrettyPrintBody:[{ return p.tail }]} {Id:1 FileId:117 StartLine:23 StartColumn:1 EndLine:25 EndColumn:2 Name:LowerLeft Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc001000700 Body:{
	return mr.xlow, mr.ylow
} PrettyPrintBody:[{ return mr.xlow, mr.ylow }]} {Id:2 FileId:117 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:UpperRight Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc00095ac00 Body:{
	return mr.xhigh, mr.yhigh
} PrettyPrintBody:[{ return mr.xhigh, mr.yhigh }]} {Id:3 FileId:117 StartLine:31 StartColumn:1 EndLine:38 EndColumn:2 Name:newMockRectangle Params:[{Name:xlow Type:int32}] Results:[{Name: Type:*mockRectangle}] Receiver:<nil> Body:{
	return &mockRectangle{
		xlow:	xlow,
		ylow:	ylow,
		xhigh:	xhigh,
		yhigh:	yhigh,
	}
} PrettyPrintBody:[{ return &mockRectangle{ xlow:	xlow, ylow:	ylow, xhigh:	xhigh, yhigh:	yhigh, } }]} {Id:1 FileId:17 StartLine:25 StartColumn:1 EndLine:36 EndColumn:2 Name:TestBlockToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := block(0)

	b = b.insert(s - 2)
	b = b.insert(s - 6)

	expected := []uint64{s - 6, s - 2}

	result := make([]uint64, 0, 0)
	b.toNums(0, &result)
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ b := block(0) b = b.insert(s - 2) b = b.insert(s - 6) expected := []uint64{s - 6, s - 2} result := make([]uint64, 0, 0) b.toNums(0, &result) assert.Equal(t, expected, result) }]} {Id:2 FileId:17 StartLine:38 StartColumn:1 EndLine:50 EndColumn:2 Name:BenchmarkBlockToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	block := block(0)
	for i := uint64(0); i < s; i++ {
		block = block.insert(i)
	}

	nums := make([]uint64, 0, 0)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		block.toNums(0, &nums)
	}
} PrettyPrintBody:[{ block := block(0) for i := uint64(0); i < s; i++ { block = block.insert(i) } nums := make([]uint64, 0, 0) b.ResetTimer() for i := 0; i < b.N; i++ { block.toNums(0, &nums) } }]} {Id:0 FileId:23 StartLine:19 StartColumn:1 EndLine:84 EndColumn:2 Name:nandSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	max := len(sba.indices)
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	var resultBlock block

	for {
		if selfIndex == len(sba.indices) {

			break
		} else if otherIndex == len(other.indices) {

			indices = append(indices, sba.indices[selfIndex])
			blocks = append(blocks, sba.blocks[selfIndex])
			selfIndex++
			continue
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch {
		case otherValue < selfValue:

			otherIndex++

		case otherValue > selfValue:

			indices = append(indices, selfValue)
			blocks = append(blocks, sba.blocks[selfIndex])

			selfIndex++

		default:

			resultBlock = sba.blocks[selfIndex].nand(other.blocks[otherIndex])
			if resultBlock > 0 {
				indices = append(indices, selfValue)
				blocks = append(blocks, resultBlock)
			}
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ max := len(sba.indices) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 var resultBlock block for { if selfIndex == len(sba.indices) { break } else if otherIndex == len(other.indices) { indices = append(indices, sba.indices[selfIndex]) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ continue } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch { case otherValue < selfValue: otherIndex++ case otherValue > selfValue: indices = append(indices, selfValue) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ default: resultBlock = sba.blocks[selfIndex].nand(other.blocks[otherIndex]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]} {Id:1 FileId:23 StartLine:86 StartColumn:1 EndLine:116 EndColumn:2 Name:nandSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	indices := make(uintSlice, 0, len(sba.indices))
	blocks := make(blocks, 0, len(sba.indices))

	var resultBlock block

	for selfIndex, selfValue := range sba.indices {
		if selfValue >= uint64(len(other.blocks)) {

			resultBlock = sba.blocks[selfIndex]
			indices = append(indices, selfValue)
			blocks = append(blocks, resultBlock)
			continue
		}

		resultBlock = sba.blocks[selfIndex].nand(other.blocks[selfValue])
		if resultBlock > 0 {
			indices = append(indices, selfValue)
			blocks = append(blocks, resultBlock)
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ indices := make(uintSlice, 0, len(sba.indices)) blocks := make(blocks, 0, len(sba.indices)) var resultBlock block for selfIndex, selfValue := range sba.indices { if selfValue >= uint64(len(other.blocks)) { resultBlock = sba.blocks[selfIndex] indices = append(indices, selfValue) blocks = append(blocks, resultBlock) continue } resultBlock = sba.blocks[selfIndex].nand(other.blocks[selfValue]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]} {Id:2 FileId:23 StartLine:118 StartColumn:1 EndLine:137 EndColumn:2 Name:nandDenseWithSparseBitArray Params:[{Name:sba Type:*bitArray} {Name:other Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	tmp := sba.copy()
	ret := tmp.(*bitArray)

	for otherIndex, otherValue := range other.indices {
		if otherValue >= uint64(len(ret.blocks)) {
			break
		}

		ret.blocks[otherValue] = sba.blocks[otherValue].nand(other.blocks[otherIndex])
	}

	ret.setLowest()
	ret.setHighest()

	return ret
} PrettyPrintBody:[{ tmp := sba.copy() ret := tmp.(*bitArray) for otherIndex, otherValue := range other.indices { if otherValue >= uint64(len(ret.blocks)) { break } ret.blocks[otherValue] = sba.blocks[otherValue].nand(other.blocks[otherIndex]) } ret.setLowest() ret.setHighest() return ret }]} {Id:3 FileId:23 StartLine:139 StartColumn:1 EndLine:152 EndColumn:2 Name:nandDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	min := uint64(len(dba.blocks))

	ba := newBitArray(min * s)

	for i := uint64(0); i < min; i++ {
		ba.blocks[i] = dba.blocks[i].nand(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ min := uint64(len(dba.blocks)) ba := newBitArray(min * s) for i := uint64(0); i < min; i++ { ba.blocks[i] = dba.blocks[i].nand(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]} {Id:2 FileId:148 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc0009f9f60 Body:{
	return e.hash
} PrettyPrintBody:[{ return e.hash }]} {Id:3 FileId:148 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0009f9fa0 Body:{
	return e.key
} PrettyPrintBody:[{ return e.key }]} {Id:4 FileId:148 StartLine:56 StartColumn:1 EndLine:58 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000fbd4e0 Body:{
	return e.value
} PrettyPrintBody:[{ return e.value }]} {Id:5 FileId:148 StartLine:62 StartColumn:1 EndLine:70 EndColumn:2 Name:New Params:[{Name:hasher Type:func(v interface{}) uint32}] Results:[{Name: Type:*Dtrie}] Receiver:<nil> Body:{
	if hasher == nil {
		hasher = defaultHasher
	}
	return &Dtrie{
		root:	emptyNode(0, 32),
		hasher:	hasher,
	}
} PrettyPrintBody:[{ if hasher == nil { hasher = defaultHasher } return &Dtrie{ root:	emptyNode(0, 32), hasher:	hasher, } }]} {Id:6 FileId:148 StartLine:73 StartColumn:1 EndLine:78 EndColumn:2 Name:Size Params:[] Results:[{Name:size Type:int}] Receiver:0xc001580a40 Body:{
	for _ = range iterate(d.root, nil) {
		size++
	}
	return size
} PrettyPrintBody:[{ for _ = range iterate(d.root, nil) { size++ } return size }]} {Id:7 FileId:148 StartLine:82 StartColumn:1 EndLine:88 EndColumn:2 Name:Get Params:[{Name:key Type:interface{}}] Results:[{Name: Type:interface{}}] Receiver:0xc001409680 Body:{
	node := get(d.root, d.hasher(key), key)
	if node != nil {
		return node.Value()
	}
	return nil
} PrettyPrintBody:[{ node := get(d.root, d.hasher(key), key) if node != nil { return node.Value() } return nil }]} {Id:8 FileId:148 StartLine:92 StartColumn:1 EndLine:95 EndColumn:2 Name:Insert Params:[{Name:key Type:interface{}}] Results:[{Name: Type:*Dtrie}] Receiver:0xc0010335a0 Body:{
	root := insert(d.root, &entry{d.hasher(key), key, value})
	return &Dtrie{root, d.hasher}
} PrettyPrintBody:[{ root := insert(d.root, &entry{d.hasher(key), key, value}) return &Dtrie{root, d.hasher} }]} {Id:9 FileId:148 StartLine:99 StartColumn:1 EndLine:102 EndColumn:2 Name:Remove Params:[{Name:key Type:interface{}}] Results:[{Name: Type:*Dtrie}] Receiver:0xc0014096e0 Body:{
	root := remove(d.root, d.hasher(key), key)
	return &Dtrie{root, d.hasher}
} PrettyPrintBody:[{ root := remove(d.root, d.hasher(key), key) return &Dtrie{root, d.hasher} }]} {Id:10 FileId:148 StartLine:108 StartColumn:1 EndLine:110 EndColumn:2 Name:Iterator Params:[{Name:stop Type:<-chan struct{}}] Results:[{Name: Type:<-chan Entry}] Receiver:0xc00095a160 Body:{
	return iterate(d.root, stop)
} PrettyPrintBody:[{ return iterate(d.root, stop) }]} {Id:2 FileId:119 StartLine:25 StartColumn:1 EndLine:42 EndColumn:2 Name:adjust Params:[{Name:rect Type:rtree.Rectangle}] Results:[] Receiver:0xc001098260 Body:{
	x, y := rect.LowerLeft()
	if x < r.xlow {
		r.xlow = x
	}
	if y < r.ylow {
		r.ylow = y
	}

	x, y = rect.UpperRight()
	if x > r.xhigh {
		r.xhigh = x
	}

	if y > r.yhigh {
		r.yhigh = y
	}
} PrettyPrintBody:[{ x, y := rect.LowerLeft() if x < r.xlow { r.xlow = x } if y < r.ylow { r.ylow = y } x, y = rect.UpperRight() if x > r.xhigh { r.xhigh = x } if y > r.yhigh { r.yhigh = y } }]} {Id:3 FileId:119 StartLine:44 StartColumn:1 EndLine:52 EndColumn:2 Name:equal Params:[{Name:r1 Type:rtree.Rectangle}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	xlow1, ylow1 := r1.LowerLeft()
	xhigh2, yhigh2 := r2.UpperRight()

	xhigh1, yhigh1 := r1.UpperRight()
	xlow2, ylow2 := r2.LowerLeft()

	return xlow1 == xlow2 && xhigh1 == xhigh2 && ylow1 == ylow2 && yhigh1 == yhigh2
} PrettyPrintBody:[{ xlow1, ylow1 := r1.LowerLeft() xhigh2, yhigh2 := r2.UpperRight() xhigh1, yhigh1 := r1.UpperRight() xlow2, ylow2 := r2.LowerLeft() return xlow1 == xlow2 && xhigh1 == xhigh2 && ylow1 == ylow2 && yhigh1 == yhigh2 }]} {Id:4 FileId:119 StartLine:54 StartColumn:1 EndLine:59 EndColumn:2 Name:intersect Params:[{Name:rect1 Type:*rectangle} {Name:rect2 Type:rtree.Rectangle}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	xhigh2, yhigh2 := rect2.UpperRight()
	xlow2, ylow2 := rect2.LowerLeft()

	return xhigh2 >= rect1.xlow && xlow2 <= rect1.xhigh && yhigh2 >= rect1.ylow && ylow2 <= rect1.yhigh
} PrettyPrintBody:[{ xhigh2, yhigh2 := rect2.UpperRight() xlow2, ylow2 := rect2.LowerLeft() return xhigh2 >= rect1.xlow && xlow2 <= rect1.xhigh && yhigh2 >= rect1.ylow && ylow2 <= rect1.yhigh }]} {Id:5 FileId:119 StartLine:61 StartColumn:1 EndLine:72 EndColumn:2 Name:newRectangeFromRect Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:*rectangle}] Receiver:<nil> Body:{
	r := &rectangle{}
	x, y := rect.LowerLeft()
	r.xlow = x
	r.ylow = y

	x, y = rect.UpperRight()
	r.xhigh = x
	r.yhigh = y

	return r
} PrettyPrintBody:[{ r := &rectangle{} x, y := rect.LowerLeft() r.xlow = x r.ylow = y x, y = rect.UpperRight() r.xhigh = x r.yhigh = y return r }]} {Id:6 FileId:119 StartLine:74 StartColumn:1 EndLine:93 EndColumn:2 Name:newRectangleFromRects Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*rectangle}] Receiver:<nil> Body:{
	if len(rects) == 0 {
		panic(`Cannot construct rectangle with no dimensions.`)
	}

	xlow, ylow := rects[0].LowerLeft()
	xhigh, yhigh := rects[0].UpperRight()
	r := &rectangle{
		xlow:	xlow,
		xhigh:	xhigh,
		ylow:	ylow,
		yhigh:	yhigh,
	}

	for i := 1; i < len(rects); i++ {
		r.adjust(rects[i])
	}

	return r
} PrettyPrintBody:[{ if len(rects) == 0 { panic(`Cannot construct rectangle with no dimensions.`) } xlow, ylow := rects[0].LowerLeft() xhigh, yhigh := rects[0].UpperRight() r := &rectangle{ xlow:	xlow, xhigh:	xhigh, ylow:	ylow, yhigh:	yhigh, } for i := 1; i < len(rects); i++ { r.adjust(rects[i]) } return r }]} {Id:1 FileId:80 StartLine:13 StartColumn:1 EndLine:18 EndColumn:2 Name:TestHash Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	key := uint64(5)
	h := hash(key)

	assert.NotEqual(t, key, h)
} PrettyPrintBody:[{ key := uint64(5) h := hash(key) assert.NotEqual(t, key, h) }]} {Id:2 FileId:80 StartLine:20 StartColumn:1 EndLine:36 EndColumn:2 Name:BenchmarkHash Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, numItems)
	for i := 0; i < numItems; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hash(key)
		}
	}
} PrettyPrintBody:[{ numItems := 1000 r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, numItems) for i := 0; i < numItems; i++ { key := uint64(r.Int63()) keys = append(keys, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hash(key) } } }]} {Id:3 FileId:80 StartLine:38 StartColumn:1 EndLine:56 EndColumn:2 Name:BenchmarkFnvHash Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, numItems)
	for i := 0; i < numItems; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hasher := fnv.New64()
			binary.Write(hasher, binary.LittleEndian, key)
			hasher.Sum64()
		}
	}
} PrettyPrintBody:[{ numItems := 1000 r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, numItems) for i := 0; i < numItems; i++ { key := uint64(r.Int63()) keys = append(keys, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hasher := fnv.New64() binary.Write(hasher, binary.LittleEndian, key) hasher.Sum64() } } }]} {Id:0 FileId:58 StartLine:36 StartColumn:1 EndLine:51 EndColumn:2 Name:keySearch Params:[{Name:keys Type:keys} {Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	low, high := 0, len(keys)-1
	var mid int
	for low <= high {
		mid = (high + low) / 2
		switch keys[mid].Compare(key) {
		case 1:
			low = mid + 1
		case -1:
			high = mid - 1
		case 0:
			return mid
		}
	}
	return low
} PrettyPrintBody:[{ low, high := 0, len(keys)-1 var mid int for low <= high { mid = (high + low) / 2 switch keys[mid].Compare(key) { case 1: low = mid + 1 case -1: high = mid - 1 case 0: return mid } } return low }]} {Id:2 FileId:58 StartLine:58 StartColumn:1 EndLine:74 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[] Receiver:0xc0016022c0 Body:{
	if tree.root == nil {
		n := newLeafNode(tree.nodeSize)
		n.insert(tree, key)
		tree.number = 1
		return
	}

	result := tree.root.insert(tree, key)
	if result {
		tree.number++
	}

	if tree.root.needsSplit(tree.nodeSize) {
		tree.root = split(tree, nil, tree.root)
	}
} PrettyPrintBody:[{ if tree.root == nil { n := newLeafNode(tree.nodeSize) n.insert(tree, key) tree.number = 1 return } result := tree.root.insert(tree, key) if result { tree.number++ } if tree.root.needsSplit(tree.nodeSize) { tree.root = split(tree, nil, tree.root) } }]} {Id:3 FileId:58 StartLine:79 StartColumn:1 EndLine:83 EndColumn:2 Name:Insert Params:[{Name:keys Type:...Key}] Results:[] Receiver:0xc001240b80 Body:{
	for _, key := range keys {
		tree.insert(key)
	}
} PrettyPrintBody:[{ for _, key := range keys { tree.insert(key) } }]} {Id:4 FileId:58 StartLine:87 StartColumn:1 EndLine:93 EndColumn:2 Name:Iter Params:[{Name:key Type:Key}] Results:[{Name: Type:Iterator}] Receiver:0xc001240fe0 Body:{
	if tree.root == nil {
		return nilIterator()
	}

	return tree.root.find(key)
} PrettyPrintBody:[{ if tree.root == nil { return nilIterator() } return tree.root.find(key) }]} {Id:5 FileId:58 StartLine:95 StartColumn:1 EndLine:106 EndColumn:2 Name:get Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc0013091c0 Body:{
	iter := tree.root.find(key)
	if !iter.Next() {
		return nil
	}

	if iter.Value().Compare(key) == 0 {
		return iter.Value()
	}

	return nil
} PrettyPrintBody:[{ iter := tree.root.find(key) if !iter.Next() { return nil } if iter.Value().Compare(key) == 0 { return iter.Value() } return nil }]} {Id:6 FileId:58 StartLine:111 StartColumn:1 EndLine:118 EndColumn:2 Name:Get Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc001033280 Body:{
	results := make(Keys, 0, len(keys))
	for _, k := range keys {
		results = append(results, tree.get(k))
	}

	return results
} PrettyPrintBody:[{ results := make(Keys, 0, len(keys)) for _, k := range keys { results = append(results, tree.get(k)) } return results }]} {Id:7 FileId:58 StartLine:121 StartColumn:1 EndLine:123 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409800 Body:{
	return tree.number
} PrettyPrintBody:[{ return tree.number }]} {Id:8 FileId:58 StartLine:125 StartColumn:1 EndLine:130 EndColumn:2 Name:newBTree Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:*btree}] Receiver:<nil> Body:{
	return &btree{
		nodeSize:	nodeSize,
		root:		newLeafNode(nodeSize),
	}
} PrettyPrintBody:[{ return &btree{ nodeSize:	nodeSize, root:		newLeafNode(nodeSize), } }]} {Id:1 FileId:87 StartLine:39 StartColumn:1 EndLine:45 EndColumn:2 Name:boolToInt Params:[{Name:value Type:bool}] Results:[{Name: Type:int32}] Receiver:<nil> Body:{
	if value {
		return int32(1)
	}

	return int32(0)
} PrettyPrintBody:[{ if value { return int32(1) } return int32(0) }]} {Id:2 FileId:87 StartLine:47 StartColumn:1 EndLine:58 EndColumn:2 Name:rotate Params:[{Name:n Type:int32} {Name:x Type:*int32}] Results:[] Receiver:<nil> Body:{
	if ry == 0 {
		if rx == 1 {
			*x = n - 1 - *x
			*y = n - 1 - *y
		}

		t := *x
		*x = *y
		*y = t
	}
} PrettyPrintBody:[{ if ry == 0 { if rx == 1 { *x = n - 1 - *x *y = n - 1 - *y } t := *x *x = *y *y = t } }]} {Id:3 FileId:87 StartLine:62 StartColumn:1 EndLine:73 EndColumn:2 Name:Encode Params:[{Name:x Type:int32}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	var rx, ry int32
	var d int64
	for s := int32(n / 2); s > 0; s /= 2 {
		rx = boolToInt(x&s > 0)
		ry = boolToInt(y&s > 0)
		d += int64(int64(s) * int64(s) * int64(((3 * rx) ^ ry)))
		rotate(s, rx, ry, &x, &y)
	}

	return d
} PrettyPrintBody:[{ var rx, ry int32 var d int64 for s := int32(n / 2); s > 0; s /= 2 { rx = boolToInt(x&s > 0) ry = boolToInt(y&s > 0) d += int64(int64(s) * int64(s) * int64(((3 * rx) ^ ry))) rotate(s, rx, ry, &x, &y) } return d }]} {Id:4 FileId:87 StartLine:77 StartColumn:1 EndLine:92 EndColumn:2 Name:Decode Params:[{Name:h Type:int64}] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:<nil> Body:{
	var ry, rx int64
	var x, y int32
	t := h

	for s := int64(1); s < int64(n); s *= 2 {
		rx = 1 & (t / 2)
		ry = 1 & (t ^ rx)
		rotate(int32(s), int32(rx), int32(ry), &x, &y)
		x += int32(s * rx)
		y += int32(s * ry)
		t /= 4
	}

	return x, y
} PrettyPrintBody:[{ var ry, rx int64 var x, y int32 t := h for s := int64(1); s < int64(n); s *= 2 { rx = 1 & (t / 2) ry = 1 & (t ^ rx) rotate(int32(s), int32(rx), int32(ry), &x, &y) x += int32(s * rx) y += int32(s * ry) t /= 4 } return x, y }]} {Id:3 FileId:73 StartLine:52 StartColumn:1 EndLine:62 EndColumn:2 Name:GetResult Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001032400 Body:{
	f.lock.Lock()
	if f.triggered {
		f.lock.Unlock()
		return f.item, f.err
	}
	f.lock.Unlock()

	f.wg.Wait()
	return f.item, f.err
} PrettyPrintBody:[{ f.lock.Lock() if f.triggered { f.lock.Unlock() return f.item, f.err } f.lock.Unlock() f.wg.Wait() return f.item, f.err }]} {Id:4 FileId:73 StartLine:65 StartColumn:1 EndLine:70 EndColumn:2 Name:HasResult Params:[] Results:[{Name: Type:bool}] Receiver:0xc0010019c0 Body:{
	f.lock.Lock()
	hasResult := f.triggered
	f.lock.Unlock()
	return hasResult
} PrettyPrintBody:[{ f.lock.Lock() hasResult := f.triggered f.lock.Unlock() return hasResult }]} {Id:5 FileId:73 StartLine:72 StartColumn:1 EndLine:79 EndColumn:2 Name:setItem Params:[{Name:item Type:interface{}} {Name:err Type:error}] Results:[] Receiver:0xc00095ac60 Body:{
	f.lock.Lock()
	f.triggered = true
	f.item = item
	f.err = err
	f.lock.Unlock()
	f.wg.Done()
} PrettyPrintBody:[{ f.lock.Lock() f.triggered = true f.item = item f.err = err f.lock.Unlock() f.wg.Done() }]} {Id:6 FileId:73 StartLine:81 StartColumn:1 EndLine:91 EndColumn:2 Name:listenForResult Params:[{Name:f Type:*Future} {Name:ch Type:Completer} {Name:timeout Type:time.Duration} {Name:wg Type:*sync.WaitGroup}] Results:[] Receiver:<nil> Body:{
	wg.Done()
	t := time.NewTimer(timeout)
	select {
	case item := <-ch:
		f.setItem(item, nil)
		t.Stop()
	case <-t.C:
		f.setItem(nil, fmt.Errorf(`timeout after %f seconds`, timeout.Seconds()))
	}
} PrettyPrintBody:[{ wg.Done() t := time.NewTimer(timeout) select { case item := <-ch: f.setItem(item, nil) t.Stop() case <-t.C: f.setItem(nil, fmt.Errorf(`timeout after %f seconds`, timeout.Seconds())) } }]} {Id:7 FileId:73 StartLine:97 StartColumn:1 EndLine:105 EndColumn:2 Name:New Params:[{Name:completer Type:Completer} {Name:timeout Type:time.Duration}] Results:[{Name: Type:*Future}] Receiver:<nil> Body:{
	f := &Future{}
	f.wg.Add(1)
	var wg sync.WaitGroup
	wg.Add(1)
	go listenForResult(f, completer, timeout, &wg)
	wg.Wait()
	return f
} PrettyPrintBody:[{ f := &Future{} f.wg.Add(1) var wg sync.WaitGroup wg.Add(1) go listenForResult(f, completer, timeout, &wg) wg.Wait() return f }]} {Id:2 FileId:160 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:iterExhausted Params:[{Name:iter Type:*Iterator}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return iter.index == iteratorExhausted
} PrettyPrintBody:[{ return iter.index == iteratorExhausted }]} {Id:4 FileId:160 StartLine:40 StartColumn:1 EndLine:61 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000dde040 Body:{
	if iterExhausted(iter) {
		return false
	}
	iter.index++
	if iter.index >= len(iter.entries.entries) {
		next := iter.xfastIterator.Next()
		if !next {
			iter.index = iteratorExhausted
			return false
		}
		var ok bool
		iter.entries, ok = iter.xfastIterator.Value().(*entriesWrapper)
		if !ok {
			iter.index = iteratorExhausted
			return false
		}
		iter.index = 0
	}

	return true
} PrettyPrintBody:[{ if iterExhausted(iter) { return false } iter.index++ if iter.index >= len(iter.entries.entries) { next := iter.xfastIterator.Next() if !next { iter.index = iteratorExhausted return false } var ok bool iter.entries, ok = iter.xfastIterator.Value().(*entriesWrapper) if !ok { iter.index = iteratorExhausted return false } iter.index = 0 } return true }]} {Id:5 FileId:160 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:Entry}] Receiver:0xc000e7fe00 Body:{
	if iterExhausted(iter) {
		return nil
	}

	if iter.entries == nil || iter.index < 0 || iter.index >= len(iter.entries.entries) {
		return nil
	}

	return iter.entries.entries[iter.index]
} PrettyPrintBody:[{ if iterExhausted(iter) { return nil } if iter.entries == nil || iter.index < 0 || iter.index >= len(iter.entries.entries) { return nil } return iter.entries.entries[iter.index] }]} {Id:6 FileId:160 StartLine:80 StartColumn:1 EndLine:87 EndColumn:2 Name:exhaust Params:[] Results:[{Name: Type:Entries}] Receiver:0xc000e7ffa0 Body:{
	entries := make(Entries, 0, 100)
	for it := iter; it.Next(); {
		entries = append(entries, it.Value())
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, 100) for it := iter; it.Next(); { entries = append(entries, it.Value()) } return entries }]} {Id:7 FileId:160 StartLine:91 StartColumn:1 EndLine:95 EndColumn:2 Name:nilIterator Params:[] Results:[{Name: Type:*Iterator}] Receiver:<nil> Body:{
	return &Iterator{
		index: iteratorExhausted,
	}
} PrettyPrintBody:[{ return &Iterator{ index: iteratorExhausted, } }]} {Id:0 FileId:29 StartLine:20 StartColumn:1 EndLine:29 EndColumn:2 Name:maxInt64 Params:[{Name:ints Type:...int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	maxInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] > maxInt {
			maxInt = ints[i]
		}
	}

	return maxInt
} PrettyPrintBody:[{ maxInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] > maxInt { maxInt = ints[i] } } return maxInt }]} {Id:1 FileId:29 StartLine:32 StartColumn:1 EndLine:41 EndColumn:2 Name:maxUint64 Params:[{Name:ints Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	maxInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] > maxInt {
			maxInt = ints[i]
		}
	}

	return maxInt
} PrettyPrintBody:[{ maxInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] > maxInt { maxInt = ints[i] } } return maxInt }]} {Id:2 FileId:29 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:minUint64 Params:[{Name:ints Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	minInt := ints[0]
	for i := 1; i < len(ints); i++ {
		if ints[i] < minInt {
			minInt = ints[i]
		}
	}

	return minInt
} PrettyPrintBody:[{ minInt := ints[0] for i := 1; i < len(ints); i++ { if ints[i] < minInt { minInt = ints[i] } } return minInt }]} {Id:1 FileId:145 StartLine:21 StartColumn:1 EndLine:25 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001291580 Body:{
	for i := range ns {
		ns[i] = nil
	}
} PrettyPrintBody:[{ for i := range ns { ns[i] = nil } }]} {Id:3 FileId:145 StartLine:35 StartColumn:1 EndLine:41 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*node}] Receiver:0xc000c499e0 Body:{
	return &node{
		balance:	n.balance,
		children:	[2]*node{n.children[0], n.children[1]},
		entry:		n.entry,
	}
} PrettyPrintBody:[{ return &node{ balance:	n.balance, children:	[2]*node{n.children[0], n.children[1]}, entry:		n.entry, } }]} {Id:4 FileId:145 StartLine:45 StartColumn:1 EndLine:50 EndColumn:2 Name:newNode Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		entry:		entry,
		children:	[2]*node{},
	}
} PrettyPrintBody:[{ return &node{ entry:		entry, children:	[2]*node{}, } }]} {Id:1 FileId:74 StartLine:27 StartColumn:1 EndLine:50 EndColumn:2 Name:TestWaitOnGetResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(30*time.Minute))
	var result interface{}
	var err error
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		result, err = f.GetResult()
		wg.Done()
	}()

	completer <- `test`
	wg.Wait()

	assert.Nil(t, err)
	assert.Equal(t, `test`, result)

	result, err = f.GetResult()

	assert.Equal(t, `test`, result)
	assert.Nil(t, err)
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(30*time.Minute)) var result interface{} var err error var wg sync.WaitGroup wg.Add(1) go func() { result, err = f.GetResult() wg.Done() }() completer <- `test` wg.Wait() assert.Nil(t, err) assert.Equal(t, `test`, result) result, err = f.GetResult() assert.Equal(t, `test`, result) assert.Nil(t, err) }]} {Id:2 FileId:74 StartLine:52 StartColumn:1 EndLine:69 EndColumn:2 Name:TestHasResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(30*time.Minute))

	assert.False(t, f.HasResult())

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		f.GetResult()
		wg.Done()
	}()

	completer <- `test`
	wg.Wait()

	assert.True(t, f.HasResult())
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(30*time.Minute)) assert.False(t, f.HasResult()) var wg sync.WaitGroup wg.Add(1) go func() { f.GetResult() wg.Done() }() completer <- `test` wg.Wait() assert.True(t, f.HasResult()) }]} {Id:3 FileId:74 StartLine:71 StartColumn:1 EndLine:79 EndColumn:2 Name:TestTimeout Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	f := New(completer, time.Duration(0))

	result, err := f.GetResult()

	assert.Nil(t, result)
	assert.NotNil(t, err)
} PrettyPrintBody:[{ completer := make(chan interface{}) f := New(completer, time.Duration(0)) result, err := f.GetResult() assert.Nil(t, result) assert.NotNil(t, err) }]} {Id:4 FileId:74 StartLine:81 StartColumn:1 EndLine:99 EndColumn:2 Name:BenchmarkFuture Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	completer := make(chan interface{})
	timeout := time.Duration(30 * time.Minute)
	var wg sync.WaitGroup

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(1)
		f := New(completer, timeout)
		go func() {
			f.GetResult()
			wg.Done()
		}()

		completer <- `test`
		wg.Wait()
	}
} PrettyPrintBody:[{ completer := make(chan interface{}) timeout := time.Duration(30 * time.Minute) var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(1) f := New(completer, timeout) go func() { f.GetResult() wg.Done() }() completer <- `test` wg.Wait() } }]} {Id:1 FileId:22 StartLine:26 StartColumn:1 EndLine:29 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000c56020 Body:{
	iter.index++
	return iter.index < int64(len(iter.sba.indices))
} PrettyPrintBody:[{ iter.index++ return iter.index < int64(len(iter.sba.indices)) }]} {Id:2 FileId:22 StartLine:32 StartColumn:1 EndLine:34 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:uint64} {Name: Type:block}] Receiver:0xc001308b60 Body:{
	return iter.sba.indices[iter.index], iter.sba.blocks[iter.index]
} PrettyPrintBody:[{ return iter.sba.indices[iter.index], iter.sba.blocks[iter.index] }]} {Id:3 FileId:22 StartLine:36 StartColumn:1 EndLine:41 EndColumn:2 Name:newCompressedBitArrayIterator Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:*sparseBitArrayIterator}] Receiver:<nil> Body:{
	return &sparseBitArrayIterator{
		sba:	sba,
		index:	-1,
	}
} PrettyPrintBody:[{ return &sparseBitArrayIterator{ sba:	sba, index:	-1, } }]} {Id:5 FileId:22 StartLine:51 StartColumn:1 EndLine:54 EndColumn:2 Name:Next Params:[] Results:[{Name: Type:bool}] Receiver:0xc000942680 Body:{
	iter.index++
	return uint64(iter.index) <= iter.stopIndex
} PrettyPrintBody:[{ iter.index++ return uint64(iter.index) <= iter.stopIndex }]} {Id:6 FileId:22 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:Value Params:[] Results:[{Name: Type:uint64} {Name: Type:block}] Receiver:0xc0013095c0 Body:{
	return uint64(iter.index), iter.ba.blocks[iter.index]
} PrettyPrintBody:[{ return uint64(iter.index), iter.ba.blocks[iter.index] }]} {Id:7 FileId:22 StartLine:61 StartColumn:1 EndLine:69 EndColumn:2 Name:newBitArrayIterator Params:[{Name:ba Type:*bitArray}] Results:[{Name: Type:*bitArrayIterator}] Receiver:<nil> Body:{
	stop, _ := getIndexAndRemainder(ba.highest)
	start, _ := getIndexAndRemainder(ba.lowest)
	return &bitArrayIterator{
		ba:		ba,
		index:		int64(start) - 1,
		stopIndex:	stop,
	}
} PrettyPrintBody:[{ stop, _ := getIndexAndRemainder(ba.highest) start, _ := getIndexAndRemainder(ba.lowest) return &bitArrayIterator{ ba:		ba, index:		int64(start) - 1, stopIndex:	stop, } }]} {Id:3 FileId:86 StartLine:15 StartColumn:1 EndLine:23 EndColumn:2 Name:Add Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc000e8d1a0 Body:{
	args := m.Called(entries)
	ifc := args.Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(entries) ifc := args.Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]} {Id:4 FileId:86 StartLine:25 StartColumn:1 EndLine:27 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000f52e60 Body:{
	return m.Called().Get(0).(uint64)
} PrettyPrintBody:[{ return m.Called().Get(0).(uint64) }]} {Id:5 FileId:86 StartLine:29 StartColumn:1 EndLine:31 EndColumn:2 Name:Delete Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0016024a0 Body:{
	return m.Called(entries).Get(0).(rangetree.Entries)
} PrettyPrintBody:[{ return m.Called(entries).Get(0).(rangetree.Entries) }]} {Id:6 FileId:86 StartLine:33 StartColumn:1 EndLine:41 EndColumn:2 Name:Query Params:[{Name:interval Type:rangetree.Interval}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0011d6240 Body:{
	args := m.Called(interval)
	ifc := args.Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(interval) ifc := args.Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]} {Id:7 FileId:86 StartLine:43 StartColumn:1 EndLine:48 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:rangetree.Entries} {Name: Type:rangetree.Entries}] Receiver:0xc0011d6360 Body:{

	args := m.Called(dimension, index, number)
	return args.Get(0).(rangetree.Entries), args.Get(1).(rangetree.Entries)
} PrettyPrintBody:[{ args := m.Called(dimension, index, number) return args.Get(0).(rangetree.Entries), args.Get(1).(rangetree.Entries) }]} {Id:8 FileId:86 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:Apply Params:[{Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[] Receiver:0xc0011d63a0 Body:{
	m.Called(interval, fn)
} PrettyPrintBody:[{ m.Called(interval, fn) }]} {Id:9 FileId:86 StartLine:54 StartColumn:1 EndLine:61 EndColumn:2 Name:Get Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0011d6580 Body:{
	ifc := m.Called(entries).Get(0)
	if ifc == nil {
		return nil
	}

	return ifc.(rangetree.Entries)
} PrettyPrintBody:[{ ifc := m.Called(entries).Get(0) if ifc == nil { return nil } return ifc.(rangetree.Entries) }]} {Id:3 FileId:75 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:NewSelectable Params:[] Results:[{Name: Type:*Selectable}] Receiver:<nil> Body:{
	return &Selectable{}
} PrettyPrintBody:[{ return &Selectable{} }]} {Id:4 FileId:75 StartLine:49 StartColumn:1 EndLine:57 EndColumn:2 Name:wchan Params:[] Results:[{Name: Type:<-chan struct{}}] Receiver:0xc000aeb200 Body:{
	f.m.Lock()
	if f.wait == nil {
		f.wait = make(chan struct{})
	}
	ch := f.wait
	f.m.Unlock()
	return ch
} PrettyPrintBody:[{ f.m.Lock() if f.wait == nil { f.wait = make(chan struct{}) } ch := f.wait f.m.Unlock() return ch }]} {Id:5 FileId:75 StartLine:60 StartColumn:1 EndLine:65 EndColumn:2 Name:WaitChan Params:[] Results:[{Name: Type:<-chan struct{}}] Receiver:0xc001239f20 Body:{
	if atomic.LoadUint32(&f.filled) == 1 {
		return closed
	}
	return f.wchan()
} PrettyPrintBody:[{ if atomic.LoadUint32(&f.filled) == 1 { return closed } return f.wchan() }]} {Id:6 FileId:75 StartLine:69 StartColumn:1 EndLine:74 EndColumn:2 Name:GetResult Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc0010331c0 Body:{
	if atomic.LoadUint32(&f.filled) == 0 {
		<-f.wchan()
	}
	return f.val, f.err
} PrettyPrintBody:[{ if atomic.LoadUint32(&f.filled) == 0 { <-f.wchan() } return f.val, f.err }]} {Id:7 FileId:75 StartLine:78 StartColumn:1 EndLine:92 EndColumn:2 Name:Fill Params:[{Name:v Type:interface{}} {Name:e Type:error}] Results:[{Name: Type:error}] Receiver:0xc001033200 Body:{
	f.m.Lock()
	if f.filled == 0 {
		f.val = v
		f.err = e
		atomic.StoreUint32(&f.filled, 1)
		w := f.wait
		f.wait = closed
		if w != nil {
			close(w)
		}
	}
	f.m.Unlock()
	return f.err
} PrettyPrintBody:[{ f.m.Lock() if f.filled == 0 { f.val = v f.err = e atomic.StoreUint32(&f.filled, 1) w := f.wait f.wait = closed if w != nil { close(w) } } f.m.Unlock() return f.err }]} {Id:8 FileId:75 StartLine:95 StartColumn:1 EndLine:97 EndColumn:2 Name:SetValue Params:[{Name:v Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc001309440 Body:{
	return f.Fill(v, nil)
} PrettyPrintBody:[{ return f.Fill(v, nil) }]} {Id:9 FileId:75 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:SetError Params:[{Name:e Type:error}] Results:[] Receiver:0xc001033520 Body:{
	f.Fill(nil, e)
} PrettyPrintBody:[{ f.Fill(nil, e) }]} {Id:10 FileId:75 StartLine:105 StartColumn:1 EndLine:107 EndColumn:2 Name:Cancel Params:[] Results:[] Receiver:0xc0013094c0 Body:{
	f.SetError(ErrFutureCanceled)
} PrettyPrintBody:[{ f.SetError(ErrFutureCanceled) }]} {Id:12 FileId:75 StartLine:111 StartColumn:1 EndLine:113 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	close(closed)
} PrettyPrintBody:[{ close(closed) }]} {Id:1 FileId:34 StartLine:25 StartColumn:1 EndLine:31 EndColumn:2 Name:newTestNode Params:[{Name:isLeaf Type:bool} {Name:ary Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	make(Keys, 0, ary),
		nodes:	make(nodes, 0, ary+1),
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	make(Keys, 0, ary), nodes:	make(nodes, 0, ary+1), } }]} {Id:2 FileId:34 StartLine:33 StartColumn:1 EndLine:39 EndColumn:2 Name:checkTree Params:[{Name:t Type:testing.TB} {Name:tree Type:*blink}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if tree.root == nil {
		return true
	}

	return checkNode(t, tree.root)
} PrettyPrintBody:[{ if tree.root == nil { return true } return checkNode(t, tree.root) }]} {Id:3 FileId:34 StartLine:41 StartColumn:1 EndLine:77 EndColumn:2 Name:checkNode Params:[{Name:t Type:testing.TB} {Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if len(n.keys) == 0 {
		assert.Len(t, n.nodes, 0)
		return false
	}

	if n.isLeaf {
		assert.Len(t, n.nodes, 0)
		return false
	}

	if !assert.Len(t, n.nodes, len(n.keys)+1) {
		return false
	}

	for i := 0; i < len(n.keys); i++ {
		if !assert.True(t, n.keys[i].Compare(n.nodes[i].key()) >= 0) {
			t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, n.keys[i], n.nodes[i])
			return false
		}
	}

	if !assert.True(t, n.nodes[len(n.nodes)-1].key().Compare(n.keys.last()) > 0) {
		t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, n.nodes[len(n.nodes)-1].key(), n.keys.last())
		return false
	}
	for _, child := range n.nodes {
		if !assert.NotNil(t, child) {
			return false
		}
		if !checkNode(t, child) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if len(n.keys) == 0 { assert.Len(t, n.nodes, 0) return false } if n.isLeaf { assert.Len(t, n.nodes, 0) return false } if !assert.Len(t, n.nodes, len(n.keys)+1) { return false } for i := 0; i < len(n.keys); i++ { if !assert.True(t, n.keys[i].Compare(n.nodes[i].key()) >= 0) { t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, n.keys[i], n.nodes[i]) return false } } if !assert.True(t, n.nodes[len(n.nodes)-1].key().Compare(n.keys.last()) > 0) { t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, n.nodes[len(n.nodes)-1].key(), n.keys.last()) return false } for _, child := range n.nodes { if !assert.NotNil(t, child) { return false } if !checkNode(t, child) { return false } } return true }]} {Id:4 FileId:34 StartLine:79 StartColumn:1 EndLine:103 EndColumn:2 Name:TestSplitInternalNodeOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(false, 3)
	n1 := newTestNode(true, 3)
	n1.keys.insert(mockKey(1))
	n2 := newTestNode(true, 3)
	n2.keys.insert(mockKey(5))
	n3 := newTestNode(true, 3)
	n3.keys.insert(mockKey(10))
	n4 := newTestNode(true, 3)
	n4.keys.insert(mockKey(15))

	parent.nodes = nodes{n1, n2, n3, n4}
	parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15)}

	key, l, r := parent.split()
	assert.Equal(t, mockKey(10), key)
	assert.Equal(t, Keys{mockKey(5)}, l.keys)
	assert.Equal(t, Keys{mockKey(15)}, r.keys)

	assert.Equal(t, nodes{n1, n2}, l.nodes)
	assert.Equal(t, nodes{n3, n4}, r.nodes)
	assert.Equal(t, l.right, r)
	assert.False(t, l.isLeaf)
	assert.False(t, r.isLeaf)
} PrettyPrintBody:[{ parent := newTestNode(false, 3) n1 := newTestNode(true, 3) n1.keys.insert(mockKey(1)) n2 := newTestNode(true, 3) n2.keys.insert(mockKey(5)) n3 := newTestNode(true, 3) n3.keys.insert(mockKey(10)) n4 := newTestNode(true, 3) n4.keys.insert(mockKey(15)) parent.nodes = nodes{n1, n2, n3, n4} parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15)} key, l, r := parent.split() assert.Equal(t, mockKey(10), key) assert.Equal(t, Keys{mockKey(5)}, l.keys) assert.Equal(t, Keys{mockKey(15)}, r.keys) assert.Equal(t, nodes{n1, n2}, l.nodes) assert.Equal(t, nodes{n3, n4}, r.nodes) assert.Equal(t, l.right, r) assert.False(t, l.isLeaf) assert.False(t, r.isLeaf) }]} {Id:5 FileId:34 StartLine:105 StartColumn:1 EndLine:131 EndColumn:2 Name:TestSplitInternalNodeEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(false, 4)
	n1 := newTestNode(true, 4)
	n1.keys.insert(mockKey(1))
	n2 := newTestNode(true, 4)
	n2.keys.insert(mockKey(5))
	n3 := newTestNode(true, 4)
	n3.keys.insert(mockKey(10))
	n4 := newTestNode(true, 4)
	n4.keys.insert(mockKey(15))
	n5 := newTestNode(true, 4)
	n5.keys.insert(mockKey(20))

	parent.nodes = nodes{n1, n2, n3, n4, n5}
	parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15), mockKey(20)}

	key, l, r := parent.split()
	assert.Equal(t, mockKey(15), key)
	assert.Equal(t, Keys{mockKey(5), mockKey(10)}, l.keys)
	assert.Equal(t, Keys{mockKey(20)}, r.keys)

	assert.Equal(t, nodes{n1, n2, n3}, l.nodes)
	assert.Equal(t, nodes{n4, n5}, r.nodes)
	assert.Equal(t, l.right, r)
	assert.False(t, l.isLeaf)
	assert.False(t, r.isLeaf)
} PrettyPrintBody:[{ parent := newTestNode(false, 4) n1 := newTestNode(true, 4) n1.keys.insert(mockKey(1)) n2 := newTestNode(true, 4) n2.keys.insert(mockKey(5)) n3 := newTestNode(true, 4) n3.keys.insert(mockKey(10)) n4 := newTestNode(true, 4) n4.keys.insert(mockKey(15)) n5 := newTestNode(true, 4) n5.keys.insert(mockKey(20)) parent.nodes = nodes{n1, n2, n3, n4, n5} parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15), mockKey(20)} key, l, r := parent.split() assert.Equal(t, mockKey(15), key) assert.Equal(t, Keys{mockKey(5), mockKey(10)}, l.keys) assert.Equal(t, Keys{mockKey(20)}, r.keys) assert.Equal(t, nodes{n1, n2, n3}, l.nodes) assert.Equal(t, nodes{n4, n5}, r.nodes) assert.Equal(t, l.right, r) assert.False(t, l.isLeaf) assert.False(t, r.isLeaf) }]} {Id:6 FileId:34 StartLine:133 StartColumn:1 EndLine:147 EndColumn:2 Name:TestSplitLeafNodeOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(true, 3)
	k1 := mockKey(5)
	k2 := mockKey(15)
	k3 := mockKey(20)

	parent.keys = Keys{k1, k2, k3}
	key, l, r := parent.split()
	assert.Equal(t, k2, key)
	assert.Equal(t, Keys{k1, k2}, l.keys)
	assert.Equal(t, Keys{k3}, r.keys)
	assert.True(t, l.isLeaf)
	assert.True(t, r.isLeaf)
	assert.Equal(t, r, l.right)
} PrettyPrintBody:[{ parent := newTestNode(true, 3) k1 := mockKey(5) k2 := mockKey(15) k3 := mockKey(20) parent.keys = Keys{k1, k2, k3} key, l, r := parent.split() assert.Equal(t, k2, key) assert.Equal(t, Keys{k1, k2}, l.keys) assert.Equal(t, Keys{k3}, r.keys) assert.True(t, l.isLeaf) assert.True(t, r.isLeaf) assert.Equal(t, r, l.right) }]} {Id:7 FileId:34 StartLine:149 StartColumn:1 EndLine:164 EndColumn:2 Name:TestSplitLeafNodeEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	parent := newTestNode(true, 4)
	k1 := mockKey(5)
	k2 := mockKey(15)
	k3 := mockKey(20)
	k4 := mockKey(25)

	parent.keys = Keys{k1, k2, k3, k4}
	key, l, r := parent.split()
	assert.Equal(t, k3, key)
	assert.Equal(t, Keys{k1, k2, k3}, l.keys)
	assert.Equal(t, Keys{k4}, r.keys)
	assert.True(t, l.isLeaf)
	assert.True(t, r.isLeaf)
	assert.Equal(t, r, l.right)
} PrettyPrintBody:[{ parent := newTestNode(true, 4) k1 := mockKey(5) k2 := mockKey(15) k3 := mockKey(20) k4 := mockKey(25) parent.keys = Keys{k1, k2, k3, k4} key, l, r := parent.split() assert.Equal(t, k3, key) assert.Equal(t, Keys{k1, k2, k3}, l.keys) assert.Equal(t, Keys{k4}, r.keys) assert.True(t, l.isLeaf) assert.True(t, r.isLeaf) assert.Equal(t, r, l.right) }]} {Id:1 FileId:81 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:roundUp Params:[{Name:v Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	v--
	v |= v >> 1
	v |= v >> 2
	v |= v >> 4
	v |= v >> 8
	v |= v >> 16
	v |= v >> 32
	v++
	return v
} PrettyPrintBody:[{ v-- v |= v >> 1 v |= v >> 2 v |= v >> 4 v |= v >> 8 v |= v >> 16 v |= v >> 32 v++ return v }]} {Id:4 FileId:81 StartLine:45 StartColumn:1 EndLine:53 EndColumn:2 Name:find Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:0xc000e8dee0 Body:{
	h := hash(key)
	i := h & (uint64(len(packets)) - 1)
	for packets[i] != nil && packets[i].key != key {
		i = (i + 1) & (uint64(len(packets)) - 1)
	}

	return i
} PrettyPrintBody:[{ h := hash(key) i := h & (uint64(len(packets)) - 1) for packets[i] != nil && packets[i].key != key { i = (i + 1) & (uint64(len(packets)) - 1) } return i }]} {Id:5 FileId:81 StartLine:55 StartColumn:1 EndLine:63 EndColumn:2 Name:set Params:[{Name:packet Type:*packet}] Results:[] Receiver:0xc0012272a0 Body:{
	i := packets.find(packet.key)
	if packets[i] == nil {
		packets[i] = packet
		return
	}

	packets[i].value = packet.value
} PrettyPrintBody:[{ i := packets.find(packet.key) if packets[i] == nil { packets[i] = packet return } packets[i].value = packet.value }]} {Id:6 FileId:81 StartLine:65 StartColumn:1 EndLine:72 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc001580980 Body:{
	i := packets.find(key)
	if packets[i] == nil {
		return 0, false
	}

	return packets[i].value, true
} PrettyPrintBody:[{ i := packets.find(key) if packets[i] == nil { return 0, false } return packets[i].value, true }]} {Id:7 FileId:81 StartLine:74 StartColumn:1 EndLine:88 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001308dc0 Body:{
	i := packets.find(key)
	if packets[i] == nil {
		return false
	}
	packets[i] = nil
	i = (i + 1) & (uint64(len(packets)) - 1)
	for packets[i] != nil {
		p := packets[i]
		packets[i] = nil
		packets.set(p)
		i = (i + 1) & (uint64(len(packets)) - 1)
	}
	return true
} PrettyPrintBody:[{ i := packets.find(key) if packets[i] == nil { return false } packets[i] = nil i = (i + 1) & (uint64(len(packets)) - 1) for packets[i] != nil { p := packets[i] packets[i] = nil packets.set(p) i = (i + 1) & (uint64(len(packets)) - 1) } return true }]} {Id:8 FileId:81 StartLine:90 StartColumn:1 EndLine:93 EndColumn:2 Name:exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000c577e0 Body:{
	i := packets.find(key)
	return packets[i] != nil
} PrettyPrintBody:[{ i := packets.find(key) return packets[i] != nil }]} {Id:10 FileId:81 StartLine:109 StartColumn:1 EndLine:119 EndColumn:2 Name:rebuild Params:[] Results:[] Receiver:0xc000118740 Body:{
	packets := make(packets, roundUp(uint64(len(fi.packets))+1))
	for _, packet := range fi.packets {
		if packet == nil {
			continue
		}

		packets.set(packet)
	}
	fi.packets = packets
} PrettyPrintBody:[{ packets := make(packets, roundUp(uint64(len(fi.packets))+1)) for _, packet := range fi.packets { if packet == nil { continue } packets.set(packet) } fi.packets = packets }]} {Id:11 FileId:81 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc00095a3c0 Body:{
	return fi.packets.get(key)
} PrettyPrintBody:[{ return fi.packets.get(key) }]} {Id:12 FileId:81 StartLine:128 StartColumn:1 EndLine:135 EndColumn:2 Name:Set Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc000a23800 Body:{
	if float64(fi.count+1)/float64(len(fi.packets)) > ratio {
		fi.rebuild()
	}

	fi.packets.set(&packet{key: key, value: value})
	fi.count++
} PrettyPrintBody:[{ if float64(fi.count+1)/float64(len(fi.packets)) > ratio { fi.rebuild() } fi.packets.set(&packet{key: key, value: value}) fi.count++ }]} {Id:13 FileId:81 StartLine:139 StartColumn:1 EndLine:141 EndColumn:2 Name:Exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001500fc0 Body:{
	return fi.packets.exists(key)
} PrettyPrintBody:[{ return fi.packets.exists(key) }]} {Id:14 FileId:81 StartLine:145 StartColumn:1 EndLine:149 EndColumn:2 Name:Delete Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc0010de4a0 Body:{
	if fi.packets.delete(key) {
		fi.count--
	}
} PrettyPrintBody:[{ if fi.packets.delete(key) { fi.count-- } }]} {Id:15 FileId:81 StartLine:152 StartColumn:1 EndLine:154 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001501cc0 Body:{
	return fi.count
} PrettyPrintBody:[{ return fi.count }]} {Id:16 FileId:81 StartLine:157 StartColumn:1 EndLine:159 EndColumn:2 Name:Cap Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602560 Body:{
	return uint64(len(fi.packets))
} PrettyPrintBody:[{ return uint64(len(fi.packets)) }]} {Id:17 FileId:81 StartLine:163 StartColumn:1 EndLine:173 EndColumn:2 Name:New Params:[{Name:hint Type:uint64}] Results:[{Name: Type:*FastIntegerHashMap}] Receiver:<nil> Body:{
	if hint == 0 {
		hint = 16
	}

	hint = roundUp(hint)
	return &FastIntegerHashMap{
		count:		0,
		packets:	make(packets, hint),
	}
} PrettyPrintBody:[{ if hint == 0 { hint = 16 } hint = roundUp(hint) return &FastIntegerHashMap{ count:		0, packets:	make(packets, hint), } }]} {Id:1 FileId:49 StartLine:12 StartColumn:1 EndLine:34 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000e7fd80 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x84, 0xa1, 0x75)
	o, err = z.UUID.MarshalMsg(o)
	if err != nil {
		return
	}

	o = append(o, 0xa1, 0x63)
	o = msgp.AppendInt(o, z.Count)

	o = append(o, 0xa1, 0x72)
	o, err = z.Root.MarshalMsg(o)
	if err != nil {
		return
	}

	o = append(o, 0xa2, 0x6e, 0x77)
	o = msgp.AppendInt(o, z.NodeWidth)
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x84, 0xa1, 0x75) o, err = z.UUID.MarshalMsg(o) if err != nil { return } o = append(o, 0xa1, 0x63) o = msgp.AppendInt(o, z.Count) o = append(o, 0xa1, 0x72) o, err = z.Root.MarshalMsg(o) if err != nil { return } o = append(o, 0xa2, 0x6e, 0x77) o = msgp.AppendInt(o, z.NodeWidth) return }]} {Id:2 FileId:49 StartLine:37 StartColumn:1 EndLine:81 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc0001187e0 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			bts, err = z.UUID.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "c":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "r":
			bts, err = z.Root.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "nw":
			z.NodeWidth, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "u": bts, err = z.UUID.UnmarshalMsg(bts) if err != nil { return } case "c": z.Count, bts, err = msgp.ReadIntBytes(bts) if err != nil { return } case "r": bts, err = z.Root.UnmarshalMsg(bts) if err != nil { return } case "nw": z.NodeWidth, bts, err = msgp.ReadIntBytes(bts) if err != nil { return } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]} {Id:3 FileId:49 StartLine:83 StartColumn:1 EndLine:86 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc00095a4a0 Body:{
	s = 1 + 2 + z.UUID.Msgsize() + 2 + msgp.IntSize + 2 + z.Root.Msgsize() + 3 + msgp.IntSize
	return
} PrettyPrintBody:[{ s = 1 + 2 + z.UUID.Msgsize() + 2 + msgp.IntSize + 2 + z.Root.Msgsize() + 3 + msgp.IntSize return }]} {Id:1 FileId:15 StartLine:35 StartColumn:1 EndLine:46 EndColumn:2 Name:TestBitmap32_PopCount Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := []uint32{
		uint32(0x55555555),
		uint32(0x33333333),
		uint32(0x0F0F0F0F),
		uint32(0x00FF00FF),
		uint32(0x0000FFFF),
	}
	for _, x := range b {
		assert.Equal(t, 16, Bitmap32(x).PopCount())
	}
} PrettyPrintBody:[{ b := []uint32{ uint32(0x55555555), uint32(0x33333333), uint32(0x0F0F0F0F), uint32(0x00FF00FF), uint32(0x0000FFFF), } for _, x := range b { assert.Equal(t, 16, Bitmap32(x).PopCount()) } }]} {Id:2 FileId:15 StartLine:48 StartColumn:1 EndLine:59 EndColumn:2 Name:TestBitmap64_PopCount Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	b := []uint64{
		uint64(0x5555555555555555),
		uint64(0x3333333333333333),
		uint64(0x0F0F0F0F0F0F0F0F),
		uint64(0x00FF00FF00FF00FF),
		uint64(0x0000FFFF0000FFFF),
	}
	for _, x := range b {
		assert.Equal(t, 32, Bitmap64(x).PopCount())
	}
} PrettyPrintBody:[{ b := []uint64{ uint64(0x5555555555555555), uint64(0x3333333333333333), uint64(0x0F0F0F0F0F0F0F0F), uint64(0x00FF00FF00FF00FF), uint64(0x0000FFFF0000FFFF), } for _, x := range b { assert.Equal(t, 32, Bitmap64(x).PopCount()) } }]} {Id:3 FileId:15 StartLine:61 StartColumn:1 EndLine:64 EndColumn:2 Name:TestBitmap32_SetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0)
	assert.Equal(t, Bitmap32(0x4), m.SetBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0) assert.Equal(t, Bitmap32(0x4), m.SetBit(2)) }]} {Id:4 FileId:15 StartLine:66 StartColumn:1 EndLine:69 EndColumn:2 Name:TestBitmap32_ClearBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x4)
	assert.Equal(t, Bitmap32(0), m.ClearBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0x4) assert.Equal(t, Bitmap32(0), m.ClearBit(2)) }]} {Id:5 FileId:15 StartLine:71 StartColumn:1 EndLine:74 EndColumn:2 Name:TestBitmap32_zGetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x55555555)
	assert.Equal(t, true, m.GetBit(2))
} PrettyPrintBody:[{ m := Bitmap32(0x55555555) assert.Equal(t, true, m.GetBit(2)) }]} {Id:6 FileId:15 StartLine:76 StartColumn:1 EndLine:79 EndColumn:2 Name:TestBitmap64_SetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0)
	assert.Equal(t, Bitmap64(0x4), m.SetBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0) assert.Equal(t, Bitmap64(0x4), m.SetBit(2)) }]} {Id:7 FileId:15 StartLine:81 StartColumn:1 EndLine:84 EndColumn:2 Name:TestBitmap64_ClearBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x4)
	assert.Equal(t, Bitmap64(0), m.ClearBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0x4) assert.Equal(t, Bitmap64(0), m.ClearBit(2)) }]} {Id:8 FileId:15 StartLine:86 StartColumn:1 EndLine:89 EndColumn:2 Name:TestBitmap64_GetBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x55555555)
	assert.Equal(t, true, m.GetBit(2))
} PrettyPrintBody:[{ m := Bitmap64(0x55555555) assert.Equal(t, true, m.GetBit(2)) }]} {Id:9 FileId:15 StartLine:91 StartColumn:1 EndLine:97 EndColumn:2 Name:BenchmarkBitmap32_PopCount Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	m := Bitmap32(0x33333333)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		m.PopCount()
	}
} PrettyPrintBody:[{ m := Bitmap32(0x33333333) b.ResetTimer() for i := b.N; i > 0; i-- { m.PopCount() } }]} {Id:10 FileId:15 StartLine:99 StartColumn:1 EndLine:105 EndColumn:2 Name:BenchmarkBitmap64_PopCount Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	m := Bitmap64(0x3333333333333333)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		m.PopCount()
	}
} PrettyPrintBody:[{ m := Bitmap64(0x3333333333333333) b.ResetTimer() for i := b.N; i > 0; i-- { m.PopCount() } }]} {Id:0 FileId:62 StartLine:19 StartColumn:1 EndLine:25 EndColumn:2 Name:chunkKeys Params:[{Name:ks Type:keys} {Name:numParts Type:int64}] Results:[{Name: Type:[]keys}] Receiver:<nil> Body:{
	parts := make([]keys, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = ks[i*int64(len(ks))/numParts : (i+1)*int64(len(ks))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]keys, numParts) for i := int64(0); i < numParts; i++ { parts[i] = ks[i*int64(len(ks))/numParts : (i+1)*int64(len(ks))/numParts] } return parts }]} {Id:2 FileId:62 StartLine:31 StartColumn:1 EndLine:41 EndColumn:2 Name:Compare Params:[{Name:other Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0010336a0 Body:{
	key := other.(*mockKey)
	if key.value == mk.value {
		return 0
	}
	if key.value > mk.value {
		return 1
	}

	return -1
} PrettyPrintBody:[{ key := other.(*mockKey) if key.value == mk.value { return 0 } if key.value > mk.value { return 1 } return -1 }]} {Id:3 FileId:62 StartLine:43 StartColumn:1 EndLine:45 EndColumn:2 Name:newMockKey Params:[{Name:value Type:int}] Results:[{Name: Type:*mockKey}] Receiver:<nil> Body:{
	return &mockKey{value}
} PrettyPrintBody:[{ return &mockKey{value} }]} {Id:3 FileId:35 StartLine:57 StartColumn:1 EndLine:77 EndColumn:2 Name:insert Params:[{Name:key Type:Key} {Name:stack Type:*nodes}] Results:[{Name: Type:Key}] Receiver:0xc00095a120 Body:{
	var parent *node
	blink.lock.Lock()
	if blink.root == nil {
		blink.root = newNode(
			true, make(Keys, 0, blink.ary), make(nodes, 0, blink.ary+1),
		)
		blink.root.keys = make(Keys, 0, blink.ary)
		blink.root.isLeaf = true
	}
	parent = blink.root
	blink.lock.Unlock()

	result := insert(blink, parent, stack, key)
	if result == nil {
		atomic.AddUint64(&blink.number, 1)
		return nil
	}

	return result
} PrettyPrintBody:[{ var parent *node blink.lock.Lock() if blink.root == nil { blink.root = newNode( true, make(Keys, 0, blink.ary), make(nodes, 0, blink.ary+1), ) blink.root.keys = make(Keys, 0, blink.ary) blink.root.isLeaf = true } parent = blink.root blink.lock.Unlock() result := insert(blink, parent, stack, key) if result == nil { atomic.AddUint64(&blink.number, 1) return nil } return result }]} {Id:4 FileId:35 StartLine:79 StartColumn:1 EndLine:103 EndColumn:2 Name:multithreadedInsert Params:[{Name:keys Type:Keys}] Results:[{Name: Type:Keys}] Receiver:0xc001308fa0 Body:{
	chunks := chunkKeys(keys, int64(blink.numRoutines))
	overwritten := make(Keys, len(keys))
	var offset uint64
	var wg sync.WaitGroup
	wg.Add(len(chunks))

	for _, chunk := range chunks {
		go func(chunk Keys, offset uint64) {
			defer wg.Done()
			stack := make(nodes, 0, blink.ary)

			for i := 0; i < len(chunk); i++ {
				result := blink.insert(chunk[i], &stack)
				stack.reset()
				overwritten[offset+uint64(i)] = result
			}
		}(chunk, offset)
		offset += uint64(len(chunk))
	}

	wg.Wait()

	return overwritten
} PrettyPrintBody:[{ chunks := chunkKeys(keys, int64(blink.numRoutines)) overwritten := make(Keys, len(keys)) var offset uint64 var wg sync.WaitGroup wg.Add(len(chunks)) for _, chunk := range chunks { go func(chunk Keys, offset uint64) { defer wg.Done() stack := make(nodes, 0, blink.ary) for i := 0; i < len(chunk); i++ { result := blink.insert(chunk[i], &stack) stack.reset() overwritten[offset+uint64(i)] = result } }(chunk, offset) offset += uint64(len(chunk)) } wg.Wait() return overwritten }]} {Id:5 FileId:35 StartLine:108 StartColumn:1 EndLine:120 EndColumn:2 Name:Insert Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc000a8a1e0 Body:{
	if len(keys) > numberOfItemsBeforeMultithread {
		return blink.multithreadedInsert(keys)
	}
	overwritten := make(Keys, 0, len(keys))
	stack := make(nodes, 0, blink.ary)
	for _, k := range keys {
		overwritten = append(overwritten, blink.insert(k, &stack))
		stack.reset()
	}

	return overwritten
} PrettyPrintBody:[{ if len(keys) > numberOfItemsBeforeMultithread { return blink.multithreadedInsert(keys) } overwritten := make(Keys, 0, len(keys)) stack := make(nodes, 0, blink.ary) for _, k := range keys { overwritten = append(overwritten, blink.insert(k, &stack)) stack.reset() } return overwritten }]} {Id:6 FileId:35 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409bc0 Body:{
	return atomic.LoadUint64(&blink.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&blink.number) }]} {Id:7 FileId:35 StartLine:127 StartColumn:1 EndLine:142 EndColumn:2 Name:get Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc001409c20 Body:{
	var parent *node
	blink.lock.RLock()
	parent = blink.root
	blink.lock.RUnlock()
	k := search(parent, key)
	if k == nil {
		return nil
	}

	if k.Compare(key) == 0 {
		return k
	}

	return nil
} PrettyPrintBody:[{ var parent *node blink.lock.RLock() parent = blink.root blink.lock.RUnlock() k := search(parent, key) if k == nil { return nil } if k.Compare(key) == 0 { return k } return nil }]} {Id:8 FileId:35 StartLine:147 StartColumn:1 EndLine:154 EndColumn:2 Name:Get Params:[{Name:keys Type:...Key}] Results:[{Name: Type:Keys}] Receiver:0xc001409ca0 Body:{
	found := make(Keys, 0, len(keys))
	for _, k := range keys {
		found = append(found, blink.get(k))
	}

	return found
} PrettyPrintBody:[{ found := make(Keys, 0, len(keys)) for _, k := range keys { found = append(found, blink.get(k)) } return found }]} {Id:9 FileId:35 StartLine:156 StartColumn:1 EndLine:163 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc001309920 Body:{
	output.Println(`PRINTING B-LINK`)
	if blink.root == nil {
		return
	}

	blink.root.print(output)
} PrettyPrintBody:[{ output.Println(`PRINTING B-LINK`) if blink.root == nil { return } blink.root.print(output) }]} {Id:10 FileId:35 StartLine:165 StartColumn:1 EndLine:167 EndColumn:2 Name:newTree Params:[{Name:ary Type:uint64}] Results:[{Name: Type:*blink}] Receiver:<nil> Body:{
	return &blink{ary: ary, numRoutines: numRoutines}
} PrettyPrintBody:[{ return &blink{ary: ary, numRoutines: numRoutines} }]} {Id:4 FileId:70 StartLine:13 StartColumn:1 EndLine:20 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Enqueue Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	node := heap.Enqueue(SomeNumber)
	fmt.Println(node.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) fmt.Println(node.Priority) }]} {Id:5 FileId:70 StartLine:22 StartColumn:1 EndLine:29 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Min Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(SomeNumber)
	heap.Enqueue(SomeLargerNumber)
	min, _ := heap.Min()
	fmt.Println(min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(SomeNumber) heap.Enqueue(SomeLargerNumber) min, _ := heap.Min() fmt.Println(min.Priority) }]} {Id:6 FileId:70 StartLine:31 StartColumn:1 EndLine:39 EndColumn:2 Name:ExampleFloatingFibonacciHeap_IsEmpty Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	fmt.Printf("Empty before insert? %v\n", heap.IsEmpty())
	heap.Enqueue(SomeNumber)
	fmt.Printf("Empty after insert? %v\n", heap.IsEmpty())

} PrettyPrintBody:[{ heap := NewFloatFibHeap() fmt.Printf("Empty before insert? %v\n", heap.IsEmpty()) heap.Enqueue(SomeNumber) fmt.Printf("Empty after insert? %v\n", heap.IsEmpty()) }]} {Id:7 FileId:70 StartLine:41 StartColumn:1 EndLine:49 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Size Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	fmt.Printf("Size before insert: %v\n", heap.Size())
	heap.Enqueue(SomeNumber)
	fmt.Printf("Size after insert: %v\n", heap.Size())

} PrettyPrintBody:[{ heap := NewFloatFibHeap() fmt.Printf("Size before insert: %v\n", heap.Size()) heap.Enqueue(SomeNumber) fmt.Printf("Size after insert: %v\n", heap.Size()) }]} {Id:8 FileId:70 StartLine:51 StartColumn:1 EndLine:58 EndColumn:2 Name:ExampleFloatingFibonacciHeap_DequeueMin Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(SomeNumber)
	node, _ := heap.DequeueMin()
	fmt.Printf("Dequeueing minimal element: %v\n", node.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(SomeNumber) node, _ := heap.DequeueMin() fmt.Printf("Dequeueing minimal element: %v\n", node.Priority) }]} {Id:9 FileId:70 StartLine:60 StartColumn:1 EndLine:71 EndColumn:2 Name:ExampleFloatingFibonacciHeap_DecreaseKey Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(SomeNumber)
	min, _ := heap.Min()
	fmt.Printf("Minimal element before decreasing key: %v\n", min.Priority)
	heap.DecreaseKey(node, SomeSmallerNumber)
	min, _ = heap.Min()
	fmt.Printf("Minimal element after decreasing key: %v\n", min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) min, _ := heap.Min() fmt.Printf("Minimal element before decreasing key: %v\n", min.Priority) heap.DecreaseKey(node, SomeSmallerNumber) min, _ = heap.Min() fmt.Printf("Minimal element after decreasing key: %v\n", min.Priority) }]} {Id:10 FileId:70 StartLine:73 StartColumn:1 EndLine:85 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Delete Params:[] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(SomeNumber)
	heap.Enqueue(SomeLargerNumber)
	min, _ := heap.Min()
	fmt.Printf("Minimal element before deletion: %v\n", min.Priority)
	heap.Delete(node)
	min, _ = heap.Min()
	fmt.Printf("Minimal element after deletion: %v\n", min.Priority)

} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(SomeNumber) heap.Enqueue(SomeLargerNumber) min, _ := heap.Min() fmt.Printf("Minimal element before deletion: %v\n", min.Priority) heap.Delete(node) min, _ = heap.Min() fmt.Printf("Minimal element after deletion: %v\n", min.Priority) }]} {Id:11 FileId:70 StartLine:87 StartColumn:1 EndLine:104 EndColumn:2 Name:ExampleFloatingFibonacciHeap_Merge Params:[] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	heap2 := NewFloatFibHeap()
	heap1.Enqueue(SomeNumber)
	heap1.Enqueue(SomeLargerNumber)
	heap2.Enqueue(SomeSmallerNumber)
	min, _ := heap1.Min()
	fmt.Printf("Minimal element of heap 1: %v\n", min.Priority)
	min, _ = heap2.Min()
	fmt.Printf("Minimal element of heap 2: %v\n", min.Priority)
	heap, _ := heap1.Merge(&heap2)
	min, _ = heap.Min()
	fmt.Printf("Minimal element of merged heap: %v\n", min.Priority)

} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() heap2 := NewFloatFibHeap() heap1.Enqueue(SomeNumber) heap1.Enqueue(SomeLargerNumber) heap2.Enqueue(SomeSmallerNumber) min, _ := heap1.Min() fmt.Printf("Minimal element of heap 1: %v\n", min.Priority) min, _ = heap2.Min() fmt.Printf("Minimal element of heap 2: %v\n", min.Priority) heap, _ := heap1.Merge(&heap2) min, _ = heap.Min() fmt.Printf("Minimal element of merged heap: %v\n", min.Priority) }]} {Id:4 FileId:65 StartLine:37 StartColumn:1 EndLine:41 EndColumn:2 Name:setElementIfNotNil Params:[{Name:element Type:*list.Element}] Results:[] Receiver:0xc0009f89c0 Body:{
	if element != nil {
		c.element = element
	}
} PrettyPrintBody:[{ if element != nil { c.element = element } }]} {Id:9 FileId:65 StartLine:69 StartColumn:1 EndLine:80 EndColumn:2 Name:EvictionPolicy Params:[{Name:policy Type:Policy}] Results:[{Name: Type:CacheOption}] Receiver:<nil> Body:{
	return func(c *cache) {
		switch policy {
		case LeastRecentlyAdded:
			c.recordAccess = c.noop
			c.recordAdd = c.record
		case LeastRecentlyUsed:
			c.recordAccess = c.record
			c.recordAdd = c.noop
		}
	}
} PrettyPrintBody:[{ return func(c *cache) { switch policy { case LeastRecentlyAdded: c.recordAccess = c.noop c.recordAdd = c.record case LeastRecentlyUsed: c.recordAccess = c.record c.recordAdd = c.noop } } }]} {Id:10 FileId:65 StartLine:85 StartColumn:1 EndLine:99 EndColumn:2 Name:New Params:[{Name:capacity Type:uint64} {Name:options Type:...CacheOption}] Results:[{Name: Type:Cache}] Receiver:<nil> Body:{
	c := &cache{
		cap:		capacity,
		keyList:	list.New(),
		items:		map[string]*cached{},
	}

	EvictionPolicy(LeastRecentlyUsed)(c)

	for _, option := range options {
		option(c)
	}

	return c
} PrettyPrintBody:[{ c := &cache{ cap:		capacity, keyList:	list.New(), items:		map[string]*cached{}, } EvictionPolicy(LeastRecentlyUsed)(c) for _, option := range options { option(c) } return c }]} {Id:11 FileId:65 StartLine:101 StartColumn:1 EndLine:117 EndColumn:2 Name:Get Params:[{Name:keys Type:...string}] Results:[{Name: Type:[]Item}] Receiver:0xc0014092a0 Body:{
	c.Lock()
	defer c.Unlock()

	items := make([]Item, len(keys))
	for i, key := range keys {
		cached := c.items[key]
		if cached == nil {
			items[i] = nil
		} else {
			c.recordAccess(key)
			items[i] = cached.item
		}
	}

	return items
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() items := make([]Item, len(keys)) for i, key := range keys { cached := c.items[key] if cached == nil { items[i] = nil } else { c.recordAccess(key) items[i] = cached.item } } return items }]} {Id:12 FileId:65 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:Put Params:[{Name:key Type:string} {Name:item Type:Item}] Results:[] Receiver:0xc001309200 Body:{
	c.Lock()
	defer c.Unlock()

	c.remove(key)

	c.ensureCapacity(item.Size())

	cached := &cached{item: item}
	cached.setElementIfNotNil(c.recordAdd(key))
	cached.setElementIfNotNil(c.recordAccess(key))
	c.items[key] = cached
	c.size += item.Size()
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() c.remove(key) c.ensureCapacity(item.Size()) cached := &cached{item: item} cached.setElementIfNotNil(c.recordAdd(key)) cached.setElementIfNotNil(c.recordAccess(key)) c.items[key] = cached c.size += item.Size() }]} {Id:13 FileId:65 StartLine:137 StartColumn:1 EndLine:144 EndColumn:2 Name:Remove Params:[{Name:keys Type:...string}] Results:[] Receiver:0xc000a8b7c0 Body:{
	c.Lock()
	defer c.Unlock()

	for _, key := range keys {
		c.remove(key)
	}
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() for _, key := range keys { c.remove(key) } }]} {Id:14 FileId:65 StartLine:146 StartColumn:1 EndLine:151 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0012cf1c0 Body:{
	c.Lock()
	defer c.Unlock()

	return c.size
} PrettyPrintBody:[{ c.Lock() defer c.Unlock() return c.size }]} {Id:15 FileId:65 StartLine:156 StartColumn:1 EndLine:163 EndColumn:2 Name:ensureCapacity Params:[{Name:toAdd Type:uint64}] Results:[] Receiver:0xc001580d80 Body:{
	mustRemove := int64(c.size+toAdd) - int64(c.cap)
	for mustRemove > 0 {
		key := c.keyList.Back().Value.(string)
		mustRemove -= int64(c.items[key].item.Size())
		c.remove(key)
	}
} PrettyPrintBody:[{ mustRemove := int64(c.size+toAdd) - int64(c.cap) for mustRemove > 0 { key := c.keyList.Back().Value.(string) mustRemove -= int64(c.items[key].item.Size()) c.remove(key) } }]} {Id:16 FileId:65 StartLine:167 StartColumn:1 EndLine:173 EndColumn:2 Name:remove Params:[{Name:key Type:string}] Results:[] Receiver:0xc000df6f40 Body:{
	if cached, ok := c.items[key]; ok {
		delete(c.items, key)
		c.size -= cached.item.Size()
		c.keyList.Remove(cached.element)
	}
} PrettyPrintBody:[{ if cached, ok := c.items[key]; ok { delete(c.items, key) c.size -= cached.item.Size() c.keyList.Remove(cached.element) } }]} {Id:17 FileId:65 StartLine:176 StartColumn:1 EndLine:176 EndColumn:58 Name:noop Params:[{Name: Type:string}] Results:[{Name: Type:*list.Element}] Receiver:0xc001309a40 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:18 FileId:65 StartLine:179 StartColumn:1 EndLine:185 EndColumn:2 Name:record Params:[{Name:key Type:string}] Results:[{Name: Type:*list.Element}] Receiver:0xc000df7e40 Body:{
	if item, ok := c.items[key]; ok {
		c.keyList.MoveToFront(item.element)
		return item.element
	}
	return c.keyList.PushFront(key)
} PrettyPrintBody:[{ if item, ok := c.items[key]; ok { c.keyList.MoveToFront(item.element) return item.element } return c.keyList.PushFront(key) }]} {Id:1 FileId:14 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:SetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap32}] Receiver:0xc0010982e0 Body:{
	return b | (1 << pos)
} PrettyPrintBody:[{ return b | (1 << pos) }]} {Id:2 FileId:14 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:ClearBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap32}] Receiver:0xc000ced1e0 Body:{
	return b & ^(1 << pos)
} PrettyPrintBody:[{ return b & ^(1 << pos) }]} {Id:3 FileId:14 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:GetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:bool}] Receiver:0xc000ced280 Body:{
	return (b & (1 << pos)) != 0
} PrettyPrintBody:[{ return (b & (1 << pos)) != 0 }]} {Id:4 FileId:14 StartLine:50 StartColumn:1 EndLine:58 EndColumn:2 Name:PopCount Params:[] Results:[{Name: Type:int}] Receiver:0xc0013081e0 Body:{

	b -= (b >> 1) & 0x55555555
	b = (b>>2)&0x33333333 + b&0x33333333
	b += b >> 4
	b &= 0x0f0f0f0f
	b *= 0x01010101
	return int(byte(b >> 24))
} PrettyPrintBody:[{ b -= (b >> 1) & 0x55555555 b = (b>>2)&0x33333333 + b&0x33333333 b += b >> 4 b &= 0x0f0f0f0f b *= 0x01010101 return int(byte(b >> 24)) }]} {Id:6 FileId:14 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:SetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap64}] Receiver:0xc001247c60 Body:{
	return b | (1 << pos)
} PrettyPrintBody:[{ return b | (1 << pos) }]} {Id:7 FileId:14 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:ClearBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:Bitmap64}] Receiver:0xc000942640 Body:{
	return b & ^(1 << pos)
} PrettyPrintBody:[{ return b & ^(1 << pos) }]} {Id:8 FileId:14 StartLine:74 StartColumn:1 EndLine:76 EndColumn:2 Name:GetBit Params:[{Name:pos Type:uint}] Results:[{Name: Type:bool}] Receiver:0xc000a23620 Body:{
	return (b & (1 << pos)) != 0
} PrettyPrintBody:[{ return (b & (1 << pos)) != 0 }]} {Id:9 FileId:14 StartLine:79 StartColumn:1 EndLine:87 EndColumn:2 Name:PopCount Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a2c0 Body:{

	b -= (b >> 1) & 0x5555555555555555
	b = (b>>2)&0x3333333333333333 + b&0x3333333333333333
	b += b >> 4
	b &= 0x0f0f0f0f0f0f0f0f
	b *= 0x0101010101010101
	return int(byte(b >> 56))
} PrettyPrintBody:[{ b -= (b >> 1) & 0x5555555555555555 b = (b>>2)&0x3333333333333333 + b&0x3333333333333333 b += b >> 4 b &= 0x0f0f0f0f0f0f0f0f b *= 0x0101010101010101 return int(byte(b >> 56)) }]} {Id:1 FileId:76 StartLine:29 StartColumn:1 EndLine:51 EndColumn:2 Name:TestSelectableGetResult Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	f := NewSelectable()
	var result interface{}
	var err error
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		result, err = f.GetResult()
		wg.Done()
	}()

	f.SetValue(`test`)
	wg.Wait()

	assert.Nil(t, err)
	assert.Equal(t, `test`, result)

	result, err = f.GetResult()

	assert.Equal(t, `test`, result)
	assert.Nil(t, err)
} PrettyPrintBody:[{ f := NewSelectable() var result interface{} var err error var wg sync.WaitGroup wg.Add(1) go func() { result, err = f.GetResult() wg.Done() }() f.SetValue(`test`) wg.Wait() assert.Nil(t, err) assert.Equal(t, `test`, result) result, err = f.GetResult() assert.Equal(t, `test`, result) assert.Nil(t, err) }]} {Id:2 FileId:76 StartLine:53 StartColumn:1 EndLine:65 EndColumn:2 Name:TestSelectableSetError Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	f := NewSelectable()
	select {
	case <-f.WaitChan():
	case <-time.After(0):
		f.SetError(fmt.Errorf("timeout"))
	}

	result, err := f.GetResult()

	assert.Nil(t, result)
	assert.NotNil(t, err)
} PrettyPrintBody:[{ f := NewSelectable() select { case <-f.WaitChan(): case <-time.After(0): f.SetError(fmt.Errorf("timeout")) } result, err := f.GetResult() assert.Nil(t, result) assert.NotNil(t, err) }]} {Id:3 FileId:76 StartLine:67 StartColumn:1 EndLine:88 EndColumn:2 Name:BenchmarkSelectable Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	timeout := time.After(30 * time.Minute)
	var wg sync.WaitGroup

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(1)
		f := NewSelectable()
		go func() {
			select {
			case <-f.WaitChan():
			case <-timeout:
				f.SetError(fmt.Errorf("timeout"))
			}
			wg.Done()
		}()

		f.SetValue(`test`)
		wg.Wait()
	}
} PrettyPrintBody:[{ timeout := time.After(30 * time.Minute) var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(1) f := NewSelectable() go func() { select { case <-f.WaitChan(): case <-timeout: f.SetError(fmt.Errorf("timeout")) } wg.Done() }() f.SetValue(`test`) wg.Wait() } }]} {Id:1 FileId:116 StartLine:27 StartColumn:1 EndLine:32 EndColumn:2 Name:getCenter Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:<nil> Body:{
	xlow, ylow := rect.LowerLeft()
	xhigh, yhigh := rect.UpperRight()

	return (xhigh + xlow) / 2, (yhigh + ylow) / 2
} PrettyPrintBody:[{ xlow, ylow := rect.LowerLeft() xhigh, yhigh := rect.UpperRight() return (xhigh + xlow) / 2, (yhigh + ylow) / 2 }]} {Id:3 FileId:116 StartLine:39 StartColumn:1 EndLine:70 EndColumn:2 Name:bundlesFromRects Params:[{Name:rects Type:...rtree.Rectangle}] Results:[{Name: Type:[]*hilbertBundle}] Receiver:<nil> Body:{
	chunks := chunkRectangles(rects, int64(runtime.NumCPU()))
	bundleChunks := make([][]*hilbertBundle, len(chunks))
	var wg sync.WaitGroup
	wg.Add(len(chunks))

	for i := 0; i < runtime.NumCPU(); i++ {
		if len(chunks[i]) == 0 {
			bundleChunks[i] = []*hilbertBundle{}
			wg.Done()
			continue
		}
		go func(i int) {
			bundles := make([]*hilbertBundle, 0, len(chunks[i]))
			for _, r := range chunks[i] {
				h := h.Encode(getCenter(r))
				bundles = append(bundles, &hilbertBundle{hilbert(h), r})
			}
			bundleChunks[i] = bundles
			wg.Done()
		}(i)
	}

	wg.Wait()

	bundles := make([]*hilbertBundle, 0, len(rects))
	for _, bc := range bundleChunks {
		bundles = append(bundles, bc...)
	}

	return bundles
} PrettyPrintBody:[{ chunks := chunkRectangles(rects, int64(runtime.NumCPU())) bundleChunks := make([][]*hilbertBundle, len(chunks)) var wg sync.WaitGroup wg.Add(len(chunks)) for i := 0; i < runtime.NumCPU(); i++ { if len(chunks[i]) == 0 { bundleChunks[i] = []*hilbertBundle{} wg.Done() continue } go func(i int) { bundles := make([]*hilbertBundle, 0, len(chunks[i])) for _, r := range chunks[i] { h := h.Encode(getCenter(r)) bundles = append(bundles, &hilbertBundle{hilbert(h), r}) } bundleChunks[i] = bundles wg.Done() }(i) } wg.Wait() bundles := make([]*hilbertBundle, 0, len(rects)) for _, bc := range bundleChunks { bundles = append(bundles, bc...) } return bundles }]} {Id:4 FileId:116 StartLine:73 StartColumn:1 EndLine:79 EndColumn:2 Name:chunkRectangles Params:[{Name:slice Type:rtree.Rectangles} {Name:numParts Type:int64}] Results:[{Name: Type:[]rtree.Rectangles}] Receiver:<nil> Body:{
	parts := make([]rtree.Rectangles, numParts)
	for i := int64(0); i < numParts; i++ {
		parts[i] = slice[i*int64(len(slice))/numParts : (i+1)*int64(len(slice))/numParts]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]rtree.Rectangles, numParts) for i := int64(0); i < numParts; i++ { parts[i] = slice[i*int64(len(slice))/numParts : (i+1)*int64(len(slice))/numParts] } return parts }]} {Id:0 FileId:10 StartLine:19 StartColumn:1 EndLine:71 EndColumn:2 Name:andSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	max := maxInt64(int64(len(sba.indices)), int64(len(other.indices)))
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	var resultBlock block

	for {
		if selfIndex == len(sba.indices) || otherIndex == len(other.indices) {

			break
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch {
		case otherValue < selfValue:

			otherIndex++

		case otherValue > selfValue:

			selfIndex++

		default:

			resultBlock = sba.blocks[selfIndex].and(other.blocks[otherIndex])
			if resultBlock > 0 {
				indices = append(indices, selfValue)
				blocks = append(blocks, resultBlock)
			}
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ max := maxInt64(int64(len(sba.indices)), int64(len(other.indices))) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 var resultBlock block for { if selfIndex == len(sba.indices) || otherIndex == len(other.indices) { break } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch { case otherValue < selfValue: otherIndex++ case otherValue > selfValue: selfIndex++ default: resultBlock = sba.blocks[selfIndex].and(other.blocks[otherIndex]) if resultBlock > 0 { indices = append(indices, selfValue) blocks = append(blocks, resultBlock) } selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]} {Id:1 FileId:10 StartLine:73 StartColumn:1 EndLine:119 EndColumn:2 Name:andSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if other.IsEmpty() {
		return newSparseBitArray()
	}

	ba := sba.copy()

	for selfIndex, selfValue := range ba.indices {

		if selfValue >= uint64(len(other.blocks)) {

			ba.blocks = ba.blocks[:selfIndex-1]
			ba.indices = ba.indices[:selfIndex-1]

			break
		}
		ba.blocks[selfIndex] = ba.blocks[selfIndex].and(
			other.blocks[selfValue])

	}

	for i := 0; i < len(ba.blocks); i++ {
		if ba.blocks[i] == 0 {
			ba.blocks.deleteAtIndex(int64(i))
			ba.indices.deleteAtIndex(int64(i))
			i--
		}
	}

	return ba
} PrettyPrintBody:[{ if other.IsEmpty() { return newSparseBitArray() } ba := sba.copy() for selfIndex, selfValue := range ba.indices { if selfValue >= uint64(len(other.blocks)) { ba.blocks = ba.blocks[:selfIndex-1] ba.indices = ba.indices[:selfIndex-1] break } ba.blocks[selfIndex] = ba.blocks[selfIndex].and( other.blocks[selfValue]) } for i := 0; i < len(ba.blocks); i++ { if ba.blocks[i] == 0 { ba.blocks.deleteAtIndex(int64(i)) ba.indices.deleteAtIndex(int64(i)) i-- } } return ba }]} {Id:2 FileId:10 StartLine:121 StartColumn:1 EndLine:134 EndColumn:2 Name:andDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	min := minUint64(uint64(len(dba.blocks)), uint64(len(other.blocks)))

	ba := newBitArray(min * s)

	for i := uint64(0); i < min; i++ {
		ba.blocks[i] = dba.blocks[i].and(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ min := minUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))) ba := newBitArray(min * s) for i := uint64(0); i < min; i++ { ba.blocks[i] = dba.blocks[i].and(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]} {Id:2 FileId:38 StartLine:38 StartColumn:1 EndLine:51 EndColumn:2 Name:asyncLoadNode Params:[{Name:t Type:*Tr} {Name:key Type:ID} {Name:completer Type:chan interface{}}] Results:[] Receiver:0xc001226fe0 Body:{
	n, err := c.loadNode(t, key)
	if err != nil {
		completer <- err
		return
	}

	if n == nil {
		completer <- ErrNodeNotFound
		return
	}

	completer <- n
} PrettyPrintBody:[{ n, err := c.loadNode(t, key) if err != nil { completer <- err return } if n == nil { completer <- ErrNodeNotFound return } completer <- n }]} {Id:3 FileId:38 StartLine:54 StartColumn:1 EndLine:59 EndColumn:2 Name:clear Params:[] Results:[] Receiver:0xc000c56320 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()

	c.cache = make(map[string]*futures.Future, 10)
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() c.cache = make(map[string]*futures.Future, 10) }]} {Id:4 FileId:38 StartLine:63 StartColumn:1 EndLine:68 EndColumn:2 Name:deleteFromCache Params:[{Name:id Type:ID}] Results:[] Receiver:0xc001308e00 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()

	delete(c.cache, string(id))
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() delete(c.cache, string(id)) }]} {Id:5 FileId:38 StartLine:70 StartColumn:1 EndLine:82 EndColumn:2 Name:loadNode Params:[{Name:t Type:*Tr} {Name:key Type:ID}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc001032d80 Body:{
	items, err := c.persister.Load(key)
	if err != nil {
		return nil, err
	}

	n, err := nodeFromBytes(t, items[0].Payload)
	if err != nil {
		return nil, err
	}

	return n, nil
} PrettyPrintBody:[{ items, err := c.persister.Load(key) if err != nil { return nil, err } n, err := nodeFromBytes(t, items[0].Payload) if err != nil { return nil, err } return n, nil }]} {Id:6 FileId:38 StartLine:88 StartColumn:1 EndLine:124 EndColumn:2 Name:getNode Params:[{Name:t Type:*Tr} {Name:key Type:ID} {Name:useCache Type:bool}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc0015810c0 Body:{
	if !useCache {
		return c.loadNode(t, key)
	}

	c.lock.Lock()
	future, ok := c.cache[string(key)]
	if ok {
		c.lock.Unlock()
		ifc, err := future.GetResult()
		if err != nil {
			return nil, err
		}

		return ifc.(*Node), nil
	}

	completer := make(chan interface{}, 1)
	future = futures.New(completer, 30*time.Second)
	c.cache[string(key)] = future
	c.lock.Unlock()

	go c.asyncLoadNode(t, key, completer)

	ifc, err := future.GetResult()
	if err != nil {
		c.deleteFromCache(key)
		return nil, err
	}

	if err, ok := ifc.(error); ok {
		c.deleteFromCache(key)
		return nil, err
	}

	return ifc.(*Node), nil
} PrettyPrintBody:[{ if !useCache { return c.loadNode(t, key) } c.lock.Lock() future, ok := c.cache[string(key)] if ok { c.lock.Unlock() ifc, err := future.GetResult() if err != nil { return nil, err } return ifc.(*Node), nil } completer := make(chan interface{}, 1) future = futures.New(completer, 30*time.Second) c.cache[string(key)] = future c.lock.Unlock() go c.asyncLoadNode(t, key, completer) ifc, err := future.GetResult() if err != nil { c.deleteFromCache(key) return nil, err } if err, ok := ifc.(error); ok { c.deleteFromCache(key) return nil, err } return ifc.(*Node), nil }]} {Id:7 FileId:38 StartLine:128 StartColumn:1 EndLine:133 EndColumn:2 Name:newCacher Params:[{Name:persister Type:Persister}] Results:[{Name: Type:*cacher}] Receiver:<nil> Body:{
	return &cacher{
		persister:	persister,
		cache:		make(map[string]*futures.Future, 10),
	}
} PrettyPrintBody:[{ return &cacher{ persister:	persister, cache:		make(map[string]*futures.Future, 10), } }]} {Id:3 FileId:77 StartLine:52 StartColumn:1 EndLine:57 EndColumn:2 Name:V Params:[] Results:[{Name: Type:int}] Receiver:0xc001308820 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	return g.v
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() return g.v }]} {Id:4 FileId:77 StartLine:60 StartColumn:1 EndLine:65 EndColumn:2 Name:E Params:[] Results:[{Name: Type:int}] Receiver:0xc000e57ca0 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	return g.e
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() return g.e }]} {Id:5 FileId:77 StartLine:68 StartColumn:1 EndLine:87 EndColumn:2 Name:AddEdge Params:[{Name:v Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc001032e20 Body:{
	g.mutex.Lock()
	defer g.mutex.Unlock()

	if v == w {
		return ErrSelfLoop
	}

	g.addVertex(v)
	g.addVertex(w)

	if _, ok := g.adjacencyList[v][w]; ok {
		return ErrParallelEdge
	}

	g.adjacencyList[v][w] = struct{}{}
	g.adjacencyList[w][v] = struct{}{}
	g.e++
	return nil
} PrettyPrintBody:[{ g.mutex.Lock() defer g.mutex.Unlock() if v == w { return ErrSelfLoop } g.addVertex(v) g.addVertex(w) if _, ok := g.adjacencyList[v][w]; ok { return ErrParallelEdge } g.adjacencyList[v][w] = struct{}{} g.adjacencyList[w][v] = struct{}{} g.e++ return nil }]} {Id:6 FileId:77 StartLine:90 StartColumn:1 EndLine:106 EndColumn:2 Name:Adj Params:[{Name:v Type:interface{}}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc000bb7580 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	deg, err := g.Degree(v)
	if err != nil {
		return nil, ErrVertexNotFound
	}

	adj := make([]interface{}, deg)
	i := 0
	for key := range g.adjacencyList[v] {
		adj[i] = key
		i++
	}
	return adj, nil
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() deg, err := g.Degree(v) if err != nil { return nil, ErrVertexNotFound } adj := make([]interface{}, deg) i := 0 for key := range g.adjacencyList[v] { adj[i] = key i++ } return adj, nil }]} {Id:7 FileId:77 StartLine:109 StartColumn:1 EndLine:118 EndColumn:2 Name:Degree Params:[{Name:v Type:interface{}}] Results:[{Name: Type:int} {Name: Type:error}] Receiver:0xc000f53420 Body:{
	g.mutex.RLock()
	defer g.mutex.RUnlock()

	val, ok := g.adjacencyList[v]
	if !ok {
		return 0, ErrVertexNotFound
	}
	return len(val), nil
} PrettyPrintBody:[{ g.mutex.RLock() defer g.mutex.RUnlock() val, ok := g.adjacencyList[v] if !ok { return 0, ErrVertexNotFound } return len(val), nil }]} {Id:8 FileId:77 StartLine:120 StartColumn:1 EndLine:127 EndColumn:2 Name:addVertex Params:[{Name:v Type:interface{}}] Results:[] Receiver:0xc000f536e0 Body:{
	mm, ok := g.adjacencyList[v]
	if !ok {
		mm = make(map[interface{}]struct{})
		g.adjacencyList[v] = mm
		g.v++
	}
} PrettyPrintBody:[{ mm, ok := g.adjacencyList[v] if !ok { mm = make(map[interface{}]struct{}) g.adjacencyList[v] = mm g.v++ } }]} {Id:9 FileId:77 StartLine:130 StartColumn:1 EndLine:136 EndColumn:2 Name:NewSimpleGraph Params:[] Results:[{Name: Type:*SimpleGraph}] Receiver:<nil> Body:{
	return &SimpleGraph{
		adjacencyList:	make(map[interface{}]map[interface{}]struct{}),
		v:		0,
		e:		0,
	}
} PrettyPrintBody:[{ return &SimpleGraph{ adjacencyList:	make(map[interface{}]map[interface{}]struct{}), v:		0, e:		0, } }]} {Id:1 FileId:136 StartLine:9 StartColumn:1 EndLine:17 EndColumn:2 Name:TestMultiThreadedSortEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(10)
	comparators = reverseComparators(comparators)

	result := MultithreadedSortComparators(comparators)
	comparators = reverseComparators(comparators)

	assert.Equal(t, comparators, result)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(10) comparators = reverseComparators(comparators) result := MultithreadedSortComparators(comparators) comparators = reverseComparators(comparators) assert.Equal(t, comparators, result) }]} {Id:2 FileId:136 StartLine:19 StartColumn:1 EndLine:27 EndColumn:2 Name:TestMultiThreadedSortOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(9)
	comparators = reverseComparators(comparators)

	result := MultithreadedSortComparators(comparators)
	comparators = reverseComparators(comparators)

	assert.Equal(t, comparators, result)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(9) comparators = reverseComparators(comparators) result := MultithreadedSortComparators(comparators) comparators = reverseComparators(comparators) assert.Equal(t, comparators, result) }]} {Id:3 FileId:136 StartLine:29 StartColumn:1 EndLine:39 EndColumn:2 Name:BenchmarkMultiThreadedSort Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numCells := 100000

	comparators := constructOrderedMockComparators(numCells)
	comparators = reverseComparators(comparators)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		MultithreadedSortComparators(comparators)
	}
} PrettyPrintBody:[{ numCells := 100000 comparators := constructOrderedMockComparators(numCells) comparators = reverseComparators(comparators) b.ResetTimer() for i := 0; i < b.N; i++ { MultithreadedSortComparators(comparators) } }]} {Id:0 FileId:25 StartLine:19 StartColumn:1 EndLine:74 EndColumn:2 Name:orSparseWithSparseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*sparseBitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{

	if len(other.indices) == 0 {
		return sba.copy()
	}

	if len(sba.indices) == 0 {
		return other.copy()
	}

	max := maxInt64(int64(len(sba.indices)), int64(len(other.indices)))
	indices := make(uintSlice, 0, max)
	blocks := make(blocks, 0, max)

	selfIndex := 0
	otherIndex := 0
	for {

		if selfIndex == len(sba.indices) && otherIndex == len(other.indices) {
			break
		} else if selfIndex == len(sba.indices) {
			indices = append(indices, other.indices[otherIndex:]...)
			blocks = append(blocks, other.blocks[otherIndex:]...)
			break
		} else if otherIndex == len(other.indices) {
			indices = append(indices, sba.indices[selfIndex:]...)
			blocks = append(blocks, sba.blocks[selfIndex:]...)
			break
		}

		selfValue := sba.indices[selfIndex]
		otherValue := other.indices[otherIndex]

		switch diff := int(otherValue) - int(selfValue); {
		case diff > 0:
			indices = append(indices, selfValue)
			blocks = append(blocks, sba.blocks[selfIndex])
			selfIndex++
		case diff < 0:
			indices = append(indices, otherValue)
			blocks = append(blocks, other.blocks[otherIndex])
			otherIndex++
		default:
			indices = append(indices, otherValue)
			blocks = append(blocks, sba.blocks[selfIndex].or(other.blocks[otherIndex]))
			selfIndex++
			otherIndex++
		}
	}

	return &sparseBitArray{
		indices:	indices,
		blocks:		blocks,
	}
} PrettyPrintBody:[{ if len(other.indices) == 0 { return sba.copy() } if len(sba.indices) == 0 { return other.copy() } max := maxInt64(int64(len(sba.indices)), int64(len(other.indices))) indices := make(uintSlice, 0, max) blocks := make(blocks, 0, max) selfIndex := 0 otherIndex := 0 for { if selfIndex == len(sba.indices) && otherIndex == len(other.indices) { break } else if selfIndex == len(sba.indices) { indices = append(indices, other.indices[otherIndex:]...) blocks = append(blocks, other.blocks[otherIndex:]...) break } else if otherIndex == len(other.indices) { indices = append(indices, sba.indices[selfIndex:]...) blocks = append(blocks, sba.blocks[selfIndex:]...) break } selfValue := sba.indices[selfIndex] otherValue := other.indices[otherIndex] switch diff := int(otherValue) - int(selfValue); { case diff > 0: indices = append(indices, selfValue) blocks = append(blocks, sba.blocks[selfIndex]) selfIndex++ case diff < 0: indices = append(indices, otherValue) blocks = append(blocks, other.blocks[otherIndex]) otherIndex++ default: indices = append(indices, otherValue) blocks = append(blocks, sba.blocks[selfIndex].or(other.blocks[otherIndex])) selfIndex++ otherIndex++ } } return &sparseBitArray{ indices:	indices, blocks:		blocks, } }]} {Id:1 FileId:25 StartLine:76 StartColumn:1 EndLine:119 EndColumn:2 Name:orSparseWithDenseBitArray Params:[{Name:sba Type:*sparseBitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if other.Capacity() == 0 || !other.anyset {
		return sba.copy()
	}

	if sba.Capacity() == 0 {
		return other.copy()
	}

	max := maxUint64(uint64(sba.Capacity()), uint64(other.Capacity()))

	ba := newBitArray(max * s)
	selfIndex := 0
	otherIndex := 0
	for {
		if selfIndex == len(sba.indices) && otherIndex == len(other.blocks) {
			break
		} else if selfIndex == len(sba.indices) {
			copy(ba.blocks[otherIndex:], other.blocks[otherIndex:])
			break
		} else if otherIndex == len(other.blocks) {
			for i, value := range sba.indices[selfIndex:] {
				ba.blocks[value] = sba.blocks[i+selfIndex]
			}
			break
		}

		selfValue := sba.indices[selfIndex]
		if selfValue == uint64(otherIndex) {
			ba.blocks[otherIndex] = sba.blocks[selfIndex].or(other.blocks[otherIndex])
			selfIndex++
			otherIndex++
			continue
		}

		ba.blocks[otherIndex] = other.blocks[otherIndex]
		otherIndex++
	}

	ba.setHighest()
	ba.setLowest()

	return ba
} PrettyPrintBody:[{ if other.Capacity() == 0 || !other.anyset { return sba.copy() } if sba.Capacity() == 0 { return other.copy() } max := maxUint64(uint64(sba.Capacity()), uint64(other.Capacity())) ba := newBitArray(max * s) selfIndex := 0 otherIndex := 0 for { if selfIndex == len(sba.indices) && otherIndex == len(other.blocks) { break } else if selfIndex == len(sba.indices) { copy(ba.blocks[otherIndex:], other.blocks[otherIndex:]) break } else if otherIndex == len(other.blocks) { for i, value := range sba.indices[selfIndex:] { ba.blocks[value] = sba.blocks[i+selfIndex] } break } selfValue := sba.indices[selfIndex] if selfValue == uint64(otherIndex) { ba.blocks[otherIndex] = sba.blocks[selfIndex].or(other.blocks[otherIndex]) selfIndex++ otherIndex++ continue } ba.blocks[otherIndex] = other.blocks[otherIndex] otherIndex++ } ba.setHighest() ba.setLowest() return ba }]} {Id:2 FileId:25 StartLine:121 StartColumn:1 EndLine:152 EndColumn:2 Name:orDenseWithDenseBitArray Params:[{Name:dba Type:*bitArray} {Name:other Type:*bitArray}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	if dba.Capacity() == 0 || !dba.anyset {
		return other.copy()
	}

	if other.Capacity() == 0 || !other.anyset {
		return dba.copy()
	}

	max := maxUint64(uint64(len(dba.blocks)), uint64(len(other.blocks)))

	ba := newBitArray(max * s)

	for i := uint64(0); i < max; i++ {
		if i == uint64(len(dba.blocks)) {
			copy(ba.blocks[i:], other.blocks[i:])
			break
		}

		if i == uint64(len(other.blocks)) {
			copy(ba.blocks[i:], dba.blocks[i:])
			break
		}

		ba.blocks[i] = dba.blocks[i].or(other.blocks[i])
	}

	ba.setLowest()
	ba.setHighest()

	return ba
} PrettyPrintBody:[{ if dba.Capacity() == 0 || !dba.anyset { return other.copy() } if other.Capacity() == 0 || !other.anyset { return dba.copy() } max := maxUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))) ba := newBitArray(max * s) for i := uint64(0); i < max; i++ { if i == uint64(len(dba.blocks)) { copy(ba.blocks[i:], other.blocks[i:]) break } if i == uint64(len(other.blocks)) { copy(ba.blocks[i:], dba.blocks[i:]) break } ba.blocks[i] = dba.blocks[i].or(other.blocks[i]) } ba.setLowest() ba.setHighest() return ba }]} {Id:2 FileId:157 StartLine:29 StartColumn:1 EndLine:31 EndColumn:2 Name:Key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0009f9fe0 Body:{
	return ew.key
} PrettyPrintBody:[{ return ew.key }]} {Id:4 FileId:157 StartLine:43 StartColumn:1 EndLine:47 EndColumn:2 Name:search Params:[{Name:key Type:uint64}] Results:[{Name: Type:int}] Receiver:0xc000f2c040 Body:{
	return sort.Search(len(entries), func(i int) bool {
		return entries[i].Key() >= key
	})
} PrettyPrintBody:[{ return sort.Search(len(entries), func(i int) bool { return entries[i].Key() >= key }) }]} {Id:5 FileId:157 StartLine:53 StartColumn:1 EndLine:71 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc0010323e0 Body:{
	i := entries.search(entry.Key())

	if i == len(*entries) {
		*entries = append(*entries, entry)
		return nil
	}

	if (*entries)[i].Key() == entry.Key() {
		oldEntry := (*entries)[i]
		(*entries)[i] = entry
		return oldEntry
	}

	(*entries) = append(*entries, nil)
	copy((*entries)[i+1:], (*entries)[i:])
	(*entries)[i] = entry
	return nil
} PrettyPrintBody:[{ i := entries.search(entry.Key()) if i == len(*entries) { *entries = append(*entries, entry) return nil } if (*entries)[i].Key() == entry.Key() { oldEntry := (*entries)[i] (*entries)[i] = entry return oldEntry } (*entries) = append(*entries, nil) copy((*entries)[i+1:], (*entries)[i:]) (*entries)[i] = entry return nil }]} {Id:6 FileId:157 StartLine:76 StartColumn:1 EndLine:91 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc000f52200 Body:{
	i := entries.search(key)
	if i == len(*entries) {
		return nil
	}

	if (*entries)[i].Key() != key {
		return nil
	}

	oldEntry := (*entries)[i]
	copy((*entries)[i:], (*entries)[i+1:])
	(*entries)[len(*entries)-1] = nil
	*entries = (*entries)[:len(*entries)-1]
	return oldEntry
} PrettyPrintBody:[{ i := entries.search(key) if i == len(*entries) { return nil } if (*entries)[i].Key() != key { return nil } oldEntry := (*entries)[i] copy((*entries)[i:], (*entries)[i+1:]) (*entries)[len(*entries)-1] = nil *entries = (*entries)[:len(*entries)-1] return oldEntry }]} {Id:7 FileId:157 StartLine:96 StartColumn:1 EndLine:102 EndColumn:2 Name:max Params:[] Results:[{Name: Type:uint64} {Name: Type:bool}] Receiver:0xc00095a2e0 Body:{
	if len(entries) == 0 {
		return 0, false
	}

	return entries[len(entries)-1].Key(), true
} PrettyPrintBody:[{ if len(entries) == 0 { return 0, false } return entries[len(entries)-1].Key(), true }]} {Id:8 FileId:157 StartLine:107 StartColumn:1 EndLine:118 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc001409940 Body:{
	i := entries.search(key)
	if i == len(entries) {
		return nil
	}

	if entries[i].Key() == key {
		return entries[i]
	}

	return nil
} PrettyPrintBody:[{ i := entries.search(key) if i == len(entries) { return nil } if entries[i].Key() == key { return entries[i] } return nil }]} {Id:9 FileId:157 StartLine:124 StartColumn:1 EndLine:131 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry} {Name: Type:int}] Receiver:0xc001580dc0 Body:{
	i := entries.search(key)
	if i == len(entries) {
		return nil, -1
	}

	return entries[i], i
} PrettyPrintBody:[{ i := entries.search(key) if i == len(entries) { return nil, -1 } return entries[i], i }]} {Id:10 FileId:157 StartLine:137 StartColumn:1 EndLine:158 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry} {Name: Type:int}] Receiver:0xc0010de700 Body:{
	if len(entries) == 0 {
		return nil, -1
	}

	i := entries.search(key)
	if i == len(entries) {
		return entries[i-1], i - 1
	}

	if entries[i].Key() == key {
		return entries[i], i
	}

	i--

	if i < 0 {
		return nil, -1
	}

	return entries[i], i
} PrettyPrintBody:[{ if len(entries) == 0 { return nil, -1 } i := entries.search(key) if i == len(entries) { return entries[i-1], i - 1 } if entries[i].Key() == key { return entries[i], i } i-- if i < 0 { return nil, -1 } return entries[i], i }]} {Id:1 FileId:98 StartLine:27 StartColumn:1 EndLine:37 EndColumn:2 Name:roundUp Params:[{Name:v Type:uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	v--
	v |= v >> 1
	v |= v >> 2
	v |= v >> 4
	v |= v >> 8
	v |= v >> 16
	v |= v >> 32
	v++
	return v
} PrettyPrintBody:[{ v-- v |= v >> 1 v |= v >> 2 v |= v >> 4 v |= v >> 8 v |= v >> 16 v |= v >> 32 v++ return v }]} {Id:5 FileId:98 StartLine:63 StartColumn:1 EndLine:70 EndColumn:2 Name:init Params:[{Name:size Type:uint64}] Results:[] Receiver:0xc001033220 Body:{
	size = roundUp(size)
	rb.nodes = make(nodes, size)
	for i := uint64(0); i < size; i++ {
		rb.nodes[i] = node{position: i}
	}
	rb.mask = size - 1
} PrettyPrintBody:[{ size = roundUp(size) rb.nodes = make(nodes, size) for i := uint64(0); i < size; i++ { rb.nodes[i] = node{position: i} } rb.mask = size - 1 }]} {Id:6 FileId:98 StartLine:75 StartColumn:1 EndLine:78 EndColumn:2 Name:Put Params:[{Name:item Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc0014095c0 Body:{
	_, err := rb.put(item, false)
	return err
} PrettyPrintBody:[{ _, err := rb.put(item, false) return err }]} {Id:7 FileId:98 StartLine:83 StartColumn:1 EndLine:85 EndColumn:2 Name:Offer Params:[{Name:item Type:interface{}}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001247740 Body:{
	return rb.put(item, true)
} PrettyPrintBody:[{ return rb.put(item, true) }]} {Id:8 FileId:98 StartLine:87 StartColumn:1 EndLine:119 EndColumn:2 Name:put Params:[{Name:item Type:interface{}} {Name:offer Type:bool}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001309520 Body:{
	var n *node
	pos := atomic.LoadUint64(&rb.queue)
L:
	for {
		if atomic.LoadUint64(&rb.disposed) == 1 {
			return false, ErrDisposed
		}

		n = &rb.nodes[pos&rb.mask]
		seq := atomic.LoadUint64(&n.position)
		switch dif := seq - pos; {
		case dif == 0:
			if atomic.CompareAndSwapUint64(&rb.queue, pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in a compromised state during a put operation.`)
		default:
			pos = atomic.LoadUint64(&rb.queue)
		}

		if offer {
			return false, nil
		}

		runtime.Gosched()
	}

	n.data = item
	atomic.StoreUint64(&n.position, pos+1)
	return true, nil
} PrettyPrintBody:[{ var n *node pos := atomic.LoadUint64(&rb.queue) L: for { if atomic.LoadUint64(&rb.disposed) == 1 { return false, ErrDisposed } n = &rb.nodes[pos&rb.mask] seq := atomic.LoadUint64(&n.position) switch dif := seq - pos; { case dif == 0: if atomic.CompareAndSwapUint64(&rb.queue, pos, pos+1) { break L } case dif < 0: panic(`Ring buffer in a compromised state during a put operation.`) default: pos = atomic.LoadUint64(&rb.queue) } if offer { return false, nil } runtime.Gosched() } n.data = item atomic.StoreUint64(&n.position, pos+1) return true, nil }]} {Id:9 FileId:98 StartLine:125 StartColumn:1 EndLine:127 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001309660 Body:{
	return rb.Poll(0)
} PrettyPrintBody:[{ return rb.Poll(0) }]} {Id:10 FileId:98 StartLine:134 StartColumn:1 EndLine:172 EndColumn:2 Name:Poll Params:[{Name:timeout Type:time.Duration}] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001602620 Body:{
	var (
		n	*node
		pos	= atomic.LoadUint64(&rb.dequeue)
		start	time.Time
	)
	if timeout > 0 {
		start = time.Now()
	}
L:
	for {
		if atomic.LoadUint64(&rb.disposed) == 1 {
			return nil, ErrDisposed
		}

		n = &rb.nodes[pos&rb.mask]
		seq := atomic.LoadUint64(&n.position)
		switch dif := seq - (pos + 1); {
		case dif == 0:
			if atomic.CompareAndSwapUint64(&rb.dequeue, pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in compromised state during a get operation.`)
		default:
			pos = atomic.LoadUint64(&rb.dequeue)
		}

		if timeout > 0 && time.Since(start) >= timeout {
			return nil, ErrTimeout
		}

		runtime.Gosched()
	}
	data := n.data
	n.data = nil
	atomic.StoreUint64(&n.position, pos+rb.mask+1)
	return data, nil
} PrettyPrintBody:[{ var ( n	*node pos	= atomic.LoadUint64(&rb.dequeue) start	time.Time ) if timeout > 0 { start = time.Now() } L: for { if atomic.LoadUint64(&rb.disposed) == 1 { return nil, ErrDisposed } n = &rb.nodes[pos&rb.mask] seq := atomic.LoadUint64(&n.position) switch dif := seq - (pos + 1); { case dif == 0: if atomic.CompareAndSwapUint64(&rb.dequeue, pos, pos+1) { break L } case dif < 0: panic(`Ring buffer in compromised state during a get operation.`) default: pos = atomic.LoadUint64(&rb.dequeue) } if timeout > 0 && time.Since(start) >= timeout { return nil, ErrTimeout } runtime.Gosched() } data := n.data n.data = nil atomic.StoreUint64(&n.position, pos+rb.mask+1) return data, nil }]} {Id:11 FileId:98 StartLine:175 StartColumn:1 EndLine:177 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001309e80 Body:{
	return atomic.LoadUint64(&rb.queue) - atomic.LoadUint64(&rb.dequeue)
} PrettyPrintBody:[{ return atomic.LoadUint64(&rb.queue) - atomic.LoadUint64(&rb.dequeue) }]} {Id:12 FileId:98 StartLine:180 StartColumn:1 EndLine:182 EndColumn:2 Name:Cap Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0011d7380 Body:{
	return uint64(len(rb.nodes))
} PrettyPrintBody:[{ return uint64(len(rb.nodes)) }]} {Id:13 FileId:98 StartLine:187 StartColumn:1 EndLine:189 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc000a8a600 Body:{
	atomic.CompareAndSwapUint64(&rb.disposed, 0, 1)
} PrettyPrintBody:[{ atomic.CompareAndSwapUint64(&rb.disposed, 0, 1) }]} {Id:14 FileId:98 StartLine:193 StartColumn:1 EndLine:195 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000a8a640 Body:{
	return atomic.LoadUint64(&rb.disposed) == 1
} PrettyPrintBody:[{ return atomic.LoadUint64(&rb.disposed) == 1 }]} {Id:15 FileId:98 StartLine:199 StartColumn:1 EndLine:203 EndColumn:2 Name:NewRingBuffer Params:[{Name:size Type:uint64}] Results:[{Name: Type:*RingBuffer}] Receiver:<nil> Body:{
	rb := &RingBuffer{}
	rb.init(size)
	return rb
} PrettyPrintBody:[{ rb := &RingBuffer{} rb.init(size) return rb }]} {Id:1 FileId:19 StartLine:25 StartColumn:1 EndLine:47 EndColumn:2 Name:TestSparseBitArraySerialization Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outBytes, err := input.Serialize()
	assert.Equal(t, err, nil)

	assert.Equal(t, len(outBytes), 337)
	assert.True(t, outBytes[0] == 'S')
	expected := []byte{83, 20, 0, 0, 0, 0, 0, 0, 0, 73}
	assert.Equal(t, expected, outBytes[:10])

	output := newSparseBitArray()
	err = output.Deserialize(outBytes)
	assert.Equal(t, err, nil)
	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newSparseBitArray() for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outBytes, err := input.Serialize() assert.Equal(t, err, nil) assert.Equal(t, len(outBytes), 337) assert.True(t, outBytes[0] == 'S') expected := []byte{83, 20, 0, 0, 0, 0, 0, 0, 0, 73} assert.Equal(t, expected, outBytes[:10]) output := newSparseBitArray() err = output.Deserialize(outBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]} {Id:2 FileId:19 StartLine:49 StartColumn:1 EndLine:73 EndColumn:2 Name:TestBitArraySerialization Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outBytes, err := input.Serialize()
	assert.Equal(t, err, nil)

	assert.Equal(t, len(outBytes), 178)

	expected := []byte{66, 0, 0, 0, 0, 0, 0, 0, 0, 254}
	assert.Equal(t, expected, outBytes[:10])

	output := newBitArray(0)
	err = output.Deserialize(outBytes)
	assert.Equal(t, err, nil)
	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outBytes, err := input.Serialize() assert.Equal(t, err, nil) assert.Equal(t, len(outBytes), 178) expected := []byte{66, 0, 0, 0, 0, 0, 0, 0, 0, 254} assert.Equal(t, expected, outBytes[:10]) output := newBitArray(0) err = output.Deserialize(outBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]} {Id:3 FileId:19 StartLine:75 StartColumn:1 EndLine:94 EndColumn:2 Name:TestBitArrayMarshalUnmarshal Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)
	assert.Equal(t, err, nil)
	assert.Equal(t, outputBytes[0], byte('B'))
	assert.Equal(t, len(outputBytes), 178)

	output, err := Unmarshal(outputBytes)
	assert.Equal(t, err, nil)

	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) assert.Equal(t, err, nil) assert.Equal(t, outputBytes[0], byte('B')) assert.Equal(t, len(outputBytes), 178) output, err := Unmarshal(outputBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]} {Id:4 FileId:19 StartLine:96 StartColumn:1 EndLine:115 EndColumn:2 Name:TestSparseBitArrayMarshalUnmarshal Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)
	assert.Equal(t, err, nil)
	assert.Equal(t, outputBytes[0], byte('S'))
	assert.Equal(t, len(outputBytes), 337)

	output, err := Unmarshal(outputBytes)
	assert.Equal(t, err, nil)

	assert.True(t, input.Equals(output))
} PrettyPrintBody:[{ numItems := uint64(1280) input := newSparseBitArray() for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) assert.Equal(t, err, nil) assert.Equal(t, outputBytes[0], byte('S')) assert.Equal(t, len(outputBytes), 337) output, err := Unmarshal(outputBytes) assert.Equal(t, err, nil) assert.True(t, input.Equals(output)) }]} {Id:5 FileId:19 StartLine:117 StartColumn:1 EndLine:138 EndColumn:2 Name:TestUnmarshalErrors Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1280)
	input := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		if i%3 == 0 {
			input.SetBit(i)
		}
	}

	outputBytes, err := Marshal(input)

	outputBytes[0] = 'C'

	output, err := Unmarshal(outputBytes)
	assert.Error(t, err)
	assert.Equal(t, output, nil)

	output, err = Unmarshal(nil)
	assert.Error(t, err)
	assert.Equal(t, output, nil)
} PrettyPrintBody:[{ numItems := uint64(1280) input := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { if i%3 == 0 { input.SetBit(i) } } outputBytes, err := Marshal(input) outputBytes[0] = 'C' output, err := Unmarshal(outputBytes) assert.Error(t, err) assert.Equal(t, output, nil) output, err = Unmarshal(nil) assert.Error(t, err) assert.Equal(t, output, nil) }]} {Id:1 FileId:153 StartLine:25 StartColumn:1 EndLine:59 EndColumn:2 Name:TestIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	iter := &Iterator{
		first: true,
	}

	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e1 := newMockEntry(5)
	n1 := newNode(nil, e1)
	iter = &Iterator{
		first:	true,
		n:	n1,
	}

	assert.True(t, iter.Next())
	assert.Equal(t, e1, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())

	e2 := newMockEntry(10)
	n2 := newNode(nil, e2)
	n1.children[1] = n2

	iter = &Iterator{
		first:	true,
		n:	n1,
	}

	assert.True(t, iter.Next())
	assert.True(t, iter.Next())
	assert.Equal(t, e2, iter.Value())
	assert.False(t, iter.Next())
	assert.Nil(t, iter.Value())
} PrettyPrintBody:[{ iter := &Iterator{ first: true, } assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e1 := newMockEntry(5) n1 := newNode(nil, e1) iter = &Iterator{ first:	true, n:	n1, } assert.True(t, iter.Next()) assert.Equal(t, e1, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) e2 := newMockEntry(10) n2 := newNode(nil, e2) n1.children[1] = n2 iter = &Iterator{ first:	true, n:	n1, } assert.True(t, iter.Next()) assert.True(t, iter.Next()) assert.Equal(t, e2, iter.Value()) assert.False(t, iter.Next()) assert.Nil(t, iter.Value()) }]} {Id:4 FileId:51 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc000fa7f20 Body:{
	ga.completer.Done()
} PrettyPrintBody:[{ ga.completer.Done() }]} {Id:5 FileId:51 StartLine:46 StartColumn:1 EndLine:48 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc00095ac40 Body:{
	return get
} PrettyPrintBody:[{ return get }]} {Id:6 FileId:51 StartLine:50 StartColumn:1 EndLine:52 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001308f00 Body:{
	return ga.result
} PrettyPrintBody:[{ return ga.result }]} {Id:7 FileId:51 StartLine:54 StartColumn:1 EndLine:56 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc000e5bb80 Body:{
	return
} PrettyPrintBody:[{ return }]} {Id:8 FileId:51 StartLine:58 StartColumn:1 EndLine:60 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001308f40 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:9 FileId:51 StartLine:62 StartColumn:1 EndLine:71 EndColumn:2 Name:newGetAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*getAction}] Receiver:<nil> Body:{
	result := make(common.Comparators, len(keys))
	copy(result, keys)
	ga := &getAction{
		result:		result,
		completer:	new(sync.WaitGroup),
	}
	ga.completer.Add(1)
	return ga
} PrettyPrintBody:[{ result := make(common.Comparators, len(keys)) copy(result, keys) ga := &getAction{ result:		result, completer:	new(sync.WaitGroup), } ga.completer.Add(1) return ga }]} {Id:11 FileId:51 StartLine:79 StartColumn:1 EndLine:81 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc001409600 Body:{
	ia.completer.Done()
} PrettyPrintBody:[{ ia.completer.Done() }]} {Id:12 FileId:51 StartLine:83 StartColumn:1 EndLine:85 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc001409720 Body:{
	return add
} PrettyPrintBody:[{ return add }]} {Id:13 FileId:51 StartLine:87 StartColumn:1 EndLine:89 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc001409760 Body:{
	return ia.result
} PrettyPrintBody:[{ return ia.result }]} {Id:14 FileId:51 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001309680 Body:{
	ia.ns[i] = n
} PrettyPrintBody:[{ ia.ns[i] = n }]} {Id:15 FileId:51 StartLine:95 StartColumn:1 EndLine:97 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc0013096e0 Body:{
	return ia.ns
} PrettyPrintBody:[{ return ia.ns }]} {Id:16 FileId:51 StartLine:99 StartColumn:1 EndLine:109 EndColumn:2 Name:newInsertAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*insertAction}] Receiver:<nil> Body:{
	result := make(common.Comparators, len(keys))
	copy(result, keys)
	ia := &insertAction{
		result:		result,
		completer:	new(sync.WaitGroup),
		ns:		make([]*node, len(keys)),
	}
	ia.completer.Add(1)
	return ia
} PrettyPrintBody:[{ result := make(common.Comparators, len(keys)) copy(result, keys) ia := &insertAction{ result:		result, completer:	new(sync.WaitGroup), ns:		make([]*node, len(keys)), } ia.completer.Add(1) return ia }]} {Id:18 FileId:51 StartLine:115 StartColumn:1 EndLine:117 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc001409d60 Body:{
	return remove
} PrettyPrintBody:[{ return remove }]} {Id:19 FileId:51 StartLine:119 StartColumn:1 EndLine:123 EndColumn:2 Name:newRemoveAction Params:[{Name:keys Type:common.Comparators}] Results:[{Name: Type:*removeAction}] Receiver:<nil> Body:{
	return &removeAction{
		newInsertAction(keys),
	}
} PrettyPrintBody:[{ return &removeAction{ newInsertAction(keys), } }]} {Id:21 FileId:51 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0010df320 Body:{
	return apply
} PrettyPrintBody:[{ return apply }]} {Id:22 FileId:51 StartLine:135 StartColumn:1 EndLine:137 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001033bc0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:23 FileId:51 StartLine:139 StartColumn:1 EndLine:139 EndColumn:52 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001602860 Body:{
} PrettyPrintBody:[{ }]} {Id:24 FileId:51 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:common.Comparators}] Receiver:0xc0016028e0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:25 FileId:51 StartLine:145 StartColumn:1 EndLine:147 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc001309e20 Body:{
	aa.completer.Done()
} PrettyPrintBody:[{ aa.completer.Done() }]} {Id:26 FileId:51 StartLine:149 StartColumn:1 EndLine:158 EndColumn:2 Name:newApplyAction Params:[{Name:fn Type:func(common.Comparator) bool} {Name:start Type:common.Comparator}] Results:[{Name: Type:*applyAction}] Receiver:<nil> Body:{
	aa := &applyAction{
		fn:		fn,
		start:		start,
		stop:		stop,
		completer:	new(sync.WaitGroup),
	}
	aa.completer.Add(1)
	return aa
} PrettyPrintBody:[{ aa := &applyAction{ fn:		fn, start:		start, stop:		stop, completer:	new(sync.WaitGroup), } aa.completer.Add(1) return aa }]} {Id:27 FileId:51 StartLine:160 StartColumn:1 EndLine:169 EndColumn:2 Name:minUint64 Params:[{Name:choices Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	min := choices[0]
	for i := 1; i < len(choices); i++ {
		if choices[i] < min {
			min = choices[i]
		}
	}

	return min
} PrettyPrintBody:[{ min := choices[0] for i := 1; i < len(choices); i++ { if choices[i] < min { min = choices[i] } } return min }]} {Id:29 FileId:51 StartLine:173 StartColumn:1 EndLine:205 EndColumn:2 Name:executeInterfacesInParallel Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	done := int64(-1)
	numCPU := uint64(runtime.NumCPU())
	if numCPU > 1 {
		numCPU--
	}

	numCPU = minUint64(numCPU, uint64(len(ifs)))

	var wg sync.WaitGroup
	wg.Add(int(numCPU))

	for i := uint64(0); i < numCPU; i++ {
		go func() {
			defer wg.Done()

			for {
				i := atomic.AddInt64(&done, 1)
				if i >= int64(len(ifs)) {
					return
				}

				fn(ifs[i])
			}
		}()
	}

	wg.Wait()
} PrettyPrintBody:[{ if len(ifs) == 0 { return } done := int64(-1) numCPU := uint64(runtime.NumCPU()) if numCPU > 1 { numCPU-- } numCPU = minUint64(numCPU, uint64(len(ifs))) var wg sync.WaitGroup wg.Add(int(numCPU)) for i := uint64(0); i < numCPU; i++ { go func() { defer wg.Done() for { i := atomic.AddInt64(&done, 1) if i >= int64(len(ifs)) { return } fn(ifs[i]) } }() } wg.Wait() }]} {Id:30 FileId:51 StartLine:207 StartColumn:1 EndLine:215 EndColumn:2 Name:executeInterfacesInSerial Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	for _, ifc := range ifs {
		fn(ifc)
	}
} PrettyPrintBody:[{ if len(ifs) == 0 { return } for _, ifc := range ifs { fn(ifc) } }]} {Id:4 FileId:115 StartLine:44 StartColumn:1 EndLine:46 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc000aeb220 Body:{
	ga.completer.Done()
} PrettyPrintBody:[{ ga.completer.Done() }]} {Id:5 FileId:115 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc000aeb280 Body:{
	return get
} PrettyPrintBody:[{ return get }]} {Id:6 FileId:115 StartLine:52 StartColumn:1 EndLine:54 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:hilberts}] Receiver:0xc00123cbe0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:7 FileId:115 StartLine:56 StartColumn:1 EndLine:58 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc001580320 Body:{
	return
} PrettyPrintBody:[{ return }]} {Id:8 FileId:115 StartLine:60 StartColumn:1 EndLine:62 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc001580ac0 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:9 FileId:115 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:rects Params:[] Results:[{Name: Type:[]*hilbertBundle}] Receiver:0xc001580b00 Body:{
	return []*hilbertBundle{&hilbertBundle{}}
} PrettyPrintBody:[{ return []*hilbertBundle{&hilbertBundle{}} }]} {Id:10 FileId:115 StartLine:68 StartColumn:1 EndLine:76 EndColumn:2 Name:newGetAction Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:*getAction}] Receiver:<nil> Body:{
	r := newRectangeFromRect(rect)
	ga := &getAction{
		completer:	new(sync.WaitGroup),
		lookup:		r,
	}
	ga.completer.Add(1)
	return ga
} PrettyPrintBody:[{ r := newRectangeFromRect(rect) ga := &getAction{ completer:	new(sync.WaitGroup), lookup:		r, } ga.completer.Add(1) return ga }]} {Id:12 FileId:115 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:complete Params:[] Results:[] Receiver:0xc0012ce0c0 Body:{
	ia.completer.Done()
} PrettyPrintBody:[{ ia.completer.Done() }]} {Id:13 FileId:115 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0012ce760 Body:{
	return add
} PrettyPrintBody:[{ return add }]} {Id:14 FileId:115 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:keys Params:[] Results:[{Name: Type:hilberts}] Receiver:0xc001409a60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:15 FileId:115 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:addNode Params:[{Name:i Type:int64} {Name:n Type:*node}] Results:[] Receiver:0xc000a8a000 Body:{
	ia.ns[i] = n
} PrettyPrintBody:[{ ia.ns[i] = n }]} {Id:16 FileId:115 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:nodes Params:[] Results:[{Name: Type:[]*node}] Receiver:0xc000a8a040 Body:{
	return ia.ns
} PrettyPrintBody:[{ return ia.ns }]} {Id:17 FileId:115 StartLine:104 StartColumn:1 EndLine:106 EndColumn:2 Name:rects Params:[] Results:[{Name: Type:[]*hilbertBundle}] Receiver:0xc000a8a080 Body:{
	return ia.rs
} PrettyPrintBody:[{ return ia.rs }]} {Id:18 FileId:115 StartLine:108 StartColumn:1 EndLine:116 EndColumn:2 Name:newInsertAction Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*insertAction}] Receiver:<nil> Body:{
	ia := &insertAction{
		rs:		bundlesFromRects(rects...),
		completer:	new(sync.WaitGroup),
		ns:		make([]*node, len(rects)),
	}
	ia.completer.Add(1)
	return ia
} PrettyPrintBody:[{ ia := &insertAction{ rs:		bundlesFromRects(rects...), completer:	new(sync.WaitGroup), ns:		make([]*node, len(rects)), } ia.completer.Add(1) return ia }]} {Id:20 FileId:115 StartLine:122 StartColumn:1 EndLine:124 EndColumn:2 Name:operation Params:[] Results:[{Name: Type:operation}] Receiver:0xc0013098e0 Body:{
	return remove
} PrettyPrintBody:[{ return remove }]} {Id:21 FileId:115 StartLine:126 StartColumn:1 EndLine:130 EndColumn:2 Name:newRemoveAction Params:[{Name:rects Type:rtree.Rectangles}] Results:[{Name: Type:*removeAction}] Receiver:<nil> Body:{
	return &removeAction{
		newInsertAction(rects),
	}
} PrettyPrintBody:[{ return &removeAction{ newInsertAction(rects), } }]} {Id:22 FileId:115 StartLine:132 StartColumn:1 EndLine:141 EndColumn:2 Name:minUint64 Params:[{Name:choices Type:...uint64}] Results:[{Name: Type:uint64}] Receiver:<nil> Body:{
	min := choices[0]
	for i := 1; i < len(choices); i++ {
		if choices[i] < min {
			min = choices[i]
		}
	}

	return min
} PrettyPrintBody:[{ min := choices[0] for i := 1; i < len(choices); i++ { if choices[i] < min { min = choices[i] } } return min }]} {Id:24 FileId:115 StartLine:145 StartColumn:1 EndLine:177 EndColumn:2 Name:executeInterfacesInParallel Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	done := int64(-1)
	numCPU := uint64(runtime.NumCPU())
	if numCPU > 1 {
		numCPU--
	}

	numCPU = minUint64(numCPU, uint64(len(ifs)))

	var wg sync.WaitGroup
	wg.Add(int(numCPU))

	for i := uint64(0); i < numCPU; i++ {
		go func() {
			defer wg.Done()

			for {
				i := atomic.AddInt64(&done, 1)
				if i >= int64(len(ifs)) {
					return
				}

				fn(ifs[i])
			}
		}()
	}

	wg.Wait()
} PrettyPrintBody:[{ if len(ifs) == 0 { return } done := int64(-1) numCPU := uint64(runtime.NumCPU()) if numCPU > 1 { numCPU-- } numCPU = minUint64(numCPU, uint64(len(ifs))) var wg sync.WaitGroup wg.Add(int(numCPU)) for i := uint64(0); i < numCPU; i++ { go func() { defer wg.Done() for { i := atomic.AddInt64(&done, 1) if i >= int64(len(ifs)) { return } fn(ifs[i]) } }() } wg.Wait() }]} {Id:25 FileId:115 StartLine:179 StartColumn:1 EndLine:187 EndColumn:2 Name:executeInterfacesInSerial Params:[{Name:ifs Type:interfaces} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if len(ifs) == 0 {
		return
	}

	for _, ifc := range ifs {
		fn(ifc)
	}
} PrettyPrintBody:[{ if len(ifs) == 0 { return } for _, ifc := range ifs { fn(ifc) } }]} {Id:1 FileId:149 StartLine:35 StartColumn:1 EndLine:40 EndColumn:2 Name:TestDefaultHasher Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert.Equal(t,
		defaultHasher(map[int]string{11234: "foo"}),
		defaultHasher(map[int]string{11234: "foo"}))
	assert.NotEqual(t, defaultHasher("foo"), defaultHasher("bar"))
} PrettyPrintBody:[{ assert.Equal(t, defaultHasher(map[int]string{11234: "foo"}), defaultHasher(map[int]string{11234: "foo"})) assert.NotEqual(t, defaultHasher("foo"), defaultHasher("bar")) }]} {Id:2 FileId:149 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:collisionHash Params:[{Name:key Type:interface{}}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	return uint32(0xffffffff)
} PrettyPrintBody:[{ return uint32(0xffffffff) }]} {Id:3 FileId:149 StartLine:46 StartColumn:1 EndLine:49 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	insertTest(t, defaultHasher, 10000)
	insertTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ insertTest(t, defaultHasher, 10000) insertTest(t, collisionHash, 1000) }]} {Id:4 FileId:149 StartLine:51 StartColumn:1 EndLine:57 EndColumn:2 Name:insertTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := emptyNode(0, 32)
	for i := 0; i < count; i++ {
		n = insert(n, &entry{hashfunc(i), i, i})
	}
	return n
} PrettyPrintBody:[{ n := emptyNode(0, 32) for i := 0; i < count; i++ { n = insert(n, &entry{hashfunc(i), i, i}) } return n }]} {Id:5 FileId:149 StartLine:59 StartColumn:1 EndLine:62 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	getTest(t, defaultHasher, 10000)
	getTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ getTest(t, defaultHasher, 10000) getTest(t, collisionHash, 1000) }]} {Id:6 FileId:149 StartLine:64 StartColumn:1 EndLine:70 EndColumn:2 Name:getTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		x := get(n, hashfunc(i), i)
		assert.Equal(t, i, x.Value())
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { x := get(n, hashfunc(i), i) assert.Equal(t, i, x.Value()) } }]} {Id:7 FileId:149 StartLine:72 StartColumn:1 EndLine:75 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	removeTest(t, defaultHasher, 10000)
	removeTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ removeTest(t, defaultHasher, 10000) removeTest(t, collisionHash, 1000) }]} {Id:8 FileId:149 StartLine:77 StartColumn:1 EndLine:87 EndColumn:2 Name:removeTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		n = remove(n, hashfunc(i), i)
	}
	for _, e := range n.entries {
		if e != nil {
			t.Fatal("final node is not empty")
		}
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { n = remove(n, hashfunc(i), i) } for _, e := range n.entries { if e != nil { t.Fatal("final node is not empty") } } }]} {Id:9 FileId:149 StartLine:89 StartColumn:1 EndLine:92 EndColumn:2 Name:TestUpdate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	updateTest(t, defaultHasher, 10000)
	updateTest(t, collisionHash, 1000)
} PrettyPrintBody:[{ updateTest(t, defaultHasher, 10000) updateTest(t, collisionHash, 1000) }]} {Id:10 FileId:149 StartLine:94 StartColumn:1 EndLine:99 EndColumn:2 Name:updateTest Params:[{Name:t Type:*testing.T} {Name:hashfunc Type:func(interface{}) uint32} {Name:count Type:int}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, hashfunc, count)
	for i := 0; i < count; i++ {
		n = insert(n, &entry{hashfunc(i), i, -i})
	}
} PrettyPrintBody:[{ n := insertTest(t, hashfunc, count) for i := 0; i < count; i++ { n = insert(n, &entry{hashfunc(i), i, -i}) } }]} {Id:11 FileId:149 StartLine:101 StartColumn:1 EndLine:129 EndColumn:2 Name:TestIterate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, defaultHasher, 10000)
	echan := iterate(n, nil)
	c := 0
	for _ = range echan {
		c++
	}
	assert.Equal(t, 10000, c)

	c = 0
	stop := make(chan struct{})
	echan = iterate(n, stop)
	for _ = range echan {
		c++
		if c == 100 {
			close(stop)
			break
		}
	}
	assert.True(t, c == 100)

	n = insertTest(t, collisionHash, 1000)
	c = 0
	echan = iterate(n, nil)
	for _ = range echan {
		c++
	}
	assert.Equal(t, 1000, c)
} PrettyPrintBody:[{ n := insertTest(t, defaultHasher, 10000) echan := iterate(n, nil) c := 0 for _ = range echan { c++ } assert.Equal(t, 10000, c) c = 0 stop := make(chan struct{}) echan = iterate(n, stop) for _ = range echan { c++ if c == 100 { close(stop) break } } assert.True(t, c == 100) n = insertTest(t, collisionHash, 1000) c = 0 echan = iterate(n, nil) for _ = range echan { c++ } assert.Equal(t, 1000, c) }]} {Id:12 FileId:149 StartLine:131 StartColumn:1 EndLine:135 EndColumn:2 Name:TestSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	n := insertTest(t, defaultHasher, 10000)
	d := &Dtrie{n, defaultHasher}
	assert.Equal(t, 10000, d.Size())
} PrettyPrintBody:[{ n := insertTest(t, defaultHasher, 10000) d := &Dtrie{n, defaultHasher} assert.Equal(t, 10000, d.Size()) }]} {Id:13 FileId:149 StartLine:137 StartColumn:1 EndLine:144 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := emptyNode(0, 32)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = insert(n, &entry{defaultHasher(i), i, i})
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := emptyNode(0, 32) b.ResetTimer() for i := b.N; i > 0; i-- { n = insert(n, &entry{defaultHasher(i), i, i}) } }]} {Id:14 FileId:149 StartLine:146 StartColumn:1 EndLine:153 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		get(n, defaultHasher(i), i)
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { get(n, defaultHasher(i), i) } }]} {Id:15 FileId:149 StartLine:155 StartColumn:1 EndLine:162 EndColumn:2 Name:BenchmarkRemove Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = remove(n, defaultHasher(i), i)
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { n = remove(n, defaultHasher(i), i) } }]} {Id:16 FileId:149 StartLine:164 StartColumn:1 EndLine:171 EndColumn:2 Name:BenchmarkUpdate Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	b.ReportAllocs()
	n := insertTest(nil, defaultHasher, b.N)
	b.ResetTimer()
	for i := b.N; i > 0; i-- {
		n = insert(n, &entry{defaultHasher(i), i, -i})
	}
} PrettyPrintBody:[{ b.ReportAllocs() n := insertTest(nil, defaultHasher, b.N) b.ResetTimer() for i := b.N; i > 0; i-- { n = insert(n, &entry{defaultHasher(i), i, -i}) } }]} {Id:1 FileId:158 StartLine:25 StartColumn:1 EndLine:40 EndColumn:2 Name:TestEntriesInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)

	es.insert(e1)
	es.insert(e2)

	assert.Equal(t, Entries{e2, e1}, es)

	e3 := newMockEntry(3)
	es.insert(e3)

	assert.Equal(t, Entries{e2, e3, e1}, es)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) assert.Equal(t, Entries{e2, e1}, es) e3 := newMockEntry(3) es.insert(e3) assert.Equal(t, Entries{e2, e3, e1}, es) }]} {Id:2 FileId:158 StartLine:42 StartColumn:1 EndLine:55 EndColumn:2 Name:TestEntriesDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	es.delete(5)
	assert.Equal(t, Entries{e2}, es)

	es.delete(1)
	assert.Equal(t, Entries{}, es)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) es.delete(5) assert.Equal(t, Entries{e2}, es) es.delete(1) assert.Equal(t, Entries{}, es) }]} {Id:3 FileId:158 StartLine:57 StartColumn:1 EndLine:74 EndColumn:2 Name:TestEntriesMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}
	max, ok := es.max()
	assert.Equal(t, uint64(0), max)
	assert.False(t, ok)

	e2 := newMockEntry(1)
	es.insert(e2)
	max, ok = es.max()
	assert.Equal(t, uint64(1), max)
	assert.True(t, ok)

	e1 := newMockEntry(5)
	es.insert(e1)
	max, ok = es.max()
	assert.Equal(t, uint64(5), max)
	assert.True(t, ok)
} PrettyPrintBody:[{ es := Entries{} max, ok := es.max() assert.Equal(t, uint64(0), max) assert.False(t, ok) e2 := newMockEntry(1) es.insert(e2) max, ok = es.max() assert.Equal(t, uint64(1), max) assert.True(t, ok) e1 := newMockEntry(5) es.insert(e1) max, ok = es.max() assert.Equal(t, uint64(5), max) assert.True(t, ok) }]} {Id:4 FileId:158 StartLine:76 StartColumn:1 EndLine:92 EndColumn:2 Name:TestEntriesGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	result := es.get(5)
	assert.Equal(t, e1, result)

	result = es.get(1)
	assert.Equal(t, e2, result)

	result = es.get(10)
	assert.Nil(t, result)
} PrettyPrintBody:[{ es := Entries{} e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) result := es.get(5) assert.Equal(t, e1, result) result = es.get(1) assert.Equal(t, e2, result) result = es.get(10) assert.Nil(t, result) }]} {Id:5 FileId:158 StartLine:94 StartColumn:1 EndLine:121 EndColumn:2 Name:TestEntriesSuccessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	successor, i := es.successor(5)
	assert.Equal(t, -1, i)
	assert.Nil(t, successor)

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	successor, i = es.successor(0)
	assert.Equal(t, 0, i)
	assert.Equal(t, e2, successor)

	successor, i = es.successor(2)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, successor)

	successor, i = es.successor(5)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, successor)

	successor, i = es.successor(10)
	assert.Equal(t, -1, i)
	assert.Nil(t, successor)
} PrettyPrintBody:[{ es := Entries{} successor, i := es.successor(5) assert.Equal(t, -1, i) assert.Nil(t, successor) e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) successor, i = es.successor(0) assert.Equal(t, 0, i) assert.Equal(t, e2, successor) successor, i = es.successor(2) assert.Equal(t, 1, i) assert.Equal(t, e1, successor) successor, i = es.successor(5) assert.Equal(t, 1, i) assert.Equal(t, e1, successor) successor, i = es.successor(10) assert.Equal(t, -1, i) assert.Nil(t, successor) }]} {Id:6 FileId:158 StartLine:123 StartColumn:1 EndLine:150 EndColumn:2 Name:TestEntriesPredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := Entries{}

	predecessor, i := es.predecessor(5)
	assert.Equal(t, -1, i)
	assert.Nil(t, predecessor)

	e1 := newMockEntry(5)
	e2 := newMockEntry(1)
	es.insert(e1)
	es.insert(e2)

	predecessor, i = es.predecessor(0)
	assert.Equal(t, -1, i)
	assert.Nil(t, predecessor)

	predecessor, i = es.predecessor(2)
	assert.Equal(t, 0, i)
	assert.Equal(t, e2, predecessor)

	predecessor, i = es.predecessor(5)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, predecessor)

	predecessor, i = es.predecessor(10)
	assert.Equal(t, 1, i)
	assert.Equal(t, e1, predecessor)
} PrettyPrintBody:[{ es := Entries{} predecessor, i := es.predecessor(5) assert.Equal(t, -1, i) assert.Nil(t, predecessor) e1 := newMockEntry(5) e2 := newMockEntry(1) es.insert(e1) es.insert(e2) predecessor, i = es.predecessor(0) assert.Equal(t, -1, i) assert.Nil(t, predecessor) predecessor, i = es.predecessor(2) assert.Equal(t, 0, i) assert.Equal(t, e2, predecessor) predecessor, i = es.predecessor(5) assert.Equal(t, 1, i) assert.Equal(t, e1, predecessor) predecessor, i = es.predecessor(10) assert.Equal(t, 1, i) assert.Equal(t, e1, predecessor) }]} {Id:3 FileId:123 StartLine:42 StartColumn:1 EndLine:50 EndColumn:2 Name:Add Params:[{Name:items Type:...interface{}}] Results:[] Receiver:0xc000d60520 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	set.flattened = nil
	for _, item := range items {
		set.items[item] = struct{}{}
	}
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() set.flattened = nil for _, item := range items { set.items[item] = struct{}{} } }]} {Id:4 FileId:123 StartLine:53 StartColumn:1 EndLine:61 EndColumn:2 Name:Remove Params:[{Name:items Type:...interface{}}] Results:[] Receiver:0xc001409480 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	set.flattened = nil
	for _, item := range items {
		delete(set.items, item)
	}
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() set.flattened = nil for _, item := range items { delete(set.items, item) } }]} {Id:5 FileId:123 StartLine:64 StartColumn:1 EndLine:72 EndColumn:2 Name:Exists Params:[{Name:item Type:interface{}}] Results:[{Name: Type:bool}] Receiver:0xc000f52a60 Body:{
	set.lock.RLock()

	_, ok := set.items[item]

	set.lock.RUnlock()

	return ok
} PrettyPrintBody:[{ set.lock.RLock() _, ok := set.items[item] set.lock.RUnlock() return ok }]} {Id:6 FileId:123 StartLine:75 StartColumn:1 EndLine:88 EndColumn:2 Name:Flatten Params:[] Results:[{Name: Type:[]interface{}}] Receiver:0xc0013093a0 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	if set.flattened != nil {
		return set.flattened
	}

	set.flattened = make([]interface{}, 0, len(set.items))
	for item := range set.items {
		set.flattened = append(set.flattened, item)
	}
	return set.flattened
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() if set.flattened != nil { return set.flattened } set.flattened = make([]interface{}, 0, len(set.items)) for item := range set.items { set.flattened = append(set.flattened, item) } return set.flattened }]} {Id:7 FileId:123 StartLine:91 StartColumn:1 EndLine:99 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc001033620 Body:{
	set.lock.RLock()

	size := int64(len(set.items))

	set.lock.RUnlock()

	return size
} PrettyPrintBody:[{ set.lock.RLock() size := int64(len(set.items)) set.lock.RUnlock() return size }]} {Id:8 FileId:123 StartLine:102 StartColumn:1 EndLine:108 EndColumn:2 Name:Clear Params:[] Results:[] Receiver:0xc001033640 Body:{
	set.lock.Lock()

	set.items = map[interface{}]struct{}{}

	set.lock.Unlock()
} PrettyPrintBody:[{ set.lock.Lock() set.items = map[interface{}]struct{}{} set.lock.Unlock() }]} {Id:9 FileId:123 StartLine:111 StartColumn:1 EndLine:122 EndColumn:2 Name:All Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:bool}] Receiver:0xc00095a440 Body:{
	set.lock.RLock()
	defer set.lock.RUnlock()

	for _, item := range items {
		if _, ok := set.items[item]; !ok {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ set.lock.RLock() defer set.lock.RUnlock() for _, item := range items { if _, ok := set.items[item]; !ok { return false } } return true }]} {Id:10 FileId:123 StartLine:125 StartColumn:1 EndLine:140 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc001309640 Body:{
	set.lock.Lock()
	defer set.lock.Unlock()

	for k := range set.items {
		delete(set.items, k)
	}

	for i := 0; i < len(set.flattened); i++ {
		set.flattened[i] = nil
	}

	set.flattened = set.flattened[:0]
	pool.Put(set)
} PrettyPrintBody:[{ set.lock.Lock() defer set.lock.Unlock() for k := range set.items { delete(set.items, k) } for i := 0; i < len(set.flattened); i++ { set.flattened[i] = nil } set.flattened = set.flattened[:0] pool.Put(set) }]} {Id:11 FileId:123 StartLine:144 StartColumn:1 EndLine:155 EndColumn:2 Name:New Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:*Set}] Receiver:<nil> Body:{
	set := pool.Get().(*Set)
	for _, item := range items {
		set.items[item] = struct{}{}
	}

	if len(items) > 0 {
		set.flattened = nil
	}

	return set
} PrettyPrintBody:[{ set := pool.Get().(*Set) for _, item := range items { set.items[item] = struct{}{} } if len(items) > 0 { set.flattened = nil } return set }]} {Id:12 FileId:123 StartLine:157 StartColumn:1 EndLine:163 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	pool.New = func() interface{} {
		return &Set{
			items: make(map[interface{}]struct{}, 10),
		}
	}
} PrettyPrintBody:[{ pool.New = func() interface{} { return &Set{ items: make(map[interface{}]struct{}, 10), } } }]} {Id:2 FileId:8 StartLine:33 StartColumn:1 EndLine:35 EndColumn:2 Name:newMutex Params:[] Results:[{Name: Type:*mutex}] Receiver:<nil> Body:{
	return &mutex{lock: make(chan struct{}, 1)}
} PrettyPrintBody:[{ return &mutex{lock: make(chan struct{}, 1)} }]} {Id:3 FileId:8 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:Lock Params:[] Results:[] Receiver:0xc001580c40 Body:{
	m.lock <- struct{}{}
} PrettyPrintBody:[{ m.lock <- struct{}{} }]} {Id:4 FileId:8 StartLine:41 StartColumn:1 EndLine:43 EndColumn:2 Name:Unlock Params:[] Results:[] Receiver:0xc001580c60 Body:{
	<-m.lock
} PrettyPrintBody:[{ <-m.lock }]} {Id:5 FileId:8 StartLine:45 StartColumn:1 EndLine:52 EndColumn:2 Name:TryLock Params:[] Results:[{Name: Type:bool}] Receiver:0xc000bb68c0 Body:{
	select {
	case m.lock <- struct{}{}:
		return true
	default:
		return false
	}
} PrettyPrintBody:[{ select { case m.lock <- struct{}{}: return true default: return false } }]} {Id:10 FileId:8 StartLine:104 StartColumn:1 EndLine:118 EndColumn:2 Name:New Params:[{Name:maxTime Type:time.Duration} {Name:maxItems Type:uint} {Name:calculate Type:CalculateBytes}] Results:[{Name: Type:Batcher} {Name: Type:error}] Receiver:<nil> Body:{
	if maxBytes > 0 && calculate == nil {
		return nil, errors.New("batcher: must provide CalculateBytes function")
	}

	return &basicBatcher{
		maxTime:	maxTime,
		maxItems:	maxItems,
		maxBytes:	maxBytes,
		calculateBytes:	calculate,
		items:		make([]interface{}, 0, maxItems),
		batchChan:	make(chan []interface{}, queueLen),
		lock:		newMutex(),
	}, nil
} PrettyPrintBody:[{ if maxBytes > 0 && calculate == nil { return nil, errors.New("batcher: must provide CalculateBytes function") } return &basicBatcher{ maxTime:	maxTime, maxItems:	maxItems, maxBytes:	maxBytes, calculateBytes:	calculate, items:		make([]interface{}, 0, maxItems), batchChan:	make(chan []interface{}, queueLen), lock:		newMutex(), }, nil }]} {Id:11 FileId:8 StartLine:121 StartColumn:1 EndLine:142 EndColumn:2 Name:Put Params:[{Name:item Type:interface{}}] Results:[{Name: Type:error}] Receiver:0xc0014098e0 Body:{
	b.lock.Lock()
	if b.disposed {
		b.lock.Unlock()
		return ErrDisposed
	}

	b.items = append(b.items, item)
	if b.calculateBytes != nil {
		b.availableBytes += b.calculateBytes(item)
	}
	if b.ready() {

		b.flush()
	}

	b.lock.Unlock()
	return nil
} PrettyPrintBody:[{ b.lock.Lock() if b.disposed { b.lock.Unlock() return ErrDisposed } b.items = append(b.items, item) if b.calculateBytes != nil { b.availableBytes += b.calculateBytes(item) } if b.ready() { b.flush() } b.lock.Unlock() return nil }]} {Id:12 FileId:8 StartLine:146 StartColumn:1 EndLine:210 EndColumn:2 Name:Get Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc001409900 Body:{

	var timeout <-chan time.Time
	if b.maxTime > 0 {
		timeout = time.After(b.maxTime)
	}

	select {
	case items, ok := <-b.batchChan:

		if !ok {
			return nil, ErrDisposed
		}
		return items, nil
	case <-timeout:

		for {
			if b.lock.TryLock() {

				select {
				case items, ok := <-b.batchChan:
					b.lock.Unlock()
					if !ok {
						return nil, ErrDisposed
					}
					return items, nil
				default:
				}

				items := b.items
				b.items = make([]interface{}, 0, b.maxItems)
				b.availableBytes = 0
				b.lock.Unlock()
				return items, nil
			} else {

				select {
				case items, ok := <-b.batchChan:
					if !ok {
						return nil, ErrDisposed
					}
					return items, nil
				default:
				}
			}
		}
	}
} PrettyPrintBody:[{ var timeout <-chan time.Time if b.maxTime > 0 { timeout = time.After(b.maxTime) } select { case items, ok := <-b.batchChan: if !ok { return nil, ErrDisposed } return items, nil case <-timeout: for { if b.lock.TryLock() { select { case items, ok := <-b.batchChan: b.lock.Unlock() if !ok { return nil, ErrDisposed } return items, nil default: } items := b.items b.items = make([]interface{}, 0, b.maxItems) b.availableBytes = 0 b.lock.Unlock() return items, nil } else { select { case items, ok := <-b.batchChan: if !ok { return nil, ErrDisposed } return items, nil default: } } } } }]} {Id:13 FileId:8 StartLine:213 StartColumn:1 EndLine:223 EndColumn:2 Name:Flush Params:[] Results:[{Name: Type:error}] Receiver:0xc000992060 Body:{

	b.lock.Lock()
	if b.disposed {
		b.lock.Unlock()
		return ErrDisposed
	}
	b.flush()
	b.lock.Unlock()
	return nil
} PrettyPrintBody:[{ b.lock.Lock() if b.disposed { b.lock.Unlock() return ErrDisposed } b.flush() b.lock.Unlock() return nil }]} {Id:14 FileId:8 StartLine:229 StartColumn:1 EndLine:254 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0011d74a0 Body:{
	for {
		if b.lock.TryLock() {

			if b.disposed {
				b.lock.Unlock()
				return
			}

			b.disposed = true
			b.items = nil
			b.drainBatchChan()
			close(b.batchChan)
			b.lock.Unlock()
		} else {

			b.drainBatchChan()
		}

	}
} PrettyPrintBody:[{ for { if b.lock.TryLock() { if b.disposed { b.lock.Unlock() return } b.disposed = true b.items = nil b.drainBatchChan() close(b.batchChan) b.lock.Unlock() } else { b.drainBatchChan() } } }]} {Id:15 FileId:8 StartLine:257 StartColumn:1 EndLine:262 EndColumn:2 Name:IsDisposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000992960 Body:{
	b.lock.Lock()
	disposed := b.disposed
	b.lock.Unlock()
	return disposed
} PrettyPrintBody:[{ b.lock.Lock() disposed := b.disposed b.lock.Unlock() return disposed }]} {Id:16 FileId:8 StartLine:266 StartColumn:1 EndLine:270 EndColumn:2 Name:flush Params:[] Results:[] Receiver:0xc001033c20 Body:{
	b.batchChan <- b.items
	b.items = make([]interface{}, 0, b.maxItems)
	b.availableBytes = 0
} PrettyPrintBody:[{ b.batchChan <- b.items b.items = make([]interface{}, 0, b.maxItems) b.availableBytes = 0 }]} {Id:17 FileId:8 StartLine:272 StartColumn:1 EndLine:280 EndColumn:2 Name:ready Params:[] Results:[{Name: Type:bool}] Receiver:0xc001033d60 Body:{
	if b.maxItems != 0 && uint(len(b.items)) >= b.maxItems {
		return true
	}
	if b.maxBytes != 0 && b.availableBytes >= b.maxBytes {
		return true
	}
	return false
} PrettyPrintBody:[{ if b.maxItems != 0 && uint(len(b.items)) >= b.maxItems { return true } if b.maxBytes != 0 && b.availableBytes >= b.maxBytes { return true } return false }]} {Id:18 FileId:8 StartLine:282 StartColumn:1 EndLine:290 EndColumn:2 Name:drainBatchChan Params:[] Results:[] Receiver:0xc001033d80 Body:{
	for {
		select {
		case <-b.batchChan:
		default:
			return
		}
	}
} PrettyPrintBody:[{ for { select { case <-b.batchChan: default: return } } }]} {Id:1 FileId:11 StartLine:26 StartColumn:1 EndLine:35 EndColumn:2 Name:checkBit Params:[{Name:t Type:*testing.T} {Name:ba Type:BitArray} {Name:position Type:uint64} {Name:expected Type:bool}] Results:[] Receiver:<nil> Body:{
	ok, err := ba.GetBit(position)
	if assert.NoError(t, err) {
		if expected {
			assert.True(t, ok, "Bitarray at position %d should be set", position)
		} else {
			assert.False(t, ok, "Bitarray at position %d should be unset", position)
		}
	}
} PrettyPrintBody:[{ ok, err := ba.GetBit(position) if assert.NoError(t, err) { if expected { assert.True(t, ok, "Bitarray at position %d should be set", position) } else { assert.False(t, ok, "Bitarray at position %d should be unset", position) } } }]} {Id:2 FileId:11 StartLine:37 StartColumn:1 EndLine:76 EndColumn:2 Name:TestAndSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(3)
	sba.SetBit(280)
	other.SetBit(9)
	other.SetBit(100)
	sba.SetBit(1000)
	other.SetBit(1001)

	sba.SetBit(1)
	other.SetBit(1)
	sba.SetBit(2680)
	other.SetBit(2680)
	sba.SetBit(30)
	other.SetBit(30)

	ba := andSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 30, true)
	checkBit(t, ba, 2680, true)

	checkBit(t, ba, 3, false)
	checkBit(t, ba, 280, false)
	checkBit(t, ba, 1000, false)

	checkBit(t, ba, 9, false)
	checkBit(t, ba, 100, false)
	checkBit(t, ba, 2, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{1, 30, 2680}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(3) sba.SetBit(280) other.SetBit(9) other.SetBit(100) sba.SetBit(1000) other.SetBit(1001) sba.SetBit(1) other.SetBit(1) sba.SetBit(2680) other.SetBit(2680) sba.SetBit(30) other.SetBit(30) ba := andSparseWithSparseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 30, true) checkBit(t, ba, 2680, true) checkBit(t, ba, 3, false) checkBit(t, ba, 280, false) checkBit(t, ba, 1000, false) checkBit(t, ba, 9, false) checkBit(t, ba, 100, false) checkBit(t, ba, 2, false) nums := ba.ToNums() assert.Equal(t, []uint64{1, 30, 2680}, nums) }]} {Id:3 FileId:11 StartLine:78 StartColumn:1 EndLine:104 EndColumn:2 Name:TestAndSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(300)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := andSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 150, true)
	checkBit(t, ba, 300, true)

	checkBit(t, ba, 155, false)

	checkBit(t, ba, 156, false)

} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(300) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 150, true) checkBit(t, ba, 300, true) checkBit(t, ba, 155, false) checkBit(t, ba, 156, false) }]} {Id:4 FileId:11 StartLine:108 StartColumn:1 EndLine:137 EndColumn:2 Name:TestAndSparseWithSmallerDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(512)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	sba.SetBit(500)

	other.SetBit(128)
	sba.SetBit(1500)
	sba.SetBit(1200)

	ba := andSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, true)
	checkBit(t, ba, 150, true)

	checkBit(t, ba, 155, false)
	checkBit(t, ba, 500, false)
	checkBit(t, ba, 1200, false)
	checkBit(t, ba, 1500, false)

	checkBit(t, ba, 128, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(512) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) sba.SetBit(500) other.SetBit(128) sba.SetBit(1500) sba.SetBit(1200) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, true) checkBit(t, ba, 150, true) checkBit(t, ba, 155, false) checkBit(t, ba, 500, false) checkBit(t, ba, 1200, false) checkBit(t, ba, 1500, false) checkBit(t, ba, 128, false) }]} {Id:5 FileId:11 StartLine:139 StartColumn:1 EndLine:163 EndColumn:2 Name:TestAndDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	dba.SetBit(1)
	other.SetBit(18)
	dba.SetBit(222)
	other.SetBit(222)
	other.SetBit(1501)

	ba := andDenseWithDenseBitArray(dba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 1, false)
	checkBit(t, ba, 3, false)
	checkBit(t, ba, 18, false)
	checkBit(t, ba, 222, true)

	_, err := ba.GetBit(1500)
	assert.Equal(t, OutOfRangeError(1500), err)
	_, err = ba.GetBit(1501)
	assert.Equal(t, OutOfRangeError(1501), err)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) dba.SetBit(1) other.SetBit(18) dba.SetBit(222) other.SetBit(222) other.SetBit(1501) ba := andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 1, false) checkBit(t, ba, 3, false) checkBit(t, ba, 18, false) checkBit(t, ba, 222, true) _, err := ba.GetBit(1500) assert.Equal(t, OutOfRangeError(1500), err) _, err = ba.GetBit(1501) assert.Equal(t, OutOfRangeError(1501), err) }]} {Id:6 FileId:11 StartLine:165 StartColumn:1 EndLine:176 EndColumn:2 Name:TestAndSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	ba := andSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 5, false)
	checkBit(t, ba, 100, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) ba := andSparseWithSparseBitArray(sba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 5, false) checkBit(t, ba, 100, false) }]} {Id:7 FileId:11 StartLine:178 StartColumn:1 EndLine:191 EndColumn:2 Name:TestAndSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	ba := andSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)

	sba.Reset()
	other.SetBit(5)

	ba = andSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) ba := andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) sba.Reset() other.SetBit(5) ba = andSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) }]} {Id:8 FileId:11 StartLine:193 StartColumn:1 EndLine:205 EndColumn:2 Name:TestAndDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	ba := andDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)

	dba.Reset()
	other.SetBit(5)
	ba = andDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) ba := andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) dba.Reset() other.SetBit(5) ba = andDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) }]} {Id:1 FileId:88 StartLine:25 StartColumn:1 EndLine:49 EndColumn:2 Name:TestHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	h := Encode(0, 0)
	x, y := Decode(h)
	assert.Equal(t, int64(0), h)
	assert.Equal(t, int32(0), x)
	assert.Equal(t, int32(0), y)

	h = Encode(1, 0)
	x, y = Decode(h)
	assert.Equal(t, int64(3), h)
	assert.Equal(t, int32(1), x)
	assert.Equal(t, int32(0), y)

	h = Encode(1, 1)
	x, y = Decode(h)
	assert.Equal(t, int64(2), h)
	assert.Equal(t, int32(1), x)
	assert.Equal(t, int32(1), y)

	h = Encode(0, 1)
	x, y = Decode(h)
	assert.Equal(t, int64(1), h)
	assert.Equal(t, int32(0), x)
	assert.Equal(t, int32(1), y)
} PrettyPrintBody:[{ h := Encode(0, 0) x, y := Decode(h) assert.Equal(t, int64(0), h) assert.Equal(t, int32(0), x) assert.Equal(t, int32(0), y) h = Encode(1, 0) x, y = Decode(h) assert.Equal(t, int64(3), h) assert.Equal(t, int32(1), x) assert.Equal(t, int32(0), y) h = Encode(1, 1) x, y = Decode(h) assert.Equal(t, int64(2), h) assert.Equal(t, int32(1), x) assert.Equal(t, int32(1), y) h = Encode(0, 1) x, y = Decode(h) assert.Equal(t, int64(1), h) assert.Equal(t, int32(0), x) assert.Equal(t, int32(1), y) }]} {Id:2 FileId:88 StartLine:51 StartColumn:1 EndLine:57 EndColumn:2 Name:TestHilbertAtMaxRange Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	x, y := int32(math.MaxInt32), int32(math.MaxInt32)
	h := Encode(x, y)
	resultx, resulty := Decode(h)
	assert.Equal(t, x, resultx)
	assert.Equal(t, y, resulty)
} PrettyPrintBody:[{ x, y := int32(math.MaxInt32), int32(math.MaxInt32) h := Encode(x, y) resultx, resulty := Decode(h) assert.Equal(t, x, resultx) assert.Equal(t, y, resulty) }]} {Id:3 FileId:88 StartLine:59 StartColumn:1 EndLine:63 EndColumn:2 Name:BenchmarkEncode Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		Encode(int32(i), int32(i))
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { Encode(int32(i), int32(i)) } }]} {Id:4 FileId:88 StartLine:65 StartColumn:1 EndLine:69 EndColumn:2 Name:BenchmarkDecode Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		Decode(int64(i))
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { Decode(int64(i)) } }]} {Id:1 FileId:137 StartLine:11 StartColumn:1 EndLine:23 EndColumn:2 Name:symSearch Params:[{Name:u Type:Comparators}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	start, stop, p := 0, len(u), len(w)-1
	for start < stop {
		mid := (start + stop) / 2
		if u[mid].Compare(w[p-mid]) <= 0 {
			start = mid + 1
		} else {
			stop = mid
		}
	}

	return start
} PrettyPrintBody:[{ start, stop, p := 0, len(u), len(w)-1 for start < stop { mid := (start + stop) / 2 if u[mid].Compare(w[p-mid]) <= 0 { start = mid + 1 } else { stop = mid } } return start }]} {Id:2 FileId:137 StartLine:28 StartColumn:1 EndLine:32 EndColumn:2 Name:swap Params:[{Name:u Type:Comparators} {Name:index Type:int}] Results:[] Receiver:<nil> Body:{
	for i := index; i < len(u); i++ {
		u[i], w[i-index] = w[i-index], u[i]
	}
} PrettyPrintBody:[{ for i := index; i < len(u); i++ { u[i], w[i-index] = w[i-index], u[i] } }]} {Id:3 FileId:137 StartLine:38 StartColumn:1 EndLine:51 EndColumn:2 Name:decomposeForSymMerge Params:[{Name:length Type:int} {Name:comparators Type:Comparators}] Results:[{Name:v1 Type:Comparators} {Name:w Type:Comparators} {Name:v2 Type:Comparators}] Receiver:<nil> Body:{

	if length >= len(comparators) {
		panic(`INCORRECT PARAMS FOR SYM MERGE.`)
	}

	overhang := (len(comparators) - length) / 2
	v1 = comparators[:overhang]
	w = comparators[overhang : overhang+length]
	v2 = comparators[overhang+length:]
	return
} PrettyPrintBody:[{ if length >= len(comparators) { panic(`INCORRECT PARAMS FOR SYM MERGE.`) } overhang := (len(comparators) - length) / 2 v1 = comparators[:overhang] w = comparators[overhang : overhang+length] v2 = comparators[overhang+length:] return }]} {Id:4 FileId:137 StartLine:55 StartColumn:1 EndLine:66 EndColumn:2 Name:symBinarySearch Params:[{Name:u Type:Comparators} {Name:start Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	for start < stop {
		mid := (start + stop) / 2
		if u[mid].Compare(u[total-mid]) <= 0 {
			start = mid + 1
		} else {
			stop = mid
		}
	}

	return start
} PrettyPrintBody:[{ for start < stop { mid := (start + stop) / 2 if u[mid].Compare(u[total-mid]) <= 0 { start = mid + 1 } else { stop = mid } } return start }]} {Id:5 FileId:137 StartLine:71 StartColumn:1 EndLine:75 EndColumn:2 Name:symSwap Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < end; i++ {
		u[start1+i], u[start2+i] = u[start2+i], u[start1+i]
	}
} PrettyPrintBody:[{ for i := 0; i < end; i++ { u[start1+i], u[start2+i] = u[start2+i], u[start1+i] } }]} {Id:6 FileId:137 StartLine:79 StartColumn:1 EndLine:106 EndColumn:2 Name:symRotate Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	i := start2 - start1
	if i == 0 {
		return
	}

	j := end - start2
	if j == 0 {
		return
	}

	if i == j {
		symSwap(u, start1, start2, i)
		return
	}

	p := start1 + i
	for i != j {
		if i > j {
			symSwap(u, p-i, p, j)
			i -= j
		} else {
			symSwap(u, p-i, p+j-i, i)
			j -= i
		}
	}
	symSwap(u, p-i, p, i)
} PrettyPrintBody:[{ i := start2 - start1 if i == 0 { return } j := end - start2 if j == 0 { return } if i == j { symSwap(u, start1, start2, i) return } p := start1 + i for i != j { if i > j { symSwap(u, p-i, p, j) i -= j } else { symSwap(u, p-i, p+j-i, i) j -= i } } symSwap(u, p-i, p, i) }]} {Id:7 FileId:137 StartLine:109 StartColumn:1 EndLine:125 EndColumn:2 Name:symMerge Params:[{Name:u Type:Comparators} {Name:start1 Type:int}] Results:[] Receiver:<nil> Body:{
	if start1 < start2 && start2 < last {
		mid := (start1 + last) / 2
		n := mid + start2
		var start int
		if start2 > mid {
			start = symBinarySearch(u, n-last, mid, n-1)
		} else {
			start = symBinarySearch(u, start1, start2, n-1)
		}
		end := n - start

		symRotate(u, start, start2, end)
		symMerge(u, start1, start, mid)
		symMerge(u, mid, end, last)
	}
} PrettyPrintBody:[{ if start1 < start2 && start2 < last { mid := (start1 + last) / 2 n := mid + start2 var start int if start2 > mid { start = symBinarySearch(u, n-last, mid, n-1) } else { start = symBinarySearch(u, start1, start2, n-1) } end := n - start symRotate(u, start, start2, end) symMerge(u, start1, start, mid) symMerge(u, mid, end, last) } }]} {Id:8 FileId:137 StartLine:133 StartColumn:1 EndLine:170 EndColumn:2 Name:SymMerge Params:[{Name:u Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	lenU, lenW := len(u), len(w)
	if lenU == 0 {
		return w
	}

	if lenW == 0 {
		return u
	}

	diff := lenU - lenW
	if math.Abs(float64(diff)) > 1 {
		u1, w1, u2, w2 := prepareForSymMerge(u, w)

		lenU1 := len(u1)
		lenU2 := len(u2)
		u = append(u1, w1...)
		w = append(u2, w2...)
		var wg sync.WaitGroup
		wg.Add(2)
		go func() {
			symMerge(u, 0, lenU1, len(u))
			wg.Done()
		}()
		go func() {
			symMerge(w, 0, lenU2, len(w))
			wg.Done()
		}()

		wg.Wait()
		u = append(u, w...)
		return u
	}

	u = append(u, w...)
	symMerge(u, 0, lenU, len(u))
	return u
} PrettyPrintBody:[{ lenU, lenW := len(u), len(w) if lenU == 0 { return w } if lenW == 0 { return u } diff := lenU - lenW if math.Abs(float64(diff)) > 1 { u1, w1, u2, w2 := prepareForSymMerge(u, w) lenU1 := len(u1) lenU2 := len(u2) u = append(u1, w1...) w = append(u2, w2...) var wg sync.WaitGroup wg.Add(2) go func() { symMerge(u, 0, lenU1, len(u)) wg.Done() }() go func() { symMerge(w, 0, lenU2, len(w)) wg.Done() }() wg.Wait() u = append(u, w...) return u } u = append(u, w...) symMerge(u, 0, lenU, len(u)) return u }]} {Id:9 FileId:137 StartLine:179 StartColumn:1 EndLine:196 EndColumn:2 Name:prepareForSymMerge Params:[{Name:u Type:Comparators}] Results:[{Name:u1 Type:Comparators}] Receiver:<nil> Body:{
	if u.Len() > w.Len() {
		u, w = w, u
	}
	v1, w, v2 := decomposeForSymMerge(len(u), w)

	i := symSearch(u, w)

	u1 = make(Comparators, i)
	copy(u1, u[:i])
	w1 = append(v1, w[:len(w)-i]...)

	u2 = make(Comparators, len(u)-i)
	copy(u2, u[i:])

	w2 = append(w[len(w)-i:], v2...)
	return
} PrettyPrintBody:[{ if u.Len() > w.Len() { u, w = w, u } v1, w, v2 := decomposeForSymMerge(len(u), w) i := symSearch(u, w) u1 = make(Comparators, i) copy(u1, u[:i]) w1 = append(v1, w[:len(w)-i]...) u2 = make(Comparators, len(u)-i) copy(u2, u[i:]) w2 = append(w[len(w)-i:], v2...) return }]} {Id:4 FileId:83 StartLine:82 StartColumn:1 EndLine:84 EndColumn:2 Name:Head Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000eee560 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]} {Id:5 FileId:83 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:Tail Params:[] Results:[{Name: Type:PersistentList} {Name: Type:bool}] Receiver:0xc001602120 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]} {Id:6 FileId:83 StartLine:93 StartColumn:1 EndLine:95 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001602160 Body:{
	return true
} PrettyPrintBody:[{ return true }]} {Id:7 FileId:83 StartLine:98 StartColumn:1 EndLine:100 EndColumn:2 Name:Length Params:[] Results:[{Name: Type:uint}] Receiver:0xc001308a00 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:8 FileId:83 StartLine:103 StartColumn:1 EndLine:105 EndColumn:2 Name:Add Params:[{Name:head Type:interface{}}] Results:[{Name: Type:PersistentList}] Receiver:0xc001308a60 Body:{
	return &list{head, e}
} PrettyPrintBody:[{ return &list{head, e} }]} {Id:9 FileId:83 StartLine:109 StartColumn:1 EndLine:114 EndColumn:2 Name:Insert Params:[{Name:val Type:interface{}} {Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc001580940 Body:{
	if pos == 0 {
		return e.Add(val), nil
	}
	return nil, ErrEmptyList
} PrettyPrintBody:[{ if pos == 0 { return e.Add(val), nil } return nil, ErrEmptyList }]} {Id:10 FileId:83 StartLine:118 StartColumn:1 EndLine:120 EndColumn:2 Name:Get Params:[{Name:pos Type:uint}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc001308ea0 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]} {Id:11 FileId:83 StartLine:124 StartColumn:1 EndLine:126 EndColumn:2 Name:Remove Params:[{Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc00095a040 Body:{
	return nil, ErrEmptyList
} PrettyPrintBody:[{ return nil, ErrEmptyList }]} {Id:12 FileId:83 StartLine:130 StartColumn:1 EndLine:132 EndColumn:2 Name:Find Params:[{Name: Type:func(interface{}) bool}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0012471c0 Body:{
	return nil, false
} PrettyPrintBody:[{ return nil, false }]} {Id:13 FileId:83 StartLine:136 StartColumn:1 EndLine:138 EndColumn:2 Name:FindIndex Params:[{Name: Type:func(interface{}) bool}] Results:[{Name: Type:int}] Receiver:0xc001033320 Body:{
	return -1
} PrettyPrintBody:[{ return -1 }]} {Id:14 FileId:83 StartLine:142 StartColumn:1 EndLine:144 EndColumn:2 Name:Map Params:[{Name: Type:func(interface{}) interface{}}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001580d60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:16 FileId:83 StartLine:153 StartColumn:1 EndLine:155 EndColumn:2 Name:Head Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000118800 Body:{
	return l.head, true
} PrettyPrintBody:[{ return l.head, true }]} {Id:17 FileId:83 StartLine:159 StartColumn:1 EndLine:161 EndColumn:2 Name:Tail Params:[] Results:[{Name: Type:PersistentList} {Name: Type:bool}] Receiver:0xc000118820 Body:{
	return l.tail, true
} PrettyPrintBody:[{ return l.tail, true }]} {Id:18 FileId:83 StartLine:164 StartColumn:1 EndLine:166 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc000118860 Body:{
	return false
} PrettyPrintBody:[{ return false }]} {Id:19 FileId:83 StartLine:169 StartColumn:1 EndLine:180 EndColumn:2 Name:Length Params:[] Results:[{Name: Type:uint}] Receiver:0xc0001188c0 Body:{
	curr := l
	length := uint(0)
	for {
		length += 1
		tail, _ := curr.Tail()
		if tail.IsEmpty() {
			return length
		}
		curr = tail.(*list)
	}
} PrettyPrintBody:[{ curr := l length := uint(0) for { length += 1 tail, _ := curr.Tail() if tail.IsEmpty() { return length } curr = tail.(*list) } }]} {Id:20 FileId:83 StartLine:183 StartColumn:1 EndLine:185 EndColumn:2 Name:Add Params:[{Name:head Type:interface{}}] Results:[{Name: Type:PersistentList}] Receiver:0xc001602600 Body:{
	return &list{head, l}
} PrettyPrintBody:[{ return &list{head, l} }]} {Id:21 FileId:83 StartLine:189 StartColumn:1 EndLine:198 EndColumn:2 Name:Insert Params:[{Name:val Type:interface{}} {Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc0010dee60 Body:{
	if pos == 0 {
		return l.Add(val), nil
	}
	nl, err := l.tail.Insert(val, pos-1)
	if err != nil {
		return nil, err
	}
	return nl.Add(l.head), nil
} PrettyPrintBody:[{ if pos == 0 { return l.Add(val), nil } nl, err := l.tail.Insert(val, pos-1) if err != nil { return nil, err } return nl.Add(l.head), nil }]} {Id:22 FileId:83 StartLine:202 StartColumn:1 EndLine:207 EndColumn:2 Name:Get Params:[{Name:pos Type:uint}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0003e4ee0 Body:{
	if pos == 0 {
		return l.head, true
	}
	return l.tail.Get(pos - 1)
} PrettyPrintBody:[{ if pos == 0 { return l.head, true } return l.tail.Get(pos - 1) }]} {Id:23 FileId:83 StartLine:211 StartColumn:1 EndLine:222 EndColumn:2 Name:Remove Params:[{Name:pos Type:uint}] Results:[{Name: Type:PersistentList} {Name: Type:error}] Receiver:0xc0001e60a0 Body:{
	if pos == 0 {
		nl, _ := l.Tail()
		return nl, nil
	}

	nl, err := l.tail.Remove(pos - 1)
	if err != nil {
		return nil, err
	}
	return &list{l.head, nl}, nil
} PrettyPrintBody:[{ if pos == 0 { nl, _ := l.Tail() return nl, nil } nl, err := l.tail.Remove(pos - 1) if err != nil { return nil, err } return &list{l.head, nl}, nil }]} {Id:24 FileId:83 StartLine:226 StartColumn:1 EndLine:231 EndColumn:2 Name:Find Params:[{Name:pred Type:func(interface{}) bool}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc001581580 Body:{
	if pred(l.head) {
		return l.head, true
	}
	return l.tail.Find(pred)
} PrettyPrintBody:[{ if pred(l.head) { return l.head, true } return l.tail.Find(pred) }]} {Id:25 FileId:83 StartLine:235 StartColumn:1 EndLine:249 EndColumn:2 Name:FindIndex Params:[{Name:pred Type:func(interface{}) bool}] Results:[{Name: Type:int}] Receiver:0xc000993bc0 Body:{
	curr := l
	idx := 0
	for {
		if pred(curr.head) {
			return idx
		}
		tail, _ := curr.Tail()
		if tail.IsEmpty() {
			return -1
		}
		curr = tail.(*list)
		idx += 1
	}
} PrettyPrintBody:[{ curr := l idx := 0 for { if pred(curr.head) { return idx } tail, _ := curr.Tail() if tail.IsEmpty() { return -1 } curr = tail.(*list) idx += 1 } }]} {Id:26 FileId:83 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:Map Params:[{Name:f Type:func(interface{}) interface{}}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001602ea0 Body:{
	return append(l.tail.Map(f), f(l.head))
} PrettyPrintBody:[{ return append(l.tail.Map(f), f(l.head)) }]} {Id:2 FileId:162 StartLine:51 StartColumn:1 EndLine:67 EndColumn:2 Name:init Params:[{Name:intType Type:interface{}}] Results:[] Receiver:0xc001155120 Body:{
	switch intType.(type) {
	case uint8:
		yfast.bits = 8
	case uint16:
		yfast.bits = 16
	case uint32:
		yfast.bits = 32
	case uint, uint64:
		yfast.bits = 64
	default:

		panic(`Invalid universe size provided.`)
	}

	yfast.xfast = xfast.New(intType)
} PrettyPrintBody:[{ switch intType.(type) { case uint8: yfast.bits = 8 case uint16: yfast.bits = 16 case uint32: yfast.bits = 32 case uint, uint64: yfast.bits = 64 default: panic(`Invalid universe size provided.`) } yfast.xfast = xfast.New(intType) }]} {Id:3 FileId:162 StartLine:71 StartColumn:1 EndLine:74 EndColumn:2 Name:getBucketKey Params:[{Name:key Type:uint64}] Results:[{Name: Type:uint64}] Receiver:0xc001033040 Body:{
	i := key/uint64(yfast.bits) + 1
	return uint64(yfast.bits)*i - 1
} PrettyPrintBody:[{ i := key/uint64(yfast.bits) + 1 return uint64(yfast.bits)*i - 1 }]} {Id:4 FileId:162 StartLine:76 StartColumn:1 EndLine:103 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001033160 Body:{

	bundleKey := yfast.getBucketKey(entry.Key())
	bundle := yfast.xfast.Get(bundleKey)

	if bundle != nil {
		overwritten := bundle.(*entriesWrapper).entries.insert(entry)
		if overwritten == nil {
			yfast.num++
			return nil
		}

		return overwritten
	}

	yfast.num++
	entries := make(Entries, 0, yfast.bits)
	entries.insert(entry)

	ew := &entriesWrapper{
		key:		bundleKey,
		entries:	entries,
	}

	yfast.xfast.Insert(ew)
	return nil
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(entry.Key()) bundle := yfast.xfast.Get(bundleKey) if bundle != nil { overwritten := bundle.(*entriesWrapper).entries.insert(entry) if overwritten == nil { yfast.num++ return nil } return overwritten } yfast.num++ entries := make(Entries, 0, yfast.bits) entries.insert(entry) ew := &entriesWrapper{ key:		bundleKey, entries:	entries, } yfast.xfast.Insert(ew) return nil }]} {Id:5 FileId:162 StartLine:107 StartColumn:1 EndLine:114 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0013099e0 Body:{
	overwritten := make(Entries, 0, len(entries))
	for _, e := range entries {
		overwritten = append(overwritten, yfast.insert(e))
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(Entries, 0, len(entries)) for _, e := range entries { overwritten = append(overwritten, yfast.insert(e)) } return overwritten }]} {Id:6 FileId:162 StartLine:116 StartColumn:1 EndLine:137 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0015810a0 Body:{
	bundleKey := yfast.getBucketKey(key)

	bundle := yfast.xfast.Get(bundleKey)
	if bundle == nil {
		return nil
	}

	ew := bundle.(*entriesWrapper)
	entry := ew.entries.delete(key)
	if entry == nil {
		return nil
	}

	yfast.num--

	if len(ew.entries) == 0 {
		yfast.xfast.Delete(bundleKey)
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Get(bundleKey) if bundle == nil { return nil } ew := bundle.(*entriesWrapper) entry := ew.entries.delete(key) if entry == nil { return nil } yfast.num-- if len(ew.entries) == 0 { yfast.xfast.Delete(bundleKey) } return entry }]} {Id:7 FileId:162 StartLine:141 StartColumn:1 EndLine:148 EndColumn:2 Name:Delete Params:[{Name:keys Type:...uint64}] Results:[{Name: Type:Entries}] Receiver:0xc001309c00 Body:{
	entries := make(Entries, 0, len(keys))
	for _, key := range keys {
		entries = append(entries, yfast.delete(key))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, len(keys)) for _, key := range keys { entries = append(entries, yfast.delete(key)) } return entries }]} {Id:8 FileId:162 StartLine:150 StartColumn:1 EndLine:163 EndColumn:2 Name:get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0016027c0 Body:{
	bundleKey := yfast.getBucketKey(key)
	bundle := yfast.xfast.Get(bundleKey)
	if bundle == nil {
		return nil
	}

	entry := bundle.(*entriesWrapper).entries.get(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Get(bundleKey) if bundle == nil { return nil } entry := bundle.(*entriesWrapper).entries.get(key) if entry == nil { return nil } return entry }]} {Id:9 FileId:162 StartLine:168 StartColumn:1 EndLine:175 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc001309e00 Body:{
	entry := yfast.get(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.get(key) if entry == nil { return nil } return entry }]} {Id:10 FileId:162 StartLine:178 StartColumn:1 EndLine:180 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00095a580 Body:{
	return yfast.num
} PrettyPrintBody:[{ return yfast.num }]} {Id:11 FileId:162 StartLine:182 StartColumn:1 EndLine:194 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0001e6160 Body:{
	bundle := yfast.xfast.Successor(key)
	if bundle == nil {
		return nil
	}

	entry, _ := bundle.(*entriesWrapper).entries.successor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundle := yfast.xfast.Successor(key) if bundle == nil { return nil } entry, _ := bundle.(*entriesWrapper).entries.successor(key) if entry == nil { return nil } return entry }]} {Id:12 FileId:162 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:Successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc00095a700 Body:{
	entry := yfast.successor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.successor(key) if entry == nil { return nil } return entry }]} {Id:13 FileId:162 StartLine:208 StartColumn:1 EndLine:237 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0003e5080 Body:{

	bundleKey := yfast.getBucketKey(key)
	bundle := yfast.xfast.Predecessor(bundleKey)
	if bundle == nil {
		return nil
	}

	ew := bundle.(*entriesWrapper)
	entry, _ := ew.entries.predecessor(key)
	if entry != nil {
		return entry
	}

	bundle = yfast.xfast.Predecessor(bundleKey - 1)
	if bundle == nil {
		return nil
	}

	ew = bundle.(*entriesWrapper)

	entry, _ = ew.entries.predecessor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ bundleKey := yfast.getBucketKey(key) bundle := yfast.xfast.Predecessor(bundleKey) if bundle == nil { return nil } ew := bundle.(*entriesWrapper) entry, _ := ew.entries.predecessor(key) if entry != nil { return entry } bundle = yfast.xfast.Predecessor(bundleKey - 1) if bundle == nil { return nil } ew = bundle.(*entriesWrapper) entry, _ = ew.entries.predecessor(key) if entry == nil { return nil } return entry }]} {Id:14 FileId:162 StartLine:242 StartColumn:1 EndLine:249 EndColumn:2 Name:Predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc000993840 Body:{
	entry := yfast.predecessor(key)
	if entry == nil {
		return nil
	}

	return entry
} PrettyPrintBody:[{ entry := yfast.predecessor(key) if entry == nil { return nil } return entry }]} {Id:15 FileId:162 StartLine:251 StartColumn:1 EndLine:265 EndColumn:2 Name:iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc001602d20 Body:{
	xfastIter := yfast.xfast.Iter(key)
	xfastIter.Next()
	bundle := xfastIter.Value()
	if bundle == nil {
		return nilIterator()
	}

	i := bundle.(*entriesWrapper).entries.search(key)
	return &Iterator{
		index:		i - 1,
		xfastIterator:	xfastIter,
		entries:	bundle.(*entriesWrapper),
	}
} PrettyPrintBody:[{ xfastIter := yfast.xfast.Iter(key) xfastIter.Next() bundle := xfastIter.Value() if bundle == nil { return nilIterator() } i := bundle.(*entriesWrapper).entries.search(key) return &Iterator{ index:		i - 1, xfastIterator:	xfastIter, entries:	bundle.(*entriesWrapper), } }]} {Id:16 FileId:162 StartLine:270 StartColumn:1 EndLine:272 EndColumn:2 Name:Iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc001033fe0 Body:{
	return yfast.iter(key)
} PrettyPrintBody:[{ return yfast.iter(key) }]} {Id:17 FileId:162 StartLine:278 StartColumn:1 EndLine:282 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*YFastTrie}] Receiver:<nil> Body:{
	yfast := &YFastTrie{}
	yfast.init(ifc)
	return yfast
} PrettyPrintBody:[{ yfast := &YFastTrie{} yfast.init(ifc) return yfast }]} {Id:1 FileId:124 StartLine:25 StartColumn:1 EndLine:33 EndColumn:2 Name:TestAddDuplicateItem Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Add(`test`)

	if !reflect.DeepEqual([]interface{}{`test`}, set.Flatten()) {
		t.Errorf(`Incorrect result returned: %+v`, set.Flatten())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Add(`test`) if !reflect.DeepEqual([]interface{}{`test`}, set.Flatten()) { t.Errorf(`Incorrect result returned: %+v`, set.Flatten()) } }]} {Id:2 FileId:124 StartLine:35 StartColumn:1 EndLine:54 EndColumn:2 Name:TestAddItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Add(`test1`)

	firstSeen := false
	secondSeen := false

	for _, item := range set.Flatten() {
		if item.(string) == `test` {
			firstSeen = true
		} else if item.(string) == `test1` {
			secondSeen = true
		}
	}

	if !firstSeen || !secondSeen {
		t.Errorf(`Not all items seen in set.`)
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Add(`test1`) firstSeen := false secondSeen := false for _, item := range set.Flatten() { if item.(string) == `test` { firstSeen = true } else if item.(string) == `test1` { secondSeen = true } } if !firstSeen || !secondSeen { t.Errorf(`Not all items seen in set.`) } }]} {Id:3 FileId:124 StartLine:56 StartColumn:1 EndLine:64 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)
	set.Remove(`test`)

	if !reflect.DeepEqual([]interface{}{}, set.Flatten()) {
		t.Errorf(`Incorrect result returned: %+v`, set.Flatten())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Remove(`test`) if !reflect.DeepEqual([]interface{}{}, set.Flatten()) { t.Errorf(`Incorrect result returned: %+v`, set.Flatten()) } }]} {Id:4 FileId:124 StartLine:66 StartColumn:1 EndLine:77 EndColumn:2 Name:TestExists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	if !set.Exists(`test`) {
		t.Errorf(`Correct existence not determined`)
	}

	if set.Exists(`test1`) {
		t.Errorf(`Correct nonexistence not determined.`)
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) if !set.Exists(`test`) { t.Errorf(`Correct existence not determined`) } if set.Exists(`test1`) { t.Errorf(`Correct nonexistence not determined.`) } }]} {Id:5 FileId:124 StartLine:79 StartColumn:1 EndLine:93 EndColumn:2 Name:TestExists_WithNewItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New(`test`, `test1`)

	if !set.Exists(`test`) {
		t.Errorf(`Correct existence not determined`)
	}

	if !set.Exists(`test1`) {
		t.Errorf(`Correct existence not determined`)
	}

	if set.Exists(`test2`) {
		t.Errorf(`Correct nonexistence not determined.`)
	}
} PrettyPrintBody:[{ set := New(`test`, `test1`) if !set.Exists(`test`) { t.Errorf(`Correct existence not determined`) } if !set.Exists(`test1`) { t.Errorf(`Correct existence not determined`) } if set.Exists(`test2`) { t.Errorf(`Correct nonexistence not determined.`) } }]} {Id:6 FileId:124 StartLine:95 StartColumn:1 EndLine:107 EndColumn:2 Name:TestLen Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	if set.Len() != 1 {
		t.Errorf(`Expected len: %d, received: %d`, 1, set.Len())
	}

	set.Add(`test1`)
	if set.Len() != 2 {
		t.Errorf(`Expected len: %d, received: %d`, 2, set.Len())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) if set.Len() != 1 { t.Errorf(`Expected len: %d, received: %d`, 1, set.Len()) } set.Add(`test1`) if set.Len() != 2 { t.Errorf(`Expected len: %d, received: %d`, 2, set.Len()) } }]} {Id:7 FileId:124 StartLine:109 StartColumn:1 EndLine:119 EndColumn:2 Name:TestFlattenCaches Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	set.Flatten()

	if len(set.flattened) != 1 {
		t.Errorf(`Expected len: %d, received: %d`, 1, len(set.flattened))
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() if len(set.flattened) != 1 { t.Errorf(`Expected len: %d, received: %d`, 1, len(set.flattened)) } }]} {Id:8 FileId:124 StartLine:121 StartColumn:1 EndLine:132 EndColumn:2 Name:TestFlattenCaches_CacheReturn Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	flatten1 := set.Flatten()
	flatten2 := set.Flatten()

	if !reflect.DeepEqual(flatten1, flatten2) {
		t.Errorf(`Flatten cache is not the same as original result. Got %+v, expected %+v`, flatten2, flatten1)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) flatten1 := set.Flatten() flatten2 := set.Flatten() if !reflect.DeepEqual(flatten1, flatten2) { t.Errorf(`Flatten cache is not the same as original result. Got %+v, expected %+v`, flatten2, flatten1) } }]} {Id:9 FileId:124 StartLine:134 StartColumn:1 EndLine:152 EndColumn:2 Name:TestAddClearsCache Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)
	set.Flatten()

	set.Add(item)

	if len(set.flattened) != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, len(set.flattened))
	}

	item = `test2`
	set.Add(item)

	if set.flattened != nil {
		t.Errorf(`Cache not cleared.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() set.Add(item) if len(set.flattened) != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, len(set.flattened)) } item = `test2` set.Add(item) if set.flattened != nil { t.Errorf(`Cache not cleared.`) } }]} {Id:10 FileId:124 StartLine:154 StartColumn:1 EndLine:165 EndColumn:2 Name:TestDeleteClearsCache Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)
	set.Flatten()

	set.Remove(item)

	if set.flattened != nil {
		t.Errorf(`Cache not cleared.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) set.Flatten() set.Remove(item) if set.flattened != nil { t.Errorf(`Cache not cleared.`) } }]} {Id:11 FileId:124 StartLine:167 StartColumn:1 EndLine:183 EndColumn:2 Name:TestAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	item := `test`
	set.Add(item)

	result := set.All(item)
	if !result {
		t.Errorf(`Expected true.`)
	}

	itemTwo := `test1`

	result = set.All(item, itemTwo)
	if result {
		t.Errorf(`Expected false.`)
	}
} PrettyPrintBody:[{ set := New() item := `test` set.Add(item) result := set.All(item) if !result { t.Errorf(`Expected true.`) } itemTwo := `test1` result = set.All(item, itemTwo) if result { t.Errorf(`Expected false.`) } }]} {Id:12 FileId:124 StartLine:185 StartColumn:1 EndLine:194 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(`test`)

	set.Clear()

	if set.Len() != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, set.Len())
	}
} PrettyPrintBody:[{ set := New() set.Add(`test`) set.Clear() if set.Len() != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, set.Len()) } }]} {Id:13 FileId:124 StartLine:196 StartColumn:1 EndLine:207 EndColumn:2 Name:BenchmarkFlatten Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < 50; i++ {
		item := strconv.Itoa(i)
		set.Add(item)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Flatten()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < 50; i++ { item := strconv.Itoa(i) set.Add(item) } b.ResetTimer() for i := 0; i < b.N; i++ { set.Flatten() } }]} {Id:14 FileId:124 StartLine:209 StartColumn:1 EndLine:220 EndColumn:2 Name:BenchmarkLen Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < 50; i++ {
		item := strconv.Itoa(i)
		set.Add(item)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Len()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < 50; i++ { item := strconv.Itoa(i) set.Add(item) } b.ResetTimer() for i := 0; i < b.N; i++ { set.Len() } }]} {Id:15 FileId:124 StartLine:222 StartColumn:1 EndLine:230 EndColumn:2 Name:BenchmarkExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	set.Add(1)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		set.Exists(1)
	}
} PrettyPrintBody:[{ set := New() set.Add(1) b.ResetTimer() for i := 0; i < b.N; i++ { set.Exists(1) } }]} {Id:16 FileId:124 StartLine:232 StartColumn:1 EndLine:237 EndColumn:2 Name:BenchmarkClear Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	set := New()
	for i := 0; i < b.N; i++ {
		set.Clear()
	}
} PrettyPrintBody:[{ set := New() for i := 0; i < b.N; i++ { set.Clear() } }]} {Id:1 FileId:33 StartLine:24 StartColumn:1 EndLine:36 EndColumn:2 Name:search Params:[{Name:parent Type:*node} {Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:<nil> Body:{
	parent = getParent(parent, nil, key)
	parent.lock.RLock()
	parent = moveRight(parent, key, false)
	defer parent.lock.RUnlock()

	i := parent.search(key)
	if i == len(parent.keys) {
		return nil
	}

	return parent.keys[i]
} PrettyPrintBody:[{ parent = getParent(parent, nil, key) parent.lock.RLock() parent = moveRight(parent, key, false) defer parent.lock.RUnlock() i := parent.search(key) if i == len(parent.keys) { return nil } return parent.keys[i] }]} {Id:2 FileId:33 StartLine:38 StartColumn:1 EndLine:53 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:stack Type:*nodes} {Name:key Type:Key}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		parent.lock.RLock()
		parent = moveRight(parent, key, false)
		n = parent.searchNode(key)
		if stack != nil {
			stack.push(parent)
		}

		parent.lock.RUnlock()
		parent = n
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { parent.lock.RLock() parent = moveRight(parent, key, false) n = parent.searchNode(key) if stack != nil { stack.push(parent) } parent.lock.RUnlock() parent = n } return parent }]} {Id:3 FileId:33 StartLine:55 StartColumn:1 EndLine:75 EndColumn:2 Name:insert Params:[{Name:tree Type:*blink} {Name:parent Type:*node} {Name:stack Type:*nodes} {Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:<nil> Body:{
	parent = getParent(parent, stack, key)

	parent.lock.Lock()
	parent = moveRight(parent, key, true)

	result := parent.insert(key)
	if result != nil {
		parent.lock.Unlock()
		return result
	}

	if !parent.needsSplit() {
		parent.lock.Unlock()
		return nil
	}

	split(tree, parent, stack)

	return nil
} PrettyPrintBody:[{ parent = getParent(parent, stack, key) parent.lock.Lock() parent = moveRight(parent, key, true) result := parent.insert(key) if result != nil { parent.lock.Unlock() return result } if !parent.needsSplit() { parent.lock.Unlock() return nil } split(tree, parent, stack) return nil }]} {Id:4 FileId:33 StartLine:77 StartColumn:1 EndLine:114 EndColumn:2 Name:split Params:[{Name:tree Type:*blink} {Name:n Type:*node} {Name:stack Type:*nodes}] Results:[] Receiver:<nil> Body:{
	var l, r *node
	var k Key
	var parent *node
	for n.needsSplit() {
		k, l, r = n.split()
		parent = stack.pop()
		if parent == nil {
			tree.lock.Lock()
			if tree.root == nil || tree.root == n {
				parent = newNode(false, make(Keys, 0, tree.ary), make(nodes, 0, tree.ary+1))
				parent.maxSeen = r.max()
				parent.keys.insert(k)
				parent.nodes.push(l)
				parent.nodes.push(r)
				tree.root = parent
				n.lock.Unlock()
				tree.lock.Unlock()
				return
			}

			parent = tree.root
			tree.lock.Unlock()
		}

		parent.lock.Lock()
		parent = moveRight(parent, r.key(), true)
		i := parent.search(k)
		parent.keys.insertAt(k, i)
		parent.nodes[i] = l
		parent.nodes.insertAt(r, i+1)

		n.lock.Unlock()
		n = parent
	}

	n.lock.Unlock()
} PrettyPrintBody:[{ var l, r *node var k Key var parent *node for n.needsSplit() { k, l, r = n.split() parent = stack.pop() if parent == nil { tree.lock.Lock() if tree.root == nil || tree.root == n { parent = newNode(false, make(Keys, 0, tree.ary), make(nodes, 0, tree.ary+1)) parent.maxSeen = r.max() parent.keys.insert(k) parent.nodes.push(l) parent.nodes.push(r) tree.root = parent n.lock.Unlock() tree.lock.Unlock() return } parent = tree.root tree.lock.Unlock() } parent.lock.Lock() parent = moveRight(parent, r.key(), true) i := parent.search(k) parent.keys.insertAt(k, i) parent.nodes[i] = l parent.nodes.insertAt(r, i+1) n.lock.Unlock() n = parent } n.lock.Unlock() }]} {Id:5 FileId:33 StartLine:116 StartColumn:1 EndLine:137 EndColumn:2 Name:moveRight Params:[{Name:n Type:*node} {Name:key Type:Key} {Name:getLock Type:bool}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var right *node
	for {
		if len(n.keys) == 0 || n.right == nil {
			return n
		}
		if key.Compare(n.max()) < 1 {
			return n
		}

		if getLock {
			n.right.lock.Lock()
			right = n.right
			n.lock.Unlock()
		} else {
			n.right.lock.RLock()
			right = n.right
			n.lock.RUnlock()
		}
		n = right
	}
} PrettyPrintBody:[{ var right *node for { if len(n.keys) == 0 || n.right == nil { return n } if key.Compare(n.max()) < 1 { return n } if getLock { n.right.lock.Lock() right = n.right n.lock.Unlock() } else { n.right.lock.RLock() right = n.right n.lock.RUnlock() } n = right } }]} {Id:7 FileId:33 StartLine:141 StartColumn:1 EndLine:147 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001602580 Body:{
	for i := range *ns {
		(*ns)[i] = nil
	}

	*ns = (*ns)[:0]
} PrettyPrintBody:[{ for i := range *ns { (*ns)[i] = nil } *ns = (*ns)[:0] }]} {Id:8 FileId:33 StartLine:149 StartColumn:1 EndLine:151 EndColumn:2 Name:push Params:[{Name:n Type:*node}] Results:[] Receiver:0xc0010337c0 Body:{
	*ns = append(*ns, n)
} PrettyPrintBody:[{ *ns = append(*ns, n) }]} {Id:9 FileId:33 StartLine:153 StartColumn:1 EndLine:162 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:*node}] Receiver:0xc001033800 Body:{
	if len(*ns) == 0 {
		return nil
	}

	n := (*ns)[len(*ns)-1]
	(*ns)[len(*ns)-1] = nil
	*ns = (*ns)[:len(*ns)-1]
	return n
} PrettyPrintBody:[{ if len(*ns) == 0 { return nil } n := (*ns)[len(*ns)-1] (*ns)[len(*ns)-1] = nil *ns = (*ns)[:len(*ns)-1] return n }]} {Id:10 FileId:33 StartLine:164 StartColumn:1 EndLine:173 EndColumn:2 Name:insertAt Params:[{Name:n Type:*node} {Name:i Type:int}] Results:[] Receiver:0xc000a22080 Body:{
	if i == len(*ns) {
		*ns = append(*ns, n)
		return
	}

	*ns = append(*ns, nil)
	copy((*ns)[i+1:], (*ns)[i:])
	(*ns)[i] = n
} PrettyPrintBody:[{ if i == len(*ns) { *ns = append(*ns, n) return } *ns = append(*ns, nil) copy((*ns)[i+1:], (*ns)[i:]) (*ns)[i] = n }]} {Id:11 FileId:33 StartLine:175 StartColumn:1 EndLine:184 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:nodes} {Name: Type:nodes}] Receiver:0xc001033a40 Body:{
	length := len(*ns) - i
	right := make(nodes, length, cap(*ns))
	copy(right, (*ns)[i+1:])
	for j := i + 1; j < len(*ns); j++ {
		(*ns)[j] = nil
	}
	*ns = (*ns)[:i+1]
	return *ns, right
} PrettyPrintBody:[{ length := len(*ns) - i right := make(nodes, length, cap(*ns)) copy(right, (*ns)[i+1:]) for j := i + 1; j < len(*ns); j++ { (*ns)[j] = nil } *ns = (*ns)[:i+1] return *ns, right }]} {Id:13 FileId:33 StartLine:195 StartColumn:1 EndLine:197 EndColumn:2 Name:key Params:[] Results:[{Name: Type:Key}] Receiver:0xc0015813a0 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]} {Id:14 FileId:33 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:insert Params:[{Name:key Type:Key}] Results:[{Name: Type:Key}] Receiver:0xc001581420 Body:{
	if !n.isLeaf {
		panic(`Can't only insert key in an internal node.`)
	}

	overwritten := n.keys.insert(key)
	return overwritten
} PrettyPrintBody:[{ if !n.isLeaf { panic(`Can't only insert key in an internal node.`) } overwritten := n.keys.insert(key) return overwritten }]} {Id:15 FileId:33 StartLine:208 StartColumn:1 EndLine:213 EndColumn:2 Name:insertNode Params:[{Name:other Type:*node}] Results:[] Receiver:0xc001581460 Body:{
	key := other.key()
	i := n.keys.search(key)
	n.keys.insertAt(key, i)
	n.nodes.insertAt(other, i)
} PrettyPrintBody:[{ key := other.key() i := n.keys.search(key) n.keys.insertAt(key, i) n.nodes.insertAt(other, i) }]} {Id:16 FileId:33 StartLine:215 StartColumn:1 EndLine:217 EndColumn:2 Name:needsSplit Params:[] Results:[{Name: Type:bool}] Receiver:0xc001309cc0 Body:{
	return n.keys.needsSplit()
} PrettyPrintBody:[{ return n.keys.needsSplit() }]} {Id:17 FileId:33 StartLine:219 StartColumn:1 EndLine:225 EndColumn:2 Name:max Params:[] Results:[{Name: Type:Key}] Receiver:0xc0015814c0 Body:{
	if n.isLeaf {
		return n.keys.last()
	}

	return n.maxSeen
} PrettyPrintBody:[{ if n.isLeaf { return n.keys.last() } return n.maxSeen }]} {Id:18 FileId:33 StartLine:227 StartColumn:1 EndLine:238 EndColumn:2 Name:splitLeaf Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095a540 Body:{
	i := (len(n.keys) / 2)
	key := n.keys[i]
	_, rightKeys := n.keys.splitAt(i)
	nn := &node{
		keys:	rightKeys,
		right:	n.right,
		isLeaf:	true,
	}
	n.right = nn
	return key, n, nn
} PrettyPrintBody:[{ i := (len(n.keys) / 2) key := n.keys[i] _, rightKeys := n.keys.splitAt(i) nn := &node{ keys:	rightKeys, right:	n.right, isLeaf:	true, } n.right = nn return key, n, nn }]} {Id:19 FileId:33 StartLine:240 StartColumn:1 EndLine:267 EndColumn:2 Name:splitInternal Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095a720 Body:{
	i := (len(n.keys) / 2)
	key := n.keys[i]

	rightKeys := make(Keys, len(n.keys)-1-i, cap(n.keys))
	rightNodes := make(nodes, len(rightKeys)+1, cap(n.nodes))

	copy(rightKeys, n.keys[i+1:])
	copy(rightNodes, n.nodes[i+1:])

	for j := i + 1; j < len(n.nodes); j++ {
		if j != len(n.keys) {
			n.keys[j] = nil
		}
		n.nodes[j] = nil
	}

	nn := newNode(false, rightKeys, rightNodes)
	nn.maxSeen = n.max()

	n.maxSeen = key
	n.keys = n.keys[:i]
	n.nodes = n.nodes[:i+1]
	n.right = nn

	return key, n, nn
} PrettyPrintBody:[{ i := (len(n.keys) / 2) key := n.keys[i] rightKeys := make(Keys, len(n.keys)-1-i, cap(n.keys)) rightNodes := make(nodes, len(rightKeys)+1, cap(n.nodes)) copy(rightKeys, n.keys[i+1:]) copy(rightNodes, n.nodes[i+1:]) for j := i + 1; j < len(n.nodes); j++ { if j != len(n.keys) { n.keys[j] = nil } n.nodes[j] = nil } nn := newNode(false, rightKeys, rightNodes) nn.maxSeen = n.max() n.maxSeen = key n.keys = n.keys[:i] n.nodes = n.nodes[:i+1] n.right = nn return key, n, nn }]} {Id:20 FileId:33 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc0003e5240 Body:{
	if n.isLeaf {
		return n.splitLeaf()
	}

	return n.splitInternal()
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf() } return n.splitInternal() }]} {Id:21 FileId:33 StartLine:277 StartColumn:1 EndLine:279 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000993a00 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]} {Id:22 FileId:33 StartLine:281 StartColumn:1 EndLine:285 EndColumn:2 Name:searchNode Params:[{Name:key Type:Key}] Results:[{Name: Type:*node}] Receiver:0xc000993aa0 Body:{
	i := n.search(key)

	return n.nodes[i]
} PrettyPrintBody:[{ i := n.search(key) return n.nodes[i] }]} {Id:23 FileId:33 StartLine:287 StartColumn:1 EndLine:298 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc000993d80 Body:{
	output.Printf(`NODE: %+v, %p`, n, n)
	if !n.isLeaf {
		for _, n := range n.nodes {
			if n == nil {
				output.Println(`NIL NODE`)
				continue
			}
			n.print(output)
		}
	}
} PrettyPrintBody:[{ output.Printf(`NODE: %+v, %p`, n, n) if !n.isLeaf { for _, n := range n.nodes { if n == nil { output.Println(`NIL NODE`) continue } n.print(output) } } }]} {Id:24 FileId:33 StartLine:300 StartColumn:1 EndLine:306 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:Keys} {Name:ns Type:nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]} {Id:1 FileId:18 StartLine:28 StartColumn:1 EndLine:36 EndColumn:2 Name:Marshal Params:[{Name:ba Type:BitArray}] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:<nil> Body:{
	if eba, ok := ba.(*bitArray); ok {
		return eba.Serialize()
	} else if sba, ok := ba.(*sparseBitArray); ok {
		return sba.Serialize()
	} else {
		return nil, errors.New("not a valid BitArray")
	}
} PrettyPrintBody:[{ if eba, ok := ba.(*bitArray); ok { return eba.Serialize() } else if sba, ok := ba.(*sparseBitArray); ok { return sba.Serialize() } else { return nil, errors.New("not a valid BitArray") } }]} {Id:2 FileId:18 StartLine:40 StartColumn:1 EndLine:61 EndColumn:2 Name:Unmarshal Params:[{Name:input Type:[]byte}] Results:[{Name: Type:BitArray} {Name: Type:error}] Receiver:<nil> Body:{
	if len(input) == 0 {
		return nil, errors.New("no data in input")
	}
	if input[0] == 'B' {
		ret := newBitArray(0)
		err := ret.Deserialize(input)
		if err != nil {
			return nil, err
		}
		return ret, nil
	} else if input[0] == 'S' {
		ret := newSparseBitArray()
		err := ret.Deserialize(input)
		if err != nil {
			return nil, err
		}
		return ret, nil
	} else {
		return nil, errors.New("unrecognized encoding")
	}
} PrettyPrintBody:[{ if len(input) == 0 { return nil, errors.New("no data in input") } if input[0] == 'B' { ret := newBitArray(0) err := ret.Deserialize(input) if err != nil { return nil, err } return ret, nil } else if input[0] == 'S' { ret := newSparseBitArray() err := ret.Deserialize(input) if err != nil { return nil, err } return ret, nil } else { return nil, errors.New("unrecognized encoding") } }]} {Id:3 FileId:18 StartLine:64 StartColumn:1 EndLine:96 EndColumn:2 Name:Serialize Params:[] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:0xc001226a60 Body:{
	w := new(bytes.Buffer)

	var identifier uint8 = 'S'
	err := binary.Write(w, binary.LittleEndian, identifier)
	if err != nil {
		return nil, err
	}

	blocksLen := uint64(len(ba.blocks))
	indexLen := uint64(len(ba.indices))

	err = binary.Write(w, binary.LittleEndian, blocksLen)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.blocks)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, indexLen)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.indices)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), nil
} PrettyPrintBody:[{ w := new(bytes.Buffer) var identifier uint8 = 'S' err := binary.Write(w, binary.LittleEndian, identifier) if err != nil { return nil, err } blocksLen := uint64(len(ba.blocks)) indexLen := uint64(len(ba.indices)) err = binary.Write(w, binary.LittleEndian, blocksLen) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.blocks) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, indexLen) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.indices) if err != nil { return nil, err } return w.Bytes(), nil }]} {Id:4 FileId:18 StartLine:102 StartColumn:1 EndLine:110 EndColumn:2 Name:Uint64FromBytes Params:[{Name:b Type:[]byte}] Results:[{Name: Type:uint64} {Name: Type:int}] Receiver:<nil> Body:{
	if len(b) < 8 {
		return 0, -1
	}

	val := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
	return val, 8
} PrettyPrintBody:[{ if len(b) < 8 { return 0, -1 } val := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 return val, 8 }]} {Id:5 FileId:18 StartLine:117 StartColumn:1 EndLine:157 EndColumn:2 Name:Deserialize Params:[{Name:incoming Type:[]byte}] Results:[{Name: Type:error}] Receiver:0xc001032fa0 Body:{
	var intsize = uint64(s / 8)
	var curLoc = uint64(1)

	var intsToRead uint64
	var bytesRead int
	intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
	if bytesRead < 0 {
		return errors.New("Invalid data for BitArray")
	}
	curLoc += intsize

	var nextblock uint64
	ret.blocks = make([]block, intsToRead)
	for i := uint64(0); i < intsToRead; i++ {
		nextblock, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
		if bytesRead < 0 {
			return errors.New("Invalid data for BitArray")
		}
		ret.blocks[i] = block(nextblock)
		curLoc += intsize
	}

	intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
	if bytesRead < 0 {
		return errors.New("Invalid data for BitArray")
	}
	curLoc += intsize

	var nextuint uint64
	ret.indices = make(uintSlice, intsToRead)
	for i := uint64(0); i < intsToRead; i++ {
		nextuint, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize])
		if bytesRead < 0 {
			return errors.New("Invalid data for BitArray")
		}
		ret.indices[i] = nextuint
		curLoc += intsize
	}
	return nil
} PrettyPrintBody:[{ var intsize = uint64(s / 8) var curLoc = uint64(1) var intsToRead uint64 var bytesRead int intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } curLoc += intsize var nextblock uint64 ret.blocks = make([]block, intsToRead) for i := uint64(0); i < intsToRead; i++ { nextblock, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } ret.blocks[i] = block(nextblock) curLoc += intsize } intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } curLoc += intsize var nextuint uint64 ret.indices = make(uintSlice, intsToRead) for i := uint64(0); i < intsToRead; i++ { nextuint, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]) if bytesRead < 0 { return errors.New("Invalid data for BitArray") } ret.indices[i] = nextuint curLoc += intsize } return nil }]} {Id:6 FileId:18 StartLine:160 StartColumn:1 EndLine:194 EndColumn:2 Name:Serialize Params:[] Results:[{Name: Type:[]byte} {Name: Type:error}] Receiver:0xc000a8a180 Body:{
	w := new(bytes.Buffer)

	var identifier uint8 = 'B'
	err := binary.Write(w, binary.LittleEndian, identifier)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.lowest)
	if err != nil {
		return nil, err
	}
	err = binary.Write(w, binary.LittleEndian, ba.highest)
	if err != nil {
		return nil, err
	}

	var encodedanyset uint8
	if ba.anyset {
		encodedanyset = 1
	} else {
		encodedanyset = 0
	}
	err = binary.Write(w, binary.LittleEndian, encodedanyset)
	if err != nil {
		return nil, err
	}

	err = binary.Write(w, binary.LittleEndian, ba.blocks)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), nil
} PrettyPrintBody:[{ w := new(bytes.Buffer) var identifier uint8 = 'B' err := binary.Write(w, binary.LittleEndian, identifier) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.lowest) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.highest) if err != nil { return nil, err } var encodedanyset uint8 if ba.anyset { encodedanyset = 1 } else { encodedanyset = 0 } err = binary.Write(w, binary.LittleEndian, encodedanyset) if err != nil { return nil, err } err = binary.Write(w, binary.LittleEndian, ba.blocks) if err != nil { return nil, err } return w.Bytes(), nil }]} {Id:7 FileId:18 StartLine:200 StartColumn:1 EndLine:234 EndColumn:2 Name:Deserialize Params:[{Name:incoming Type:[]byte}] Results:[{Name: Type:error}] Receiver:0xc001033e60 Body:{
	r := bytes.NewReader(incoming[1:])

	err := binary.Read(r, binary.LittleEndian, &ret.lowest)
	if err != nil {
		return err
	}

	err = binary.Read(r, binary.LittleEndian, &ret.highest)
	if err != nil {
		return err
	}

	var encodedanyset uint8
	err = binary.Read(r, binary.LittleEndian, &encodedanyset)
	if err != nil {
		return err
	}

	if encodedanyset == 1 {
		ret.anyset = true
	}

	var nextblock block
	err = binary.Read(r, binary.LittleEndian, &nextblock)
	for err == nil {
		ret.blocks = append(ret.blocks, nextblock)
		err = binary.Read(r, binary.LittleEndian, &nextblock)
	}
	if err != io.EOF {
		return err
	}
	return nil
} PrettyPrintBody:[{ r := bytes.NewReader(incoming[1:]) err := binary.Read(r, binary.LittleEndian, &ret.lowest) if err != nil { return err } err = binary.Read(r, binary.LittleEndian, &ret.highest) if err != nil { return err } var encodedanyset uint8 err = binary.Read(r, binary.LittleEndian, &encodedanyset) if err != nil { return err } if encodedanyset == 1 { ret.anyset = true } var nextblock block err = binary.Read(r, binary.LittleEndian, &nextblock) for err == nil { ret.blocks = append(ret.blocks, nextblock) err = binary.Read(r, binary.LittleEndian, &nextblock) } if err != io.EOF { return err } return nil }]} {Id:1 FileId:78 StartLine:25 StartColumn:1 EndLine:50 EndColumn:2 Name:TestV Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()
	assert.Equal(0, sgraph.V())

	sgraph.AddEdge("A", "B")
	assert.Equal(2, sgraph.V())

	sgraph.AddEdge("B", "C")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.V())
	sgraph.AddEdge("C", "A")
	assert.Equal(3, sgraph.V())

	sgraph.AddEdge("C", "C")
	assert.Equal(3, sgraph.V())
	sgraph.AddEdge("D", "D")
	assert.Equal(3, sgraph.V())
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() assert.Equal(0, sgraph.V()) sgraph.AddEdge("A", "B") assert.Equal(2, sgraph.V()) sgraph.AddEdge("B", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("C", "A") assert.Equal(3, sgraph.V()) sgraph.AddEdge("C", "C") assert.Equal(3, sgraph.V()) sgraph.AddEdge("D", "D") assert.Equal(3, sgraph.V()) }]} {Id:2 FileId:78 StartLine:52 StartColumn:1 EndLine:78 EndColumn:2 Name:TestE Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	assert.Equal(0, sgraph.E())

	sgraph.AddEdge("A", "B")
	assert.Equal(1, sgraph.E())

	sgraph.AddEdge("B", "C")
	assert.Equal(2, sgraph.E())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.E())

	sgraph.AddEdge("A", "C")
	assert.Equal(3, sgraph.E())
	sgraph.AddEdge("C", "A")
	assert.Equal(3, sgraph.E())

	sgraph.AddEdge("C", "C")
	assert.Equal(3, sgraph.E())
	sgraph.AddEdge("D", "D")
	assert.Equal(3, sgraph.E())
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() assert.Equal(0, sgraph.E()) sgraph.AddEdge("A", "B") assert.Equal(1, sgraph.E()) sgraph.AddEdge("B", "C") assert.Equal(2, sgraph.E()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("A", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("C", "A") assert.Equal(3, sgraph.E()) sgraph.AddEdge("C", "C") assert.Equal(3, sgraph.E()) sgraph.AddEdge("D", "D") assert.Equal(3, sgraph.E()) }]} {Id:3 FileId:78 StartLine:80 StartColumn:1 EndLine:144 EndColumn:2 Name:TestDegree Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	v, err := sgraph.Degree("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("A", "A")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)
	sgraph.AddEdge("B", "A")
	v, err = sgraph.Degree("A")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("B")
	assert.Equal(1, v)
	assert.Nil(err)

	sgraph.AddEdge("C", "D")
	sgraph.AddEdge("A", "C")
	sgraph.AddEdge("E", "F")
	sgraph.AddEdge("E", "G")
	sgraph.AddEdge("H", "G")

	v, err = sgraph.Degree("A")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("B")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("C")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("D")
	assert.Equal(1, v)
	assert.Nil(err)

	v, err = sgraph.Degree("E")
	assert.Equal(2, v)
	assert.Nil(err)

	v, err = sgraph.Degree("G")
	assert.Equal(2, v)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() v, err := sgraph.Degree("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "B") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("A", "A") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("A", "B") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("B", "A") v, err = sgraph.Degree("A") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("B") assert.Equal(1, v) assert.Nil(err) sgraph.AddEdge("C", "D") sgraph.AddEdge("A", "C") sgraph.AddEdge("E", "F") sgraph.AddEdge("E", "G") sgraph.AddEdge("H", "G") v, err = sgraph.Degree("A") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("B") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("C") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("D") assert.Equal(1, v) assert.Nil(err) v, err = sgraph.Degree("E") assert.Equal(2, v) assert.Nil(err) v, err = sgraph.Degree("G") assert.Equal(2, v) assert.Nil(err) }]} {Id:4 FileId:78 StartLine:146 StartColumn:1 EndLine:168 EndColumn:2 Name:TestAddEdge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	err := sgraph.AddEdge("A", "B")
	assert.Nil(err)

	err = sgraph.AddEdge("A", "B")
	assert.Error(err)

	err = sgraph.AddEdge("B", "A")
	assert.Error(err)

	err = sgraph.AddEdge("A", "A")
	assert.Error(err)

	err = sgraph.AddEdge("C", "C")
	assert.Error(err)

	err = sgraph.AddEdge("B", "C")
	assert.Nil(err)

} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() err := sgraph.AddEdge("A", "B") assert.Nil(err) err = sgraph.AddEdge("A", "B") assert.Error(err) err = sgraph.AddEdge("B", "A") assert.Error(err) err = sgraph.AddEdge("A", "A") assert.Error(err) err = sgraph.AddEdge("C", "C") assert.Error(err) err = sgraph.AddEdge("B", "C") assert.Nil(err) }]} {Id:5 FileId:78 StartLine:170 StartColumn:1 EndLine:246 EndColumn:2 Name:TestAdj Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	sgraph := NewSimpleGraph()

	v, err := sgraph.Adj("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "A")
	v, err = sgraph.Adj("A")
	assert.Zero(v)
	assert.Error(err)

	sgraph.AddEdge("A", "B")
	v, err = sgraph.Adj("A")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("B", v[0])

	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("A", v[0])

	sgraph.AddEdge("A", "B")
	sgraph.AddEdge("B", "A")
	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Equal("A", v[0])

	sgraph.AddEdge("C", "D")
	sgraph.AddEdge("A", "C")
	sgraph.AddEdge("E", "F")
	sgraph.AddEdge("E", "G")
	sgraph.AddEdge("H", "G")

	v, err = sgraph.Adj("A")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "B")
	assert.Contains(v, "C")
	assert.NotContains(v, "A")
	assert.NotContains(v, "D")

	v, err = sgraph.Adj("B")
	assert.Equal(1, len(v))
	assert.Nil(err)
	assert.Contains(v, "A")
	assert.NotContains(v, "B")
	assert.NotContains(v, "C")
	assert.NotContains(v, "D")

	v, err = sgraph.Adj("C")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "A")
	assert.Contains(v, "D")
	assert.NotContains(v, "B")
	assert.NotContains(v, "C")

	v, err = sgraph.Adj("E")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "F")
	assert.Contains(v, "G")
	assert.NotContains(v, "A")

	v, err = sgraph.Adj("G")
	assert.Equal(2, len(v))
	assert.Nil(err)
	assert.Contains(v, "E")
	assert.Contains(v, "H")
	assert.NotContains(v, "A")
} PrettyPrintBody:[{ assert := assert.New(t) sgraph := NewSimpleGraph() v, err := sgraph.Adj("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "A") v, err = sgraph.Adj("A") assert.Zero(v) assert.Error(err) sgraph.AddEdge("A", "B") v, err = sgraph.Adj("A") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("B", v[0]) v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("A", v[0]) sgraph.AddEdge("A", "B") sgraph.AddEdge("B", "A") v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Equal("A", v[0]) sgraph.AddEdge("C", "D") sgraph.AddEdge("A", "C") sgraph.AddEdge("E", "F") sgraph.AddEdge("E", "G") sgraph.AddEdge("H", "G") v, err = sgraph.Adj("A") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "B") assert.Contains(v, "C") assert.NotContains(v, "A") assert.NotContains(v, "D") v, err = sgraph.Adj("B") assert.Equal(1, len(v)) assert.Nil(err) assert.Contains(v, "A") assert.NotContains(v, "B") assert.NotContains(v, "C") assert.NotContains(v, "D") v, err = sgraph.Adj("C") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "A") assert.Contains(v, "D") assert.NotContains(v, "B") assert.NotContains(v, "C") v, err = sgraph.Adj("E") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "F") assert.Contains(v, "G") assert.NotContains(v, "A") v, err = sgraph.Adj("G") assert.Equal(2, len(v)) assert.Nil(err) assert.Contains(v, "E") assert.Contains(v, "H") assert.NotContains(v, "A") }]} {Id:2 FileId:108 StartLine:25 StartColumn:1 EndLine:30 EndColumn:2 Name:search Params:[{Name:value Type:int64}] Results:[{Name: Type:int}] Receiver:0xc001602180 Body:{
	return sort.Search(
		len(nodes),
		func(i int) bool { return nodes[i].value >= value },
	)
} PrettyPrintBody:[{ return sort.Search( len(nodes), func(i int) bool { return nodes[i].value >= value }, ) }]} {Id:3 FileId:108 StartLine:34 StartColumn:1 EndLine:52 EndColumn:2 Name:addAt Params:[{Name:i Type:int} {Name:node Type:*node}] Results:[{Name: Type:*node}] Receiver:0xc0011d6780 Body:{
	if i == len(*nodes) {
		*nodes = append(*nodes, node)
		return nil
	}

	if (*nodes)[i].value == node.value {
		overwritten := (*nodes)[i]

		(*nodes)[i] = node
		return overwritten
	}

	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
	return nil
} PrettyPrintBody:[{ if i == len(*nodes) { *nodes = append(*nodes, node) return nil } if (*nodes)[i].value == node.value { overwritten := (*nodes)[i] (*nodes)[i] = node return overwritten } *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node return nil }]} {Id:4 FileId:108 StartLine:54 StartColumn:1 EndLine:57 EndColumn:2 Name:add Params:[{Name:node Type:*node}] Results:[{Name: Type:*node}] Receiver:0xc0011d6ce0 Body:{
	i := nodes.search(node.value)
	return nodes.addAt(i, node)
} PrettyPrintBody:[{ i := nodes.search(node.value) return nodes.addAt(i, node) }]} {Id:5 FileId:108 StartLine:59 StartColumn:1 EndLine:69 EndColumn:2 Name:deleteAt Params:[{Name:i Type:int}] Results:[{Name: Type:*node}] Receiver:0xc0011d6f60 Body:{
	if i >= len(*nodes) {
		return nil
	}

	deleted := (*nodes)[i]
	copy((*nodes)[i:], (*nodes)[i+1:])
	(*nodes)[len(*nodes)-1] = nil
	*nodes = (*nodes)[:len(*nodes)-1]
	return deleted
} PrettyPrintBody:[{ if i >= len(*nodes) { return nil } deleted := (*nodes)[i] copy((*nodes)[i:], (*nodes)[i+1:]) (*nodes)[len(*nodes)-1] = nil *nodes = (*nodes)[:len(*nodes)-1] return deleted }]} {Id:6 FileId:108 StartLine:71 StartColumn:1 EndLine:79 EndColumn:2 Name:delete Params:[{Name:value Type:int64}] Results:[{Name: Type:*node}] Receiver:0xc000df65a0 Body:{
	i := nodes.search(value)

	if (*nodes)[i].value != value || i == len(*nodes) {
		return nil
	}

	return nodes.deleteAt(i)
} PrettyPrintBody:[{ i := nodes.search(value) if (*nodes)[i].value != value || i == len(*nodes) { return nil } return nodes.deleteAt(i) }]} {Id:7 FileId:108 StartLine:81 StartColumn:1 EndLine:98 EndColumn:2 Name:apply Params:[{Name:low Type:int64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc000df7060 Body:{
	index := nodes.search(low)
	if index == len(nodes) {
		return true
	}

	for ; index < len(nodes); index++ {
		if nodes[index].value > high {
			break
		}

		if !fn(nodes[index]) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ index := nodes.search(low) if index == len(nodes) { return true } for ; index < len(nodes); index++ { if nodes[index].value > high { break } if !fn(nodes[index]) { return false } } return true }]} {Id:8 FileId:108 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:get Params:[{Name:value Type:int64}] Results:[{Name: Type:*node} {Name: Type:int}] Receiver:0xc001033880 Body:{
	i := nodes.search(value)
	if i == len(nodes) {
		return nil, i
	}

	if nodes[i].value == value {
		return nodes[i], i
	}

	return nil, i
} PrettyPrintBody:[{ i := nodes.search(value) if i == len(nodes) { return nil, i } if nodes[i].value == value { return nodes[i], i } return nil, i }]} {Id:9 FileId:108 StartLine:113 StartColumn:1 EndLine:135 EndColumn:2 Name:getOrAdd Params:[{Name:entry Type:Entry} {Name:dimension Type:uint64}] Results:[{Name: Type:*node} {Name: Type:bool}] Receiver:0xc000a8a3c0 Body:{

	isLastDimension := isLastDimension(lastDimension, dimension)
	value := entry.ValueAtDimension(dimension)

	i := nodes.search(value)
	if i == len(*nodes) {
		node := newNode(value, entry, !isLastDimension)
		*nodes = append(*nodes, node)
		return node, true
	}

	if (*nodes)[i].value == value {
		return (*nodes)[i], false
	}

	node := newNode(value, entry, !isLastDimension)
	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
	return node, true
} PrettyPrintBody:[{ isLastDimension := isLastDimension(lastDimension, dimension) value := entry.ValueAtDimension(dimension) i := nodes.search(value) if i == len(*nodes) { node := newNode(value, entry, !isLastDimension) *nodes = append(*nodes, node) return node, true } if (*nodes)[i].value == value { return (*nodes)[i], false } node := newNode(value, entry, !isLastDimension) *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node return node, true }]} {Id:10 FileId:108 StartLine:137 StartColumn:1 EndLine:145 EndColumn:2 Name:flatten Params:[{Name:entries Type:*Entries}] Results:[] Receiver:0xc0015813e0 Body:{
	for _, node := range nodes {
		if node.orderedNodes != nil {
			node.orderedNodes.flatten(entries)
		} else {
			*entries = append(*entries, node.entry)
		}
	}
} PrettyPrintBody:[{ for _, node := range nodes { if node.orderedNodes != nil { node.orderedNodes.flatten(entries) } else { *entries = append(*entries, node.entry) } } }]} {Id:11 FileId:108 StartLine:147 StartColumn:1 EndLine:187 EndColumn:2 Name:insert Params:[{Name:insertDimension Type:uint64} {Name:index Type:int64} {Name:modified Type:*Entries}] Results:[] Receiver:0xc000a239a0 Body:{

	lastDimension := isLastDimension(maxDimension, dimension)

	if insertDimension == dimension {
		i := nodes.search(index)
		var toDelete []int

		for j := i; j < len(*nodes); j++ {
			(*nodes)[j].value += number
			if (*nodes)[j].value < index {
				toDelete = append(toDelete, j)
				if lastDimension {
					*deleted = append(*deleted, (*nodes)[j].entry)
				} else {
					(*nodes)[j].orderedNodes.flatten(deleted)
				}
				continue
			}
			if lastDimension {
				*modified = append(*modified, (*nodes)[j].entry)
			} else {
				(*nodes)[j].orderedNodes.flatten(modified)
			}
		}

		for i, index := range toDelete {
			nodes.deleteAt(index - i)
		}

		return
	}

	for _, node := range *nodes {
		node.orderedNodes.insert(
			insertDimension, dimension+1, maxDimension,
			index, number, modified, deleted,
		)
	}
} PrettyPrintBody:[{ lastDimension := isLastDimension(maxDimension, dimension) if insertDimension == dimension { i := nodes.search(index) var toDelete []int for j := i; j < len(*nodes); j++ { (*nodes)[j].value += number if (*nodes)[j].value < index { toDelete = append(toDelete, j) if lastDimension { *deleted = append(*deleted, (*nodes)[j].entry) } else { (*nodes)[j].orderedNodes.flatten(deleted) } continue } if lastDimension { *modified = append(*modified, (*nodes)[j].entry) } else { (*nodes)[j].orderedNodes.flatten(modified) } } for i, index := range toDelete { nodes.deleteAt(index - i) } return } for _, node := range *nodes { node.orderedNodes.insert( insertDimension, dimension+1, maxDimension, index, number, modified, deleted, ) } }]} {Id:12 FileId:108 StartLine:189 StartColumn:1 EndLine:241 EndColumn:2 Name:immutableInsert Params:[{Name:insertDimension Type:uint64} {Name:index Type:int64} {Name:modified Type:*Entries}] Results:[{Name: Type:orderedNodes}] Receiver:0xc001033cc0 Body:{

	lastDimension := isLastDimension(maxDimension, dimension)

	cp := make(orderedNodes, len(nodes))
	copy(cp, nodes)

	if insertDimension == dimension {
		i := cp.search(index)
		var toDelete []int

		for j := i; j < len(cp); j++ {
			nn := newNode(cp[j].value+number, cp[j].entry, !lastDimension)
			nn.orderedNodes = cp[j].orderedNodes
			cp[j] = nn
			if cp[j].value < index {
				toDelete = append(toDelete, j)
				if lastDimension {
					*deleted = append(*deleted, cp[j].entry)
				} else {
					cp[j].orderedNodes.flatten(deleted)
				}
				continue
			}
			if lastDimension {
				*modified = append(*modified, cp[j].entry)
			} else {
				cp[j].orderedNodes.flatten(modified)
			}
		}

		for _, index := range toDelete {
			cp.deleteAt(index)
		}

		return cp
	}

	for i := 0; i < len(cp); i++ {
		oldNode := nodes[i]
		nn := newNode(oldNode.value, oldNode.entry, !lastDimension)
		nn.orderedNodes = oldNode.orderedNodes.immutableInsert(
			insertDimension, dimension+1,
			maxDimension,
			index, number,
			modified, deleted,
		)
		cp[i] = nn
	}

	return cp
} PrettyPrintBody:[{ lastDimension := isLastDimension(maxDimension, dimension) cp := make(orderedNodes, len(nodes)) copy(cp, nodes) if insertDimension == dimension { i := cp.search(index) var toDelete []int for j := i; j < len(cp); j++ { nn := newNode(cp[j].value+number, cp[j].entry, !lastDimension) nn.orderedNodes = cp[j].orderedNodes cp[j] = nn if cp[j].value < index { toDelete = append(toDelete, j) if lastDimension { *deleted = append(*deleted, cp[j].entry) } else { cp[j].orderedNodes.flatten(deleted) } continue } if lastDimension { *modified = append(*modified, cp[j].entry) } else { cp[j].orderedNodes.flatten(modified) } } for _, index := range toDelete { cp.deleteAt(index) } return cp } for i := 0; i < len(cp); i++ { oldNode := nodes[i] nn := newNode(oldNode.value, oldNode.entry, !lastDimension) nn.orderedNodes = oldNode.orderedNodes.immutableInsert( insertDimension, dimension+1, maxDimension, index, number, modified, deleted, ) cp[i] = nn } return cp }]} {Id:2 FileId:27 StartLine:27 StartColumn:1 EndLine:29 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc000956040 Body:{
	return int64(len(u))
} PrettyPrintBody:[{ return int64(len(u)) }]} {Id:3 FileId:27 StartLine:32 StartColumn:1 EndLine:34 EndColumn:2 Name:Swap Params:[{Name:i Type:int64}] Results:[] Receiver:0xc000956080 Body:{
	u[i], u[j] = u[j], u[i]
} PrettyPrintBody:[{ u[i], u[j] = u[j], u[i] }]} {Id:4 FileId:27 StartLine:38 StartColumn:1 EndLine:40 EndColumn:2 Name:Less Params:[{Name:i Type:int64}] Results:[{Name: Type:bool}] Receiver:0xc00129ba20 Body:{
	return u[i] < u[j]
} PrettyPrintBody:[{ return u[i] < u[j] }]} {Id:5 FileId:27 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:search Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc00129ba80 Body:{
	return int64(sort.Search(len(u), func(i int) bool { return uint64(u[i]) >= x }))
} PrettyPrintBody:[{ return int64(sort.Search(len(u), func(i int) bool { return uint64(u[i]) >= x })) }]} {Id:6 FileId:27 StartLine:46 StartColumn:1 EndLine:62 EndColumn:2 Name:insert Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64} {Name: Type:bool}] Receiver:0xc000e7e480 Body:{
	i := u.search(x)

	if i == int64(len(*u)) {
		*u = append(*u, x)
		return i, true
	}

	if (*u)[i] == x {
		return i, false
	}

	*u = append(*u, 0)
	copy((*u)[i+1:], (*u)[i:])
	(*u)[i] = x
	return i, true
} PrettyPrintBody:[{ i := u.search(x) if i == int64(len(*u)) { *u = append(*u, x) return i, true } if (*u)[i] == x { return i, false } *u = append(*u, 0) copy((*u)[i+1:], (*u)[i:]) (*u)[i] = x return i, true }]} {Id:7 FileId:27 StartLine:64 StartColumn:1 EndLine:68 EndColumn:2 Name:deleteAtIndex Params:[{Name:i Type:int64}] Results:[] Receiver:0xc001033100 Body:{
	copy((*u)[i:], (*u)[i+1:])
	(*u)[len(*u)-1] = 0
	*u = (*u)[:len(*u)-1]
} PrettyPrintBody:[{ copy((*u)[i:], (*u)[i+1:]) (*u)[len(*u)-1] = 0 *u = (*u)[:len(*u)-1] }]} {Id:8 FileId:27 StartLine:70 StartColumn:1 EndLine:81 EndColumn:2 Name:get Params:[{Name:x Type:uint64}] Results:[{Name: Type:int64}] Receiver:0xc0010de920 Body:{
	i := u.search(x)
	if i == int64(len(u)) {
		return -1
	}

	if u[i] == x {
		return i
	}

	return -1
} PrettyPrintBody:[{ i := u.search(x) if i == int64(len(u)) { return -1 } if u[i] == x { return i } return -1 }]} {Id:10 FileId:27 StartLine:85 StartColumn:1 EndLine:94 EndColumn:2 Name:insert Params:[{Name:index Type:int64}] Results:[] Receiver:0xc001309d40 Body:{
	if index == int64(len(*b)) {
		*b = append(*b, block(0))
		return
	}

	*b = append(*b, block(0))
	copy((*b)[index+1:], (*b)[index:])
	(*b)[index] = block(0)
} PrettyPrintBody:[{ if index == int64(len(*b)) { *b = append(*b, block(0)) return } *b = append(*b, block(0)) copy((*b)[index+1:], (*b)[index:]) (*b)[index] = block(0) }]} {Id:11 FileId:27 StartLine:96 StartColumn:1 EndLine:100 EndColumn:2 Name:deleteAtIndex Params:[{Name:i Type:int64}] Results:[] Receiver:0xc001309d80 Body:{
	copy((*b)[i:], (*b)[i+1:])
	(*b)[len(*b)-1] = block(0)
	*b = (*b)[:len(*b)-1]
} PrettyPrintBody:[{ copy((*b)[i:], (*b)[i+1:]) (*b)[len(*b)-1] = block(0) *b = (*b)[:len(*b)-1] }]} {Id:13 FileId:27 StartLine:108 StartColumn:1 EndLine:117 EndColumn:2 Name:SetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001309ee0 Body:{
	index, position := getIndexAndRemainder(k)
	i, inserted := sba.indices.insert(index)

	if inserted {
		sba.blocks.insert(i)
	}
	sba.blocks[i] = sba.blocks[i].insert(position)
	return nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i, inserted := sba.indices.insert(index) if inserted { sba.blocks.insert(i) } sba.blocks[i] = sba.blocks[i].insert(position) return nil }]} {Id:14 FileId:27 StartLine:120 StartColumn:1 EndLine:128 EndColumn:2 Name:GetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc00026cb00 Body:{
	index, position := getIndexAndRemainder(k)
	i := sba.indices.get(index)
	if i == -1 {
		return false, nil
	}

	return sba.blocks[i].get(position), nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i := sba.indices.get(index) if i == -1 { return false, nil } return sba.blocks[i].get(position), nil }]} {Id:15 FileId:27 StartLine:132 StartColumn:1 EndLine:145 EndColumn:2 Name:ToNums Params:[] Results:[{Name: Type:[]uint64}] Receiver:0xc000992e60 Body:{
	if len(sba.indices) == 0 {
		return nil
	}

	diff := uint64(len(sba.indices)) * s
	nums := make([]uint64, 0, diff/4)

	for i, offset := range sba.indices {
		sba.blocks[i].toNums(offset*s, &nums)
	}

	return nums
} PrettyPrintBody:[{ if len(sba.indices) == 0 { return nil } diff := uint64(len(sba.indices)) * s nums := make([]uint64, 0, diff/4) for i, offset := range sba.indices { sba.blocks[i].toNums(offset*s, &nums) } return nums }]} {Id:16 FileId:27 StartLine:148 StartColumn:1 EndLine:162 EndColumn:2 Name:ClearBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001033d20 Body:{
	index, position := getIndexAndRemainder(k)
	i := sba.indices.get(index)
	if i == -1 {
		return nil
	}

	sba.blocks[i] = sba.blocks[i].remove(position)
	if sba.blocks[i] == 0 {
		sba.blocks.deleteAtIndex(i)
		sba.indices.deleteAtIndex(i)
	}

	return nil
} PrettyPrintBody:[{ index, position := getIndexAndRemainder(k) i := sba.indices.get(index) if i == -1 { return nil } sba.blocks[i] = sba.blocks[i].remove(position) if sba.blocks[i] == 0 { sba.blocks.deleteAtIndex(i) sba.indices.deleteAtIndex(i) } return nil }]} {Id:17 FileId:27 StartLine:165 StartColumn:1 EndLine:168 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0003e5340 Body:{
	sba.blocks = sba.blocks[:0]
	sba.indices = sba.indices[:0]
} PrettyPrintBody:[{ sba.blocks = sba.blocks[:0] sba.indices = sba.indices[:0] }]} {Id:18 FileId:27 StartLine:171 StartColumn:1 EndLine:173 EndColumn:2 Name:Blocks Params:[] Results:[{Name: Type:Iterator}] Receiver:0xc0003e53c0 Body:{
	return newCompressedBitArrayIterator(sba)
} PrettyPrintBody:[{ return newCompressedBitArrayIterator(sba) }]} {Id:19 FileId:27 StartLine:177 StartColumn:1 EndLine:183 EndColumn:2 Name:Capacity Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0003e5400 Body:{
	if len(sba.indices) == 0 {
		return 0
	}

	return (sba.indices[len(sba.indices)-1] + 1) * s
} PrettyPrintBody:[{ if len(sba.indices) == 0 { return 0 } return (sba.indices[len(sba.indices)-1] + 1) * s }]} {Id:20 FileId:27 StartLine:187 StartColumn:1 EndLine:226 EndColumn:2 Name:Equals Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc000993b00 Body:{
	if other.Capacity() == 0 && sba.Capacity() > 0 {
		return false
	}

	var selfIndex uint64
	for iter := other.Blocks(); iter.Next(); {
		otherIndex, otherBlock := iter.Value()
		if len(sba.indices) == 0 {
			if otherBlock > 0 {
				return false
			}

			continue
		}

		if selfIndex >= uint64(len(sba.indices)) {
			return false
		}

		if otherIndex < sba.indices[selfIndex] {
			if otherBlock > 0 {
				return false
			}
			continue
		}

		if otherIndex > sba.indices[selfIndex] {
			return false
		}

		if !sba.blocks[selfIndex].equals(otherBlock) {
			return false
		}

		selfIndex++
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 && sba.Capacity() > 0 { return false } var selfIndex uint64 for iter := other.Blocks(); iter.Next(); { otherIndex, otherBlock := iter.Value() if len(sba.indices) == 0 { if otherBlock > 0 { return false } continue } if selfIndex >= uint64(len(sba.indices)) { return false } if otherIndex < sba.indices[selfIndex] { if otherBlock > 0 { return false } continue } if otherIndex > sba.indices[selfIndex] { return false } if !sba.blocks[selfIndex].equals(otherBlock) { return false } selfIndex++ } return true }]} {Id:21 FileId:27 StartLine:230 StartColumn:1 EndLine:236 EndColumn:2 Name:Or Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc001602f40 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return orSparseWithSparseBitArray(sba, ba)
	}

	return orSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return orSparseWithSparseBitArray(sba, ba) } return orSparseWithDenseBitArray(sba, other.(*bitArray)) }]} {Id:22 FileId:27 StartLine:240 StartColumn:1 EndLine:246 EndColumn:2 Name:And Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc0003e5500 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return andSparseWithSparseBitArray(sba, ba)
	}

	return andSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return andSparseWithSparseBitArray(sba, ba) } return andSparseWithDenseBitArray(sba, other.(*bitArray)) }]} {Id:23 FileId:27 StartLine:250 StartColumn:1 EndLine:256 EndColumn:2 Name:Nand Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc001409ee0 Body:{
	if ba, ok := other.(*sparseBitArray); ok {
		return nandSparseWithSparseBitArray(sba, ba)
	}

	return nandSparseWithDenseBitArray(sba, other.(*bitArray))
} PrettyPrintBody:[{ if ba, ok := other.(*sparseBitArray); ok { return nandSparseWithSparseBitArray(sba, ba) } return nandSparseWithDenseBitArray(sba, other.(*bitArray)) }]} {Id:24 FileId:27 StartLine:258 StartColumn:1 EndLine:262 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001409f80 Body:{

	return len(sba.indices) == 0
} PrettyPrintBody:[{ return len(sba.indices) == 0 }]} {Id:25 FileId:27 StartLine:264 StartColumn:1 EndLine:273 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*sparseBitArray}] Receiver:0xc001603180 Body:{
	blocks := make(blocks, len(sba.blocks))
	copy(blocks, sba.blocks)
	indices := make(uintSlice, len(sba.indices))
	copy(indices, sba.indices)
	return &sparseBitArray{
		blocks:		blocks,
		indices:	indices,
	}
} PrettyPrintBody:[{ blocks := make(blocks, len(sba.blocks)) copy(blocks, sba.blocks) indices := make(uintSlice, len(sba.indices)) copy(indices, sba.indices) return &sparseBitArray{ blocks:		blocks, indices:	indices, } }]} {Id:26 FileId:27 StartLine:277 StartColumn:1 EndLine:310 EndColumn:2 Name:Intersects Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc00019e4a0 Body:{
	if other.Capacity() == 0 {
		return true
	}

	var selfIndex int64
	for iter := other.Blocks(); iter.Next(); {
		otherI, otherBlock := iter.Value()
		if len(sba.indices) == 0 {
			if otherBlock > 0 {
				return false
			}
			continue
		}

		i := uintSlice(sba.indices[selfIndex:]).search(otherI)

		if i == int64(len(sba.indices)) {
			return false
		}

		if sba.indices[i] != otherI {
			return false
		}

		if !sba.blocks[i].intersects(otherBlock) {
			return false
		}

		selfIndex = i
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 { return true } var selfIndex int64 for iter := other.Blocks(); iter.Next(); { otherI, otherBlock := iter.Value() if len(sba.indices) == 0 { if otherBlock > 0 { return false } continue } i := uintSlice(sba.indices[selfIndex:]).search(otherI) if i == int64(len(sba.indices)) { return false } if sba.indices[i] != otherI { return false } if !sba.blocks[i].intersects(otherBlock) { return false } selfIndex = i } return true }]} {Id:27 FileId:27 StartLine:312 StartColumn:1 EndLine:314 EndColumn:2 Name:IntersectsBetween Params:[{Name:other Type:BitArray} {Name:start Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000a8b400 Body:{
	return true
} PrettyPrintBody:[{ return true }]} {Id:28 FileId:27 StartLine:316 StartColumn:1 EndLine:318 EndColumn:2 Name:newSparseBitArray Params:[] Results:[{Name: Type:*sparseBitArray}] Receiver:<nil> Body:{
	return &sparseBitArray{}
} PrettyPrintBody:[{ return &sparseBitArray{} }]} {Id:29 FileId:27 StartLine:322 StartColumn:1 EndLine:324 EndColumn:2 Name:NewSparseBitArray Params:[] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	return newSparseBitArray()
} PrettyPrintBody:[{ return newSparseBitArray() }]} {Id:1 FileId:47 StartLine:26 StartColumn:1 EndLine:86 EndColumn:2 Name:Apply Params:[{Name:fn Type:func(item *Item)} {Name:keys Type:...interface{}}] Results:[{Name: Type:error}] Receiver:0xc000879a80 Body:{
	if t.Root == nil || len(keys) == 0 {
		return nil
	}

	positions := make(map[interface{}]int, len(keys))
	for i, key := range keys {
		positions[key] = i
	}

	chunks := splitValues(keys, runtime.NumCPU())
	var wg sync.WaitGroup
	wg.Add(len(chunks))
	lerr := terr.New()
	result := make(Keys, len(keys))

	for i := 0; i < len(chunks); i++ {
		go func(i int) {
			defer wg.Done()

			chunk := chunks[i]
			if len(chunk) == 0 {
				return
			}

			for _, value := range chunk {
				n, _, err := t.iterativeFindWithoutPath(value, t.Root)
				if err != nil {
					lerr.Set(err)
					return
				}

				if n == nil {
					continue
				}

				k, _ := n.searchKey(t.config.Comparator, value)
				if k != nil && t.config.Comparator(k.Value, value) == 0 {
					result[positions[value]] = k
				}
			}
		}(i)
	}

	wg.Wait()

	if lerr.Get() != nil {
		return lerr.Get()
	}

	for _, k := range result {
		if k == nil {
			continue
		}

		item := k.ToItem()
		fn(item)
	}

	return nil
} PrettyPrintBody:[{ if t.Root == nil || len(keys) == 0 { return nil } positions := make(map[interface{}]int, len(keys)) for i, key := range keys { positions[key] = i } chunks := splitValues(keys, runtime.NumCPU()) var wg sync.WaitGroup wg.Add(len(chunks)) lerr := terr.New() result := make(Keys, len(keys)) for i := 0; i < len(chunks); i++ { go func(i int) { defer wg.Done() chunk := chunks[i] if len(chunk) == 0 { return } for _, value := range chunk { n, _, err := t.iterativeFindWithoutPath(value, t.Root) if err != nil { lerr.Set(err) return } if n == nil { continue } k, _ := n.searchKey(t.config.Comparator, value) if k != nil && t.config.Comparator(k.Value, value) == 0 { result[positions[value]] = k } } }(i) } wg.Wait() if lerr.Get() != nil { return lerr.Get() } for _, k := range result { if k == nil { continue } item := k.ToItem() fn(item) } return nil }]} {Id:2 FileId:47 StartLine:92 StartColumn:1 EndLine:101 EndColumn:2 Name:filter Params:[{Name:start Type:interface{}} {Name:n Type:*Node} {Name:fn Type:func(key *Key) bool}] Results:[{Name: Type:bool}] Receiver:0xc001033460 Body:{
	for iter := n.iter(t.config.Comparator, start, stop); iter.next(); {
		id, _ := iter.value()
		if !fn(id) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for iter := n.iter(t.config.Comparator, start, stop); iter.next(); { id, _ := iter.value() if !fn(id) { return false } } return true }]} {Id:3 FileId:47 StartLine:103 StartColumn:1 EndLine:133 EndColumn:2 Name:iter Params:[{Name:start Type:interface{}} {Name:fn Type:func(*Key) bool}] Results:[{Name: Type:error}] Receiver:0xc001309a80 Body:{
	if len(t.Root) == 0 {
		return nil
	}

	cur := start
	seen := make(map[string]struct{}, 10)

	for t.config.Comparator(stop, cur) > 0 {
		n, highestValue, err := t.iterativeFindWithoutPath(cur, t.Root)
		if err != nil {
			return err
		}

		if n == nil && highestValue == nil {
			break
		} else if n != nil {
			if _, ok := seen[string(n.ID)]; ok {
				break
			}
			if !t.filter(cur, stop, n, fn) {
				break
			}
		}

		cur = n.lastValue()
		seen[string(n.ID)] = struct{}{}
	}

	return nil
} PrettyPrintBody:[{ if len(t.Root) == 0 { return nil } cur := start seen := make(map[string]struct{}, 10) for t.config.Comparator(stop, cur) > 0 { n, highestValue, err := t.iterativeFindWithoutPath(cur, t.Root) if err != nil { return err } if n == nil && highestValue == nil { break } else if n != nil { if _, ok := seen[string(n.ID)]; ok { break } if !t.filter(cur, stop, n, fn) { break } } cur = n.lastValue() seen[string(n.ID)] = struct{}{} } return nil }]} {Id:4 FileId:47 StartLine:138 StartColumn:1 EndLine:166 EndColumn:2 Name:iterativeFind Params:[{Name:value Type:interface{}} {Name:id Type:ID}] Results:[{Name: Type:*path} {Name: Type:error}] Receiver:0xc000a8a840 Body:{
	if len(id) == 0 {
		return nil, nil
	}

	path := &path{}
	var n *Node
	var err error
	var i int
	var key *Key

	for {
		n, err = t.contextOrCachedNode(id, t.mutable)
		if err != nil {
			return nil, err
		}

		key, i = n.searchKey(t.config.Comparator, value)

		pb := &pathBundle{i: i, n: n}
		path.append(pb)
		if n.IsLeaf {
			return path, nil
		}
		id = key.ID()
	}

	return path, nil
} PrettyPrintBody:[{ if len(id) == 0 { return nil, nil } path := &path{} var n *Node var err error var i int var key *Key for { n, err = t.contextOrCachedNode(id, t.mutable) if err != nil { return nil, err } key, i = n.searchKey(t.config.Comparator, value) pb := &pathBundle{i: i, n: n} path.append(pb) if n.IsLeaf { return path, nil } id = key.ID() } return path, nil }]} {Id:5 FileId:47 StartLine:168 StartColumn:1 EndLine:197 EndColumn:2 Name:iterativeFindWithoutPath Params:[{Name:value Type:interface{}} {Name:id Type:ID}] Results:[{Name: Type:*Node} {Name: Type:interface{}} {Name: Type:error}] Receiver:0xc0001e6460 Body:{
	var n *Node
	var err error
	var i int
	var key *Key
	var highestValue interface{}

	for {
		n, err = t.contextOrCachedNode(id, t.mutable)
		if err != nil {
			return nil, highestValue, err
		}

		if n.IsLeaf {
			if t.config.Comparator(n.lastValue(), value) < 0 {
				return nil, highestValue, nil
			}
			highestValue = n.lastValue()
			return n, highestValue, nil
		}

		key, i = n.searchKey(t.config.Comparator, value)
		if i < n.lenValues() {
			highestValue = n.valueAt(i)
		}
		id = key.ID()
	}

	return n, highestValue, nil
} PrettyPrintBody:[{ var n *Node var err error var i int var key *Key var highestValue interface{} for { n, err = t.contextOrCachedNode(id, t.mutable) if err != nil { return nil, highestValue, err } if n.IsLeaf { if t.config.Comparator(n.lastValue(), value) < 0 { return nil, highestValue, nil } highestValue = n.lastValue() return n, highestValue, nil } key, i = n.searchKey(t.config.Comparator, value) if i < n.lenValues() { highestValue = n.valueAt(i) } id = key.ID() } return n, highestValue, nil }]} {Id:2 FileId:48 StartLine:33 StartColumn:1 EndLine:38 EndColumn:2 Name:nodeExists Params:[{Name:id Type:ID}] Results:[{Name: Type:bool}] Receiver:0xc001032cc0 Body:{
	c.lock.RLock()
	defer c.lock.RUnlock()
	_, ok := c.seenNodes[string(id)]
	return ok
} PrettyPrintBody:[{ c.lock.RLock() defer c.lock.RUnlock() _, ok := c.seenNodes[string(id)] return ok }]} {Id:3 FileId:48 StartLine:40 StartColumn:1 EndLine:44 EndColumn:2 Name:addNode Params:[{Name:n Type:*Node}] Results:[] Receiver:0xc0016021e0 Body:{
	c.lock.Lock()
	defer c.lock.Unlock()
	c.seenNodes[string(n.ID)] = n
} PrettyPrintBody:[{ c.lock.Lock() defer c.lock.Unlock() c.seenNodes[string(n.ID)] = n }]} {Id:4 FileId:48 StartLine:46 StartColumn:1 EndLine:50 EndColumn:2 Name:getNode Params:[{Name:id Type:ID}] Results:[{Name: Type:*Node}] Receiver:0xc001309160 Body:{
	c.lock.RLock()
	defer c.lock.RUnlock()
	return c.seenNodes[string(id)]
} PrettyPrintBody:[{ c.lock.RLock() defer c.lock.RUnlock() return c.seenNodes[string(id)] }]} {Id:5 FileId:48 StartLine:52 StartColumn:1 EndLine:56 EndColumn:2 Name:newContext Params:[] Results:[{Name: Type:*context}] Receiver:<nil> Body:{
	return &context{
		seenNodes: make(map[string]*Node, 10),
	}
} PrettyPrintBody:[{ return &context{ seenNodes: make(map[string]*Node, 10), } }]} {Id:7 FileId:48 StartLine:72 StartColumn:1 EndLine:76 EndColumn:2 Name:createRoot Params:[] Results:[{Name: Type:*Node}] Receiver:0xc0010334a0 Body:{
	n := newNode()
	n.IsLeaf = true
	return n
} PrettyPrintBody:[{ n := newNode() n.IsLeaf = true return n }]} {Id:8 FileId:48 StartLine:80 StartColumn:1 EndLine:89 EndColumn:2 Name:contextOrCachedNode Params:[{Name:id Type:ID} {Name:cache Type:bool}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:0xc000f53a80 Body:{
	if t.context != nil {
		n := t.context.getNode(id)
		if n != nil {
			return n, nil
		}
	}

	return t.cacher.getNode(t, id, cache)
} PrettyPrintBody:[{ if t.context != nil { n := t.context.getNode(id) if n != nil { return n, nil } } return t.cacher.getNode(t, id, cache) }]} {Id:9 FileId:48 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:ID}] Receiver:0xc001580e00 Body:{
	return t.UUID
} PrettyPrintBody:[{ return t.UUID }]} {Id:10 FileId:48 StartLine:97 StartColumn:1 EndLine:104 EndColumn:2 Name:toBytes Params:[] Results:[{Name: Type:[]byte}] Receiver:0xc001309ae0 Body:{
	buf, err := t.MarshalMsg(nil)
	if err != nil {
		panic(`unable to encode tree`)
	}

	return buf
} PrettyPrintBody:[{ buf, err := t.MarshalMsg(nil) if err != nil { panic(`unable to encode tree`) } return buf }]} {Id:11 FileId:48 StartLine:107 StartColumn:1 EndLine:110 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc0016026c0 Body:{
	t.cacher.clear()
	t.context = nil
} PrettyPrintBody:[{ t.cacher.clear() t.context = nil }]} {Id:12 FileId:48 StartLine:114 StartColumn:1 EndLine:129 EndColumn:2 Name:commit Params:[] Results:[{Name: Type:[]*Payload}] Receiver:0xc000a22ca0 Body:{
	items := make([]*Payload, 0, len(t.context.seenNodes))
	for _, n := range t.context.seenNodes {
		n.ChildValues, n.ChildKeys = n.flatten()
		buf, err := n.MarshalMsg(nil)
		if err != nil {
			panic(`unable to encode node`)
		}

		n.ChildValues, n.ChildKeys = nil, nil
		item := &Payload{n.ID, buf}
		items = append(items, item)
	}

	return items
} PrettyPrintBody:[{ items := make([]*Payload, 0, len(t.context.seenNodes)) for _, n := range t.context.seenNodes { n.ChildValues, n.ChildKeys = n.flatten() buf, err := n.MarshalMsg(nil) if err != nil { panic(`unable to encode node`) } n.ChildValues, n.ChildKeys = nil, nil item := &Payload{n.ID, buf} items = append(items, item) } return items }]} {Id:13 FileId:48 StartLine:131 StartColumn:1 EndLine:139 EndColumn:2 Name:copyNode Params:[{Name:n Type:*Node}] Results:[{Name: Type:*Node}] Receiver:0xc00095a7a0 Body:{
	if t.context.nodeExists(n.ID) {
		return n
	}

	cp := n.copy()
	t.context.addNode(cp)
	return cp
} PrettyPrintBody:[{ if t.context.nodeExists(n.ID) { return n } cp := n.copy() t.context.addNode(cp) return cp }]} {Id:14 FileId:48 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0003e51c0 Body:{
	return t.Count
} PrettyPrintBody:[{ return t.Count }]} {Id:15 FileId:48 StartLine:145 StartColumn:1 EndLine:156 EndColumn:2 Name:AsMutable Params:[] Results:[{Name: Type:MutableTree}] Receiver:0xc0015815c0 Body:{
	return &Tr{
		Count:		t.Count,
		UUID:		newID(),
		Root:		t.Root,
		config:		t.config,
		cacher:		t.cacher,
		context:	newContext(),
		NodeWidth:	t.NodeWidth,
		mutable:	true,
	}
} PrettyPrintBody:[{ return &Tr{ Count:		t.Count, UUID:		newID(), Root:		t.Root, config:		t.config, cacher:		t.cacher, context:	newContext(), NodeWidth:	t.NodeWidth, mutable:	true, } }]} {Id:16 FileId:48 StartLine:158 StartColumn:1 EndLine:174 EndColumn:2 Name:Commit Params:[] Results:[{Name: Type:ReadableTree} {Name: Type:error}] Receiver:0xc001033f40 Body:{
	t.NodeWidth = t.config.NodeWidth
	items := make([]*Payload, 0, len(t.context.seenNodes))
	items = append(items, t.commit()...)

	items = append(items, &Payload{t.ID(), t.toBytes()})

	err := t.config.Persister.Save(items...)
	if err != nil {
		return nil, err
	}

	t.reset()
	t.context = nil
	return t, nil
} PrettyPrintBody:[{ t.NodeWidth = t.config.NodeWidth items := make([]*Payload, 0, len(t.context.seenNodes)) items = append(items, t.commit()...) items = append(items, &Payload{t.ID(), t.toBytes()}) err := t.config.Persister.Save(items...) if err != nil { return nil, err } t.reset() t.context = nil return t, nil }]} {Id:17 FileId:48 StartLine:176 StartColumn:1 EndLine:191 EndColumn:2 Name:treeFromBytes Params:[{Name:p Type:Persister} {Name:data Type:[]byte} {Name:comparator Type:Comparator}] Results:[{Name: Type:*Tr} {Name: Type:error}] Receiver:<nil> Body:{
	t := &Tr{}
	_, err := t.UnmarshalMsg(data)
	if err != nil {
		return nil, err
	}

	cfg := DefaultConfig(p, comparator)
	if t.NodeWidth > 0 {
		cfg.NodeWidth = t.NodeWidth
	}
	t.config = cfg
	t.cacher = newCacher(cfg.Persister)

	return t, nil
} PrettyPrintBody:[{ t := &Tr{} _, err := t.UnmarshalMsg(data) if err != nil { return nil, err } cfg := DefaultConfig(p, comparator) if t.NodeWidth > 0 { cfg.NodeWidth = t.NodeWidth } t.config = cfg t.cacher = newCacher(cfg.Persister) return t, nil }]} {Id:18 FileId:48 StartLine:193 StartColumn:1 EndLine:199 EndColumn:2 Name:newTree Params:[{Name:cfg Type:Config}] Results:[{Name: Type:*Tr}] Receiver:<nil> Body:{
	return &Tr{
		config:	cfg,
		UUID:	newID(),
		cacher:	newCacher(cfg.Persister),
	}
} PrettyPrintBody:[{ return &Tr{ config:	cfg, UUID:	newID(), cacher:	newCacher(cfg.Persister), } }]} {Id:19 FileId:48 StartLine:202 StartColumn:1 EndLine:204 EndColumn:2 Name:New Params:[{Name:cfg Type:Config}] Results:[{Name: Type:ReadableTree}] Receiver:<nil> Body:{
	return newTree(cfg)
} PrettyPrintBody:[{ return newTree(cfg) }]} {Id:20 FileId:48 StartLine:210 StartColumn:1 EndLine:226 EndColumn:2 Name:Load Params:[{Name:p Type:Persister} {Name:id Type:[]byte} {Name:comparator Type:Comparator}] Results:[{Name: Type:ReadableTree} {Name: Type:error}] Receiver:<nil> Body:{
	items, err := p.Load(id)
	if err != nil {
		return nil, err
	}

	if len(items) == 0 || items[0] == nil {
		return nil, ErrTreeNotFound
	}

	rt, err := treeFromBytes(p, items[0].Payload, comparator)
	if err != nil {
		return nil, err
	}

	return rt, nil
} PrettyPrintBody:[{ items, err := p.Load(id) if err != nil { return nil, err } if len(items) == 0 || items[0] == nil { return nil, ErrTreeNotFound } rt, err := treeFromBytes(p, items[0].Payload, comparator) if err != nil { return nil, err } return rt, nil }]} {Id:2 FileId:96 StartLine:63 StartColumn:1 EndLine:73 EndColumn:2 Name:get Params:[] Results:[{Name: Type:*sema}] Receiver:0xc0012ce1a0 Body:{
	if len(*w) == 0 {
		return nil
	}

	sema := (*w)[0]
	copy((*w)[0:], (*w)[1:])
	(*w)[len(*w)-1] = nil
	*w = (*w)[:len(*w)-1]
	return sema
} PrettyPrintBody:[{ if len(*w) == 0 { return nil } sema := (*w)[0] copy((*w)[0:], (*w)[1:]) (*w)[len(*w)-1] = nil *w = (*w)[:len(*w)-1] return sema }]} {Id:3 FileId:96 StartLine:75 StartColumn:1 EndLine:77 EndColumn:2 Name:put Params:[{Name:sema Type:*sema}] Results:[] Receiver:0xc00123c740 Body:{
	*w = append(*w, sema)
} PrettyPrintBody:[{ *w = append(*w, sema) }]} {Id:4 FileId:96 StartLine:79 StartColumn:1 EndLine:92 EndColumn:2 Name:remove Params:[{Name:sema Type:*sema}] Results:[] Receiver:0xc00123c920 Body:{
	if len(*w) == 0 {
		return
	}

	ws := *w
	newWs := make(waiters, 0, len(*w))
	for i := range ws {
		if ws[i] != sema {
			newWs = append(newWs, ws[i])
		}
	}
	*w = newWs
} PrettyPrintBody:[{ if len(*w) == 0 { return } ws := *w newWs := make(waiters, 0, len(*w)) for i := range ws { if ws[i] != sema { newWs = append(newWs, ws[i]) } } *w = newWs }]} {Id:6 FileId:96 StartLine:96 StartColumn:1 EndLine:111 EndColumn:2 Name:get Params:[{Name:number Type:int64}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001602500 Body:{
	returnItems := make([]interface{}, 0, number)
	index := int64(0)
	for i := int64(0); i < number; i++ {
		if i >= int64(len(*items)) {
			break
		}

		returnItems = append(returnItems, (*items)[i])
		(*items)[i] = nil
		index++
	}

	*items = (*items)[index:]
	return returnItems
} PrettyPrintBody:[{ returnItems := make([]interface{}, 0, number) index := int64(0) for i := int64(0); i < number; i++ { if i >= int64(len(*items)) { break } returnItems = append(returnItems, (*items)[i]) (*items)[i] = nil index++ } *items = (*items)[index:] return returnItems }]} {Id:7 FileId:96 StartLine:113 StartColumn:1 EndLine:121 EndColumn:2 Name:peek Params:[] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000df6ca0 Body:{
	length := len(*items)

	if length == 0 {
		return nil, false
	}

	return (*items)[0], true
} PrettyPrintBody:[{ length := len(*items) if length == 0 { return nil, false } return (*items)[0], true }]} {Id:8 FileId:96 StartLine:123 StartColumn:1 EndLine:146 EndColumn:2 Name:getUntil Params:[{Name:checker Type:func(item interface{}) bool}] Results:[{Name: Type:[]interface{}}] Receiver:0xc001409b60 Body:{
	length := len(*items)

	if len(*items) == 0 {

		return []interface{}{}
	}

	returnItems := make([]interface{}, 0, length)
	index := -1
	for i, item := range *items {
		if !checker(item) {
			break
		}

		returnItems = append(returnItems, item)
		index = i
		(*items)[i] = nil
	}

	*items = (*items)[index+1:]
	return returnItems
} PrettyPrintBody:[{ length := len(*items) if len(*items) == 0 { return []interface{}{} } returnItems := make([]interface{}, 0, length) index := -1 for i, item := range *items { if !checker(item) { break } returnItems = append(returnItems, item) index = i (*items)[i] = nil } *items = (*items)[index+1:] return returnItems }]} {Id:10 FileId:96 StartLine:153 StartColumn:1 EndLine:158 EndColumn:2 Name:newSema Params:[] Results:[{Name: Type:*sema}] Receiver:<nil> Body:{
	return &sema{
		ready:		make(chan bool, 1),
		response:	&sync.WaitGroup{},
	}
} PrettyPrintBody:[{ return &sema{ ready:		make(chan bool, 1), response:	&sync.WaitGroup{}, } }]} {Id:12 FileId:96 StartLine:170 StartColumn:1 EndLine:202 EndColumn:2 Name:Put Params:[{Name:items Type:...interface{}}] Results:[{Name: Type:error}] Receiver:0xc000a8a560 Body:{
	if len(items) == 0 {
		return nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return ErrDisposed
	}

	q.items = append(q.items, items...)
	for {
		sema := q.waiters.get()
		if sema == nil {
			break
		}
		sema.response.Add(1)
		select {
		case sema.ready <- true:
			sema.response.Wait()
		default:

		}
		if len(q.items) == 0 {
			break
		}
	}

	q.lock.Unlock()
	return nil
} PrettyPrintBody:[{ if len(items) == 0 { return nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return ErrDisposed } q.items = append(q.items, items...) for { sema := q.waiters.get() if sema == nil { break } sema.response.Add(1) select { case sema.ready <- true: sema.response.Wait() default: } if len(q.items) == 0 { break } } q.lock.Unlock() return nil }]} {Id:13 FileId:96 StartLine:208 StartColumn:1 EndLine:210 EndColumn:2 Name:Get Params:[{Name:number Type:int64}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0001e60c0 Body:{
	return q.Poll(number, 0)
} PrettyPrintBody:[{ return q.Poll(number, 0) }]} {Id:14 FileId:96 StartLine:217 StartColumn:1 EndLine:270 EndColumn:2 Name:Poll Params:[{Name:number Type:int64} {Name:timeout Type:time.Duration}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0003e4f40 Body:{
	if number < 1 {

		return []interface{}{}, nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return nil, ErrDisposed
	}

	var items []interface{}

	if len(q.items) == 0 {
		sema := newSema()
		q.waiters.put(sema)
		q.lock.Unlock()

		var timeoutC <-chan time.Time
		if timeout > 0 {
			timeoutC = time.After(timeout)
		}
		select {
		case <-sema.ready:

			if q.disposed {
				return nil, ErrDisposed
			}
			items = q.items.get(number)
			sema.response.Done()
			return items, nil
		case <-timeoutC:

			select {
			case sema.ready <- true:

				q.lock.Lock()
				q.waiters.remove(sema)
				q.lock.Unlock()
			default:

				sema.response.Done()
			}
			return nil, ErrTimeout
		}
	}

	items = q.items.get(number)
	q.lock.Unlock()
	return items, nil
} PrettyPrintBody:[{ if number < 1 { return []interface{}{}, nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return nil, ErrDisposed } var items []interface{} if len(q.items) == 0 { sema := newSema() q.waiters.put(sema) q.lock.Unlock() var timeoutC <-chan time.Time if timeout > 0 { timeoutC = time.After(timeout) } select { case <-sema.ready: if q.disposed { return nil, ErrDisposed } items = q.items.get(number) sema.response.Done() return items, nil case <-timeoutC: select { case sema.ready <- true: q.lock.Lock() q.waiters.remove(sema) q.lock.Unlock() default: sema.response.Done() } return nil, ErrTimeout } } items = q.items.get(number) q.lock.Unlock() return items, nil }]} {Id:15 FileId:96 StartLine:274 StartColumn:1 EndLine:288 EndColumn:2 Name:Peek Params:[] Results:[{Name: Type:interface{}} {Name: Type:error}] Receiver:0xc001033dc0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	if q.disposed {
		return nil, ErrDisposed
	}

	peekItem, ok := q.items.peek()
	if !ok {
		return nil, ErrEmptyQueue
	}

	return peekItem, nil
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() if q.disposed { return nil, ErrDisposed } peekItem, ok := q.items.peek() if !ok { return nil, ErrEmptyQueue } return peekItem, nil }]} {Id:16 FileId:96 StartLine:293 StartColumn:1 EndLine:308 EndColumn:2 Name:TakeUntil Params:[{Name:checker Type:func(item interface{}) bool}] Results:[{Name: Type:[]interface{}} {Name: Type:error}] Receiver:0xc0015816c0 Body:{
	if checker == nil {
		return nil, nil
	}

	q.lock.Lock()

	if q.disposed {
		q.lock.Unlock()
		return nil, ErrDisposed
	}

	result := q.items.getUntil(checker)
	q.lock.Unlock()
	return result, nil
} PrettyPrintBody:[{ if checker == nil { return nil, nil } q.lock.Lock() if q.disposed { q.lock.Unlock() return nil, ErrDisposed } result := q.items.getUntil(checker) q.lock.Unlock() return result, nil }]} {Id:17 FileId:96 StartLine:311 StartColumn:1 EndLine:316 EndColumn:2 Name:Empty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001409f20 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return len(q.items) == 0
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return len(q.items) == 0 }]} {Id:18 FileId:96 StartLine:319 StartColumn:1 EndLine:324 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int64}] Receiver:0xc000a8a9c0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return int64(len(q.items))
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return int64(len(q.items)) }]} {Id:19 FileId:96 StartLine:328 StartColumn:1 EndLine:333 EndColumn:2 Name:Disposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc000993ca0 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	return q.disposed
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() return q.disposed }]} {Id:20 FileId:96 StartLine:338 StartColumn:1 EndLine:359 EndColumn:2 Name:Dispose Params:[] Results:[{Name: Type:[]interface{}}] Receiver:0xc0001e6520 Body:{
	q.lock.Lock()
	defer q.lock.Unlock()

	q.disposed = true
	for _, waiter := range q.waiters {
		waiter.response.Add(1)
		select {
		case waiter.ready <- true:

		default:

		}
	}

	disposedItems := q.items

	q.items = nil
	q.waiters = nil

	return disposedItems
} PrettyPrintBody:[{ q.lock.Lock() defer q.lock.Unlock() q.disposed = true for _, waiter := range q.waiters { waiter.response.Add(1) select { case waiter.ready <- true: default: } } disposedItems := q.items q.items = nil q.waiters = nil return disposedItems }]} {Id:21 FileId:96 StartLine:362 StartColumn:1 EndLine:366 EndColumn:2 Name:New Params:[{Name:hint Type:int64}] Results:[{Name: Type:*Queue}] Receiver:<nil> Body:{
	return &Queue{
		items: make([]interface{}, 0, hint),
	}
} PrettyPrintBody:[{ return &Queue{ items: make([]interface{}, 0, hint), } }]} {Id:22 FileId:96 StartLine:372 StartColumn:1 EndLine:411 EndColumn:2 Name:ExecuteInParallel Params:[{Name:q Type:*Queue} {Name:fn Type:func(interface{})}] Results:[] Receiver:<nil> Body:{
	if q == nil {
		return
	}

	q.lock.Lock()

	todo, done := uint64(len(q.items)), int64(-1)

	if todo == 0 {
		return
	}

	numCPU := 1
	if runtime.NumCPU() > 1 {
		numCPU = runtime.NumCPU() - 1
	}

	var wg sync.WaitGroup
	wg.Add(numCPU)
	items := q.items

	for i := 0; i < numCPU; i++ {
		go func() {
			for {
				index := atomic.AddInt64(&done, 1)
				if index >= int64(todo) {
					wg.Done()
					break
				}

				fn(items[index])
				items[index] = 0
			}
		}()
	}
	wg.Wait()
	q.lock.Unlock()
	q.Dispose()
} PrettyPrintBody:[{ if q == nil { return } q.lock.Lock() todo, done := uint64(len(q.items)), int64(-1) if todo == 0 { return } numCPU := 1 if runtime.NumCPU() > 1 { numCPU = runtime.NumCPU() - 1 } var wg sync.WaitGroup wg.Add(numCPU) items := q.items for i := 0; i < numCPU; i++ { go func() { for { index := atomic.AddInt64(&done, 1) if index >= int64(todo) { wg.Done() break } fn(items[index]) items[index] = 0 } }() } wg.Wait() q.lock.Unlock() q.Dispose() }]} {Id:2 FileId:103 StartLine:27 StartColumn:1 EndLine:33 EndColumn:2 Name:newCache Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:[]slice.Int64Slice}] Receiver:<nil> Body:{
	cache := make([]slice.Int64Slice, 0, dimensions-1)
	for i := uint64(0); i < dimensions; i++ {
		cache = append(cache, slice.Int64Slice{})
	}
	return cache
} PrettyPrintBody:[{ cache := make([]slice.Int64Slice, 0, dimensions-1) for i := uint64(0); i < dimensions; i++ { cache = append(cache, slice.Int64Slice{}) } return cache }]} {Id:3 FileId:103 StartLine:35 StartColumn:1 EndLine:37 EndColumn:2 Name:needNextDimension Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095abc0 Body:{
	return irt.dimensions > 1
} PrettyPrintBody:[{ return irt.dimensions > 1 }]} {Id:4 FileId:103 StartLine:39 StartColumn:1 EndLine:74 EndColumn:2 Name:add Params:[{Name:nodes Type:*orderedNodes} {Name:cache Type:[]slice.Int64Slice} {Name:entry Type:Entry} {Name:added Type:*uint64}] Results:[] Receiver:0xc001602280 Body:{
	var node *node
	list := nodes

	for i := uint64(1); i <= irt.dimensions; i++ {
		if isLastDimension(irt.dimensions, i) {
			if i != 1 && !cache[i-1].Exists(node.value) {
				nodes := make(orderedNodes, len(*list))
				copy(nodes, *list)
				list = &nodes
				cache[i-1].Insert(node.value)
			}

			newNode := newNode(entry.ValueAtDimension(i), entry, false)
			overwritten := list.add(newNode)
			if overwritten == nil {
				*added++
			}
			if node != nil {
				node.orderedNodes = *list
			}
			break
		}

		if i != 1 && !cache[i-1].Exists(node.value) {
			nodes := make(orderedNodes, len(*list))
			copy(nodes, *list)
			list = &nodes
			cache[i-1].Insert(node.value)
			node.orderedNodes = *list
		}

		node, _ = list.getOrAdd(entry, i, irt.dimensions)
		list = &node.orderedNodes
	}
} PrettyPrintBody:[{ var node *node list := nodes for i := uint64(1); i <= irt.dimensions; i++ { if isLastDimension(irt.dimensions, i) { if i != 1 && !cache[i-1].Exists(node.value) { nodes := make(orderedNodes, len(*list)) copy(nodes, *list) list = &nodes cache[i-1].Insert(node.value) } newNode := newNode(entry.ValueAtDimension(i), entry, false) overwritten := list.add(newNode) if overwritten == nil { *added++ } if node != nil { node.orderedNodes = *list } break } if i != 1 && !cache[i-1].Exists(node.value) { nodes := make(orderedNodes, len(*list)) copy(nodes, *list) list = &nodes cache[i-1].Insert(node.value) node.orderedNodes = *list } node, _ = list.getOrAdd(entry, i, irt.dimensions) list = &node.orderedNodes } }]} {Id:5 FileId:103 StartLine:78 StartColumn:1 EndLine:95 EndColumn:2 Name:Add Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*immutableRangeTree}] Receiver:0xc001409a40 Body:{
	if len(entries) == 0 {
		return irt
	}

	cache := newCache(irt.dimensions)
	top := make(orderedNodes, len(irt.top))
	copy(top, irt.top)
	added := uint64(0)
	for _, entry := range entries {
		irt.add(&top, cache, entry, &added)
	}

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = top
	tree.number = irt.number + added
	return tree
} PrettyPrintBody:[{ if len(entries) == 0 { return irt } cache := newCache(irt.dimensions) top := make(orderedNodes, len(irt.top)) copy(top, irt.top) added := uint64(0) for _, entry := range entries { irt.add(&top, cache, entry, &added) } tree := newImmutableRangeTree(irt.dimensions) tree.top = top tree.number = irt.number + added return tree }]} {Id:6 FileId:103 StartLine:102 StartColumn:1 EndLine:120 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:*immutableRangeTree} {Name: Type:Entries} {Name: Type:Entries}] Receiver:0xc0010df120 Body:{

	if dimension > irt.dimensions || number == 0 {
		return irt, nil, nil
	}

	modified, deleted := make(Entries, 0, 100), make(Entries, 0, 100)

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = irt.top.immutableInsert(
		dimension, 1, irt.dimensions,
		index, number,
		&modified, &deleted,
	)
	tree.number = irt.number - uint64(len(deleted))

	return tree, modified, deleted
} PrettyPrintBody:[{ if dimension > irt.dimensions || number == 0 { return irt, nil, nil } modified, deleted := make(Entries, 0, 100), make(Entries, 0, 100) tree := newImmutableRangeTree(irt.dimensions) tree.top = irt.top.immutableInsert( dimension, 1, irt.dimensions, index, number, &modified, &deleted, ) tree.number = irt.number - uint64(len(deleted)) return tree, modified, deleted }]} {Id:8 FileId:103 StartLine:129 StartColumn:1 EndLine:142 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*immutableRangeTree}] Receiver:0xc0010339e0 Body:{
	cache := newCache(irt.dimensions)
	top := make(orderedNodes, len(irt.top))
	copy(top, irt.top)
	deleted := uint64(0)
	for _, entry := range entries {
		irt.delete(&top, cache, entry, &deleted)
	}

	tree := newImmutableRangeTree(irt.dimensions)
	tree.top = top
	tree.number = irt.number - deleted
	return tree
} PrettyPrintBody:[{ cache := newCache(irt.dimensions) top := make(orderedNodes, len(irt.top)) copy(top, irt.top) deleted := uint64(0) for _, entry := range entries { irt.delete(&top, cache, entry, &deleted) } tree := newImmutableRangeTree(irt.dimensions) tree.top = top tree.number = irt.number - deleted return tree }]} {Id:9 FileId:103 StartLine:144 StartColumn:1 EndLine:198 EndColumn:2 Name:delete Params:[{Name:top Type:*orderedNodes} {Name:cache Type:[]slice.Int64Slice} {Name:entry Type:Entry} {Name:deleted Type:*uint64}] Results:[] Receiver:0xc001581140 Body:{

	path := make([]*immutableNodeBundle, 0, 5)
	var index int
	var n *node
	var local *node
	list := top

	for i := uint64(1); i <= irt.dimensions; i++ {
		value := entry.ValueAtDimension(i)
		local, index = list.get(value)
		if local == nil {
			return
		}

		nb := &immutableNodeBundle{
			list:		list,
			index:		index,
			previousNode:	n,
		}
		path = append(path, nb)
		n = local
		list = &n.orderedNodes
	}

	*deleted++

	for i := len(path) - 1; i >= 0; i-- {
		nb := path[i]
		if nb.previousNode != nil {
			nodes := make(orderedNodes, len(*nb.list))
			copy(nodes, *nb.list)
			nb.list = &nodes
			if len(*nb.list) == 1 {
				continue
			}
			nn := newNode(
				nb.previousNode.value,
				nb.previousNode.entry,
				!isLastDimension(irt.dimensions, uint64(i)+1),
			)
			nn.orderedNodes = nodes
			path[i-1].newNode = nn
		}
	}

	for _, nb := range path {
		if nb.newNode == nil {
			nb.list.deleteAt(nb.index)
		} else {
			(*nb.list)[nb.index] = nb.newNode
		}
	}
} PrettyPrintBody:[{ path := make([]*immutableNodeBundle, 0, 5) var index int var n *node var local *node list := top for i := uint64(1); i <= irt.dimensions; i++ { value := entry.ValueAtDimension(i) local, index = list.get(value) if local == nil { return } nb := &immutableNodeBundle{ list:		list, index:		index, previousNode:	n, } path = append(path, nb) n = local list = &n.orderedNodes } *deleted++ for i := len(path) - 1; i >= 0; i-- { nb := path[i] if nb.previousNode != nil { nodes := make(orderedNodes, len(*nb.list)) copy(nodes, *nb.list) nb.list = &nodes if len(*nb.list) == 1 { continue } nn := newNode( nb.previousNode.value, nb.previousNode.entry, !isLastDimension(irt.dimensions, uint64(i)+1), ) nn.orderedNodes = nodes path[i-1].newNode = nn } } for _, nb := range path { if nb.newNode == nil { nb.list.deleteAt(nb.index) } else { (*nb.list)[nb.index] = nb.newNode } } }]} {Id:10 FileId:103 StartLine:200 StartColumn:1 EndLine:222 EndColumn:2 Name:apply Params:[{Name:list Type:orderedNodes} {Name:interval Type:Interval} {Name:dimension Type:uint64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc000a8ab40 Body:{

	low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	if isLastDimension(irt.dimensions, dimension) {
		if !list.apply(low, high, fn) {
			return false
		}
	} else {
		if !list.apply(low, high, func(n *node) bool {
			if !irt.apply(n.orderedNodes, interval, dimension+1, fn) {
				return false
			}
			return true
		}) {
			return false
		}
		return true
	}

	return true
} PrettyPrintBody:[{ low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) if isLastDimension(irt.dimensions, dimension) { if !list.apply(low, high, fn) { return false } } else { if !list.apply(low, high, func(n *node) bool { if !irt.apply(n.orderedNodes, interval, dimension+1, fn) { return false } return true }) { return false } return true } return true }]} {Id:11 FileId:103 StartLine:226 StartColumn:1 EndLine:235 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Entries}] Receiver:0xc0000ed620 Body:{
	entries := NewEntries()

	irt.apply(irt.top, interval, 1, func(n *node) bool {
		entries = append(entries, n.entry)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := NewEntries() irt.apply(irt.top, interval, 1, func(n *node) bool { entries = append(entries, n.entry) return true }) return entries }]} {Id:12 FileId:103 StartLine:237 StartColumn:1 EndLine:251 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc00095ae00 Body:{
	on := irt.top
	for i := uint64(1); i <= irt.dimensions; i++ {
		n, _ := on.get(entry.ValueAtDimension(i))
		if n == nil {
			return nil
		}
		if i == irt.dimensions {
			return n.entry
		}
		on = n.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ on := irt.top for i := uint64(1); i <= irt.dimensions; i++ { n, _ := on.get(entry.ValueAtDimension(i)) if n == nil { return nil } if i == irt.dimensions { return n.entry } on = n.orderedNodes } return nil }]} {Id:13 FileId:103 StartLine:257 StartColumn:1 EndLine:264 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0000ed740 Body:{
	result := make(Entries, 0, len(entries))
	for _, entry := range entries {
		result = append(result, irt.get(entry))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, entry := range entries { result = append(result, irt.get(entry)) } return result }]} {Id:14 FileId:103 StartLine:267 StartColumn:1 EndLine:269 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0003e55a0 Body:{
	return irt.number
} PrettyPrintBody:[{ return irt.number }]} {Id:15 FileId:103 StartLine:271 StartColumn:1 EndLine:275 EndColumn:2 Name:newImmutableRangeTree Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*immutableRangeTree}] Receiver:<nil> Body:{
	return &immutableRangeTree{
		dimensions: dimensions,
	}
} PrettyPrintBody:[{ return &immutableRangeTree{ dimensions: dimensions, } }]} {Id:3 FileId:94 StartLine:42 StartColumn:1 EndLine:44 EndColumn:2 Name:swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0012915e0 Body:{
	(*items)[i], (*items)[j] = (*items)[j], (*items)[i]
} PrettyPrintBody:[{ (*items)[i], (*items)[j] = (*items)[j], (*items)[i] }]} {Id:4 FileId:94 StartLine:46 StartColumn:1 EndLine:74 EndColumn:2 Name:pop Params:[] Results:[{Name: Type:Item}] Receiver:0xc0011dba00 Body:{
	size := len(*items)

	items.swap(size-1, 0)
	item := (*items)[size-1]
	(*items)[size-1], *items = nil, (*items)[:size-1]

	index := 0
	childL, childR := 2*index+1, 2*index+2
	for len(*items) > childL {
		child := childL
		if len(*items) > childR && (*items)[childR].Compare((*items)[childL]) < 0 {
			child = childR
		}

		if (*items)[child].Compare((*items)[index]) < 0 {
			items.swap(index, child)

			index = child
			childL, childR = 2*index+1, 2*index+2
		} else {
			break
		}
	}

	return item
} PrettyPrintBody:[{ size := len(*items) items.swap(size-1, 0) item := (*items)[size-1] (*items)[size-1], *items = nil, (*items)[:size-1] index := 0 childL, childR := 2*index+1, 2*index+2 for len(*items) > childL { child := childL if len(*items) > childR && (*items)[childR].Compare((*items)[childL]) < 0 { child = childR } if (*items)[child].Compare((*items)[index]) < 0 { items.swap(index, child) index = child childL, childR = 2*index+1, 2*index+2 } else { break } } return item }]} {Id:5 FileId:94 StartLine:76 StartColumn:1 EndLine:87 EndColumn:2 Name:get Params:[{Name:number Type:int}] Results:[{Name: Type:[]Item}] Receiver:0xc001409a80 Body:{
	returnItems := make([]Item, 0, number)
	for i := 0; i < number; i++ {
		if len(*items) == 0 {
			break
		}

		returnItems = append(returnItems, items.pop())
	}

	return returnItems
} PrettyPrintBody:[{ returnItems := make([]Item, 0, number) for i := 0; i < number; i++ { if len(*items) == 0 { break } returnItems = append(returnItems, items.pop()) } return returnItems }]} {Id:6 FileId:94 StartLine:89 StartColumn:1 EndLine:102 EndColumn:2 Name:push Params:[{Name:item Type:Item}] Results:[] Receiver:0xc000a22ae0 Body:{

	*items = append(*items, item)

	index := len(*items) - 1
	parent := int((index - 1) / 2)
	for parent >= 0 && (*items)[parent].Compare(item) > 0 {
		items.swap(index, parent)

		index = parent
		parent = int((index - 1) / 2)
	}
} PrettyPrintBody:[{ *items = append(*items, item) index := len(*items) - 1 parent := int((index - 1) / 2) for parent >= 0 && (*items)[parent].Compare(item) > 0 { items.swap(index, parent) index = parent parent = int((index - 1) / 2) } }]} {Id:8 FileId:94 StartLine:118 StartColumn:1 EndLine:154 EndColumn:2 Name:Put Params:[{Name:items Type:...Item}] Results:[{Name: Type:error}] Receiver:0xc001581320 Body:{
	if len(items) == 0 {
		return nil
	}

	pq.lock.Lock()
	defer pq.lock.Unlock()

	if pq.disposed {
		return ErrDisposed
	}

	for _, item := range items {
		if pq.allowDuplicates {
			pq.items.push(item)
		} else if _, ok := pq.itemMap[item]; !ok {
			pq.itemMap[item] = struct{}{}
			pq.items.push(item)
		}
	}

	for {
		sema := pq.waiters.get()
		if sema == nil {
			break
		}

		sema.response.Add(1)
		sema.ready <- true
		sema.response.Wait()
		if len(pq.items) == 0 {
			break
		}
	}

	return nil
} PrettyPrintBody:[{ if len(items) == 0 { return nil } pq.lock.Lock() defer pq.lock.Unlock() if pq.disposed { return ErrDisposed } for _, item := range items { if pq.allowDuplicates { pq.items.push(item) } else if _, ok := pq.itemMap[item]; !ok { pq.itemMap[item] = struct{}{} pq.items.push(item) } } for { sema := pq.waiters.get() if sema == nil { break } sema.response.Add(1) sema.ready <- true sema.response.Wait() if len(pq.items) == 0 { break } } return nil }]} {Id:9 FileId:94 StartLine:159 StartColumn:1 EndLine:203 EndColumn:2 Name:Get Params:[{Name:number Type:int}] Results:[{Name: Type:[]Item} {Name: Type:error}] Receiver:0xc001309fe0 Body:{
	if number < 1 {
		return nil, nil
	}

	pq.lock.Lock()

	if pq.disposed {
		pq.lock.Unlock()
		return nil, ErrDisposed
	}

	var items []Item

	deleteItems := func(items []Item) {
		for _, item := range items {
			delete(pq.itemMap, item)
		}
	}

	if len(pq.items) == 0 {
		sema := newSema()
		pq.waiters.put(sema)
		pq.lock.Unlock()

		<-sema.ready

		if pq.Disposed() {
			return nil, ErrDisposed
		}

		items = pq.items.get(number)
		if !pq.allowDuplicates {
			deleteItems(items)
		}
		sema.response.Done()
		return items, nil
	}

	items = pq.items.get(number)
	deleteItems(items)
	pq.lock.Unlock()
	return items, nil
} PrettyPrintBody:[{ if number < 1 { return nil, nil } pq.lock.Lock() if pq.disposed { pq.lock.Unlock() return nil, ErrDisposed } var items []Item deleteItems := func(items []Item) { for _, item := range items { delete(pq.itemMap, item) } } if len(pq.items) == 0 { sema := newSema() pq.waiters.put(sema) pq.lock.Unlock() <-sema.ready if pq.Disposed() { return nil, ErrDisposed } items = pq.items.get(number) if !pq.allowDuplicates { deleteItems(items) } sema.response.Done() return items, nil } items = pq.items.get(number) deleteItems(items) pq.lock.Unlock() return items, nil }]} {Id:10 FileId:94 StartLine:206 StartColumn:1 EndLine:213 EndColumn:2 Name:Peek Params:[] Results:[{Name: Type:Item}] Receiver:0xc00019e280 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()
	if len(pq.items) > 0 {
		return pq.items[0]
	}
	return nil
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() if len(pq.items) > 0 { return pq.items[0] } return nil }]} {Id:11 FileId:94 StartLine:217 StartColumn:1 EndLine:222 EndColumn:2 Name:Empty Params:[] Results:[{Name: Type:bool}] Receiver:0xc000a8a900 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	return len(pq.items) == 0
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() return len(pq.items) == 0 }]} {Id:12 FileId:94 StartLine:225 StartColumn:1 EndLine:230 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001602fe0 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	return len(pq.items)
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() return len(pq.items) }]} {Id:13 FileId:94 StartLine:233 StartColumn:1 EndLine:238 EndColumn:2 Name:Disposed Params:[] Results:[{Name: Type:bool}] Receiver:0xc001603000 Body:{
	pq.disposeLock.Lock()
	defer pq.disposeLock.Unlock()

	return pq.disposed
} PrettyPrintBody:[{ pq.disposeLock.Lock() defer pq.disposeLock.Unlock() return pq.disposed }]} {Id:14 FileId:94 StartLine:242 StartColumn:1 EndLine:257 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0016033a0 Body:{
	pq.lock.Lock()
	defer pq.lock.Unlock()

	pq.disposeLock.Lock()
	defer pq.disposeLock.Unlock()

	pq.disposed = true
	for _, waiter := range pq.waiters {
		waiter.response.Add(1)
		waiter.ready <- true
	}

	pq.items = nil
	pq.waiters = nil
} PrettyPrintBody:[{ pq.lock.Lock() defer pq.lock.Unlock() pq.disposeLock.Lock() defer pq.disposeLock.Unlock() pq.disposed = true for _, waiter := range pq.waiters { waiter.response.Add(1) waiter.ready <- true } pq.items = nil pq.waiters = nil }]} {Id:15 FileId:94 StartLine:260 StartColumn:1 EndLine:266 EndColumn:2 Name:NewPriorityQueue Params:[{Name:hint Type:int} {Name:allowDuplicates Type:bool}] Results:[{Name: Type:*PriorityQueue}] Receiver:<nil> Body:{
	return &PriorityQueue{
		items:			make(priorityItems, 0, hint),
		itemMap:		make(map[Item]struct{}, hint),
		allowDuplicates:	allowDuplicates,
	}
} PrettyPrintBody:[{ return &PriorityQueue{ items:			make(priorityItems, 0, hint), itemMap:		make(map[Item]struct{}, hint), allowDuplicates:	allowDuplicates, } }]} {Id:1 FileId:109 StartLine:25 StartColumn:1 EndLine:45 EndColumn:2 Name:TestOrderedAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	overwritten := nodes.add(n1)
	assert.Nil(t, overwritten)

	overwritten = nodes.add(n2)
	assert.Nil(t, overwritten)

	assert.Equal(t, orderedNodes{n2, n1}, nodes)

	n3 := newNode(4, constructMockEntry(1, 4), false)

	overwritten = nodes.add(n3)

	assert.True(t, n1 == overwritten)
	assert.Equal(t, orderedNodes{n2, n3}, nodes)
} PrettyPrintBody:[{ nodes := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) overwritten := nodes.add(n1) assert.Nil(t, overwritten) overwritten = nodes.add(n2) assert.Nil(t, overwritten) assert.Equal(t, orderedNodes{n2, n1}, nodes) n3 := newNode(4, constructMockEntry(1, 4), false) overwritten = nodes.add(n3) assert.True(t, n1 == overwritten) assert.Equal(t, orderedNodes{n2, n3}, nodes) }]} {Id:2 FileId:109 StartLine:47 StartColumn:1 EndLine:71 EndColumn:2 Name:TestOrderedDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	nodes.add(n1)
	nodes.add(n2)

	deleted := nodes.delete(n2.value)

	assert.Equal(t, orderedNodes{n1}, nodes)
	assert.Equal(t, n2, deleted)

	missingValue := int64(3)
	deleted = nodes.delete(missingValue)

	assert.Equal(t, orderedNodes{n1}, nodes)
	assert.Nil(t, deleted)

	deleted = nodes.delete(n1.value)

	assert.Empty(t, nodes)
	assert.Equal(t, n1, deleted)
} PrettyPrintBody:[{ nodes := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) nodes.add(n1) nodes.add(n2) deleted := nodes.delete(n2.value) assert.Equal(t, orderedNodes{n1}, nodes) assert.Equal(t, n2, deleted) missingValue := int64(3) deleted = nodes.delete(missingValue) assert.Equal(t, orderedNodes{n1}, nodes) assert.Nil(t, deleted) deleted = nodes.delete(n1.value) assert.Empty(t, nodes) assert.Equal(t, n1, deleted) }]} {Id:3 FileId:109 StartLine:73 StartColumn:1 EndLine:139 EndColumn:2 Name:TestApply Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ns := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)

	ns.add(n1)
	ns.add(n2)

	results := make(nodes, 0, 2)

	ns.apply(1, 1, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n2}, results)

	results = results[:0]

	ns.apply(0, 0, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(2, 3, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(4, 5, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n1}, results)
	results = results[:0]

	ns.apply(0, 5, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Equal(t, nodes{n2, n1}, results)
	results = results[:0]

	ns.apply(5, 10, func(n *node) bool {
		results = append(results, n)
		return true
	})

	assert.Len(t, results, 0)
	results = results[:0]

	ns.apply(0, 100, func(n *node) bool {
		results = append(results, n)
		return false
	})

	assert.Equal(t, nodes{n2}, results)
} PrettyPrintBody:[{ ns := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) ns.add(n1) ns.add(n2) results := make(nodes, 0, 2) ns.apply(1, 1, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n2}, results) results = results[:0] ns.apply(0, 0, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(2, 3, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(4, 5, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n1}, results) results = results[:0] ns.apply(0, 5, func(n *node) bool { results = append(results, n) return true }) assert.Equal(t, nodes{n2, n1}, results) results = results[:0] ns.apply(5, 10, func(n *node) bool { results = append(results, n) return true }) assert.Len(t, results, 0) results = results[:0] ns.apply(0, 100, func(n *node) bool { results = append(results, n) return false }) assert.Equal(t, nodes{n2}, results) }]} {Id:4 FileId:109 StartLine:141 StartColumn:1 EndLine:159 EndColumn:2 Name:TestInsertDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ns := make(orderedNodes, 0)

	n1 := newNode(4, constructMockEntry(1, 4), false)
	n2 := newNode(1, constructMockEntry(2, 1), false)
	n3 := newNode(2, constructMockEntry(3, 2), false)

	ns.add(n1)
	ns.add(n2)
	ns.add(n3)

	modified := make(Entries, 0, 1)
	deleted := make(Entries, 0, 1)

	ns.insert(2, 2, 2, 0, -5, &modified, &deleted)

	assert.Len(t, ns, 0)
	assert.Equal(t, Entries{n2.entry, n3.entry, n1.entry}, deleted)
} PrettyPrintBody:[{ ns := make(orderedNodes, 0) n1 := newNode(4, constructMockEntry(1, 4), false) n2 := newNode(1, constructMockEntry(2, 1), false) n3 := newNode(2, constructMockEntry(3, 2), false) ns.add(n1) ns.add(n2) ns.add(n3) modified := make(Entries, 0, 1) deleted := make(Entries, 0, 1) ns.insert(2, 2, 2, 0, -5, &modified, &deleted) assert.Len(t, ns, 0) assert.Equal(t, Entries{n2.entry, n3.entry, n1.entry}, deleted) }]} {Id:5 FileId:109 StartLine:161 StartColumn:1 EndLine:174 EndColumn:2 Name:BenchmarkPrepend Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	ns := make(orderedNodes, 0, numItems)

	for i := b.N; i < b.N+numItems; i++ {
		ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false))
	}
} PrettyPrintBody:[{ numItems := 100000 ns := make(orderedNodes, 0, numItems) for i := b.N; i < b.N+numItems; i++ { ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false)) } b.ResetTimer() for i := 0; i < b.N; i++ { ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false)) } }]} {Id:0 FileId:110 StartLine:18 StartColumn:1 EndLine:20 EndColumn:2 Name:isLastDimension Params:[{Name:value Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return test >= value
} PrettyPrintBody:[{ return test >= value }]} {Id:3 FileId:110 StartLine:34 StartColumn:1 EndLine:36 EndColumn:2 Name:resetPath Params:[] Results:[] Receiver:0xc000ec6060 Body:{
	ot.path = ot.path[:0]
} PrettyPrintBody:[{ ot.path = ot.path[:0] }]} {Id:4 FileId:110 StartLine:38 StartColumn:1 EndLine:40 EndColumn:2 Name:needNextDimension Params:[] Results:[{Name: Type:bool}] Receiver:0xc000e7fdc0 Body:{
	return ot.dimensions > 1
} PrettyPrintBody:[{ return ot.dimensions > 1 }]} {Id:5 FileId:110 StartLine:44 StartColumn:1 EndLine:63 EndColumn:2 Name:add Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:0xc000e7f0c0 Body:{
	var node *node
	list := &ot.top

	for i := uint64(1); i <= ot.dimensions; i++ {
		if isLastDimension(ot.dimensions, i) {
			overwritten := list.add(
				newNode(entry.ValueAtDimension(i), entry, false),
			)
			if overwritten == nil {
				ot.number++
			}
			return overwritten
		}
		node, _ = list.getOrAdd(entry, i, ot.dimensions)
		list = &node.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ var node *node list := &ot.top for i := uint64(1); i <= ot.dimensions; i++ { if isLastDimension(ot.dimensions, i) { overwritten := list.add( newNode(entry.ValueAtDimension(i), entry, false), ) if overwritten == nil { ot.number++ } return overwritten } node, _ = list.getOrAdd(entry, i, ot.dimensions) list = &node.orderedNodes } return nil }]} {Id:6 FileId:110 StartLine:70 StartColumn:1 EndLine:88 EndColumn:2 Name:Add Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0013092e0 Body:{
	if len(entries) == 0 {
		return nil
	}

	overwrittens := make(Entries, len(entries))
	for i, entry := range entries {
		if entry == nil {
			continue
		}

		overwritten := ot.add(entry)
		if overwritten != nil {
			overwrittens[i] = overwritten.entry
		}
	}

	return overwrittens
} PrettyPrintBody:[{ if len(entries) == 0 { return nil } overwrittens := make(Entries, len(entries)) for i, entry := range entries { if entry == nil { continue } overwritten := ot.add(entry) if overwritten != nil { overwrittens[i] = overwritten.entry } } return overwrittens }]} {Id:7 FileId:110 StartLine:90 StartColumn:1 EndLine:120 EndColumn:2 Name:delete Params:[{Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:0xc001409880 Body:{
	ot.resetPath()
	var index int
	var node *node
	list := &ot.top

	for i := uint64(1); i <= ot.dimensions; i++ {
		value := entry.ValueAtDimension(i)
		node, index = list.get(value)
		if node == nil {
			return nil
		}

		nb := &nodeBundle{list: list, index: index}
		ot.path = append(ot.path, nb)

		list = &node.orderedNodes
	}

	ot.number--

	for i := len(ot.path) - 1; i >= 0; i-- {
		nb := ot.path[i]
		nb.list.deleteAt(nb.index)
		if len(*nb.list) > 0 {
			break
		}
	}

	return node
} PrettyPrintBody:[{ ot.resetPath() var index int var node *node list := &ot.top for i := uint64(1); i <= ot.dimensions; i++ { value := entry.ValueAtDimension(i) node, index = list.get(value) if node == nil { return nil } nb := &nodeBundle{list: list, index: index} ot.path = append(ot.path, nb) list = &node.orderedNodes } ot.number-- for i := len(ot.path) - 1; i >= 0; i-- { nb := ot.path[i] nb.list.deleteAt(nb.index) if len(*nb.list) > 0 { break } } return node }]} {Id:8 FileId:110 StartLine:122 StartColumn:1 EndLine:136 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001309720 Body:{
	on := ot.top
	for i := uint64(1); i <= ot.dimensions; i++ {
		n, _ := on.get(entry.ValueAtDimension(i))
		if n == nil {
			return nil
		}
		if i == ot.dimensions {
			return n.entry
		}
		on = n.orderedNodes
	}

	return nil
} PrettyPrintBody:[{ on := ot.top for i := uint64(1); i <= ot.dimensions; i++ { n, _ := on.get(entry.ValueAtDimension(i)) if n == nil { return nil } if i == ot.dimensions { return n.entry } on = n.orderedNodes } return nil }]} {Id:9 FileId:110 StartLine:142 StartColumn:1 EndLine:149 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc000a8a500 Body:{
	result := make(Entries, 0, len(entries))
	for _, entry := range entries {
		result = append(result, ot.get(entry))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, entry := range entries { result = append(result, ot.get(entry)) } return result }]} {Id:10 FileId:110 StartLine:155 StartColumn:1 EndLine:173 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc0001e6280 Body:{
	if len(entries) == 0 {
		return nil
	}

	deletedEntries := make(Entries, len(entries))
	for i, entry := range entries {
		if entry == nil {
			continue
		}

		deleted := ot.delete(entry)
		if deleted != nil {
			deletedEntries[i] = deleted.entry
		}
	}

	return deletedEntries
} PrettyPrintBody:[{ if len(entries) == 0 { return nil } deletedEntries := make(Entries, len(entries)) for i, entry := range entries { if entry == nil { continue } deleted := ot.delete(entry) if deleted != nil { deletedEntries[i] = deleted.entry } } return deletedEntries }]} {Id:11 FileId:110 StartLine:176 StartColumn:1 EndLine:178 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602be0 Body:{
	return ot.number
} PrettyPrintBody:[{ return ot.number }]} {Id:12 FileId:110 StartLine:180 StartColumn:1 EndLine:202 EndColumn:2 Name:apply Params:[{Name:list Type:orderedNodes} {Name:interval Type:Interval} {Name:dimension Type:uint64} {Name:fn Type:func(*node) bool}] Results:[{Name: Type:bool}] Receiver:0xc00095a900 Body:{

	low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	if isLastDimension(ot.dimensions, dimension) {
		if !list.apply(low, high, fn) {
			return false
		}
	} else {
		if !list.apply(low, high, func(n *node) bool {
			if !ot.apply(n.orderedNodes, interval, dimension+1, fn) {
				return false
			}
			return true
		}) {
			return false
		}
		return true
	}

	return true
} PrettyPrintBody:[{ low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) if isLastDimension(ot.dimensions, dimension) { if !list.apply(low, high, fn) { return false } } else { if !list.apply(low, high, func(n *node) bool { if !ot.apply(n.orderedNodes, interval, dimension+1, fn) { return false } return true }) { return false } return true } return true }]} {Id:13 FileId:110 StartLine:208 StartColumn:1 EndLine:212 EndColumn:2 Name:Apply Params:[{Name:interval Type:Interval} {Name:fn Type:func(Entry) bool}] Results:[] Receiver:0xc001602ee0 Body:{
	ot.apply(ot.top, interval, 1, func(n *node) bool {
		return fn(n.entry)
	})
} PrettyPrintBody:[{ ot.apply(ot.top, interval, 1, func(n *node) bool { return fn(n.entry) }) }]} {Id:14 FileId:110 StartLine:216 StartColumn:1 EndLine:225 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Entries}] Receiver:0xc000a8abc0 Body:{
	entries := NewEntries()

	ot.apply(ot.top, interval, 1, func(n *node) bool {
		entries = append(entries, n.entry)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := NewEntries() ot.apply(ot.top, interval, 1, func(n *node) bool { entries = append(entries, n.entry) return true }) return entries }]} {Id:15 FileId:110 StartLine:232 StartColumn:1 EndLine:250 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:Entries} {Name: Type:Entries}] Receiver:0xc0001e65e0 Body:{

	if dimension > ot.dimensions || number == 0 {
		return nil, nil
	}

	modified := make(Entries, 0, 100)
	deleted := make(Entries, 0, 100)

	ot.top.insert(dimension, 1, ot.dimensions,
		index, number, &modified, &deleted,
	)

	ot.number -= uint64(len(deleted))

	return modified, deleted
} PrettyPrintBody:[{ if dimension > ot.dimensions || number == 0 { return nil, nil } modified := make(Entries, 0, 100) deleted := make(Entries, 0, 100) ot.top.insert(dimension, 1, ot.dimensions, index, number, &modified, &deleted, ) ot.number -= uint64(len(deleted)) return modified, deleted }]} {Id:16 FileId:110 StartLine:252 StartColumn:1 EndLine:257 EndColumn:2 Name:newOrderedTree Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*orderedTree}] Receiver:<nil> Body:{
	return &orderedTree{
		dimensions:	dimensions,
		path:		make([]*nodeBundle, 0, dimensions),
	}
} PrettyPrintBody:[{ return &orderedTree{ dimensions:	dimensions, path:		make([]*nodeBundle, 0, dimensions), } }]} {Id:17 FileId:110 StartLine:261 StartColumn:1 EndLine:263 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:RangeTree}] Receiver:<nil> Body:{
	return newOrderedTree(dimensions)
} PrettyPrintBody:[{ return newOrderedTree(dimensions) }]} {Id:4 FileId:69 StartLine:102 StartColumn:1 EndLine:104 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc001032380 Body:{
	return string(e)
} PrettyPrintBody:[{ return string(e) }]} {Id:6 FileId:69 StartLine:110 StartColumn:1 EndLine:112 EndColumn:2 Name:Error Params:[] Results:[{Name: Type:string}] Receiver:0xc001308a80 Body:{
	return string(e)
} PrettyPrintBody:[{ return string(e) }]} {Id:7 FileId:69 StartLine:115 StartColumn:1 EndLine:115 EndColumn:86 Name:NewFloatFibHeap Params:[] Results:[{Name: Type:FloatingFibonacciHeap}] Receiver:<nil> Body:{
	return FloatingFibonacciHeap{nil, 0}
} PrettyPrintBody:[{ return FloatingFibonacciHeap{nil, 0} }]} {Id:8 FileId:69 StartLine:118 StartColumn:1 EndLine:125 EndColumn:2 Name:Enqueue Params:[{Name:priority Type:float64}] Results:[{Name: Type:*Entry}] Receiver:0xc000e5ad20 Body:{
	singleton := newEntry(priority)

	heap.min = mergeLists(heap.min, singleton)
	heap.size++
	return singleton
} PrettyPrintBody:[{ singleton := newEntry(priority) heap.min = mergeLists(heap.min, singleton) heap.size++ return singleton }]} {Id:9 FileId:69 StartLine:128 StartColumn:1 EndLine:133 EndColumn:2 Name:Min Params:[] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc001239940 Body:{
	if heap.IsEmpty() {
		return nil, EmptyHeapError("Trying to get minimum element of empty heap")
	}
	return heap.min, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Trying to get minimum element of empty heap") } return heap.min, nil }]} {Id:10 FileId:69 StartLine:136 StartColumn:1 EndLine:138 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc001239bc0 Body:{
	return heap.size == 0
} PrettyPrintBody:[{ return heap.size == 0 }]} {Id:11 FileId:69 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint}] Receiver:0xc001308e60 Body:{
	return heap.size
} PrettyPrintBody:[{ return heap.size }]} {Id:12 FileId:69 StartLine:147 StartColumn:1 EndLine:247 EndColumn:2 Name:DequeueMin Params:[] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc00123db40 Body:{
	if heap.IsEmpty() {
		return nil, EmptyHeapError("Cannot dequeue minimum of empty heap")
	}

	heap.size--

	min := heap.min

	if min.next == min {
		heap.min = nil
	} else {
		heap.min.prev.next = heap.min.next
		heap.min.next.prev = heap.min.prev
		heap.min = heap.min.next
	}

	if min.child != nil {

		curr := min.child
		for ok := true; ok; ok = (curr != min.child) {
			curr.parent = nil
			curr = curr.next
		}
	}

	heap.min = mergeLists(heap.min, min.child)

	if heap.min == nil {

		return min, nil
	}

	treeSlice := make([]*Entry, 0, heap.size)
	toVisit := make([]*Entry, 0, heap.size)

	for curr := heap.min; len(toVisit) == 0 || toVisit[0] != curr; curr = curr.next {
		toVisit = append(toVisit, curr)
	}

	for _, curr := range toVisit {
		for {
			for curr.degree >= len(treeSlice) {
				treeSlice = append(treeSlice, nil)
			}

			if treeSlice[curr.degree] == nil {
				treeSlice[curr.degree] = curr
				break
			}

			other := treeSlice[curr.degree]
			treeSlice[curr.degree] = nil

			var minT, maxT *Entry
			if other.Priority < curr.Priority {
				minT = other
				maxT = curr
			} else {
				minT = curr
				maxT = other
			}

			maxT.next.prev = maxT.prev
			maxT.prev.next = maxT.next

			maxT.prev = maxT
			maxT.next = maxT
			minT.child = mergeLists(minT.child, maxT)

			maxT.parent = minT

			maxT.marked = false

			minT.degree++

			curr = minT
		}

		if curr.Priority <= heap.min.Priority {
			heap.min = curr
		}
	}

	return min, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Cannot dequeue minimum of empty heap") } heap.size-- min := heap.min if min.next == min { heap.min = nil } else { heap.min.prev.next = heap.min.next heap.min.next.prev = heap.min.prev heap.min = heap.min.next } if min.child != nil { curr := min.child for ok := true; ok; ok = (curr != min.child) { curr.parent = nil curr = curr.next } } heap.min = mergeLists(heap.min, min.child) if heap.min == nil { return min, nil } treeSlice := make([]*Entry, 0, heap.size) toVisit := make([]*Entry, 0, heap.size) for curr := heap.min; len(toVisit) == 0 || toVisit[0] != curr; curr = curr.next { toVisit = append(toVisit, curr) } for _, curr := range toVisit { for { for curr.degree >= len(treeSlice) { treeSlice = append(treeSlice, nil) } if treeSlice[curr.degree] == nil { treeSlice[curr.degree] = curr break } other := treeSlice[curr.degree] treeSlice[curr.degree] = nil var minT, maxT *Entry if other.Priority < curr.Priority { minT = other maxT = curr } else { minT = curr maxT = other } maxT.next.prev = maxT.prev maxT.prev.next = maxT.next maxT.prev = maxT maxT.next = maxT minT.child = mergeLists(minT.child, maxT) maxT.parent = minT maxT.marked = false minT.degree++ curr = minT } if curr.Priority <= heap.min.Priority { heap.min = curr } } return min, nil }]} {Id:13 FileId:69 StartLine:251 StartColumn:1 EndLine:268 EndColumn:2 Name:DecreaseKey Params:[{Name:node Type:*Entry} {Name:newPriority Type:float64}] Results:[{Name: Type:*Entry} {Name: Type:error}] Receiver:0xc0003e50a0 Body:{

	if heap.IsEmpty() {
		return nil, EmptyHeapError("Cannot decrease key in an empty heap")
	}

	if node == nil {
		return nil, NilError("Cannot decrease key: given node is nil")
	}

	if newPriority >= node.Priority {
		return nil, fmt.Errorf("The given new priority: %v, is larger than or equal to the old: %v",
			newPriority, node.Priority)
	}

	decreaseKeyUnchecked(heap, node, newPriority)
	return node, nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return nil, EmptyHeapError("Cannot decrease key in an empty heap") } if node == nil { return nil, NilError("Cannot decrease key: given node is nil") } if newPriority >= node.Priority { return nil, fmt.Errorf("The given new priority: %v, is larger than or equal to the old: %v", newPriority, node.Priority) } decreaseKeyUnchecked(heap, node, newPriority) return node, nil }]} {Id:14 FileId:69 StartLine:271 StartColumn:1 EndLine:284 EndColumn:2 Name:Delete Params:[{Name:node Type:*Entry}] Results:[{Name: Type:error}] Receiver:0xc00095aca0 Body:{

	if heap.IsEmpty() {
		return EmptyHeapError("Cannot delete element from an empty heap")
	}

	if node == nil {
		return NilError("Cannot delete node: given node is nil")
	}

	decreaseKeyUnchecked(heap, node, -math.MaxFloat64)
	heap.DequeueMin()
	return nil
} PrettyPrintBody:[{ if heap.IsEmpty() { return EmptyHeapError("Cannot delete element from an empty heap") } if node == nil { return NilError("Cannot delete node: given node is nil") } decreaseKeyUnchecked(heap, node, -math.MaxFloat64) heap.DequeueMin() return nil }]} {Id:15 FileId:69 StartLine:291 StartColumn:1 EndLine:307 EndColumn:2 Name:Merge Params:[{Name:other Type:*FloatingFibonacciHeap}] Results:[{Name: Type:FloatingFibonacciHeap} {Name: Type:error}] Receiver:0xc001033f20 Body:{

	if heap == nil || other == nil {
		return FloatingFibonacciHeap{}, NilError("One of the heaps to merge is nil. Cannot merge")
	}

	resultSize := heap.size + other.size

	resultMin := mergeLists(heap.min, other.min)

	heap.min = nil
	other.min = nil
	heap.size = 0
	other.size = 0

	return FloatingFibonacciHeap{resultMin, resultSize}, nil
} PrettyPrintBody:[{ if heap == nil || other == nil { return FloatingFibonacciHeap{}, NilError("One of the heaps to merge is nil. Cannot merge") } resultSize := heap.size + other.size resultMin := mergeLists(heap.min, other.min) heap.min = nil other.min = nil heap.size = 0 other.size = 0 return FloatingFibonacciHeap{resultMin, resultSize}, nil }]} {Id:16 FileId:69 StartLine:317 StartColumn:1 EndLine:327 EndColumn:2 Name:newEntry Params:[{Name:priority Type:float64}] Results:[{Name: Type:*Entry}] Receiver:<nil> Body:{
	result := new(Entry)
	result.degree = 0
	result.marked = false
	result.child = nil
	result.parent = nil
	result.next = result
	result.prev = result
	result.Priority = priority
	return result
} PrettyPrintBody:[{ result := new(Entry) result.degree = 0 result.marked = false result.child = nil result.parent = nil result.next = result result.prev = result result.Priority = priority return result }]} {Id:17 FileId:69 StartLine:329 StartColumn:1 EndLine:349 EndColumn:2 Name:mergeLists Params:[{Name:one Type:*Entry}] Results:[{Name: Type:*Entry}] Receiver:<nil> Body:{
	if one == nil && two == nil {
		return nil
	} else if one != nil && two == nil {
		return one
	} else if one == nil && two != nil {
		return two
	}

	oneNext := one.next
	one.next = two.next
	one.next.prev = one
	two.next = oneNext
	two.next.prev = two

	if one.Priority < two.Priority {
		return one
	}
	return two

} PrettyPrintBody:[{ if one == nil && two == nil { return nil } else if one != nil && two == nil { return one } else if one == nil && two != nil { return two } oneNext := one.next one.next = two.next one.next.prev = one two.next = oneNext two.next.prev = two if one.Priority < two.Priority { return one } return two }]} {Id:18 FileId:69 StartLine:351 StartColumn:1 EndLine:361 EndColumn:2 Name:decreaseKeyUnchecked Params:[{Name:heap Type:*FloatingFibonacciHeap} {Name:node Type:*Entry} {Name:priority Type:float64}] Results:[] Receiver:<nil> Body:{
	node.Priority = priority

	if node.parent != nil && node.Priority <= node.parent.Priority {
		cutNode(heap, node)
	}

	if node.Priority <= heap.min.Priority {
		heap.min = node
	}
} PrettyPrintBody:[{ node.Priority = priority if node.parent != nil && node.Priority <= node.parent.Priority { cutNode(heap, node) } if node.Priority <= heap.min.Priority { heap.min = node } }]} {Id:19 FileId:69 StartLine:363 StartColumn:1 EndLine:399 EndColumn:2 Name:cutNode Params:[{Name:heap Type:*FloatingFibonacciHeap} {Name:node Type:*Entry}] Results:[] Receiver:<nil> Body:{
	node.marked = false

	if node.parent == nil {
		return
	}

	if node.next != node {
		node.next.prev = node.prev
		node.prev.next = node.next
	}

	if node.parent.child == node {
		if node.next != node {
			node.parent.child = node.next
		} else {
			node.parent.child = nil
		}
	}

	node.parent.degree--

	node.prev = node
	node.next = node
	heap.min = mergeLists(heap.min, node)

	if node.parent.marked {
		cutNode(heap, node.parent)
	} else {
		node.parent.marked = true
	}

	node.parent = nil
} PrettyPrintBody:[{ node.marked = false if node.parent == nil { return } if node.next != node { node.next.prev = node.prev node.prev.next = node.next } if node.parent.child == node { if node.next != node { node.parent.child = node.next } else { node.parent.child = nil } } node.parent.degree-- node.prev = node node.next = node heap.min = mergeLists(heap.min, node) if node.parent.marked { cutNode(heap, node.parent) } else { node.parent.marked = true } node.parent = nil }]} {Id:3 FileId:89 StartLine:26 StartColumn:1 EndLine:31 EndColumn:2 Name:calculateVVP Params:[{Name:guess Type:*nmVertex} {Name:sigma Type:float64}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	distance := -guess.euclideanDistance(vertex)
	lhs := 1 / (math.Sqrt(2*math.Pi) * sigma)
	rhs := 1 - math.Exp(math.Pow(distance, 2)/(2*math.Pow(sigma, 2)))
	return rhs * lhs
} PrettyPrintBody:[{ distance := -guess.euclideanDistance(vertex) lhs := 1 / (math.Sqrt(2*math.Pi) * sigma) rhs := 1 - math.Exp(math.Pow(distance, 2)/(2*math.Pow(sigma, 2))) return rhs * lhs }]} {Id:4 FileId:89 StartLine:39 StartColumn:1 EndLine:41 EndColumn:2 Name:calculateSigma Params:[{Name:dimensions Type:int}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	return math.Pow(3*math.Pow(float64(guesses), 1/float64(dimensions)), -1)
} PrettyPrintBody:[{ return math.Pow(3*math.Pow(float64(guesses), 1/float64(dimensions)), -1) }]} {Id:5 FileId:89 StartLine:43 StartColumn:1 EndLine:47 EndColumn:2 Name:calculateProbabilities Params:[{Name:bestGuess Type:*nmVertex} {Name:sigma Type:float64}] Results:[] Receiver:0xc001033400 Body:{
	for _, v := range pbs {
		v.probability = calculateVVP(bestGuess, v.vertex, sigma)
	}
} PrettyPrintBody:[{ for _, v := range pbs { v.probability = calculateVVP(bestGuess, v.vertex, sigma) } }]} {Id:6 FileId:89 StartLine:49 StartColumn:1 EndLine:51 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc000e7f6e0 Body:{
	sort.Sort(pbs)
} PrettyPrintBody:[{ sort.Sort(pbs) }]} {Id:7 FileId:89 StartLine:53 StartColumn:1 EndLine:55 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000e7fc20 Body:{
	return pbs[i].probability < pbs[j].probability
} PrettyPrintBody:[{ return pbs[i].probability < pbs[j].probability }]} {Id:8 FileId:89 StartLine:57 StartColumn:1 EndLine:59 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc0010334e0 Body:{
	pbs[i], pbs[j] = pbs[j], pbs[i]
} PrettyPrintBody:[{ pbs[i], pbs[j] = pbs[j], pbs[i] }]} {Id:9 FileId:89 StartLine:61 StartColumn:1 EndLine:63 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc000df73c0 Body:{
	return len(pbs)
} PrettyPrintBody:[{ return len(pbs) }]} {Id:11 FileId:89 StartLine:79 StartColumn:1 EndLine:83 EndColumn:2 Name:search Params:[{Name:result Type:*nmVertex}] Results:[{Name: Type:int}] Receiver:0xc001309b60 Body:{
	return sort.Search(len(results.vertices), func(i int) bool {
		return !results.vertices[i].less(results.config, result)
	})
} PrettyPrintBody:[{ return sort.Search(len(results.vertices), func(i int) bool { return !results.vertices[i].less(results.config, result) }) }]} {Id:12 FileId:89 StartLine:85 StartColumn:1 EndLine:102 EndColumn:2 Name:exists Params:[{Name:result Type:*nmVertex} {Name:hint Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000a8a3a0 Body:{
	if hint < 0 {
		hint = results.search(result)
	}

	if hint > 0 && results.vertices[hint-1].approximatelyEqualToVertex(result) {
		return true
	}

	if hint < len(results.vertices)-1 && results.vertices[hint].approximatelyEqualToVertex(result) {
		return true
	}

	return false
} PrettyPrintBody:[{ if hint < 0 { hint = results.search(result) } if hint > 0 && results.vertices[hint-1].approximatelyEqualToVertex(result) { return true } if hint < len(results.vertices)-1 && results.vertices[hint].approximatelyEqualToVertex(result) { return true } return false }]} {Id:13 FileId:89 StartLine:104 StartColumn:1 EndLine:118 EndColumn:2 Name:insert Params:[{Name:vertex Type:*nmVertex}] Results:[] Receiver:0xc000a224a0 Body:{
	i := results.search(vertex)
	if results.exists(vertex, i) {
		return
	}

	if i == len(results.vertices) {
		results.vertices = append(results.vertices, vertex)
		return
	}

	results.vertices = append(results.vertices, nil)
	copy(results.vertices[i+1:], results.vertices[i:])
	results.vertices[i] = vertex
} PrettyPrintBody:[{ i := results.search(vertex) if results.exists(vertex, i) { return } if i == len(results.vertices) { results.vertices = append(results.vertices, vertex) return } results.vertices = append(results.vertices, nil) copy(results.vertices[i+1:], results.vertices[i:]) results.vertices[i] = vertex }]} {Id:14 FileId:89 StartLine:120 StartColumn:1 EndLine:140 EndColumn:2 Name:grab Params:[{Name:num Type:int}] Results:[{Name: Type:vertices}] Receiver:0xc0011726c0 Body:{
	vs := make(vertices, 0, num)

	for i := 0; i < num; i++ {
		vs = append(vs, results.pbs[i].vertex)
	}

	copy(results.pbs, results.pbs[num:])
	length := len(results.pbs) - num

	for i := length; i < len(results.pbs); i++ {
		results.pbs[i] = nil
	}

	results.pbs = results.pbs[:length]
	return vs
} PrettyPrintBody:[{ vs := make(vertices, 0, num) for i := 0; i < num; i++ { vs = append(vs, results.pbs[i].vertex) } copy(results.pbs, results.pbs[num:]) length := len(results.pbs) - num for i := length; i < len(results.pbs); i++ { results.pbs[i] = nil } results.pbs = results.pbs[:length] return vs }]} {Id:15 FileId:89 StartLine:145 StartColumn:1 EndLine:152 EndColumn:2 Name:reSort Params:[{Name:vertex Type:*nmVertex}] Results:[] Receiver:0xc00019e420 Body:{
	results.insert(vertex)

	bestGuess := results.vertices[0]
	sigma := calculateSigma(len(results.config.Vars), len(results.vertices))
	results.pbs.calculateProbabilities(bestGuess, sigma)
	results.pbs.sort()
} PrettyPrintBody:[{ results.insert(vertex) bestGuess := results.vertices[0] sigma := calculateSigma(len(results.config.Vars), len(results.vertices)) results.pbs.calculateProbabilities(bestGuess, sigma) results.pbs.sort() }]} {Id:16 FileId:89 StartLine:154 StartColumn:1 EndLine:168 EndColumn:2 Name:newResults Params:[{Name:guess Type:*nmVertex} {Name:config Type:NelderMeadConfiguration} {Name:num Type:int}] Results:[{Name: Type:*results}] Receiver:<nil> Body:{
	vertices := make(vertices, 0, num+1)
	vertices = append(vertices, guess)
	vertices = append(vertices, generateRandomVerticesFromGuess(guess, num)...)

	bundles := make(pbs, 0, len(vertices))
	for _, v := range vertices {
		bundles = append(bundles, &vertexProbabilityBundle{vertex: v})
	}

	return &results{
		pbs:	bundles,
		config:	config,
	}
} PrettyPrintBody:[{ vertices := make(vertices, 0, num+1) vertices = append(vertices, guess) vertices = append(vertices, generateRandomVerticesFromGuess(guess, num)...) bundles := make(pbs, 0, len(vertices)) for _, v := range vertices { bundles = append(bundles, &vertexProbabilityBundle{vertex: v}) } return &results{ pbs:	bundles, config:	config, } }]} {Id:1 FileId:40 StartLine:21 StartColumn:1 EndLine:47 EndColumn:2 Name:DeleteItems Params:[{Name:values Type:...interface{}}] Results:[{Name: Type:[]*Item} {Name: Type:error}] Receiver:0xc001032d60 Body:{
	if len(values) == 0 {
		return nil, nil
	}

	keys := make(Keys, 0, len(values))
	err := t.Apply(func(item *Item) {
		keys = append(keys, &Key{Value: item.Value, Payload: item.Payload})
	}, values...)

	if err != nil {
		return nil, err
	}

	keys = keys.sort(t.config.Comparator)

	err = t.delete(keys)
	if err != nil {
		return nil, err
	}

	t.Count -= len(keys)

	return keys.toItems(), nil
} PrettyPrintBody:[{ if len(values) == 0 { return nil, nil } keys := make(Keys, 0, len(values)) err := t.Apply(func(item *Item) { keys = append(keys, &Key{Value: item.Value, Payload: item.Payload}) }, values...) if err != nil { return nil, err } keys = keys.sort(t.config.Comparator) err = t.delete(keys) if err != nil { return nil, err } t.Count -= len(keys) return keys.toItems(), nil }]} {Id:2 FileId:40 StartLine:49 StartColumn:1 EndLine:139 EndColumn:2 Name:delete Params:[{Name:keys Type:Keys}] Results:[{Name: Type:error}] Receiver:0xc0013099c0 Body:{
	if len(keys) == 0 {
		return nil
	}

	toDelete := make([]*Key, 0, len(keys))

	for i := 0; i < len(keys); {
		key := keys[i]
		mapping := make(map[string]*Node, 10)
		path, err := t.iterativeFind(key.Value, t.Root)
		if err != nil {
			return err
		}

		pb := path.peek()
		node := pb.n
		isRoot := bytes.Compare(node.ID, t.Root) == 0
		if !t.context.nodeExists(node.ID) {
			cp := node.copy()
			t.context.addNode(cp)
			mapping[string(node.ID)] = cp
			node = cp
		}
		base := node

		toDelete = append(toDelete, key)
		for j := i + 1; j <= len(keys); j++ {
			i = j
			if j == len(keys) {
				break
			}
			neighbor := keys[j]
			if t.config.Comparator(neighbor.Value, node.lastValue()) <= 0 {
				toDelete = append(toDelete, neighbor)
			} else {
				break
			}
		}

		if len(toDelete) > len(node.ChildValues)/4 {
			node.multiDelete(t.config.Comparator, toDelete...)
		} else {
			for _, k := range toDelete {
				node.delete(t.config.Comparator, k)
			}
		}

		toDelete = toDelete[:0]
		if isRoot {
			t.Root = node.ID
			continue
		}

		for pb.prev != nil {
			parentBundle := pb.prev
			parent := parentBundle.n
			isRoot := bytes.Compare(parent.ID, t.Root) == 0
			if !t.context.nodeExists(parent.ID) {
				cp := parent.copy()
				t.context.addNode(cp)
				mapping[string(parent.ID)] = cp
				parent = cp
			} else {
				mapping[string(parent.ID)] = parent
			}

			if isRoot {
				t.Root = parent.ID
			}

			i := pb.prev.i
			parent.replaceKeyAt(&Key{UUID: node.ID}, i)
			node = parent
			pb = pb.prev
		}

		path.pop()
		err = t.walkupDelete(key, base, path, mapping)
		if err != nil {
			return err
		}
	}

	n := t.context.getNode(t.Root)
	if n.lenValues() == 0 {
		t.Root = nil
	}

	return nil
} PrettyPrintBody:[{ if len(keys) == 0 { return nil } toDelete := make([]*Key, 0, len(keys)) for i := 0; i < len(keys); { key := keys[i] mapping := make(map[string]*Node, 10) path, err := t.iterativeFind(key.Value, t.Root) if err != nil { return err } pb := path.peek() node := pb.n isRoot := bytes.Compare(node.ID, t.Root) == 0 if !t.context.nodeExists(node.ID) { cp := node.copy() t.context.addNode(cp) mapping[string(node.ID)] = cp node = cp } base := node toDelete = append(toDelete, key) for j := i + 1; j <= len(keys); j++ { i = j if j == len(keys) { break } neighbor := keys[j] if t.config.Comparator(neighbor.Value, node.lastValue()) <= 0 { toDelete = append(toDelete, neighbor) } else { break } } if len(toDelete) > len(node.ChildValues)/4 { node.multiDelete(t.config.Comparator, toDelete...) } else { for _, k := range toDelete { node.delete(t.config.Comparator, k) } } toDelete = toDelete[:0] if isRoot { t.Root = node.ID continue } for pb.prev != nil { parentBundle := pb.prev parent := parentBundle.n isRoot := bytes.Compare(parent.ID, t.Root) == 0 if !t.context.nodeExists(parent.ID) { cp := parent.copy() t.context.addNode(cp) mapping[string(parent.ID)] = cp parent = cp } else { mapping[string(parent.ID)] = parent } if isRoot { t.Root = parent.ID } i := pb.prev.i parent.replaceKeyAt(&Key{UUID: node.ID}, i) node = parent pb = pb.prev } path.pop() err = t.walkupDelete(key, base, path, mapping) if err != nil { return err } } n := t.context.getNode(t.Root) if n.lenValues() == 0 { t.Root = nil } return nil }]} {Id:3 FileId:40 StartLine:145 StartColumn:1 EndLine:279 EndColumn:2 Name:walkupDelete Params:[{Name:key Type:*Key} {Name:node Type:*Node} {Name:path Type:*path} {Name:mapping Type:map[string]*Node}] Results:[{Name: Type:error}] Receiver:0xc001603140 Body:{
	needsMerged := t.config.NodeWidth / 2
	if needsMerged < 1 {
		needsMerged = 1
	}
	if node.lenValues() >= needsMerged {
		return nil
	}

	if string(node.ID) == string(t.Root) {
		if node.lenKeys() == 1 {
			id := node.keyAt(0)
			t.Root = id.UUID
		}

		return nil
	}

	var getSibling = func(parent *Node, i int) (*Node, error) {
		key := parent.keyAt(i)
		n, err := t.contextOrCachedNode(key.UUID, true)
		if err != nil {
			return nil, err
		}

		if !t.context.nodeExists(n.ID) {
			cp := t.copyNode(n)
			mapping[string(n.ID)] = cp
			parent.replaceKeyAt(&Key{UUID: cp.ID}, i)
			n = cp
		}

		return n, nil
	}

	parentBundle := path.pop()
	parent := mapping[string(parentBundle.n.ID)]

	_, i := parent.searchKey(t.config.Comparator, key.Value)
	siblingPosition := i
	if i == parent.lenValues() {
		siblingPosition--
	} else {
		siblingPosition++
	}

	sibling, err := getSibling(parent, siblingPosition)
	if err != nil {
		return err
	}

	prepend := false

	if siblingPosition < i {
		node, sibling = sibling, node
		prepend = true
	}

	if (sibling.lenValues()+node.lenValues())/2 >= needsMerged {
		if i == parent.lenValues() {
			i--
		}

		var key *Key
		var value interface{}
		for node.lenValues() < needsMerged || sibling.lenValues() < needsMerged {
			if prepend {
				correctedValue, key := node.popValue(), node.popKey()
				if node.IsLeaf {
					sibling.prependValue(correctedValue)
					sibling.prependKey(key)
					parent.replaceValueAt(i, node.lastValue())
				} else {
					parentValue := parent.valueAt(i)
					sibling.prependKey(key)
					sibling.prependValue(parentValue)
					parent.replaceValueAt(i, correctedValue)
				}
			} else {
				value, key = sibling.popFirstValue(), sibling.popFirstKey()
				correctedValue := value
				if !node.IsLeaf {
					correctedValue = parent.valueAt(i)
				}
				node.appendValue(correctedValue)
				node.appendChild(key)
				parent.replaceValueAt(i, value)
			}
		}

		return nil
	}

	if node.IsLeaf {
		node.append(sibling)
		if prepend {
			parent.deleteKeyAt(i)
		} else {
			parent.deleteKeyAt(i + 1)
		}

		if i == parent.lenValues() {
			i--
		}

		parent.deleteValueAt(i)
		return t.walkupDelete(key, parent, path, mapping)
	}

	valueIndex := i
	if i == parent.lenValues() {
		valueIndex--
	}

	parentValue := parent.valueAt(valueIndex)
	node.appendValue(parentValue)
	node.append(sibling)
	parent.deleteKeyAt(i)
	parent.deleteValueAt(valueIndex)
	parent.replaceKeyAt(&Key{UUID: node.ID}, valueIndex)
	return t.walkupDelete(key, parent, path, mapping)
} PrettyPrintBody:[{ needsMerged := t.config.NodeWidth / 2 if needsMerged < 1 { needsMerged = 1 } if node.lenValues() >= needsMerged { return nil } if string(node.ID) == string(t.Root) { if node.lenKeys() == 1 { id := node.keyAt(0) t.Root = id.UUID } return nil } var getSibling = func(parent *Node, i int) (*Node, error) { key := parent.keyAt(i) n, err := t.contextOrCachedNode(key.UUID, true) if err != nil { return nil, err } if !t.context.nodeExists(n.ID) { cp := t.copyNode(n) mapping[string(n.ID)] = cp parent.replaceKeyAt(&Key{UUID: cp.ID}, i) n = cp } return n, nil } parentBundle := path.pop() parent := mapping[string(parentBundle.n.ID)] _, i := parent.searchKey(t.config.Comparator, key.Value) siblingPosition := i if i == parent.lenValues() { siblingPosition-- } else { siblingPosition++ } sibling, err := getSibling(parent, siblingPosition) if err != nil { return err } prepend := false if siblingPosition < i { node, sibling = sibling, node prepend = true } if (sibling.lenValues()+node.lenValues())/2 >= needsMerged { if i == parent.lenValues() { i-- } var key *Key var value interface{} for node.lenValues() < needsMerged || sibling.lenValues() < needsMerged { if prepend { correctedValue, key := node.popValue(), node.popKey() if node.IsLeaf { sibling.prependValue(correctedValue) sibling.prependKey(key) parent.replaceValueAt(i, node.lastValue()) } else { parentValue := parent.valueAt(i) sibling.prependKey(key) sibling.prependValue(parentValue) parent.replaceValueAt(i, correctedValue) } } else { value, key = sibling.popFirstValue(), sibling.popFirstKey() correctedValue := value if !node.IsLeaf { correctedValue = parent.valueAt(i) } node.appendValue(correctedValue) node.appendChild(key) parent.replaceValueAt(i, value) } } return nil } if node.IsLeaf { node.append(sibling) if prepend { parent.deleteKeyAt(i) } else { parent.deleteKeyAt(i + 1) } if i == parent.lenValues() { i-- } parent.deleteValueAt(i) return t.walkupDelete(key, parent, path, mapping) } valueIndex := i if i == parent.lenValues() { valueIndex-- } parentValue := parent.valueAt(valueIndex) node.appendValue(parentValue) node.append(sibling) parent.deleteKeyAt(i) parent.deleteValueAt(valueIndex) parent.replaceKeyAt(&Key{UUID: node.ID}, valueIndex) return t.walkupDelete(key, parent, path, mapping) }]} {Id:1 FileId:84 StartLine:25 StartColumn:1 EndLine:36 EndColumn:2 Name:TestEmptyList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	head, ok := Empty.Head()
	assert.Nil(head)
	assert.False(ok)

	tail, ok := Empty.Tail()
	assert.Nil(tail)
	assert.False(ok)

	assert.True(Empty.IsEmpty())
} PrettyPrintBody:[{ assert := assert.New(t) head, ok := Empty.Head() assert.Nil(head) assert.False(ok) tail, ok := Empty.Tail() assert.Nil(tail) assert.False(ok) assert.True(Empty.IsEmpty()) }]} {Id:2 FileId:84 StartLine:38 StartColumn:1 EndLine:90 EndColumn:2 Name:TestAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	l1 := Empty.Add(1)

	assert.False(l1.IsEmpty())
	head, ok := l1.Head()
	assert.True(ok)
	assert.Equal(1, head)
	tail, ok := l1.Tail()
	assert.True(ok)
	assert.Equal(Empty, tail)

	l1 = l1.Add(2)

	head, ok = l1.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l1.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err := l1.Insert("a", 1)
	assert.Nil(err)

	head, ok = l1.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l1.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal("a", head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)
} PrettyPrintBody:[{ assert := assert.New(t) l1 := Empty.Add(1) assert.False(l1.IsEmpty()) head, ok := l1.Head() assert.True(ok) assert.Equal(1, head) tail, ok := l1.Tail() assert.True(ok) assert.Equal(Empty, tail) l1 = l1.Add(2) head, ok = l1.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l1.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err := l1.Insert("a", 1) assert.Nil(err) head, ok = l1.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l1.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) head, ok = l2.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal("a", head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) }]} {Id:3 FileId:84 StartLine:92 StartColumn:1 EndLine:122 EndColumn:2 Name:TestInsertAndGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	_, err := Empty.Insert(1, 5)
	assert.Error(err)

	l, err := Empty.Insert(1, 0)
	assert.Nil(err)

	item, ok := l.Get(0)
	assert.True(ok)
	assert.Equal(1, item)

	l, err = l.Insert(2, 0)
	assert.Nil(err)

	item, ok = l.Get(0)
	assert.True(ok)
	assert.Equal(2, item)
	item, ok = l.Get(1)
	assert.True(ok)
	assert.Equal(1, item)

	_, ok = l.Get(2)
	assert.False(ok)

	l, err = l.Insert("a", 3)
	assert.Nil(l)
	assert.Error(err)
} PrettyPrintBody:[{ assert := assert.New(t) _, err := Empty.Insert(1, 5) assert.Error(err) l, err := Empty.Insert(1, 0) assert.Nil(err) item, ok := l.Get(0) assert.True(ok) assert.Equal(1, item) l, err = l.Insert(2, 0) assert.Nil(err) item, ok = l.Get(0) assert.True(ok) assert.Equal(2, item) item, ok = l.Get(1) assert.True(ok) assert.Equal(1, item) _, ok = l.Get(2) assert.False(ok) l, err = l.Insert("a", 3) assert.Nil(l) assert.Error(err) }]} {Id:4 FileId:84 StartLine:124 StartColumn:1 EndLine:225 EndColumn:2 Name:TestRemove Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	l, err := Empty.Remove(0)
	assert.Nil(l)
	assert.Error(err)

	l = Empty.Add(1)
	l = l.Add(2)
	l = l.Add(3)

	l1, err := l.Remove(3)
	assert.Nil(l1)
	assert.Error(err)

	l2, err := l.Remove(0)

	assert.Nil(err)
	head, ok := l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok := l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err = l.Remove(1)

	assert.Nil(err)
	head, ok = l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	l2, err = l.Remove(2)

	assert.Nil(err)
	head, ok = l.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
	tail, ok = tail.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(1, head)

	assert.Nil(err)
	head, ok = l2.Head()
	assert.True(ok)
	assert.Equal(3, head)
	tail, ok = l2.Tail()
	assert.True(ok)
	head, ok = tail.Head()
	assert.True(ok)
	assert.Equal(2, head)
} PrettyPrintBody:[{ assert := assert.New(t) l, err := Empty.Remove(0) assert.Nil(l) assert.Error(err) l = Empty.Add(1) l = l.Add(2) l = l.Add(3) l1, err := l.Remove(3) assert.Nil(l1) assert.Error(err) l2, err := l.Remove(0) assert.Nil(err) head, ok := l.Head() assert.True(ok) assert.Equal(3, head) tail, ok := l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(2, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err = l.Remove(1) assert.Nil(err) head, ok = l.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) l2, err = l.Remove(2) assert.Nil(err) head, ok = l.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) tail, ok = tail.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(1, head) assert.Nil(err) head, ok = l2.Head() assert.True(ok) assert.Equal(3, head) tail, ok = l2.Tail() assert.True(ok) head, ok = tail.Head() assert.True(ok) assert.Equal(2, head) }]} {Id:5 FileId:84 StartLine:227 StartColumn:1 EndLine:248 EndColumn:2 Name:TestFind Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	pred := func(item interface{}) bool {
		return item == 1
	}

	found, ok := Empty.Find(pred)
	assert.Nil(found)
	assert.False(ok)

	l := Empty.Add("blah").Add("bleh")

	found, ok = l.Find(pred)
	assert.Nil(found)
	assert.False(ok)

	l = l.Add(1).Add("foo")

	found, ok = l.Find(pred)
	assert.Equal(1, found)
	assert.True(ok)
} PrettyPrintBody:[{ assert := assert.New(t) pred := func(item interface{}) bool { return item == 1 } found, ok := Empty.Find(pred) assert.Nil(found) assert.False(ok) l := Empty.Add("blah").Add("bleh") found, ok = l.Find(pred) assert.Nil(found) assert.False(ok) l = l.Add(1).Add("foo") found, ok = l.Find(pred) assert.Equal(1, found) assert.True(ok) }]} {Id:6 FileId:84 StartLine:250 StartColumn:1 EndLine:268 EndColumn:2 Name:TestFindIndex Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	pred := func(item interface{}) bool {
		return item == 1
	}

	idx := Empty.FindIndex(pred)
	assert.Equal(-1, idx)

	l := Empty.Add("blah").Add("bleh")

	idx = l.FindIndex(pred)
	assert.Equal(-1, idx)

	l = l.Add(1).Add("foo")

	idx = l.FindIndex(pred)
	assert.Equal(1, idx)
} PrettyPrintBody:[{ assert := assert.New(t) pred := func(item interface{}) bool { return item == 1 } idx := Empty.FindIndex(pred) assert.Equal(-1, idx) l := Empty.Add("blah").Add("bleh") idx = l.FindIndex(pred) assert.Equal(-1, idx) l = l.Add(1).Add("foo") idx = l.FindIndex(pred) assert.Equal(1, idx) }]} {Id:7 FileId:84 StartLine:270 StartColumn:1 EndLine:278 EndColumn:2 Name:TestLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	assert.Equal(uint(0), Empty.Length())

	l := Empty.Add("foo")
	assert.Equal(uint(1), l.Length())
	l = l.Add("bar").Add("baz")
	assert.Equal(uint(3), l.Length())
} PrettyPrintBody:[{ assert := assert.New(t) assert.Equal(uint(0), Empty.Length()) l := Empty.Add("foo") assert.Equal(uint(1), l.Length()) l = l.Add("bar").Add("baz") assert.Equal(uint(3), l.Length()) }]} {Id:8 FileId:84 StartLine:280 StartColumn:1 EndLine:289 EndColumn:2 Name:TestMap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	f := func(x interface{}) interface{} {
		return x.(int) * x.(int)
	}
	assert.Nil(Empty.Map(f))

	l := Empty.Add(1).Add(2).Add(3).Add(4)
	assert.Equal([]interface{}{1, 4, 9, 16}, l.Map(f))
} PrettyPrintBody:[{ assert := assert.New(t) f := func(x interface{}) interface{} { return x.(int) * x.(int) } assert.Nil(Empty.Map(f)) l := Empty.Add(1).Add(2).Add(3).Add(4) assert.Equal([]interface{}{1, 4, 9, 16}, l.Map(f)) }]} {Id:1 FileId:26 StartLine:25 StartColumn:1 EndLine:72 EndColumn:2 Name:TestOrSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	sba.SetBit(s - 1)
	other.SetBit(s - 1)

	result := orSparseWithSparseBitArray(sba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 2)
	assert.Nil(t, err)
	assert.False(t, ok)

	other.SetBit(2000)
	result = orSparseWithSparseBitArray(sba, other)

	ok, err = result.GetBit(2000)
	assert.Nil(t, err)
	assert.True(t, ok)

	sba.SetBit(2000)
	result = orSparseWithSparseBitArray(sba, other)

	ok, err = result.GetBit(2000)
	assert.Nil(t, err)
	assert.True(t, ok)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() ctx := false for i := uint64(0); i < 1000; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } sba.SetBit(s - 1) other.SetBit(s - 1) result := orSparseWithSparseBitArray(sba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 2) assert.Nil(t, err) assert.False(t, ok) other.SetBit(2000) result = orSparseWithSparseBitArray(sba, other) ok, err = result.GetBit(2000) assert.Nil(t, err) assert.True(t, ok) sba.SetBit(2000) result = orSparseWithSparseBitArray(sba, other) ok, err = result.GetBit(2000) assert.Nil(t, err) assert.True(t, ok) }]} {Id:2 FileId:26 StartLine:74 StartColumn:1 EndLine:95 EndColumn:2 Name:BenchmarkOrSparseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newSparseBitArray()

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orSparseWithSparseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newSparseBitArray() ctx := false for i := uint64(0); i < numItems; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orSparseWithSparseBitArray(sba, other) } }]} {Id:3 FileId:26 StartLine:97 StartColumn:1 EndLine:142 EndColumn:2 Name:TestOrSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(2000)

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	other.SetBit(1500)
	other.SetBit(s - 1)
	sba.SetBit(s - 1)

	result := orSparseWithDenseBitArray(sba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(1500)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(s - 2)
	assert.Nil(t, err)
	assert.False(t, ok)

	sba.SetBit(2500)
	result = orSparseWithDenseBitArray(sba, other)

	ok, err = result.GetBit(2500)
	assert.Nil(t, err)
	assert.True(t, ok)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(2000) ctx := false for i := uint64(0); i < 1000; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } other.SetBit(1500) other.SetBit(s - 1) sba.SetBit(s - 1) result := orSparseWithDenseBitArray(sba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(1500) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(s - 2) assert.Nil(t, err) assert.False(t, ok) sba.SetBit(2500) result = orSparseWithDenseBitArray(sba, other) ok, err = result.GetBit(2500) assert.Nil(t, err) assert.True(t, ok) }]} {Id:4 FileId:26 StartLine:144 StartColumn:1 EndLine:165 EndColumn:2 Name:BenchmarkOrSparseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newBitArray(numItems)

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			sba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orSparseWithDenseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newBitArray(numItems) ctx := false for i := uint64(0); i < numItems; i += s { if ctx { sba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orSparseWithDenseBitArray(sba, other) } }]} {Id:5 FileId:26 StartLine:167 StartColumn:1 EndLine:205 EndColumn:2 Name:TestOrDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	ctx := false
	for i := uint64(0); i < 1000; i += s {
		if ctx {
			dba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	other.SetBit(1500)
	other.SetBit(s - 1)
	dba.SetBit(s - 1)

	result := orDenseWithDenseBitArray(dba, other)

	for i := uint64(0); i < 1000; i += s {
		ok, err := result.GetBit(i)
		assert.Nil(t, err)
		assert.True(t, ok)
	}

	ok, err := result.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(1500)
	assert.Nil(t, err)
	assert.True(t, ok)

	ok, err = result.GetBit(1700)
	assert.Nil(t, err)
	assert.False(t, ok)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) ctx := false for i := uint64(0); i < 1000; i += s { if ctx { dba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } other.SetBit(1500) other.SetBit(s - 1) dba.SetBit(s - 1) result := orDenseWithDenseBitArray(dba, other) for i := uint64(0); i < 1000; i += s { ok, err := result.GetBit(i) assert.Nil(t, err) assert.True(t, ok) } ok, err := result.GetBit(s - 1) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(1500) assert.Nil(t, err) assert.True(t, ok) ok, err = result.GetBit(1700) assert.Nil(t, err) assert.False(t, ok) }]} {Id:6 FileId:26 StartLine:207 StartColumn:1 EndLine:228 EndColumn:2 Name:BenchmarkOrDenseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	dba := newBitArray(numItems)
	other := newBitArray(numItems)

	ctx := false
	for i := uint64(0); i < numItems; i += s {
		if ctx {
			dba.SetBit(i)
		} else {
			other.SetBit(i)
		}

		ctx = !ctx
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		orDenseWithDenseBitArray(dba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) dba := newBitArray(numItems) other := newBitArray(numItems) ctx := false for i := uint64(0); i < numItems; i += s { if ctx { dba.SetBit(i) } else { other.SetBit(i) } ctx = !ctx } b.ResetTimer() for i := 0; i < b.N; i++ { orDenseWithDenseBitArray(dba, other) } }]} {Id:7 FileId:26 StartLine:230 StartColumn:1 EndLine:244 EndColumn:2 Name:TestOrSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	result := orSparseWithSparseBitArray(sba, other)
	assert.Equal(t, sba, result)

	sba.Reset()
	other.SetBit(5)

	result = orSparseWithSparseBitArray(sba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) result := orSparseWithSparseBitArray(sba, other) assert.Equal(t, sba, result) sba.Reset() other.SetBit(5) result = orSparseWithSparseBitArray(sba, other) assert.Equal(t, other, result) }]} {Id:8 FileId:26 StartLine:246 StartColumn:1 EndLine:259 EndColumn:2 Name:TestOrSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	result := orSparseWithDenseBitArray(sba, other)
	assert.Equal(t, sba, result)

	sba.Reset()
	other.SetBit(5)

	result = orSparseWithDenseBitArray(sba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) result := orSparseWithDenseBitArray(sba, other) assert.Equal(t, sba, result) sba.Reset() other.SetBit(5) result = orSparseWithDenseBitArray(sba, other) assert.Equal(t, other, result) }]} {Id:9 FileId:26 StartLine:261 StartColumn:1 EndLine:273 EndColumn:2 Name:TestOrDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	result := orDenseWithDenseBitArray(dba, other)
	assert.Equal(t, dba, result)

	dba.Reset()
	other.SetBit(5)
	result = orDenseWithDenseBitArray(dba, other)
	assert.Equal(t, other, result)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) result := orDenseWithDenseBitArray(dba, other) assert.Equal(t, dba, result) dba.Reset() other.SetBit(5) result = orDenseWithDenseBitArray(dba, other) assert.Equal(t, other, result) }]} {Id:1 FileId:9 StartLine:27 StartColumn:1 EndLine:30 EndColumn:2 Name:TestNoCalculateBytes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	_, err := New(0, 0, 100, 5, nil)
	assert.Error(t, err)
} PrettyPrintBody:[{ _, err := New(0, 0, 100, 5, nil) assert.Error(t, err) }]} {Id:2 FileId:9 StartLine:32 StartColumn:1 EndLine:46 EndColumn:2 Name:TestMaxItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 100, 100000, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	for i := 0; i < 1000; i++ {
		assert.Nil(b.Put("foo bar baz"))
	}

	batch, err := b.Get()
	assert.Len(batch, 100)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 100, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) for i := 0; i < 1000; i++ { assert.Nil(b.Put("foo bar baz")) } batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) }]} {Id:3 FileId:9 StartLine:48 StartColumn:1 EndLine:64 EndColumn:2 Name:TestMaxBytes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10000, 100, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	go func() {
		for i := 0; i < 1000; i++ {
			b.Put("a")
		}
	}()

	batch, err := b.Get()
	assert.Len(batch, 100)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10000, 100, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) go func() { for i := 0; i < 1000; i++ { b.Put("a") } }() batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) }]} {Id:4 FileId:9 StartLine:66 StartColumn:1 EndLine:90 EndColumn:2 Name:TestMaxTime Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(time.Millisecond*200, 100000, 100000, 10,
		func(str interface{}) uint {
			return uint(len(str.(string)))
		},
	)
	assert.Nil(err)

	go func() {
		for i := 0; i < 10000; i++ {
			b.Put("a")
			time.Sleep(time.Millisecond)
		}
	}()

	before := time.Now()
	batch, err := b.Get()

	assert.InDelta(200, time.Since(before).Seconds()*1000, 100)
	assert.True(len(batch) > 0)
	assert.Nil(err)
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(time.Millisecond*200, 100000, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }, ) assert.Nil(err) go func() { for i := 0; i < 10000; i++ { b.Put("a") time.Sleep(time.Millisecond) } }() before := time.Now() batch, err := b.Get() assert.InDelta(200, time.Since(before).Seconds()*1000, 100) assert.True(len(batch) > 0) assert.Nil(err) }]} {Id:5 FileId:9 StartLine:92 StartColumn:1 EndLine:109 EndColumn:2 Name:TestFlush Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10, 10, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	b.Put("a")
	wait := make(chan bool)
	go func() {
		batch, err := b.Get()
		assert.Equal([]interface{}{"a"}, batch)
		assert.Nil(err)
		wait <- true
	}()

	b.Flush()
	<-wait
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10, 10, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) b.Put("a") wait := make(chan bool) go func() { batch, err := b.Get() assert.Equal([]interface{}{"a"}, batch) assert.Nil(err) wait <- true }() b.Flush() <-wait }]} {Id:6 FileId:9 StartLine:111 StartColumn:1 EndLine:136 EndColumn:2 Name:TestMultiConsumer Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 100, 100000, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)

	var wg sync.WaitGroup
	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			batch, err := b.Get()
			assert.Len(batch, 100)
			assert.Nil(err)
			wg.Done()
		}()
	}

	go func() {
		for i := 0; i < 500; i++ {
			b.Put("a")
		}
	}()

	wg.Wait()
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 100, 100000, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) var wg sync.WaitGroup wg.Add(5) for i := 0; i < 5; i++ { go func() { batch, err := b.Get() assert.Len(batch, 100) assert.Nil(err) wg.Done() }() } go func() { for i := 0; i < 500; i++ { b.Put("a") } }() wg.Wait() }]} {Id:7 FileId:9 StartLine:138 StartColumn:1 EndLine:168 EndColumn:2 Name:TestDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(1, 2, 100000, 2, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	b.Put("a")
	b.Put("b")
	b.Put("c")

	batch1, err := b.Get()
	assert.Equal([]interface{}{"a", "b"}, batch1)
	assert.Nil(err)

	batch2, err := b.Get()
	assert.Equal([]interface{}{"c"}, batch2)
	assert.Nil(err)

	b.Put("d")
	b.Put("e")
	b.Put("f")

	b.Dispose()

	_, err = b.Get()
	assert.Equal(ErrDisposed, err)

	assert.Equal(ErrDisposed, b.Put("j"))
	assert.Equal(ErrDisposed, b.Flush())

} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(1, 2, 100000, 2, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) b.Put("a") b.Put("b") b.Put("c") batch1, err := b.Get() assert.Equal([]interface{}{"a", "b"}, batch1) assert.Nil(err) batch2, err := b.Get() assert.Equal([]interface{}{"c"}, batch2) assert.Nil(err) b.Put("d") b.Put("e") b.Put("f") b.Dispose() _, err = b.Get() assert.Equal(ErrDisposed, err) assert.Equal(ErrDisposed, b.Put("j")) assert.Equal(ErrDisposed, b.Flush()) }]} {Id:8 FileId:9 StartLine:170 StartColumn:1 EndLine:179 EndColumn:2 Name:TestIsDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	b, err := New(0, 10, 10, 10, func(str interface{}) uint {
		return uint(len(str.(string)))
	})
	assert.Nil(err)
	assert.False(b.IsDisposed())
	b.Dispose()
	assert.True(b.IsDisposed())
} PrettyPrintBody:[{ assert := assert.New(t) b, err := New(0, 10, 10, 10, func(str interface{}) uint { return uint(len(str.(string))) }) assert.Nil(err) assert.False(b.IsDisposed()) b.Dispose() assert.True(b.IsDisposed()) }]} {Id:1 FileId:45 StartLine:12 StartColumn:1 EndLine:16 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001226d20 Body:{
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = msgp.AppendBytes(o, []byte(z)) return }]} {Id:2 FileId:45 StartLine:19 StartColumn:1 EndLine:30 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602320 Body:{
	{
		var tmp []byte
		tmp, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		(*z) = ID(tmp)
	}
	if err != nil {
		return
	}
	o = bts
	return
} PrettyPrintBody:[{ { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte((*z))) (*z) = ID(tmp) } if err != nil { return } o = bts return }]} {Id:3 FileId:45 StartLine:32 StartColumn:1 EndLine:35 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc001309340 Body:{
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
} PrettyPrintBody:[{ s = msgp.BytesPrefixSize + len([]byte(z)) return }]} {Id:4 FileId:45 StartLine:38 StartColumn:1 EndLine:54 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000f530a0 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x83, 0xa1, 0x75)
	o = msgp.AppendBytes(o, []byte(z.UUID))

	o = append(o, 0xa1, 0x76)
	o, err = msgp.AppendIntf(o, z.Value)
	if err != nil {
		return
	}

	o = append(o, 0xa1, 0x70)
	o = msgp.AppendBytes(o, z.Payload)
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x83, 0xa1, 0x75) o = msgp.AppendBytes(o, []byte(z.UUID)) o = append(o, 0xa1, 0x76) o, err = msgp.AppendIntf(o, z.Value) if err != nil { return } o = append(o, 0xa1, 0x70) o = msgp.AppendBytes(o, z.Payload) return }]} {Id:5 FileId:45 StartLine:57 StartColumn:1 EndLine:100 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc000df6920 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			{
				var tmp []byte
				tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.UUID))
				z.UUID = ID(tmp)
			}
			if err != nil {
				return
			}
		case "v":
			z.Value, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				return
			}
		case "p":
			z.Payload, bts, err = msgp.ReadBytesBytes(bts, z.Payload)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "u": { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.UUID)) z.UUID = ID(tmp) } if err != nil { return } case "v": z.Value, bts, err = msgp.ReadIntfBytes(bts) if err != nil { return } case "p": z.Payload, bts, err = msgp.ReadBytesBytes(bts, z.Payload) if err != nil { return } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]} {Id:6 FileId:45 StartLine:102 StartColumn:1 EndLine:105 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc000a8a4a0 Body:{
	s = 1 + 2 + msgp.BytesPrefixSize + len([]byte(z.UUID)) + 2 + msgp.GuessSize(z.Value) + 2 + msgp.BytesPrefixSize + len(z.Payload)
	return
} PrettyPrintBody:[{ s = 1 + 2 + msgp.BytesPrefixSize + len([]byte(z.UUID)) + 2 + msgp.GuessSize(z.Value) + 2 + msgp.BytesPrefixSize + len(z.Payload) return }]} {Id:7 FileId:45 StartLine:108 StartColumn:1 EndLine:122 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001581360 Body:{
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for xvk := range z {
		if z[xvk] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z[xvk].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = msgp.AppendArrayHeader(o, uint32(len(z))) for xvk := range z { if z[xvk] == nil { o = msgp.AppendNil(o) } else { o, err = z[xvk].MarshalMsg(o) if err != nil { return } } } return }]} {Id:8 FileId:45 StartLine:125 StartColumn:1 EndLine:155 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602d60 Body:{
	var xsz uint32
	xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap((*z)) >= int(xsz) {
		(*z) = (*z)[:xsz]
	} else {
		(*z) = make(Keys, xsz)
	}
	for bzg := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[bzg] = nil
		} else {
			if (*z)[bzg] == nil {
				(*z)[bzg] = new(Key)
			}
			bts, err = (*z)[bzg].UnmarshalMsg(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap((*z)) >= int(xsz) { (*z) = (*z)[:xsz] } else { (*z) = make(Keys, xsz) } for bzg := range *z { if msgp.IsNil(bts) { bts, err = msgp.ReadNilBytes(bts) if err != nil { return } (*z)[bzg] = nil } else { if (*z)[bzg] == nil { (*z)[bzg] = new(Key) } bts, err = (*z)[bzg].UnmarshalMsg(bts) if err != nil { return } } } o = bts return }]} {Id:9 FileId:45 StartLine:157 StartColumn:1 EndLine:167 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc001602e20 Body:{
	s = msgp.ArrayHeaderSize
	for bai := range z {
		if z[bai] == nil {
			s += msgp.NilSize
		} else {
			s += z[bai].Msgsize()
		}
	}
	return
} PrettyPrintBody:[{ s = msgp.ArrayHeaderSize for bai := range z { if z[bai] == nil { s += msgp.NilSize } else { s += z[bai].Msgsize() } } return }]} {Id:10 FileId:45 StartLine:170 StartColumn:1 EndLine:202 EndColumn:2 Name:MarshalMsg Params:[{Name:b Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc001602f80 Body:{
	o = msgp.Require(b, z.Msgsize())

	o = append(o, 0x84, 0xa2, 0x69, 0x64)
	o = msgp.AppendBytes(o, []byte(z.ID))

	o = append(o, 0xa2, 0x69, 0x6c)
	o = msgp.AppendBool(o, z.IsLeaf)

	o = append(o, 0xa2, 0x63, 0x76)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChildValues)))
	for cmr := range z.ChildValues {
		o, err = msgp.AppendIntf(o, z.ChildValues[cmr])
		if err != nil {
			return
		}
	}

	o = append(o, 0xa2, 0x63, 0x6b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChildKeys)))
	for ajw := range z.ChildKeys {
		if z.ChildKeys[ajw] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ChildKeys[ajw].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
} PrettyPrintBody:[{ o = msgp.Require(b, z.Msgsize()) o = append(o, 0x84, 0xa2, 0x69, 0x64) o = msgp.AppendBytes(o, []byte(z.ID)) o = append(o, 0xa2, 0x69, 0x6c) o = msgp.AppendBool(o, z.IsLeaf) o = append(o, 0xa2, 0x63, 0x76) o = msgp.AppendArrayHeader(o, uint32(len(z.ChildValues))) for cmr := range z.ChildValues { o, err = msgp.AppendIntf(o, z.ChildValues[cmr]) if err != nil { return } } o = append(o, 0xa2, 0x63, 0x6b) o = msgp.AppendArrayHeader(o, uint32(len(z.ChildKeys))) for ajw := range z.ChildKeys { if z.ChildKeys[ajw] == nil { o = msgp.AppendNil(o) } else { o, err = z.ChildKeys[ajw].MarshalMsg(o) if err != nil { return } } } return }]} {Id:11 FileId:45 StartLine:205 StartColumn:1 EndLine:288 EndColumn:2 Name:UnmarshalMsg Params:[{Name:bts Type:[]byte}] Results:[{Name:o Type:[]byte} {Name:err Type:error}] Receiver:0xc0001e6620 Body:{
	var field []byte
	_ = field
	var isz uint32
	isz, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for isz > 0 {
		isz--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			{
				var tmp []byte
				tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.ID))
				z.ID = ID(tmp)
			}
			if err != nil {
				return
			}
		case "il":
			z.IsLeaf, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				return
			}
		case "cv":
			var xsz uint32
			xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.ChildValues) >= int(xsz) {
				z.ChildValues = z.ChildValues[:xsz]
			} else {
				z.ChildValues = make([]interface{}, xsz)
			}
			for cmr := range z.ChildValues {
				z.ChildValues[cmr], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					return
				}
			}
		case "ck":
			var xsz uint32
			xsz, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.ChildKeys) >= int(xsz) {
				z.ChildKeys = z.ChildKeys[:xsz]
			} else {
				z.ChildKeys = make(Keys, xsz)
			}
			for ajw := range z.ChildKeys {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ChildKeys[ajw] = nil
				} else {
					if z.ChildKeys[ajw] == nil {
						z.ChildKeys[ajw] = new(Key)
					}
					bts, err = z.ChildKeys[ajw].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
} PrettyPrintBody:[{ var field []byte _ = field var isz uint32 isz, bts, err = msgp.ReadMapHeaderBytes(bts) if err != nil { return } for isz > 0 { isz-- field, bts, err = msgp.ReadMapKeyZC(bts) if err != nil { return } switch msgp.UnsafeString(field) { case "id": { var tmp []byte tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.ID)) z.ID = ID(tmp) } if err != nil { return } case "il": z.IsLeaf, bts, err = msgp.ReadBoolBytes(bts) if err != nil { return } case "cv": var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap(z.ChildValues) >= int(xsz) { z.ChildValues = z.ChildValues[:xsz] } else { z.ChildValues = make([]interface{}, xsz) } for cmr := range z.ChildValues { z.ChildValues[cmr], bts, err = msgp.ReadIntfBytes(bts) if err != nil { return } } case "ck": var xsz uint32 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts) if err != nil { return } if cap(z.ChildKeys) >= int(xsz) { z.ChildKeys = z.ChildKeys[:xsz] } else { z.ChildKeys = make(Keys, xsz) } for ajw := range z.ChildKeys { if msgp.IsNil(bts) { bts, err = msgp.ReadNilBytes(bts) if err != nil { return } z.ChildKeys[ajw] = nil } else { if z.ChildKeys[ajw] == nil { z.ChildKeys[ajw] = new(Key) } bts, err = z.ChildKeys[ajw].UnmarshalMsg(bts) if err != nil { return } } } default: bts, err = msgp.Skip(bts) if err != nil { return } } } o = bts return }]} {Id:12 FileId:45 StartLine:290 StartColumn:1 EndLine:304 EndColumn:2 Name:Msgsize Params:[] Results:[{Name:s Type:int}] Receiver:0xc0009921e0 Body:{
	s = 1 + 3 + msgp.BytesPrefixSize + len([]byte(z.ID)) + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize
	for cmr := range z.ChildValues {
		s += msgp.GuessSize(z.ChildValues[cmr])
	}
	s += 3 + msgp.ArrayHeaderSize
	for ajw := range z.ChildKeys {
		if z.ChildKeys[ajw] == nil {
			s += msgp.NilSize
		} else {
			s += z.ChildKeys[ajw].Msgsize()
		}
	}
	return
} PrettyPrintBody:[{ s = 1 + 3 + msgp.BytesPrefixSize + len([]byte(z.ID)) + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize for cmr := range z.ChildValues { s += msgp.GuessSize(z.ChildValues[cmr]) } s += 3 + msgp.ArrayHeaderSize for ajw := range z.ChildKeys { if z.ChildKeys[ajw] == nil { s += msgp.NilSize } else { s += z.ChildKeys[ajw].Msgsize() } } return }]} {Id:1 FileId:59 StartLine:26 StartColumn:1 EndLine:42 EndColumn:2 Name:TestSearchKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := keys{newMockKey(1), newMockKey(2), newMockKey(4)}

	testKey := newMockKey(5)
	assert.Equal(t, 3, keySearch(keys, testKey))

	testKey = newMockKey(2)
	assert.Equal(t, 1, keySearch(keys, testKey))

	testKey = newMockKey(0)
	assert.Equal(t, 0, keySearch(keys, testKey))

	testKey = newMockKey(3)
	assert.Equal(t, 2, keySearch(keys, testKey))

	assert.Equal(t, 0, keySearch(nil, testKey))
} PrettyPrintBody:[{ keys := keys{newMockKey(1), newMockKey(2), newMockKey(4)} testKey := newMockKey(5) assert.Equal(t, 3, keySearch(keys, testKey)) testKey = newMockKey(2) assert.Equal(t, 1, keySearch(keys, testKey)) testKey = newMockKey(0) assert.Equal(t, 0, keySearch(keys, testKey)) testKey = newMockKey(3) assert.Equal(t, 2, keySearch(keys, testKey)) assert.Equal(t, 0, keySearch(nil, testKey)) }]} {Id:2 FileId:59 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:TestTreeInsert2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)

	tree.Insert(keys...)

	assert.Len(t, tree.root.(*inode).keys, 2)
	assert.Len(t, tree.root.(*inode).nodes, 3)
	assert.IsType(t, &inode{}, tree.root)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) tree.Insert(keys...) assert.Len(t, tree.root.(*inode).keys, 2) assert.Len(t, tree.root.(*inode).nodes, 3) assert.IsType(t, &inode{}, tree.root) }]} {Id:3 FileId:59 StartLine:55 StartColumn:1 EndLine:64 EndColumn:2 Name:TestTreeInsert3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	assert.Len(t, tree.root.(*inode).keys, 1)
	assert.Len(t, tree.root.(*inode).nodes, 2)
	assert.IsType(t, &inode{}, tree.root)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) assert.Len(t, tree.root.(*inode).keys, 1) assert.Len(t, tree.root.(*inode).nodes, 2) assert.IsType(t, &inode{}, tree.root) }]} {Id:4 FileId:59 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:TestTreeInsertQuery2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:5 FileId:59 StartLine:78 StartColumn:1 EndLine:88 EndColumn:2 Name:TestTreeInsertQuery3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:6 FileId:59 StartLine:90 StartColumn:1 EndLine:103 EndColumn:2 Name:TestTreeInsertReverseOrder2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	keys := constructMockKeys(4)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(3) keys := constructMockKeys(4) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]} {Id:7 FileId:59 StartLine:105 StartColumn:1 EndLine:118 EndColumn:2 Name:TestTreeInsertReverseOrder3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]} {Id:8 FileId:59 StartLine:120 StartColumn:1 EndLine:133 EndColumn:2 Name:TestTreeInsert3_4_5_WithEndDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(4)
	tree.Insert(duplicate)
	keys[4] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(4) tree.Insert(duplicate) keys[4] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:9 FileId:59 StartLine:135 StartColumn:1 EndLine:148 EndColumn:2 Name:TestTreeInsert3_4_5_WithMiddleDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(2)
	tree.Insert(duplicate)
	keys[2] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(2) tree.Insert(duplicate) keys[2] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:10 FileId:59 StartLine:150 StartColumn:1 EndLine:163 EndColumn:2 Name:TestTreeInsert3_4_5WithEarlyDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)
	duplicate := newMockKey(0)
	tree.Insert(duplicate)
	keys[0] = duplicate

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) duplicate := newMockKey(0) tree.Insert(duplicate) keys[0] = duplicate iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:11 FileId:59 StartLine:165 StartColumn:1 EndLine:177 EndColumn:2 Name:TestTreeInsert3_4_5WithDuplicateID Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	key := newMockKey(2)
	tree.Insert(keys...)
	tree.Insert(key)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) key := newMockKey(2) tree.Insert(keys...) tree.Insert(key) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:12 FileId:59 StartLine:179 StartColumn:1 EndLine:189 EndColumn:2 Name:TestTreeInsert3_4_5MiddleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(2))
	result := iter.exhaust()

	assert.Equal(t, keys[2:], result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(2)) result := iter.exhaust() assert.Equal(t, keys[2:], result) }]} {Id:13 FileId:59 StartLine:191 StartColumn:1 EndLine:201 EndColumn:2 Name:TestTreeInsert3_4_5LateQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(4))
	result := iter.exhaust()

	assert.Equal(t, keys[4:], result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(4)) result := iter.exhaust() assert.Equal(t, keys[4:], result) }]} {Id:14 FileId:59 StartLine:203 StartColumn:1 EndLine:213 EndColumn:2 Name:TestTreeInsert3_4_5AfterQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(5)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(5))
	result := iter.exhaust()

	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(5) tree.Insert(keys...) iter := tree.Iter(newMockKey(5)) result := iter.exhaust() assert.Len(t, result, 0) }]} {Id:15 FileId:59 StartLine:215 StartColumn:1 EndLine:225 EndColumn:2 Name:TestTreeInternalNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(10)

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(10) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Equal(t, keys, result) }]} {Id:16 FileId:59 StartLine:227 StartColumn:1 EndLine:239 EndColumn:2 Name:TestTreeInternalNodeSplitReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(4)
	keys := constructMockKeys(10)
	keys.reverse()

	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()
	keys.reverse()

	assert.Equal(t, keys, result)
} PrettyPrintBody:[{ tree := newBTree(4) keys := constructMockKeys(10) keys.reverse() tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() keys.reverse() assert.Equal(t, keys, result) }]} {Id:17 FileId:59 StartLine:241 StartColumn:1 EndLine:259 EndColumn:2 Name:TestTreeInternalNodeSplitRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5}
	keys := make(keys, 0, len(ids))

	for _, id := range ids {
		keys = append(keys, newMockKey(id))
	}

	tree := newBTree(4)
	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(0))
	result := iter.exhaust()

	assert.Len(t, result, 10)
	for i, key := range result {
		assert.Equal(t, newMockKey(i), key)
	}
} PrettyPrintBody:[{ ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5} keys := make(keys, 0, len(ids)) for _, id := range ids { keys = append(keys, newMockKey(id)) } tree := newBTree(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(0)) result := iter.exhaust() assert.Len(t, result, 10) for i, key := range result { assert.Equal(t, newMockKey(i), key) } }]} {Id:18 FileId:59 StartLine:261 StartColumn:1 EndLine:279 EndColumn:2 Name:TestTreeRandomOrderQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5}
	keys := make(keys, 0, len(ids))

	for _, id := range ids {
		keys = append(keys, newMockKey(id))
	}

	tree := newBTree(4)
	tree.Insert(keys...)

	iter := tree.Iter(newMockKey(4))
	result := iter.exhaust()

	assert.Len(t, result, 6)
	for i, key := range result {
		assert.Equal(t, newMockKey(i+4), key)
	}
} PrettyPrintBody:[{ ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5} keys := make(keys, 0, len(ids)) for _, id := range ids { keys = append(keys, newMockKey(id)) } tree := newBTree(4) tree.Insert(keys...) iter := tree.Iter(newMockKey(4)) result := iter.exhaust() assert.Len(t, result, 6) for i, key := range result { assert.Equal(t, newMockKey(i+4), key) } }]} {Id:19 FileId:59 StartLine:281 StartColumn:1 EndLine:291 EndColumn:2 Name:TestTreeGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructRandomMockKeys(100)
	tree := newBTree(64)
	tree.Insert(keys...)

	assert.Equal(t, uint64(100), tree.Len())
	fromTree := tree.Get(keys...)
	for _, key := range keys {
		assert.Contains(t, fromTree, key)
	}
} PrettyPrintBody:[{ keys := constructRandomMockKeys(100) tree := newBTree(64) tree.Insert(keys...) assert.Equal(t, uint64(100), tree.Len()) fromTree := tree.Get(keys...) for _, key := range keys { assert.Contains(t, fromTree, key) } }]} {Id:20 FileId:59 StartLine:293 StartColumn:1 EndLine:299 EndColumn:2 Name:TestTreeGetNotFound Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockKeys(5)
	tree := newBTree(64)
	tree.Insert(keys...)

	assert.Equal(t, Keys{nil}, tree.Get(newMockKey(20)))
} PrettyPrintBody:[{ keys := constructMockKeys(5) tree := newBTree(64) tree.Insert(keys...) assert.Equal(t, Keys{nil}, tree.Get(newMockKey(20))) }]} {Id:21 FileId:59 StartLine:301 StartColumn:1 EndLine:308 EndColumn:2 Name:TestGetExactMatchesOnly Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := newMockKey(0)
	k2 := newMockKey(5)
	tree := newBTree(64)
	tree.Insert(k1, k2)

	assert.Equal(t, Keys{nil}, tree.Get(newMockKey(3)))
} PrettyPrintBody:[{ k1 := newMockKey(0) k2 := newMockKey(5) tree := newBTree(64) tree.Insert(k1, k2) assert.Equal(t, Keys{nil}, tree.Get(newMockKey(3))) }]} {Id:22 FileId:59 StartLine:310 StartColumn:1 EndLine:325 EndColumn:2 Name:BenchmarkIteration Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)
	tree.Insert(keys...)

	searchKey := newMockKey(0)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		iter := tree.Iter(searchKey)
		iter.exhaust()
	}
} PrettyPrintBody:[{ numItems := 1000 ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) tree.Insert(keys...) searchKey := newMockKey(0) b.ResetTimer() for i := 0; i < b.N; i++ { iter := tree.Iter(searchKey) iter.exhaust() } }]} {Id:23 FileId:59 StartLine:327 StartColumn:1 EndLine:338 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]} {Id:24 FileId:59 StartLine:340 StartColumn:1 EndLine:350 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := constructRandomMockKeys(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newBTree(1024)
		tree.Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := constructRandomMockKeys(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newBTree(1024) tree.Insert(keys...) } }]} {Id:25 FileId:59 StartLine:352 StartColumn:1 EndLine:365 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	ary := uint64(16)

	keys := constructMockKeys(numItems)
	tree := newBTree(ary)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N ary := uint64(16) keys := constructMockKeys(numItems) tree := newBTree(ary) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]} {Id:26 FileId:59 StartLine:367 StartColumn:1 EndLine:381 EndColumn:2 Name:BenchmarkBulkAddToExisting Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	keySet := make([]keys, 0, b.N)
	for i := 0; i < b.N; i++ {
		keySet = append(keySet, constructRandomMockKeys(numItems))
	}

	tree := newBTree(1024)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keySet[i]...)
	}
} PrettyPrintBody:[{ numItems := 100000 keySet := make([]keys, 0, b.N) for i := 0; i < b.N; i++ { keySet = append(keySet, constructRandomMockKeys(numItems)) } tree := newBTree(1024) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keySet[i]...) } }]} {Id:27 FileId:59 StartLine:383 StartColumn:1 EndLine:397 EndColumn:2 Name:BenchmarkReadAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ks := make([]keys, 0, b.N)
	for i := 0; i < b.N; i++ {
		ks = append(ks, constructRandomMockKeys(numItems))
	}

	tree := newBTree(16)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(ks[i]...)
		tree.Get(ks[i]...)
	}
} PrettyPrintBody:[{ numItems := 1000 ks := make([]keys, 0, b.N) for i := 0; i < b.N; i++ { ks = append(ks, constructRandomMockKeys(numItems)) } tree := newBTree(16) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(ks[i]...) tree.Get(ks[i]...) } }]} {Id:28 FileId:59 StartLine:399 StartColumn:1 EndLine:428 EndColumn:2 Name:BenchmarkSimultaneousReadsAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	numRoutines := 8
	keys := constructRandomMockKeys(numItems)
	chunks := chunkKeys(keys, int64(numRoutines))

	trees := make([]*btree, 0, numItems)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newBTree(8))
	}

	var wg sync.WaitGroup
	var lock sync.Mutex
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(numRoutines)
		for j := 0; j < numRoutines; j++ {
			go func(i, j int) {
				lock.Lock()
				trees[i].Insert(chunks[j]...)
				trees[i].Get(chunks[j]...)
				lock.Unlock()
				wg.Done()
			}(i, j)
		}

		wg.Wait()
	}
} PrettyPrintBody:[{ numItems := 10000 numRoutines := 8 keys := constructRandomMockKeys(numItems) chunks := chunkKeys(keys, int64(numRoutines)) trees := make([]*btree, 0, numItems) for i := 0; i < b.N; i++ { trees = append(trees, newBTree(8)) } var wg sync.WaitGroup var lock sync.Mutex b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(numRoutines) for j := 0; j < numRoutines; j++ { go func(i, j int) { lock.Lock() trees[i].Insert(chunks[j]...) trees[i].Get(chunks[j]...) lock.Unlock() wg.Done() }(i, j) } wg.Wait() } }]} {Id:2 FileId:138 StartLine:11 StartColumn:1 EndLine:21 EndColumn:2 Name:Compare Params:[{Name:other Type:Comparator}] Results:[{Name: Type:int}] Receiver:0xc00113e660 Body:{
	if mc == other.(mockComparator) {
		return 0
	}

	if mc > other.(mockComparator) {
		return 1
	}

	return -1
} PrettyPrintBody:[{ if mc == other.(mockComparator) { return 0 } if mc > other.(mockComparator) { return 1 } return -1 }]} {Id:3 FileId:138 StartLine:23 StartColumn:1 EndLine:30 EndColumn:2 Name:constructMockComparators Params:[{Name:values Type:...int}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	comparators := make(Comparators, 0, len(values))
	for _, v := range values {
		comparators = append(comparators, mockComparator(v))
	}

	return comparators
} PrettyPrintBody:[{ comparators := make(Comparators, 0, len(values)) for _, v := range values { comparators = append(comparators, mockComparator(v)) } return comparators }]} {Id:4 FileId:138 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:constructOrderedMockComparators Params:[{Name:upTo Type:int}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	comparators := make(Comparators, 0, upTo)
	for i := 0; i < upTo; i++ {
		comparators = append(comparators, mockComparator(i))
	}

	return comparators
} PrettyPrintBody:[{ comparators := make(Comparators, 0, upTo) for i := 0; i < upTo; i++ { comparators = append(comparators, mockComparator(i)) } return comparators }]} {Id:5 FileId:138 StartLine:41 StartColumn:1 EndLine:47 EndColumn:2 Name:reverseComparators Params:[{Name:comparators Type:Comparators}] Results:[{Name: Type:Comparators}] Receiver:<nil> Body:{
	for i := 0; i < len(comparators); i++ {
		li := len(comparators) - i - 1
		comparators[i], comparators[li] = comparators[li], comparators[i]
	}
	return comparators
} PrettyPrintBody:[{ for i := 0; i < len(comparators); i++ { li := len(comparators) - i - 1 comparators[i], comparators[li] = comparators[li], comparators[i] } return comparators }]} {Id:6 FileId:138 StartLine:49 StartColumn:1 EndLine:56 EndColumn:2 Name:TestDecomposeForSymMergeOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(7)

	v1, w, v2 := decomposeForSymMerge(3, comparators)
	assert.Equal(t, comparators[:2], v1)
	assert.Equal(t, comparators[2:5], w)
	assert.Equal(t, comparators[5:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(7) v1, w, v2 := decomposeForSymMerge(3, comparators) assert.Equal(t, comparators[:2], v1) assert.Equal(t, comparators[2:5], w) assert.Equal(t, comparators[5:], v2) }]} {Id:7 FileId:138 StartLine:58 StartColumn:1 EndLine:65 EndColumn:2 Name:TestDecomposeForSymMergeEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	v1, w, v2 := decomposeForSymMerge(5, comparators)

	assert.Equal(t, comparators[:1], v1)
	assert.Equal(t, comparators[1:6], w)
	assert.Equal(t, comparators[6:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) v1, w, v2 := decomposeForSymMerge(5, comparators) assert.Equal(t, comparators[:1], v1) assert.Equal(t, comparators[1:6], w) assert.Equal(t, comparators[6:], v2) }]} {Id:8 FileId:138 StartLine:67 StartColumn:1 EndLine:74 EndColumn:2 Name:TestNearCompleteDecomposeForSymMerge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	v1, w, v2 := decomposeForSymMerge(7, comparators)

	assert.Len(t, v1, 0)
	assert.Equal(t, comparators[:7], w)
	assert.Equal(t, comparators[7:], v2)
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) v1, w, v2 := decomposeForSymMerge(7, comparators) assert.Len(t, v1, 0) assert.Equal(t, comparators[:7], w) assert.Equal(t, comparators[7:], v2) }]} {Id:9 FileId:138 StartLine:76 StartColumn:1 EndLine:81 EndColumn:2 Name:TestDecomposePanicsWithWrongLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	comparators := constructOrderedMockComparators(8)
	assert.Panics(t, func() {
		decomposeForSymMerge(8, comparators)
	})
} PrettyPrintBody:[{ comparators := constructOrderedMockComparators(8) assert.Panics(t, func() { decomposeForSymMerge(8, comparators) }) }]} {Id:10 FileId:138 StartLine:83 StartColumn:1 EndLine:95 EndColumn:2 Name:TestSymSearch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5, 7, 9)
	w := constructMockComparators(1, 3, 9, 10)

	result := symSearch(u, w)
	assert.Equal(t, 2, result)

	u = constructMockComparators(1, 5, 7)
	w = constructMockComparators(1, 3, 9)

	result = symSearch(u, w)
	assert.Equal(t, 1, result)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5, 7, 9) w := constructMockComparators(1, 3, 9, 10) result := symSearch(u, w) assert.Equal(t, 2, result) u = constructMockComparators(1, 5, 7) w = constructMockComparators(1, 3, 9) result = symSearch(u, w) assert.Equal(t, 1, result) }]} {Id:11 FileId:138 StartLine:97 StartColumn:1 EndLine:107 EndColumn:2 Name:TestSwap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5, 7, 9)
	w := constructMockComparators(2, 8, 11, 13)
	u1 := constructMockComparators(1, 5, 2, 8)
	w1 := constructMockComparators(7, 9, 11, 13)

	swap(u, w, 2)

	assert.Equal(t, u1, u)
	assert.Equal(t, w1, w)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5, 7, 9) w := constructMockComparators(2, 8, 11, 13) u1 := constructMockComparators(1, 5, 2, 8) w1 := constructMockComparators(7, 9, 11, 13) swap(u, w, 2) assert.Equal(t, u1, u) assert.Equal(t, w1, w) }]} {Id:12 FileId:138 StartLine:109 StartColumn:1 EndLine:116 EndColumn:2 Name:TestSymMergeSmallLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5)
	w := constructMockComparators(2, 8)
	expected := constructMockComparators(1, 2, 5, 8)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5) w := constructMockComparators(2, 8) expected := constructMockComparators(1, 2, 5, 8) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:13 FileId:138 StartLine:118 StartColumn:1 EndLine:125 EndColumn:2 Name:TestSymMergeAlreadySorted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 5)
	w := constructMockComparators(6, 7)
	expected := constructMockComparators(1, 5, 6, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 5) w := constructMockComparators(6, 7) expected := constructMockComparators(1, 5, 6, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:14 FileId:138 StartLine:127 StartColumn:1 EndLine:134 EndColumn:2 Name:TestSymMergeAlreadySortedReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(6, 7)
	w := constructMockComparators(1, 5)
	expected := constructMockComparators(1, 5, 6, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(6, 7) w := constructMockComparators(1, 5) expected := constructMockComparators(1, 5, 6, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:15 FileId:138 StartLine:136 StartColumn:1 EndLine:143 EndColumn:2 Name:TestSymMergeUnevenLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 7)
	w := constructMockComparators(2, 4)
	expected := constructMockComparators(1, 2, 3, 4, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 7) w := constructMockComparators(2, 4) expected := constructMockComparators(1, 2, 3, 4, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:16 FileId:138 StartLine:145 StartColumn:1 EndLine:152 EndColumn:2 Name:TestSymMergeUnevenListsWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 7)
	expected := constructMockComparators(1, 2, 3, 4, 7)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 7) expected := constructMockComparators(1, 2, 3, 4, 7) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:17 FileId:138 StartLine:154 StartColumn:1 EndLine:161 EndColumn:2 Name:TestMergeVeryUnevenLists Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 7, 12, 15)
	w := constructMockComparators(2, 4)
	expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 7, 12, 15) w := constructMockComparators(2, 4) expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:18 FileId:138 StartLine:163 StartColumn:1 EndLine:170 EndColumn:2 Name:TestMergeVeryUnevenListsWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 7, 12, 15)
	expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 7, 12, 15) expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:19 FileId:138 StartLine:172 StartColumn:1 EndLine:179 EndColumn:2 Name:TestMergeVeryUnevenListsAlreadySorted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(5, 7, 9, 10, 11, 12)
	expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(5, 7, 9, 10, 11, 12) expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:20 FileId:138 StartLine:181 StartColumn:1 EndLine:188 EndColumn:2 Name:TestMergeVeryUnevenListsAlreadySortedWrongOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	w := constructMockComparators(2, 4)
	u := constructMockComparators(5, 7, 9, 10, 11, 12)
	expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ w := constructMockComparators(2, 4) u := constructMockComparators(5, 7, 9, 10, 11, 12) expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:21 FileId:138 StartLine:190 StartColumn:1 EndLine:197 EndColumn:2 Name:TestMergeVeryUnevenListIsSubset Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(2, 4)
	w := constructMockComparators(1, 3, 5, 7, 9)
	expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(2, 4) w := constructMockComparators(1, 3, 5, 7, 9) expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:22 FileId:138 StartLine:199 StartColumn:1 EndLine:206 EndColumn:2 Name:TestMergeVeryUnevenListIsSubsetReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	w := constructMockComparators(2, 4)
	u := constructMockComparators(1, 3, 5, 7, 9)
	expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ w := constructMockComparators(2, 4) u := constructMockComparators(1, 3, 5, 7, 9) expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:23 FileId:138 StartLine:208 StartColumn:1 EndLine:215 EndColumn:2 Name:TestMergeUnevenOneListIsOne Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1)
	w := constructMockComparators(0, 3, 5, 7, 9)
	expected := constructMockComparators(0, 1, 3, 5, 7, 9)

	u = SymMerge(u, w)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1) w := constructMockComparators(0, 3, 5, 7, 9) expected := constructMockComparators(0, 1, 3, 5, 7, 9) u = SymMerge(u, w) assert.Equal(t, expected, u) }]} {Id:24 FileId:138 StartLine:217 StartColumn:1 EndLine:223 EndColumn:2 Name:TestMergeEmptyList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	u := constructMockComparators(1, 3, 5)
	expected := constructMockComparators(1, 3, 5)

	u = SymMerge(u, nil)
	assert.Equal(t, expected, u)
} PrettyPrintBody:[{ u := constructMockComparators(1, 3, 5) expected := constructMockComparators(1, 3, 5) u = SymMerge(u, nil) assert.Equal(t, expected, u) }]} {Id:1 FileId:12 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:getIndexAndRemainder Params:[{Name:k Type:uint64}] Results:[{Name: Type:uint64} {Name: Type:uint64}] Receiver:<nil> Body:{
	return k / s, k % s
} PrettyPrintBody:[{ return k / s, k % s }]} {Id:2 FileId:12 StartLine:35 StartColumn:1 EndLine:50 EndColumn:2 Name:setLowest Params:[] Results:[] Receiver:0xc000e7fd00 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		if ba.blocks[i] == 0 {
			continue
		}

		pos := ba.blocks[i].findRightPosition()
		ba.lowest = (i * s) + pos
		ba.anyset = true
		return
	}

	ba.anyset = false
	ba.lowest = 0
	ba.highest = 0
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { if ba.blocks[i] == 0 { continue } pos := ba.blocks[i].findRightPosition() ba.lowest = (i * s) + pos ba.anyset = true return } ba.anyset = false ba.lowest = 0 ba.highest = 0 }]} {Id:3 FileId:12 StartLine:52 StartColumn:1 EndLine:67 EndColumn:2 Name:setHighest Params:[] Results:[] Receiver:0xc000e569a0 Body:{
	for i := len(ba.blocks) - 1; i >= 0; i-- {
		if ba.blocks[i] == 0 {
			continue
		}

		pos := ba.blocks[i].findLeftPosition()
		ba.highest = (uint64(i) * s) + pos
		ba.anyset = true
		return
	}

	ba.anyset = false
	ba.highest = 0
	ba.lowest = 0
} PrettyPrintBody:[{ for i := len(ba.blocks) - 1; i >= 0; i-- { if ba.blocks[i] == 0 { continue } pos := ba.blocks[i].findLeftPosition() ba.highest = (uint64(i) * s) + pos ba.anyset = true return } ba.anyset = false ba.highest = 0 ba.lowest = 0 }]} {Id:4 FileId:12 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:Capacity Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000bb6140 Body:{
	return uint64(len(ba.blocks)) * s
} PrettyPrintBody:[{ return uint64(len(ba.blocks)) * s }]} {Id:5 FileId:12 StartLine:75 StartColumn:1 EndLine:82 EndColumn:2 Name:ToNums Params:[] Results:[{Name: Type:[]uint64}] Receiver:0xc0001186a0 Body:{
	nums := make([]uint64, 0, ba.highest-ba.lowest/4)
	for i, block := range ba.blocks {
		block.toNums(uint64(i)*s, &nums)
	}

	return nums
} PrettyPrintBody:[{ nums := make([]uint64, 0, ba.highest-ba.lowest/4) for i, block := range ba.blocks { block.toNums(uint64(i)*s, &nums) } return nums }]} {Id:6 FileId:12 StartLine:85 StartColumn:1 EndLine:105 EndColumn:2 Name:SetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc000a23740 Body:{
	if k >= ba.Capacity() {
		return OutOfRangeError(k)
	}

	if !ba.anyset {
		ba.lowest = k
		ba.highest = k
		ba.anyset = true
	} else {
		if k < ba.lowest {
			ba.lowest = k
		} else if k > ba.highest {
			ba.highest = k
		}
	}

	i, pos := getIndexAndRemainder(k)
	ba.blocks[i] = ba.blocks[i].insert(pos)
	return nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return OutOfRangeError(k) } if !ba.anyset { ba.lowest = k ba.highest = k ba.anyset = true } else { if k < ba.lowest { ba.lowest = k } else if k > ba.highest { ba.highest = k } } i, pos := getIndexAndRemainder(k) ba.blocks[i] = ba.blocks[i].insert(pos) return nil }]} {Id:7 FileId:12 StartLine:109 StartColumn:1 EndLine:117 EndColumn:2 Name:GetBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:bool} {Name: Type:error}] Receiver:0xc001309760 Body:{
	if k >= ba.Capacity() {
		return false, OutOfRangeError(k)
	}

	i, pos := getIndexAndRemainder(k)
	result := ba.blocks[i]&block(1<<pos) != 0
	return result, nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return false, OutOfRangeError(k) } i, pos := getIndexAndRemainder(k) result := ba.blocks[i]&block(1<<pos) != 0 return result, nil }]} {Id:8 FileId:12 StartLine:120 StartColumn:1 EndLine:138 EndColumn:2 Name:ClearBit Params:[{Name:k Type:uint64}] Results:[{Name: Type:error}] Receiver:0xc001409d00 Body:{
	if k >= ba.Capacity() {
		return OutOfRangeError(k)
	}

	if !ba.anyset {
		return nil
	}

	i, pos := getIndexAndRemainder(k)
	ba.blocks[i] &^= block(1 << pos)

	if k == ba.highest {
		ba.setHighest()
	} else if k == ba.lowest {
		ba.setLowest()
	}
	return nil
} PrettyPrintBody:[{ if k >= ba.Capacity() { return OutOfRangeError(k) } if !ba.anyset { return nil } i, pos := getIndexAndRemainder(k) ba.blocks[i] &^= block(1 << pos) if k == ba.highest { ba.setHighest() } else if k == ba.lowest { ba.setLowest() } return nil }]} {Id:9 FileId:12 StartLine:142 StartColumn:1 EndLine:148 EndColumn:2 Name:Or Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc00019e160 Body:{
	if dba, ok := other.(*bitArray); ok {
		return orDenseWithDenseBitArray(ba, dba)
	}

	return orSparseWithDenseBitArray(other.(*sparseBitArray), ba)
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return orDenseWithDenseBitArray(ba, dba) } return orSparseWithDenseBitArray(other.(*sparseBitArray), ba) }]} {Id:10 FileId:12 StartLine:152 StartColumn:1 EndLine:158 EndColumn:2 Name:And Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc000a8a740 Body:{
	if dba, ok := other.(*bitArray); ok {
		return andDenseWithDenseBitArray(ba, dba)
	}

	return andSparseWithDenseBitArray(other.(*sparseBitArray), ba)
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return andDenseWithDenseBitArray(ba, dba) } return andSparseWithDenseBitArray(other.(*sparseBitArray), ba) }]} {Id:11 FileId:12 StartLine:162 StartColumn:1 EndLine:168 EndColumn:2 Name:Nand Params:[{Name:other Type:BitArray}] Results:[{Name: Type:BitArray}] Receiver:0xc0001e6360 Body:{
	if dba, ok := other.(*bitArray); ok {
		return nandDenseWithDenseBitArray(ba, dba)
	}

	return nandDenseWithSparseBitArray(ba, other.(*sparseBitArray))
} PrettyPrintBody:[{ if dba, ok := other.(*bitArray); ok { return nandDenseWithDenseBitArray(ba, dba) } return nandDenseWithSparseBitArray(ba, other.(*sparseBitArray)) }]} {Id:12 FileId:12 StartLine:171 StartColumn:1 EndLine:176 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0001e6380 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		ba.blocks[i] &= block(0)
	}
	ba.anyset = false
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] &= block(0) } ba.anyset = false }]} {Id:13 FileId:12 StartLine:179 StartColumn:1 EndLine:212 EndColumn:2 Name:Equals Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc000993940 Body:{
	if other.Capacity() == 0 && ba.highest > 0 {
		return false
	}

	if other.Capacity() == 0 && !ba.anyset {
		return true
	}

	var selfIndex uint64
	for iter := other.Blocks(); iter.Next(); {
		toIndex, otherBlock := iter.Value()
		if toIndex > selfIndex {
			for i := selfIndex; i < toIndex; i++ {
				if ba.blocks[i] > 0 {
					return false
				}
			}
		}

		selfIndex = toIndex
		if !ba.blocks[selfIndex].equals(otherBlock) {
			return false
		}
		selfIndex++
	}

	lastIndex, _ := getIndexAndRemainder(ba.highest)
	if lastIndex >= selfIndex {
		return false
	}

	return true
} PrettyPrintBody:[{ if other.Capacity() == 0 && ba.highest > 0 { return false } if other.Capacity() == 0 && !ba.anyset { return true } var selfIndex uint64 for iter := other.Blocks(); iter.Next(); { toIndex, otherBlock := iter.Value() if toIndex > selfIndex { for i := selfIndex; i < toIndex; i++ { if ba.blocks[i] > 0 { return false } } } selfIndex = toIndex if !ba.blocks[selfIndex].equals(otherBlock) { return false } selfIndex++ } lastIndex, _ := getIndexAndRemainder(ba.highest) if lastIndex >= selfIndex { return false } return true }]} {Id:14 FileId:12 StartLine:218 StartColumn:1 EndLine:228 EndColumn:2 Name:Intersects Params:[{Name:other Type:BitArray}] Results:[{Name: Type:bool}] Receiver:0xc0001e6720 Body:{
	if other.Capacity() > ba.Capacity() {
		return false
	}

	if sba, ok := other.(*sparseBitArray); ok {
		return ba.intersectsSparseBitArray(sba)
	}

	return ba.intersectsDenseBitArray(other.(*bitArray))
} PrettyPrintBody:[{ if other.Capacity() > ba.Capacity() { return false } if sba, ok := other.(*sparseBitArray); ok { return ba.intersectsSparseBitArray(sba) } return ba.intersectsDenseBitArray(other.(*bitArray)) }]} {Id:15 FileId:12 StartLine:231 StartColumn:1 EndLine:233 EndColumn:2 Name:Blocks Params:[] Results:[{Name: Type:Iterator}] Receiver:0xc0003e56e0 Body:{
	return newBitArrayIterator(ba)
} PrettyPrintBody:[{ return newBitArrayIterator(ba) }]} {Id:16 FileId:12 StartLine:235 StartColumn:1 EndLine:237 EndColumn:2 Name:IsEmpty Params:[] Results:[{Name: Type:bool}] Receiver:0xc00095b240 Body:{
	return !ba.anyset
} PrettyPrintBody:[{ return !ba.anyset }]} {Id:17 FileId:12 StartLine:240 StartColumn:1 EndLine:249 EndColumn:2 Name:complement Params:[] Results:[] Receiver:0xc00019e660 Body:{
	for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
		ba.blocks[i] = ^ba.blocks[i]
	}

	ba.setLowest()
	if ba.anyset {
		ba.setHighest()
	}
} PrettyPrintBody:[{ for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] = ^ba.blocks[i] } ba.setLowest() if ba.anyset { ba.setHighest() } }]} {Id:18 FileId:12 StartLine:251 StartColumn:1 EndLine:259 EndColumn:2 Name:intersectsSparseBitArray Params:[{Name:other Type:*sparseBitArray}] Results:[{Name: Type:bool}] Receiver:0xc0001e6a00 Body:{
	for i, index := range other.indices {
		if !ba.blocks[index].intersects(other.blocks[i]) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, index := range other.indices { if !ba.blocks[index].intersects(other.blocks[i]) { return false } } return true }]} {Id:19 FileId:12 StartLine:261 StartColumn:1 EndLine:269 EndColumn:2 Name:intersectsDenseBitArray Params:[{Name:other Type:*bitArray}] Results:[{Name: Type:bool}] Receiver:0xc000992380 Body:{
	for i, block := range other.blocks {
		if !ba.blocks[i].intersects(block) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, block := range other.blocks { if !ba.blocks[i].intersects(block) { return false } } return true }]} {Id:20 FileId:12 StartLine:271 StartColumn:1 EndLine:280 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:BitArray}] Receiver:0xc00095b480 Body:{
	blocks := make(blocks, len(ba.blocks))
	copy(blocks, ba.blocks)
	return &bitArray{
		blocks:		blocks,
		lowest:		ba.lowest,
		highest:	ba.highest,
		anyset:		ba.anyset,
	}
} PrettyPrintBody:[{ blocks := make(blocks, len(ba.blocks)) copy(blocks, ba.blocks) return &bitArray{ blocks:		blocks, lowest:		ba.lowest, highest:	ba.highest, anyset:		ba.anyset, } }]} {Id:21 FileId:12 StartLine:285 StartColumn:1 EndLine:307 EndColumn:2 Name:newBitArray Params:[{Name:size Type:uint64} {Name:args Type:...bool}] Results:[{Name: Type:*bitArray}] Receiver:<nil> Body:{
	i, r := getIndexAndRemainder(size)
	if r > 0 {
		i++
	}

	ba := &bitArray{
		blocks:	make([]block, i),
		anyset:	false,
	}

	if len(args) > 0 && args[0] == true {
		for i := uint64(0); i < uint64(len(ba.blocks)); i++ {
			ba.blocks[i] = maximumBlock
		}

		ba.lowest = 0
		ba.highest = i*s - 1
		ba.anyset = true
	}

	return ba
} PrettyPrintBody:[{ i, r := getIndexAndRemainder(size) if r > 0 { i++ } ba := &bitArray{ blocks:	make([]block, i), anyset:	false, } if len(args) > 0 && args[0] == true { for i := uint64(0); i < uint64(len(ba.blocks)); i++ { ba.blocks[i] = maximumBlock } ba.lowest = 0 ba.highest = i*s - 1 ba.anyset = true } return ba }]} {Id:22 FileId:12 StartLine:312 StartColumn:1 EndLine:314 EndColumn:2 Name:NewBitArray Params:[{Name:size Type:uint64} {Name:args Type:...bool}] Results:[{Name: Type:BitArray}] Receiver:<nil> Body:{
	return newBitArray(size, args...)
} PrettyPrintBody:[{ return newBitArray(size, args...) }]} {Id:1 FileId:95 StartLine:26 StartColumn:1 EndLine:41 EndColumn:2 Name:TestPriorityPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(2))

	assert.Len(t, q.items, 1)
	assert.Equal(t, mockItem(2), q.items[0])

	q.Put(mockItem(1))

	if !assert.Len(t, q.items, 2) {
		return
	}
	assert.Equal(t, mockItem(1), q.items[0])
	assert.Equal(t, mockItem(2), q.items[1])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(2)) assert.Len(t, q.items, 1) assert.Equal(t, mockItem(2), q.items[0]) q.Put(mockItem(1)) if !assert.Len(t, q.items, 2) { return } assert.Equal(t, mockItem(1), q.items[0]) assert.Equal(t, mockItem(2), q.items[1]) }]} {Id:2 FileId:95 StartLine:43 StartColumn:1 EndLine:84 EndColumn:2 Name:TestPriorityGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(2))
	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(2), result[0])
	assert.Len(t, q.items, 0)

	q.Put(mockItem(2))
	q.Put(mockItem(1))

	result, err = q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(1), result[0])
	assert.Len(t, q.items, 1)

	result, err = q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}

	assert.Equal(t, mockItem(2), result[0])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(2)) result, err := q.Get(2) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(2), result[0]) assert.Len(t, q.items, 0) q.Put(mockItem(2)) q.Put(mockItem(1)) result, err = q.Get(1) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(1), result[0]) assert.Len(t, q.items, 1) result, err = q.Get(2) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(2), result[0]) }]} {Id:3 FileId:95 StartLine:86 StartColumn:1 EndLine:92 EndColumn:2 Name:TestAddEmptyPriorityPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put()

	assert.Len(t, q.items, 0)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put() assert.Len(t, q.items, 0) }]} {Id:4 FileId:95 StartLine:94 StartColumn:1 EndLine:112 EndColumn:2 Name:TestPriorityGetNonPositiveNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	q.Put(mockItem(1))

	result, err := q.Get(0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 0)

	result, err = q.Get(-1)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 0)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) result, err := q.Get(0) if !assert.Nil(t, err) { return } assert.Len(t, result, 0) result, err = q.Get(-1) if !assert.Nil(t, err) { return } assert.Len(t, result, 0) }]} {Id:5 FileId:95 StartLine:114 StartColumn:1 EndLine:121 EndColumn:2 Name:TestPriorityEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	assert.True(t, q.Empty())

	q.Put(mockItem(1))

	assert.False(t, q.Empty())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) assert.True(t, q.Empty()) q.Put(mockItem(1)) assert.False(t, q.Empty()) }]} {Id:6 FileId:95 StartLine:123 StartColumn:1 EndLine:139 EndColumn:2 Name:TestPriorityGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)

	go func() {
		q.Put(mockItem(1))
	}()

	result, err := q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	if !assert.Len(t, result, 1) {
		return
	}
	assert.Equal(t, mockItem(1), result[0])
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) go func() { q.Put(mockItem(1)) }() result, err := q.Get(1) if !assert.Nil(t, err) { return } if !assert.Len(t, result, 1) { return } assert.Equal(t, mockItem(1), result[0]) }]} {Id:7 FileId:95 StartLine:141 StartColumn:1 EndLine:175 EndColumn:2 Name:TestMultiplePriorityGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	var wg sync.WaitGroup
	wg.Add(2)
	results := make([][]Item, 2)

	go func() {
		wg.Done()
		local, _ := q.Get(1)
		results[0] = local
		wg.Done()
	}()

	go func() {
		wg.Done()
		local, _ := q.Get(1)
		results[1] = local
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	q.Put(mockItem(1), mockItem(3), mockItem(2))
	wg.Wait()

	if !assert.Len(t, results[0], 1) || !assert.Len(t, results[1], 1) {
		return
	}

	assert.True(
		t, (results[0][0] == mockItem(1) && results[1][0] == mockItem(2)) ||
			results[0][0] == mockItem(2) && results[1][0] == mockItem(1),
	)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) var wg sync.WaitGroup wg.Add(2) results := make([][]Item, 2) go func() { wg.Done() local, _ := q.Get(1) results[0] = local wg.Done() }() go func() { wg.Done() local, _ := q.Get(1) results[1] = local wg.Done() }() wg.Wait() wg.Add(2) q.Put(mockItem(1), mockItem(3), mockItem(2)) wg.Wait() if !assert.Len(t, results[0], 1) || !assert.Len(t, results[1], 1) { return } assert.True( t, (results[0][0] == mockItem(1) && results[1][0] == mockItem(2)) || results[0][0] == mockItem(2) && results[1][0] == mockItem(1), ) }]} {Id:8 FileId:95 StartLine:177 StartColumn:1 EndLine:197 EndColumn:2 Name:TestEmptyPriorityGetWithDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	var wg sync.WaitGroup
	wg.Add(1)

	var err error
	go func() {
		wg.Done()
		_, err = q.Get(1)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)

	q.Dispose()

	wg.Wait()

	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) var wg sync.WaitGroup wg.Add(1) var err error go func() { wg.Done() _, err = q.Get(1) wg.Done() }() wg.Wait() wg.Add(1) q.Dispose() wg.Wait() assert.IsType(t, ErrDisposed, err) }]} {Id:9 FileId:95 StartLine:199 StartColumn:1 EndLine:208 EndColumn:2 Name:TestPriorityGetPutDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Dispose()

	_, err := q.Get(1)
	assert.IsType(t, ErrDisposed, err)

	err = q.Put(mockItem(1))
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Dispose() _, err := q.Get(1) assert.IsType(t, ErrDisposed, err) err = q.Put(mockItem(1)) assert.IsType(t, ErrDisposed, err) }]} {Id:10 FileId:95 StartLine:210 StartColumn:1 EndLine:232 EndColumn:2 Name:BenchmarkPriorityQueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(b.N, false)
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			q.Get(1)
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		q.Put(mockItem(i))
	}

	wg.Wait()
} PrettyPrintBody:[{ q := NewPriorityQueue(b.N, false) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { q.Get(1) i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { q.Put(mockItem(i)) } wg.Wait() }]} {Id:11 FileId:95 StartLine:234 StartColumn:1 EndLine:239 EndColumn:2 Name:TestPriorityPeek Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Put(mockItem(1))

	assert.Equal(t, mockItem(1), q.Peek())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) assert.Equal(t, mockItem(1), q.Peek()) }]} {Id:12 FileId:95 StartLine:241 StartColumn:1 EndLine:247 EndColumn:2 Name:TestInsertDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(1, false)
	q.Put(mockItem(1))
	q.Put(mockItem(1))

	assert.Equal(t, 1, q.Len())
} PrettyPrintBody:[{ q := NewPriorityQueue(1, false) q.Put(mockItem(1)) q.Put(mockItem(1)) assert.Equal(t, 1, q.Len()) }]} {Id:13 FileId:95 StartLine:249 StartColumn:1 EndLine:255 EndColumn:2 Name:TestAllowDuplicates Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := NewPriorityQueue(2, true)
	q.Put(mockItem(1))
	q.Put(mockItem(1))

	assert.Equal(t, 2, q.Len())
} PrettyPrintBody:[{ q := NewPriorityQueue(2, true) q.Put(mockItem(1)) q.Put(mockItem(1)) assert.Equal(t, 2, q.Len()) }]} {Id:1 FileId:37 StartLine:27 StartColumn:1 EndLine:43 EndColumn:2 Name:AddItems Params:[{Name:its Type:...*Item}] Results:[{Name: Type:[]*Item} {Name: Type:error}] Receiver:0xc001308d40 Body:{
	if len(its) == 0 {
		return nil, nil
	}

	keys := make(Keys, 0, len(its))
	for _, item := range its {
		keys = append(keys, &Key{Value: item.Value, Payload: item.Payload})
	}

	overwrittens, err := t.add(keys)
	if err != nil {
		return nil, err
	}

	return overwrittens.toItems(), nil
} PrettyPrintBody:[{ if len(its) == 0 { return nil, nil } keys := make(Keys, 0, len(its)) for _, item := range its { keys = append(keys, &Key{Value: item.Value, Payload: item.Payload}) } overwrittens, err := t.add(keys) if err != nil { return nil, err } return overwrittens.toItems(), nil }]} {Id:2 FileId:37 StartLine:45 StartColumn:1 EndLine:116 EndColumn:2 Name:add Params:[{Name:keys Type:Keys}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:0xc001246160 Body:{
	if t.Root == nil {
		n := t.createRoot()
		t.Root = n.ID
		t.context.addNode(n)
	}

	nodes, err := t.determinePaths(keys)
	if err != nil {
		return nil, err
	}

	var overwrittens Keys

	var wg sync.WaitGroup
	wg.Add(len(nodes))
	var treeLock sync.Mutex
	localOverwrittens := make([]Keys, len(nodes))
	tree := make(map[string]*path, runtime.NumCPU())
	lerr := terr.New()

	i := 0
	for id, bundles := range nodes {
		go func(i int, id string, bundles []*nodeBundle) {
			defer wg.Done()
			if len(bundles) == 0 {
				return
			}

			n, err := t.contextOrCachedNode(ID(id), true)
			if err != nil {
				lerr.Set(err)
				return
			}

			if !t.context.nodeExists(n.ID) {
				n = n.copy()
				t.context.addNode(n)
			}

			overwrittens, err := insertLastDimension(t, n, bundles)

			if err != nil {
				lerr.Set(err)
				return
			}

			localOverwrittens[i] = overwrittens
			path := bundles[0].path
			treeLock.Lock()
			tree[string(n.ID)] = path
			treeLock.Unlock()
		}(i, id, bundles)
		i++
	}

	wg.Wait()

	if lerr.Get() != nil {
		return nil, lerr.Get()
	}

	t.walkupInsert(tree)

	for _, chunk := range localOverwrittens {
		overwrittens = append(overwrittens, chunk...)
	}

	t.Count += len(keys) - len(overwrittens)

	return overwrittens, nil
} PrettyPrintBody:[{ if t.Root == nil { n := t.createRoot() t.Root = n.ID t.context.addNode(n) } nodes, err := t.determinePaths(keys) if err != nil { return nil, err } var overwrittens Keys var wg sync.WaitGroup wg.Add(len(nodes)) var treeLock sync.Mutex localOverwrittens := make([]Keys, len(nodes)) tree := make(map[string]*path, runtime.NumCPU()) lerr := terr.New() i := 0 for id, bundles := range nodes { go func(i int, id string, bundles []*nodeBundle) { defer wg.Done() if len(bundles) == 0 { return } n, err := t.contextOrCachedNode(ID(id), true) if err != nil { lerr.Set(err) return } if !t.context.nodeExists(n.ID) { n = n.copy() t.context.addNode(n) } overwrittens, err := insertLastDimension(t, n, bundles) if err != nil { lerr.Set(err) return } localOverwrittens[i] = overwrittens path := bundles[0].path treeLock.Lock() tree[string(n.ID)] = path treeLock.Unlock() }(i, id, bundles) i++ } wg.Wait() if lerr.Get() != nil { return nil, lerr.Get() } t.walkupInsert(tree) for _, chunk := range localOverwrittens { overwrittens = append(overwrittens, chunk...) } t.Count += len(keys) - len(overwrittens) return overwrittens, nil }]} {Id:3 FileId:37 StartLine:118 StartColumn:1 EndLine:162 EndColumn:2 Name:determinePaths Params:[{Name:keys Type:Keys}] Results:[{Name: Type:map[string][]*nodeBundle} {Name: Type:error}] Receiver:0xc0015811c0 Body:{
	chunks := splitKeys(keys, runtime.NumCPU())
	var wg sync.WaitGroup
	wg.Add(len(chunks))
	chunkPaths := make([]map[interface{}]*nodeBundle, len(chunks))
	lerr := terr.New()

	for i := range chunks {
		go func(i int) {
			defer wg.Done()
			keys := chunks[i]
			if len(keys) == 0 {
				return
			}
			mp := make(map[interface{}]*nodeBundle, len(keys))
			for _, key := range keys {
				path, err := t.iterativeFind(
					key.Value, t.Root,
				)

				if err != nil {
					lerr.Set(err)
					return
				}
				mp[key.Value] = &nodeBundle{path: path, k: key}
			}
			chunkPaths[i] = mp
		}(i)
	}

	wg.Wait()

	if lerr.Get() != nil {
		return nil, lerr.Get()
	}

	nodes := make(map[string][]*nodeBundle, 10)
	for _, chunk := range chunkPaths {
		for _, pb := range chunk {
			nodes[string(pb.path.peek().n.ID)] = append(nodes[string(pb.path.pop().n.ID)], pb)
		}
	}

	return nodes, nil
} PrettyPrintBody:[{ chunks := splitKeys(keys, runtime.NumCPU()) var wg sync.WaitGroup wg.Add(len(chunks)) chunkPaths := make([]map[interface{}]*nodeBundle, len(chunks)) lerr := terr.New() for i := range chunks { go func(i int) { defer wg.Done() keys := chunks[i] if len(keys) == 0 { return } mp := make(map[interface{}]*nodeBundle, len(keys)) for _, key := range keys { path, err := t.iterativeFind( key.Value, t.Root, ) if err != nil { lerr.Set(err) return } mp[key.Value] = &nodeBundle{path: path, k: key} } chunkPaths[i] = mp }(i) } wg.Wait() if lerr.Get() != nil { return nil, lerr.Get() } nodes := make(map[string][]*nodeBundle, 10) for _, chunk := range chunkPaths { for _, pb := range chunk { nodes[string(pb.path.peek().n.ID)] = append(nodes[string(pb.path.pop().n.ID)], pb) } } return nodes, nil }]} {Id:4 FileId:37 StartLine:164 StartColumn:1 EndLine:203 EndColumn:2 Name:insertByMerge Params:[{Name:comparator Type:Comparator} {Name:n Type:*Node} {Name:bundles Type:[]*nodeBundle}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:<nil> Body:{
	positions := make(map[interface{}]int, len(n.ChildValues))
	overwrittens := make(Keys, 0, 10)

	for i, value := range n.ChildValues {
		positions[value] = i
	}

	for _, bundle := range bundles {
		if i, ok := positions[bundle.k.Value]; ok {
			overwrittens = append(overwrittens, n.ChildKeys[i])
			n.ChildKeys[i] = bundle.k
		} else {
			n.ChildValues = append(n.ChildValues, bundle.k.Value)
			n.ChildKeys = append(n.ChildKeys, bundle.k)
		}
	}

	nsw := &nodeSortWrapper{
		values:		n.ChildValues,
		keys:		n.ChildKeys,
		comparator:	comparator,
	}

	sort.Sort(nsw)

	for i := 0; i < len(nsw.values); i++ {
		if nsw.values[i] != nil {
			nsw.values = nsw.values[i:]
			nsw.keys = nsw.keys[i:]
			break
		}

		nsw.keys[i] = nil
	}

	n.ChildValues = nsw.values
	n.ChildKeys = nsw.keys
	return overwrittens, nil
} PrettyPrintBody:[{ positions := make(map[interface{}]int, len(n.ChildValues)) overwrittens := make(Keys, 0, 10) for i, value := range n.ChildValues { positions[value] = i } for _, bundle := range bundles { if i, ok := positions[bundle.k.Value]; ok { overwrittens = append(overwrittens, n.ChildKeys[i]) n.ChildKeys[i] = bundle.k } else { n.ChildValues = append(n.ChildValues, bundle.k.Value) n.ChildKeys = append(n.ChildKeys, bundle.k) } } nsw := &nodeSortWrapper{ values:		n.ChildValues, keys:		n.ChildKeys, comparator:	comparator, } sort.Sort(nsw) for i := 0; i < len(nsw.values); i++ { if nsw.values[i] != nil { nsw.values = nsw.values[i:] nsw.keys = nsw.keys[i:] break } nsw.keys[i] = nil } n.ChildValues = nsw.values n.ChildKeys = nsw.keys return overwrittens, nil }]} {Id:5 FileId:37 StartLine:205 StartColumn:1 EndLine:219 EndColumn:2 Name:insertLastDimension Params:[{Name:t Type:*Tr} {Name:n Type:*Node} {Name:bundles Type:[]*nodeBundle}] Results:[{Name: Type:Keys} {Name: Type:error}] Receiver:<nil> Body:{
	if n.IsLeaf && len(bundles) >= n.lenValues()/16 {
		return insertByMerge(t.config.Comparator, n, bundles)
	}

	overwrittens := make(Keys, 0, len(bundles))
	for _, bundle := range bundles {
		overwritten := n.insert(t.config.Comparator, bundle.k)
		if overwritten != nil {
			overwrittens = append(overwrittens, overwritten)
		}
	}

	return overwrittens, nil
} PrettyPrintBody:[{ if n.IsLeaf && len(bundles) >= n.lenValues()/16 { return insertByMerge(t.config.Comparator, n, bundles) } overwrittens := make(Keys, 0, len(bundles)) for _, bundle := range bundles { overwritten := n.insert(t.config.Comparator, bundle.k) if overwritten != nil { overwrittens = append(overwrittens, overwritten) } } return overwrittens, nil }]} {Id:6 FileId:37 StartLine:221 StartColumn:1 EndLine:230 EndColumn:2 Name:iterativeSplit Params:[{Name:n Type:*Node}] Results:[{Name: Type:Keys}] Receiver:0xc000993b60 Body:{
	keys := make(Keys, 0, 10)
	for n.needsSplit(t.config.NodeWidth) {
		leftValue, leftNode := n.splitAt(t.config.NodeWidth / 2)
		t.context.addNode(leftNode)
		keys = append(keys, &Key{UUID: leftNode.ID, Value: leftValue})
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, 10) for n.needsSplit(t.config.NodeWidth) { leftValue, leftNode := n.splitAt(t.config.NodeWidth / 2) t.context.addNode(leftNode) keys = append(keys, &Key{UUID: leftNode.ID, Value: leftValue}) } return keys }]} {Id:7 FileId:37 StartLine:235 StartColumn:1 EndLine:319 EndColumn:2 Name:walkupInsert Params:[{Name:nodes Type:map[string]*path}] Results:[{Name: Type:error}] Receiver:0xc000a8b260 Body:{
	mapping := make(map[string]*Node, len(nodes))

	for len(nodes) > 0 {
		splitNodes := make(map[string]Keys)
		newNodes := make(map[string]*path)
		for id, path := range nodes {
			node := t.context.getNode(ID(id))

			parentPath := path.pop()
			if parentPath == nil {
				t.Root = node.ID
				continue
			}

			parent := parentPath.n
			newNode := mapping[string(parent.ID)]
			if newNode == nil {
				if !t.context.nodeExists(parent.ID) {
					cp := parent.copy()
					if string(t.Root) == string(parent.ID) {
						t.Root = cp.ID
					}

					t.context.addNode(cp)
					mapping[string(parent.ID)] = cp
					parent = cp
				} else {
					newNode = t.context.getNode(parent.ID)
					mapping[string(parent.ID)] = newNode
					parent = newNode
				}
			} else {
				parent = newNode
			}

			i := parentPath.i

			parent.replaceKeyAt(&Key{UUID: node.ID}, i)
			splitNodes[string(parent.ID)] = append(splitNodes[string(parent.ID)], t.iterativeSplit(node)...)
			newNodes[string(parent.ID)] = path
		}

		var wg sync.WaitGroup
		wg.Add(len(splitNodes))
		lerr := terr.New()

		for id, keys := range splitNodes {
			go func(id ID, keys Keys) {
				defer wg.Done()
				n, err := t.contextOrCachedNode(id, true)
				if err != nil {
					lerr.Set(err)
					return
				}
				for _, key := range keys {
					n.insert(t.config.Comparator, key)
				}
			}(ID(id), keys)
		}

		wg.Wait()

		if lerr.Get() != nil {
			return lerr.Get()
		}

		nodes = newNodes
	}

	n := t.context.getNode(t.Root)
	for n.needsSplit(t.config.NodeWidth) {
		root := newNode()
		t.Root = root.ID
		t.context.addNode(root)
		root.appendChild(&Key{UUID: n.ID})
		keys := t.iterativeSplit(n)
		for _, key := range keys {
			root.insert(t.config.Comparator, key)
		}
		n = root
	}

	return nil
} PrettyPrintBody:[{ mapping := make(map[string]*Node, len(nodes)) for len(nodes) > 0 { splitNodes := make(map[string]Keys) newNodes := make(map[string]*path) for id, path := range nodes { node := t.context.getNode(ID(id)) parentPath := path.pop() if parentPath == nil { t.Root = node.ID continue } parent := parentPath.n newNode := mapping[string(parent.ID)] if newNode == nil { if !t.context.nodeExists(parent.ID) { cp := parent.copy() if string(t.Root) == string(parent.ID) { t.Root = cp.ID } t.context.addNode(cp) mapping[string(parent.ID)] = cp parent = cp } else { newNode = t.context.getNode(parent.ID) mapping[string(parent.ID)] = newNode parent = newNode } } else { parent = newNode } i := parentPath.i parent.replaceKeyAt(&Key{UUID: node.ID}, i) splitNodes[string(parent.ID)] = append(splitNodes[string(parent.ID)], t.iterativeSplit(node)...) newNodes[string(parent.ID)] = path } var wg sync.WaitGroup wg.Add(len(splitNodes)) lerr := terr.New() for id, keys := range splitNodes { go func(id ID, keys Keys) { defer wg.Done() n, err := t.contextOrCachedNode(id, true) if err != nil { lerr.Set(err) return } for _, key := range keys { n.insert(t.config.Comparator, key) } }(ID(id), keys) } wg.Wait() if lerr.Get() != nil { return lerr.Get() } nodes = newNodes } n := t.context.getNode(t.Root) for n.needsSplit(t.config.NodeWidth) { root := newNode() t.Root = root.ID t.context.addNode(root) root.appendChild(&Key{UUID: n.ID}) keys := t.iterativeSplit(n) for _, key := range keys { root.insert(t.config.Comparator, key) } n = root } return nil }]} {Id:1 FileId:64 StartLine:26 StartColumn:1 EndLine:33 EndColumn:2 Name:constructMockPayloads Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(i)) } return keys }]} {Id:2 FileId:64 StartLine:35 StartColumn:1 EndLine:43 EndColumn:2 Name:constructMockKeys Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)

	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(i)) } return keys }]} {Id:3 FileId:64 StartLine:45 StartColumn:1 EndLine:52 EndColumn:2 Name:constructRandomMockKeys Params:[{Name:num Type:int}] Results:[{Name: Type:keys}] Receiver:<nil> Body:{
	keys := make(keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, newMockKey(rand.Int()))
	}

	return keys
} PrettyPrintBody:[{ keys := make(keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, newMockKey(rand.Int())) } return keys }]} {Id:4 FileId:64 StartLine:54 StartColumn:1 EndLine:72 EndColumn:2 Name:constructMockNodes Params:[{Name:num Type:int}] Results:[{Name: Type:nodes}] Receiver:<nil> Body:{
	nodes := make(nodes, 0, num)
	for i := 0; i < num; i++ {
		keys := make(keys, 0, num)
		for j := 0; j < num; j++ {
			keys = append(keys, newMockKey(j*i+j))
		}

		node := &lnode{
			keys: keys,
		}
		nodes = append(nodes, node)
		if i > 0 {
			nodes[i-1].(*lnode).pointer = node
		}
	}

	return nodes
} PrettyPrintBody:[{ nodes := make(nodes, 0, num) for i := 0; i < num; i++ { keys := make(keys, 0, num) for j := 0; j < num; j++ { keys = append(keys, newMockKey(j*i+j)) } node := &lnode{ keys: keys, } nodes = append(nodes, node) if i > 0 { nodes[i-1].(*lnode).pointer = node } } return nodes }]} {Id:5 FileId:64 StartLine:74 StartColumn:1 EndLine:89 EndColumn:2 Name:constructMockInternalNode Params:[{Name:nodes Type:nodes}] Results:[{Name: Type:*inode}] Receiver:<nil> Body:{
	if len(nodes) < 2 {
		return nil
	}

	keys := make(keys, 0, len(nodes)-1)
	for i := 1; i < len(nodes); i++ {
		keys = append(keys, nodes[i].(*lnode).keys[0])
	}

	in := &inode{
		keys:	keys,
		nodes:	nodes,
	}
	return in
} PrettyPrintBody:[{ if len(nodes) < 2 { return nil } keys := make(keys, 0, len(nodes)-1) for i := 1; i < len(nodes); i++ { keys = append(keys, nodes[i].(*lnode).keys[0]) } in := &inode{ keys:	keys, nodes:	nodes, } return in }]} {Id:6 FileId:64 StartLine:91 StartColumn:1 EndLine:102 EndColumn:2 Name:TestLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)
	key := newMockKey(3)

	n.insert(tree, key)

	assert.Len(t, n.keys, 1)
	assert.Nil(t, n.pointer)
	assert.Equal(t, n.keys[0], key)
	assert.Equal(t, 0, n.keys[0].Compare(key))
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) key := newMockKey(3) n.insert(tree, key) assert.Len(t, n.keys, 1) assert.Nil(t, n.pointer) assert.Equal(t, n.keys[0], key) assert.Equal(t, 0, n.keys[0].Compare(key)) }]} {Id:7 FileId:64 StartLine:104 StartColumn:1 EndLine:113 EndColumn:2 Name:TestDuplicateLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)
	k1 := newMockKey(3)
	k2 := newMockKey(3)

	assert.True(t, n.insert(tree, k1))
	assert.False(t, n.insert(tree, k2))
	assert.False(t, n.insert(tree, k1))
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) k1 := newMockKey(3) k2 := newMockKey(3) assert.True(t, n.insert(tree, k1)) assert.False(t, n.insert(tree, k2)) assert.False(t, n.insert(tree, k1)) }]} {Id:8 FileId:64 StartLine:115 StartColumn:1 EndLine:131 EndColumn:2 Name:TestMultipleLeafNodeInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newBTree(3)
	n := newLeafNode(3)

	k1 := newMockKey(3)
	k2 := newMockKey(4)

	assert.True(t, n.insert(tree, k1))
	n.insert(tree, k2)

	if !assert.Len(t, n.keys, 2) {
		return
	}
	assert.Nil(t, n.pointer)
	assert.Equal(t, k1, n.keys[0])
	assert.Equal(t, k2, n.keys[1])
} PrettyPrintBody:[{ tree := newBTree(3) n := newLeafNode(3) k1 := newMockKey(3) k2 := newMockKey(4) assert.True(t, n.insert(tree, k1)) n.insert(tree, k2) if !assert.Len(t, n.keys, 2) { return } assert.Nil(t, n.pointer) assert.Equal(t, k1, n.keys[0]) assert.Equal(t, k2, n.keys[1]) }]} {Id:9 FileId:64 StartLine:133 StartColumn:1 EndLine:145 EndColumn:2 Name:TestLeafNodeSplitEvenNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(4)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[2], key)
	assert.Equal(t, left.(*lnode).keys, keys[:2])
	assert.Equal(t, right.(*lnode).keys, keys[2:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(4) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[2], key) assert.Equal(t, left.(*lnode).keys, keys[:2]) assert.Equal(t, right.(*lnode).keys, keys[2:]) assert.Equal(t, left.(*lnode).pointer, right) }]} {Id:10 FileId:64 StartLine:147 StartColumn:1 EndLine:159 EndColumn:2 Name:TestLeafNodeSplitOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(3)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[1], key)
	assert.Equal(t, left.(*lnode).keys, keys[:1])
	assert.Equal(t, right.(*lnode).keys, keys[1:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(3) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[1], key) assert.Equal(t, left.(*lnode).keys, keys[:1]) assert.Equal(t, right.(*lnode).keys, keys[1:]) assert.Equal(t, left.(*lnode).pointer, right) }]} {Id:11 FileId:64 StartLine:161 StartColumn:1 EndLine:173 EndColumn:2 Name:TestTwoKeysLeafNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(2)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Equal(t, keys[1], key)
	assert.Equal(t, left.(*lnode).keys, keys[:1])
	assert.Equal(t, right.(*lnode).keys, keys[1:])
	assert.Equal(t, left.(*lnode).pointer, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(2) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Equal(t, keys[1], key) assert.Equal(t, left.(*lnode).keys, keys[:1]) assert.Equal(t, right.(*lnode).keys, keys[1:]) assert.Equal(t, left.(*lnode).pointer, right) }]} {Id:12 FileId:64 StartLine:175 StartColumn:1 EndLine:186 EndColumn:2 Name:TestLessThanTwoKeysSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := constructMockPayloads(1)

	node := &lnode{
		keys: keys,
	}

	key, left, right := node.split()
	assert.Nil(t, key)
	assert.Nil(t, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ keys := constructMockPayloads(1) node := &lnode{ keys: keys, } key, left, right := node.split() assert.Nil(t, key) assert.Nil(t, left) assert.Nil(t, right) }]} {Id:13 FileId:64 StartLine:188 StartColumn:1 EndLine:198 EndColumn:2 Name:TestInternalNodeSplit2_3_4 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(4)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Equal(t, nodes[3].(*lnode).keys[0], key)
	assert.Len(t, left.(*inode).keys, 1)
	assert.Len(t, right.(*inode).keys, 1)
	assert.Equal(t, nodes[:2], left.(*inode).nodes)
	assert.Equal(t, nodes[2:], right.(*inode).nodes)
} PrettyPrintBody:[{ nodes := constructMockNodes(4) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Equal(t, nodes[3].(*lnode).keys[0], key) assert.Len(t, left.(*inode).keys, 1) assert.Len(t, right.(*inode).keys, 1) assert.Equal(t, nodes[:2], left.(*inode).nodes) assert.Equal(t, nodes[2:], right.(*inode).nodes) }]} {Id:14 FileId:64 StartLine:200 StartColumn:1 EndLine:210 EndColumn:2 Name:TestInternalNodeSplit3_4_5 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(5)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Equal(t, nodes[4].(*lnode).keys[0], key)
	assert.Len(t, left.(*inode).keys, 2)
	assert.Len(t, right.(*inode).keys, 1)
	assert.Equal(t, nodes[:3], left.(*inode).nodes)
	assert.Equal(t, nodes[3:], right.(*inode).nodes)
} PrettyPrintBody:[{ nodes := constructMockNodes(5) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Equal(t, nodes[4].(*lnode).keys[0], key) assert.Len(t, left.(*inode).keys, 2) assert.Len(t, right.(*inode).keys, 1) assert.Equal(t, nodes[:3], left.(*inode).nodes) assert.Equal(t, nodes[3:], right.(*inode).nodes) }]} {Id:15 FileId:64 StartLine:212 StartColumn:1 EndLine:220 EndColumn:2 Name:TestInternalNodeLessThan3Keys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	nodes := constructMockNodes(2)
	in := constructMockInternalNode(nodes)

	key, left, right := in.split()
	assert.Nil(t, key)
	assert.Nil(t, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ nodes := constructMockNodes(2) in := constructMockInternalNode(nodes) key, left, right := in.split() assert.Nil(t, key) assert.Nil(t, left) assert.Nil(t, right) }]} {Id:1 FileId:28 StartLine:25 StartColumn:1 EndLine:31 EndColumn:2 Name:TestGetCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() result, err := ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) }]} {Id:2 FileId:28 StartLine:33 StartColumn:1 EndLine:46 EndColumn:2 Name:BenchmarkGetCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()

	for i := 0; i < numItems; i++ {
		ba.SetBit(uint64(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.GetBit(s)
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() for i := 0; i < numItems; i++ { ba.SetBit(uint64(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.GetBit(s) } }]} {Id:3 FileId:28 StartLine:48 StartColumn:1 EndLine:65 EndColumn:2 Name:TestGetSetCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()

	ba.SetBit(5)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.True(t, result)
	result, err = ba.GetBit(7)
	assert.Nil(t, err)
	assert.False(t, result)

	ba.SetBit(s * 2)
	result, _ = ba.GetBit(s * 2)
	assert.True(t, result)
	result, _ = ba.GetBit(s*2 + 1)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) result, err := ba.GetBit(5) assert.Nil(t, err) assert.True(t, result) result, err = ba.GetBit(7) assert.Nil(t, err) assert.False(t, result) ba.SetBit(s * 2) result, _ = ba.GetBit(s * 2) assert.True(t, result) result, _ = ba.GetBit(s*2 + 1) assert.False(t, result) }]} {Id:4 FileId:28 StartLine:67 StartColumn:1 EndLine:77 EndColumn:2 Name:BenchmarkSetCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for j := 0; j < numItems; j++ {
			ba.SetBit(uint64(j))
		}
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() b.ResetTimer() for i := 0; i < b.N; i++ { for j := 0; j < numItems; j++ { ba.SetBit(uint64(j)) } } }]} {Id:5 FileId:28 StartLine:79 StartColumn:1 EndLine:97 EndColumn:2 Name:TestClearCompressedBit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	ba.SetBit(5)
	ba.ClearBit(5)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
	assert.Len(t, ba.blocks, 0)
	assert.Len(t, ba.indices, 0)

	ba.SetBit(s * 2)
	ba.ClearBit(s * 2)

	result, _ = ba.GetBit(s * 2)
	assert.False(t, result)
	assert.Len(t, ba.indices, 0)
	assert.Len(t, ba.blocks, 0)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) ba.ClearBit(5) result, err := ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) assert.Len(t, ba.blocks, 0) assert.Len(t, ba.indices, 0) ba.SetBit(s * 2) ba.ClearBit(s * 2) result, _ = ba.GetBit(s * 2) assert.False(t, result) assert.Len(t, ba.indices, 0) assert.Len(t, ba.blocks, 0) }]} {Id:6 FileId:28 StartLine:99 StartColumn:1 EndLine:111 EndColumn:2 Name:BenchmarkClearCompressedBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ba := newSparseBitArray()
	for i := 0; i < numItems; i++ {
		ba.SetBit(uint64(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.ClearBit(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 1000 ba := newSparseBitArray() for i := 0; i < numItems; i++ { ba.SetBit(uint64(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.ClearBit(uint64(i)) } }]} {Id:7 FileId:28 StartLine:113 StartColumn:1 EndLine:131 EndColumn:2 Name:TestClearCompressedBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	ba.SetBit(5)
	ba.SetBit(s * 2)

	result, err := ba.GetBit(5)
	assert.Nil(t, err)
	assert.True(t, result)
	result, _ = ba.GetBit(s * 2)
	assert.True(t, result)

	ba.Reset()

	result, err = ba.GetBit(5)
	assert.Nil(t, err)
	assert.False(t, result)
	result, _ = ba.GetBit(s * 2)
	assert.False(t, result)
} PrettyPrintBody:[{ ba := newSparseBitArray() ba.SetBit(5) ba.SetBit(s * 2) result, err := ba.GetBit(5) assert.Nil(t, err) assert.True(t, result) result, _ = ba.GetBit(s * 2) assert.True(t, result) ba.Reset() result, err = ba.GetBit(5) assert.Nil(t, err) assert.False(t, result) result, _ = ba.GetBit(s * 2) assert.False(t, result) }]} {Id:8 FileId:28 StartLine:133 StartColumn:1 EndLine:147 EndColumn:2 Name:TestCompressedEquals Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	assert.True(t, ba.Equals(other))

	ba.SetBit(5)
	assert.False(t, ba.Equals(other))

	other.SetBit(5)
	assert.True(t, ba.Equals(other))

	ba.ClearBit(5)
	assert.False(t, ba.Equals(other))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() assert.True(t, ba.Equals(other)) ba.SetBit(5) assert.False(t, ba.Equals(other)) other.SetBit(5) assert.True(t, ba.Equals(other)) ba.ClearBit(5) assert.False(t, ba.Equals(other)) }]} {Id:9 FileId:28 StartLine:149 StartColumn:1 EndLine:169 EndColumn:2 Name:TestCompressedIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	assert.True(t, ba.Intersects(other))

	other.SetBit(5)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	ba.SetBit(5)

	assert.True(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	other.SetBit(10)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() assert.True(t, ba.Intersects(other)) other.SetBit(5) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) ba.SetBit(5) assert.True(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) other.SetBit(10) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) }]} {Id:10 FileId:28 StartLine:171 StartColumn:1 EndLine:194 EndColumn:2 Name:TestLongCompressedIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newSparseBitArray()
	other := newSparseBitArray()

	ba.SetBit(5)
	other.SetBit(5)

	assert.True(t, ba.Intersects(other))

	other.SetBit(s * 2)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	ba.SetBit(s * 2)

	assert.True(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))

	other.SetBit(s*2 + 1)

	assert.False(t, ba.Intersects(other))
	assert.True(t, other.Intersects(ba))
} PrettyPrintBody:[{ ba := newSparseBitArray() other := newSparseBitArray() ba.SetBit(5) other.SetBit(5) assert.True(t, ba.Intersects(other)) other.SetBit(s * 2) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) ba.SetBit(s * 2) assert.True(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) other.SetBit(s*2 + 1) assert.False(t, ba.Intersects(other)) assert.True(t, other.Intersects(ba)) }]} {Id:11 FileId:28 StartLine:196 StartColumn:1 EndLine:212 EndColumn:2 Name:BenchmarkCompressedIntersects Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	ba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Intersects(other)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) ba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i++ { ba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.Intersects(other) } }]} {Id:12 FileId:28 StartLine:214 StartColumn:1 EndLine:237 EndColumn:2 Name:TestSparseIntersectsBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cba := newSparseBitArray()
	ba := newBitArray(s * 2)

	assert.True(t, cba.Intersects(ba))
	ba.SetBit(5)

	assert.False(t, cba.Intersects(ba))
	cba.SetBit(5)

	assert.True(t, cba.Intersects(ba))
	cba.SetBit(10)

	assert.True(t, cba.Intersects(ba))
	ba.SetBit(s + 1)

	assert.False(t, cba.Intersects(ba))
	cba.SetBit(s + 1)

	assert.True(t, cba.Intersects(ba))
	cba.SetBit(s * 3)

	assert.True(t, cba.Intersects(ba))
} PrettyPrintBody:[{ cba := newSparseBitArray() ba := newBitArray(s * 2) assert.True(t, cba.Intersects(ba)) ba.SetBit(5) assert.False(t, cba.Intersects(ba)) cba.SetBit(5) assert.True(t, cba.Intersects(ba)) cba.SetBit(10) assert.True(t, cba.Intersects(ba)) ba.SetBit(s + 1) assert.False(t, cba.Intersects(ba)) cba.SetBit(s + 1) assert.True(t, cba.Intersects(ba)) cba.SetBit(s * 3) assert.True(t, cba.Intersects(ba)) }]} {Id:13 FileId:28 StartLine:239 StartColumn:1 EndLine:256 EndColumn:2 Name:TestSparseEqualsBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cba := newSparseBitArray()
	ba := newBitArray(s * 2)

	assert.True(t, cba.Equals(ba))

	ba.SetBit(5)
	assert.False(t, cba.Equals(ba))

	cba.SetBit(5)
	assert.True(t, cba.Equals(ba))

	ba.SetBit(s + 1)
	assert.False(t, cba.Equals(ba))

	cba.SetBit(s + 1)
	assert.True(t, cba.Equals(ba))
} PrettyPrintBody:[{ cba := newSparseBitArray() ba := newBitArray(s * 2) assert.True(t, cba.Equals(ba)) ba.SetBit(5) assert.False(t, cba.Equals(ba)) cba.SetBit(5) assert.True(t, cba.Equals(ba)) ba.SetBit(s + 1) assert.False(t, cba.Equals(ba)) cba.SetBit(s + 1) assert.True(t, cba.Equals(ba)) }]} {Id:14 FileId:28 StartLine:258 StartColumn:1 EndLine:273 EndColumn:2 Name:BenchmarkCompressedEquals Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	cba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		cba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		cba.Equals(other)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) cba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i++ { cba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { cba.Equals(other) } }]} {Id:15 FileId:28 StartLine:275 StartColumn:1 EndLine:284 EndColumn:2 Name:TestInsertPreviousBlockInSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()

	sba.SetBit(s * 2)
	sba.SetBit(s - 1)

	result, err := sba.GetBit(s - 1)
	assert.Nil(t, err)
	assert.True(t, result)
} PrettyPrintBody:[{ sba := newSparseBitArray() sba.SetBit(s * 2) sba.SetBit(s - 1) result, err := sba.GetBit(s - 1) assert.Nil(t, err) assert.True(t, result) }]} {Id:16 FileId:28 StartLine:286 StartColumn:1 EndLine:296 EndColumn:2 Name:TestSparseBitArrayToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()

	sba.SetBit(s - 1)
	sba.SetBit(s + 1)

	expected := []uint64{s - 1, s + 1}

	results := sba.ToNums()
	assert.Equal(t, expected, results)
} PrettyPrintBody:[{ sba := newSparseBitArray() sba.SetBit(s - 1) sba.SetBit(s + 1) expected := []uint64{s - 1, s + 1} results := sba.ToNums() assert.Equal(t, expected, results) }]} {Id:17 FileId:28 StartLine:298 StartColumn:1 EndLine:310 EndColumn:2 Name:BenchmarkSparseBitArrayToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	sba := newSparseBitArray()

	for i := uint64(0); i < numItems; i++ {
		sba.SetBit(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sba.ToNums()
	}
} PrettyPrintBody:[{ numItems := uint64(1000) sba := newSparseBitArray() for i := uint64(0); i < numItems; i++ { sba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { sba.ToNums() } }]} {Id:1 FileId:66 StartLine:10 StartColumn:1 EndLine:22 EndColumn:2 Name:TestEvictionPolicy Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	c := &cache{keyList: list.New()}
	EvictionPolicy(LeastRecentlyUsed)(c)
	accessed, added := c.recordAccess("foo"), c.recordAdd("foo")
	assert.NotNil(t, accessed)
	assert.Nil(t, added)

	c = &cache{keyList: list.New()}
	EvictionPolicy(LeastRecentlyAdded)(c)
	accessed, added = c.recordAccess("foo"), c.recordAdd("foo")
	assert.Nil(t, accessed)
	assert.NotNil(t, added)
} PrettyPrintBody:[{ c := &cache{keyList: list.New()} EvictionPolicy(LeastRecentlyUsed)(c) accessed, added := c.recordAccess("foo"), c.recordAdd("foo") assert.NotNil(t, accessed) assert.Nil(t, added) c = &cache{keyList: list.New()} EvictionPolicy(LeastRecentlyAdded)(c) accessed, added = c.recordAccess("foo"), c.recordAdd("foo") assert.Nil(t, accessed) assert.NotNil(t, added) }]} {Id:2 FileId:66 StartLine:24 StartColumn:1 EndLine:41 EndColumn:2 Name:TestNew Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	optionApplied := false
	option := func(*cache) {
		optionApplied = true
	}

	c := New(314159, option).(*cache)

	assert.Equal(t, uint64(314159), c.cap)
	assert.Equal(t, uint64(0), c.size)
	assert.NotNil(t, c.items)
	assert.NotNil(t, c.keyList)
	assert.True(t, optionApplied)

	accessed, added := c.recordAccess("foo"), c.recordAdd("foo")
	assert.NotNil(t, accessed)
	assert.Nil(t, added)
} PrettyPrintBody:[{ optionApplied := false option := func(*cache) { optionApplied = true } c := New(314159, option).(*cache) assert.Equal(t, uint64(314159), c.cap) assert.Equal(t, uint64(0), c.size) assert.NotNil(t, c.items) assert.NotNil(t, c.keyList) assert.True(t, optionApplied) accessed, added := c.recordAccess("foo"), c.recordAdd("foo") assert.NotNil(t, accessed) assert.Nil(t, added) }]} {Id:4 FileId:66 StartLine:45 StartColumn:1 EndLine:47 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000f52720 Body:{
	return uint64(ti)
} PrettyPrintBody:[{ return uint64(ti) }]} {Id:5 FileId:66 StartLine:49 StartColumn:1 EndLine:122 EndColumn:2 Name:TestPutGetRemoveSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := []string{"foo", "bar", "baz"}
	testCases := []struct {
		label		string
		cache		Cache
		useCache	func(c Cache)
		expectedSize	uint64
		expectedItems	[]Item
	}{{
		label:	"Items added, key doesn't exist",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
		},
		expectedSize:	1,
		expectedItems:	[]Item{testItem(1), nil, nil},
	}, {
		label:	"Items added, key exists",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("foo", testItem(10))
		},
		expectedSize:	10,
		expectedItems:	[]Item{testItem(10), nil, nil},
	}, {
		label:	"Items added, LRA eviction",
		cache:	New(2, EvictionPolicy(LeastRecentlyAdded)),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("bar", testItem(1))
			c.Get("foo")
			c.Put("baz", testItem(1))
		},
		expectedSize:	2,
		expectedItems:	[]Item{nil, testItem(1), testItem(1)},
	}, {
		label:	"Items added, LRU eviction",
		cache:	New(2, EvictionPolicy(LeastRecentlyUsed)),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Put("bar", testItem(1))
			c.Get("foo")
			c.Put("baz", testItem(1))
		},
		expectedSize:	2,
		expectedItems:	[]Item{testItem(1), nil, testItem(1)},
	}, {
		label:	"Items removed, key doesn't exist",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Remove("baz")
		},
		expectedSize:	1,
		expectedItems:	[]Item{testItem(1), nil, nil},
	}, {
		label:	"Items removed, key exists",
		cache:	New(10000),
		useCache: func(c Cache) {
			c.Put("foo", testItem(1))
			c.Remove("foo")
		},
		expectedSize:	0,
		expectedItems:	[]Item{nil, nil, nil},
	}}

	for _, testCase := range testCases {
		t.Log(testCase.label)
		testCase.useCache(testCase.cache)
		assert.Equal(t, testCase.expectedSize, testCase.cache.Size())
		assert.Equal(t, testCase.expectedItems, testCase.cache.Get(keys...))
	}
} PrettyPrintBody:[{ keys := []string{"foo", "bar", "baz"} testCases := []struct { label		string cache		Cache useCache	func(c Cache) expectedSize	uint64 expectedItems	[]Item }{{ label:	"Items added, key doesn't exist", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) }, expectedSize:	1, expectedItems:	[]Item{testItem(1), nil, nil}, }, { label:	"Items added, key exists", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("foo", testItem(10)) }, expectedSize:	10, expectedItems:	[]Item{testItem(10), nil, nil}, }, { label:	"Items added, LRA eviction", cache:	New(2, EvictionPolicy(LeastRecentlyAdded)), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("bar", testItem(1)) c.Get("foo") c.Put("baz", testItem(1)) }, expectedSize:	2, expectedItems:	[]Item{nil, testItem(1), testItem(1)}, }, { label:	"Items added, LRU eviction", cache:	New(2, EvictionPolicy(LeastRecentlyUsed)), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Put("bar", testItem(1)) c.Get("foo") c.Put("baz", testItem(1)) }, expectedSize:	2, expectedItems:	[]Item{testItem(1), nil, testItem(1)}, }, { label:	"Items removed, key doesn't exist", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Remove("baz") }, expectedSize:	1, expectedItems:	[]Item{testItem(1), nil, nil}, }, { label:	"Items removed, key exists", cache:	New(10000), useCache: func(c Cache) { c.Put("foo", testItem(1)) c.Remove("foo") }, expectedSize:	0, expectedItems:	[]Item{nil, nil, nil}, }} for _, testCase := range testCases { t.Log(testCase.label) testCase.useCache(testCase.cache) assert.Equal(t, testCase.expectedSize, testCase.cache.Size()) assert.Equal(t, testCase.expectedItems, testCase.cache.Get(keys...)) } }]} {Id:0 FileId:63 StartLine:19 StartColumn:1 EndLine:47 EndColumn:2 Name:split Params:[{Name:tree Type:*btree} {Name:parent Type:node}] Results:[{Name: Type:node}] Receiver:<nil> Body:{
	if !child.needsSplit(tree.nodeSize) {
		return parent
	}

	key, left, right := child.split()
	if parent == nil {
		in := newInternalNode(tree.nodeSize)
		in.keys = append(in.keys, key)
		in.nodes = append(in.nodes, left)
		in.nodes = append(in.nodes, right)
		return in
	}

	p := parent.(*inode)
	i := p.search(key)

	if cr, ok := left.(*lnode); ok {
		if i > 0 {
			p.nodes[i-1].(*lnode).pointer = cr
		}
	}
	p.keys.insertAt(i, key)
	p.nodes[i] = left
	p.nodes.insertAt(i+1, right)

	return parent
} PrettyPrintBody:[{ if !child.needsSplit(tree.nodeSize) { return parent } key, left, right := child.split() if parent == nil { in := newInternalNode(tree.nodeSize) in.keys = append(in.keys, key) in.nodes = append(in.nodes, left) in.nodes = append(in.nodes, right) return in } p := parent.(*inode) i := p.search(key) if cr, ok := left.(*lnode); ok { if i > 0 { p.nodes[i-1].(*lnode).pointer = cr } } p.keys.insertAt(i, key) p.nodes[i] = left p.nodes.insertAt(i+1, right) return parent }]} {Id:3 FileId:63 StartLine:61 StartColumn:1 EndLine:70 EndColumn:2 Name:insertAt Params:[{Name:i Type:int} {Name:node Type:node}] Results:[] Receiver:0xc001001de0 Body:{
	if i == len(*nodes) {
		*nodes = append(*nodes, node)
		return
	}

	*nodes = append(*nodes, nil)
	copy((*nodes)[i+1:], (*nodes)[i:])
	(*nodes)[i] = node
} PrettyPrintBody:[{ if i == len(*nodes) { *nodes = append(*nodes, node) return } *nodes = append(*nodes, nil) copy((*nodes)[i+1:], (*nodes)[i:]) (*nodes)[i] = node }]} {Id:4 FileId:63 StartLine:72 StartColumn:1 EndLine:78 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:nodes} {Name: Type:nodes}] Receiver:0xc001308c00 Body:{
	left := make(nodes, i, cap(ns))
	right := make(nodes, len(ns)-i, cap(ns))
	copy(left, ns[:i])
	copy(right, ns[i:])
	return left, right
} PrettyPrintBody:[{ left := make(nodes, i, cap(ns)) right := make(nodes, len(ns)-i, cap(ns)) copy(left, ns[:i]) copy(right, ns[i:]) return left, right }]} {Id:6 FileId:63 StartLine:85 StartColumn:1 EndLine:87 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000e7fe80 Body:{
	return node.keys.search(key)
} PrettyPrintBody:[{ return node.keys.search(key) }]} {Id:7 FileId:63 StartLine:89 StartColumn:1 EndLine:102 EndColumn:2 Name:find Params:[{Name:key Type:Key}] Results:[{Name: Type:*iterator}] Receiver:0xc000c565e0 Body:{
	i := node.search(key)
	if i == len(node.keys) {
		return node.nodes[len(node.nodes)-1].find(key)
	}

	found := node.keys[i]
	switch found.Compare(key) {
	case 0, 1:
		return node.nodes[i+1].find(key)
	default:
		return node.nodes[i].find(key)
	}
} PrettyPrintBody:[{ i := node.search(key) if i == len(node.keys) { return node.nodes[len(node.nodes)-1].find(key) } found := node.keys[i] switch found.Compare(key) { case 0, 1: return node.nodes[i+1].find(key) default: return node.nodes[i].find(key) } }]} {Id:8 FileId:63 StartLine:104 StartColumn:1 EndLine:129 EndColumn:2 Name:insert Params:[{Name:tree Type:*btree} {Name:key Type:Key}] Results:[{Name: Type:bool}] Receiver:0xc001033700 Body:{
	i := n.search(key)
	var child node
	if i == len(n.keys) {
		child = n.nodes[len(n.nodes)-1]
	} else {
		match := n.keys[i]
		switch match.Compare(key) {
		case 1, 0:
			child = n.nodes[i+1]
		default:
			child = n.nodes[i]
		}
	}

	result := child.insert(tree, key)
	if !result {
		return result
	}

	if child.needsSplit(tree.nodeSize) {
		split(tree, n, child)
	}

	return result
} PrettyPrintBody:[{ i := n.search(key) var child node if i == len(n.keys) { child = n.nodes[len(n.nodes)-1] } else { match := n.keys[i] switch match.Compare(key) { case 1, 0: child = n.nodes[i+1] default: child = n.nodes[i] } } result := child.insert(tree, key) if !result { return result } if child.needsSplit(tree.nodeSize) { split(tree, n, child) } return result }]} {Id:9 FileId:63 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:needsSplit Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001581220 Body:{
	return uint64(len(n.keys)) >= nodeSize
} PrettyPrintBody:[{ return uint64(len(n.keys)) >= nodeSize }]} {Id:10 FileId:63 StartLine:135 StartColumn:1 EndLine:155 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:node} {Name: Type:node}] Receiver:0xc0011721c0 Body:{
	if len(n.keys) < 3 {
		return nil, nil, nil
	}

	i := len(n.keys) / 2
	key := n.keys[i]

	ourKeys := make(keys, len(n.keys)-i-1, cap(n.keys))
	otherKeys := make(keys, i, cap(n.keys))
	copy(ourKeys, n.keys[i+1:])
	copy(otherKeys, n.keys[:i])
	left, right := n.nodes.splitAt(i + 1)
	otherNode := &inode{
		keys:	otherKeys,
		nodes:	left,
	}
	n.keys = ourKeys
	n.nodes = right
	return key, otherNode, n
} PrettyPrintBody:[{ if len(n.keys) < 3 { return nil, nil, nil } i := len(n.keys) / 2 key := n.keys[i] ourKeys := make(keys, len(n.keys)-i-1, cap(n.keys)) otherKeys := make(keys, i, cap(n.keys)) copy(ourKeys, n.keys[i+1:]) copy(otherKeys, n.keys[:i]) left, right := n.nodes.splitAt(i + 1) otherNode := &inode{ keys:	otherKeys, nodes:	left, } n.keys = ourKeys n.nodes = right return key, otherNode, n }]} {Id:11 FileId:63 StartLine:157 StartColumn:1 EndLine:162 EndColumn:2 Name:newInternalNode Params:[{Name:size Type:uint64}] Results:[{Name: Type:*inode}] Receiver:<nil> Body:{
	return &inode{
		keys:	make(keys, 0, size),
		nodes:	make(nodes, 0, size+1),
	}
} PrettyPrintBody:[{ return &inode{ keys:	make(keys, 0, size), nodes:	make(nodes, 0, size+1), } }]} {Id:13 FileId:63 StartLine:170 StartColumn:1 EndLine:172 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc0003e5120 Body:{
	return node.keys.search(key)
} PrettyPrintBody:[{ return node.keys.search(key) }]} {Id:14 FileId:63 StartLine:174 StartColumn:1 EndLine:194 EndColumn:2 Name:insert Params:[{Name:tree Type:*btree} {Name:key Type:Key}] Results:[{Name: Type:bool}] Receiver:0xc00095a7e0 Body:{
	i := keySearch(lnode.keys, key)
	var inserted bool
	if i == len(lnode.keys) {
		lnode.keys = append(lnode.keys, key)
		inserted = true
	} else {
		if lnode.keys[i].Compare(key) == 0 {
			lnode.keys[i] = key
		} else {
			lnode.keys.insertAt(i, key)
			inserted = true
		}
	}

	if !inserted {
		return false
	}

	return true
} PrettyPrintBody:[{ i := keySearch(lnode.keys, key) var inserted bool if i == len(lnode.keys) { lnode.keys = append(lnode.keys, key) inserted = true } else { if lnode.keys[i].Compare(key) == 0 { lnode.keys[i] = key } else { lnode.keys.insertAt(i, key) inserted = true } } if !inserted { return false } return true }]} {Id:15 FileId:63 StartLine:196 StartColumn:1 EndLine:214 EndColumn:2 Name:find Params:[{Name:key Type:Key}] Results:[{Name: Type:*iterator}] Receiver:0xc0001e62e0 Body:{
	i := node.search(key)
	if i == len(node.keys) {
		if node.pointer == nil {
			return nilIterator()
		}

		return &iterator{
			node:	node.pointer,
			index:	-1,
		}
	}

	iter := &iterator{
		node:	node,
		index:	i - 1,
	}
	return iter
} PrettyPrintBody:[{ i := node.search(key) if i == len(node.keys) { if node.pointer == nil { return nilIterator() } return &iterator{ node:	node.pointer, index:	-1, } } iter := &iterator{ node:	node, index:	i - 1, } return iter }]} {Id:16 FileId:63 StartLine:216 StartColumn:1 EndLine:237 EndColumn:2 Name:split Params:[] Results:[{Name: Type:Key} {Name: Type:node} {Name: Type:node}] Receiver:0xc000a8a980 Body:{
	if len(node.keys) < 2 {
		return nil, nil, nil
	}
	i := len(node.keys) / 2
	key := node.keys[i]
	otherKeys := make(keys, i, cap(node.keys))
	ourKeys := make(keys, len(node.keys)-i, cap(node.keys))

	copy(otherKeys, node.keys[:i])
	copy(ourKeys, node.keys[i:])

	node.keys = ourKeys
	otherNode := &lnode{
		keys:		otherKeys,
		pointer:	node,
	}
	return key, otherNode, node
} PrettyPrintBody:[{ if len(node.keys) < 2 { return nil, nil, nil } i := len(node.keys) / 2 key := node.keys[i] otherKeys := make(keys, i, cap(node.keys)) ourKeys := make(keys, len(node.keys)-i, cap(node.keys)) copy(otherKeys, node.keys[:i]) copy(ourKeys, node.keys[i:]) node.keys = ourKeys otherNode := &lnode{ keys:		otherKeys, pointer:	node, } return key, otherNode, node }]} {Id:17 FileId:63 StartLine:239 StartColumn:1 EndLine:241 EndColumn:2 Name:needsSplit Params:[{Name:nodeSize Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc000a8bae0 Body:{
	return uint64(len(lnode.keys)) >= nodeSize
} PrettyPrintBody:[{ return uint64(len(lnode.keys)) >= nodeSize }]} {Id:18 FileId:63 StartLine:243 StartColumn:1 EndLine:247 EndColumn:2 Name:newLeafNode Params:[{Name:size Type:uint64}] Results:[{Name: Type:*lnode}] Receiver:<nil> Body:{
	return &lnode{
		keys: make(keys, 0, size),
	}
} PrettyPrintBody:[{ return &lnode{ keys: make(keys, 0, size), } }]} {Id:20 FileId:63 StartLine:251 StartColumn:1 EndLine:253 EndColumn:2 Name:search Params:[{Name:key Type:Key}] Results:[{Name: Type:int}] Receiver:0xc000992240 Body:{
	return keySearch(keys, key)
} PrettyPrintBody:[{ return keySearch(keys, key) }]} {Id:21 FileId:63 StartLine:255 StartColumn:1 EndLine:264 EndColumn:2 Name:insertAt Params:[{Name:i Type:int} {Name:key Type:Key}] Results:[] Receiver:0xc0001e69a0 Body:{
	if i == len(*keys) {
		*keys = append(*keys, key)
		return
	}

	*keys = append(*keys, nil)
	copy((*keys)[i+1:], (*keys)[i:])
	(*keys)[i] = key
} PrettyPrintBody:[{ if i == len(*keys) { *keys = append(*keys, key) return } *keys = append(*keys, nil) copy((*keys)[i+1:], (*keys)[i:]) (*keys)[i] = key }]} {Id:22 FileId:63 StartLine:266 StartColumn:1 EndLine:270 EndColumn:2 Name:reverse Params:[] Results:[] Receiver:0xc0009923c0 Body:{
	for i := 0; i < len(keys)/2; i++ {
		keys[i], keys[len(keys)-i-1] = keys[len(keys)-i-1], keys[i]
	}
} PrettyPrintBody:[{ for i := 0; i < len(keys)/2; i++ { keys[i], keys[len(keys)-i-1] = keys[len(keys)-i-1], keys[i] } }]} {Id:1 FileId:24 StartLine:25 StartColumn:1 EndLine:64 EndColumn:2 Name:TestNandSparseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(3)
	sba.SetBit(280)
	other.SetBit(9)
	other.SetBit(100)
	sba.SetBit(1000)
	other.SetBit(1001)

	sba.SetBit(1)
	other.SetBit(1)
	sba.SetBit(2680)
	other.SetBit(2680)
	sba.SetBit(30)
	other.SetBit(30)

	ba := nandSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 30, false)
	checkBit(t, ba, 2680, false)

	checkBit(t, ba, 3, true)
	checkBit(t, ba, 280, true)
	checkBit(t, ba, 1000, true)

	checkBit(t, ba, 9, false)
	checkBit(t, ba, 100, false)
	checkBit(t, ba, 2, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{3, 280, 1000}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(3) sba.SetBit(280) other.SetBit(9) other.SetBit(100) sba.SetBit(1000) other.SetBit(1001) sba.SetBit(1) other.SetBit(1) sba.SetBit(2680) other.SetBit(2680) sba.SetBit(30) other.SetBit(30) ba := nandSparseWithSparseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 30, false) checkBit(t, ba, 2680, false) checkBit(t, ba, 3, true) checkBit(t, ba, 280, true) checkBit(t, ba, 1000, true) checkBit(t, ba, 9, false) checkBit(t, ba, 100, false) checkBit(t, ba, 2, false) nums := ba.ToNums() assert.Equal(t, []uint64{3, 280, 1000}, nums) }]} {Id:2 FileId:24 StartLine:66 StartColumn:1 EndLine:94 EndColumn:2 Name:TestNandSparseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(300)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := nandSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)
	checkBit(t, ba, 300, false)

	checkBit(t, ba, 155, true)

	checkBit(t, ba, 156, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(300) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 300, false) checkBit(t, ba, 155, true) checkBit(t, ba, 156, false) nums := ba.ToNums() assert.Equal(t, []uint64{155}, nums) }]} {Id:3 FileId:24 StartLine:96 StartColumn:1 EndLine:124 EndColumn:2 Name:TestNandDenseWithSparseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newBitArray(300)
	other := newSparseBitArray()

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	other.SetBit(156)
	sba.SetBit(300)
	other.SetBit(300)

	ba := nandDenseWithSparseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)
	checkBit(t, ba, 300, false)

	checkBit(t, ba, 155, true)

	checkBit(t, ba, 156, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155}, nums)
} PrettyPrintBody:[{ sba := newBitArray(300) other := newSparseBitArray() other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) other.SetBit(156) sba.SetBit(300) other.SetBit(300) ba := nandDenseWithSparseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 300, false) checkBit(t, ba, 155, true) checkBit(t, ba, 156, false) nums := ba.ToNums() assert.Equal(t, []uint64{155}, nums) }]} {Id:4 FileId:24 StartLine:126 StartColumn:1 EndLine:158 EndColumn:2 Name:TestNandSparseWithSmallerDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(512)

	other.SetBit(1)
	sba.SetBit(1)
	other.SetBit(150)
	sba.SetBit(150)
	sba.SetBit(155)
	sba.SetBit(500)

	other.SetBit(128)
	sba.SetBit(1500)
	sba.SetBit(1200)

	ba := nandSparseWithDenseBitArray(sba, other)

	checkBit(t, ba, 1, false)
	checkBit(t, ba, 150, false)

	checkBit(t, ba, 155, true)
	checkBit(t, ba, 500, true)
	checkBit(t, ba, 1200, true)
	checkBit(t, ba, 1500, true)

	checkBit(t, ba, 128, false)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{155, 500, 1200, 1500}, nums)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(512) other.SetBit(1) sba.SetBit(1) other.SetBit(150) sba.SetBit(150) sba.SetBit(155) sba.SetBit(500) other.SetBit(128) sba.SetBit(1500) sba.SetBit(1200) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 1, false) checkBit(t, ba, 150, false) checkBit(t, ba, 155, true) checkBit(t, ba, 500, true) checkBit(t, ba, 1200, true) checkBit(t, ba, 1500, true) checkBit(t, ba, 128, false) nums := ba.ToNums() assert.Equal(t, []uint64{155, 500, 1200, 1500}, nums) }]} {Id:5 FileId:24 StartLine:160 StartColumn:1 EndLine:194 EndColumn:2 Name:TestNandDenseWithDenseBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(2000)

	dba.SetBit(1)
	other.SetBit(18)
	dba.SetBit(222)
	other.SetBit(222)
	other.SetBit(1501)

	ba := nandDenseWithDenseBitArray(dba, other)

	checkBit(t, ba, 222, false)

	checkBit(t, ba, 1, true)

	checkBit(t, ba, 18, false)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 3, false)

	_, err := ba.GetBit(1500)
	assert.Equal(t, OutOfRangeError(1500), err)
	_, err = ba.GetBit(1501)
	assert.Equal(t, OutOfRangeError(1501), err)

	nums := ba.ToNums()
	assert.Equal(t, []uint64{1}, nums)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(2000) dba.SetBit(1) other.SetBit(18) dba.SetBit(222) other.SetBit(222) other.SetBit(1501) ba := nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 222, false) checkBit(t, ba, 1, true) checkBit(t, ba, 18, false) checkBit(t, ba, 0, false) checkBit(t, ba, 3, false) _, err := ba.GetBit(1500) assert.Equal(t, OutOfRangeError(1500), err) _, err = ba.GetBit(1501) assert.Equal(t, OutOfRangeError(1501), err) nums := ba.ToNums() assert.Equal(t, []uint64{1}, nums) }]} {Id:6 FileId:24 StartLine:196 StartColumn:1 EndLine:207 EndColumn:2 Name:TestNandSparseWithEmptySparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newSparseBitArray()

	sba.SetBit(5)

	ba := nandSparseWithSparseBitArray(sba, other)

	checkBit(t, ba, 0, false)
	checkBit(t, ba, 5, true)
	checkBit(t, ba, 100, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newSparseBitArray() sba.SetBit(5) ba := nandSparseWithSparseBitArray(sba, other) checkBit(t, ba, 0, false) checkBit(t, ba, 5, true) checkBit(t, ba, 100, false) }]} {Id:7 FileId:24 StartLine:209 StartColumn:1 EndLine:222 EndColumn:2 Name:TestNandSparseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sba := newSparseBitArray()
	other := newBitArray(1000)

	sba.SetBit(5)
	ba := nandSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, true)

	sba.Reset()
	other.SetBit(5)

	ba = nandSparseWithDenseBitArray(sba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ sba := newSparseBitArray() other := newBitArray(1000) sba.SetBit(5) ba := nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, true) sba.Reset() other.SetBit(5) ba = nandSparseWithDenseBitArray(sba, other) checkBit(t, ba, 5, false) }]} {Id:8 FileId:24 StartLine:224 StartColumn:1 EndLine:236 EndColumn:2 Name:TestNandDenseWithEmptyDense Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	dba := newBitArray(1000)
	other := newBitArray(1000)

	dba.SetBit(5)
	ba := nandDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, true)

	dba.Reset()
	other.SetBit(5)
	ba = nandDenseWithDenseBitArray(dba, other)
	checkBit(t, ba, 5, false)
} PrettyPrintBody:[{ dba := newBitArray(1000) other := newBitArray(1000) dba.SetBit(5) ba := nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, true) dba.Reset() other.SetBit(5) ba = nandDenseWithDenseBitArray(dba, other) checkBit(t, ba, 5, false) }]} {Id:9 FileId:24 StartLine:238 StartColumn:1 EndLine:256 EndColumn:2 Name:BenchmarkNandSparseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i += s {
		if i%200 == 0 {
			sba.SetBit(i)
		} else if i%300 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandSparseWithSparseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newSparseBitArray() for i := uint64(0); i < numItems; i += s { if i%200 == 0 { sba.SetBit(i) } else if i%300 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandSparseWithSparseBitArray(sba, other) } }]} {Id:10 FileId:24 StartLine:258 StartColumn:1 EndLine:276 EndColumn:2 Name:BenchmarkNandSparseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	sba := newSparseBitArray()
	other := newBitArray(numItems)

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			sba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandSparseWithDenseBitArray(sba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) sba := newSparseBitArray() other := newBitArray(numItems) for i := uint64(0); i < numItems; i += s { if i%2 == 0 { sba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandSparseWithDenseBitArray(sba, other) } }]} {Id:11 FileId:24 StartLine:278 StartColumn:1 EndLine:296 EndColumn:2 Name:BenchmarkNandDenseWithSparse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	ba := newBitArray(numItems)
	other := newSparseBitArray()

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			ba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandDenseWithSparseBitArray(ba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) ba := newBitArray(numItems) other := newSparseBitArray() for i := uint64(0); i < numItems; i += s { if i%2 == 0 { ba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandDenseWithSparseBitArray(ba, other) } }]} {Id:12 FileId:24 StartLine:298 StartColumn:1 EndLine:316 EndColumn:2 Name:BenchmarkNandDenseWithDense Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(160000)
	dba := newBitArray(numItems)
	other := newBitArray(numItems)

	for i := uint64(0); i < numItems; i += s {
		if i%2 == 0 {
			dba.SetBit(i)
		} else if i%3 == 0 {
			other.SetBit(i)
		}
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		nandDenseWithDenseBitArray(dba, other)
	}
} PrettyPrintBody:[{ numItems := uint64(160000) dba := newBitArray(numItems) other := newBitArray(numItems) for i := uint64(0); i < numItems; i += s { if i%2 == 0 { dba.SetBit(i) } else if i%3 == 0 { other.SetBit(i) } } b.ResetTimer() for i := 0; i < b.N; i++ { nandDenseWithDenseBitArray(dba, other) } }]} {Id:1 FileId:82 StartLine:11 StartColumn:1 EndLine:21 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:[]uint64}] Receiver:<nil> Body:{
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	keys := make([]uint64, 0, num)
	for i := 0; i < num; i++ {
		key := uint64(r.Int63())
		keys = append(keys, key)
	}

	return keys
} PrettyPrintBody:[{ r := rand.New(rand.NewSource(time.Now().UnixNano())) keys := make([]uint64, 0, num) for i := 0; i < num; i++ { key := uint64(r.Int63()) keys = append(keys, key) } return keys }]} {Id:2 FileId:82 StartLine:23 StartColumn:1 EndLine:32 EndColumn:2 Name:TestRoundUp Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	result := roundUp(21)
	assert.Equal(t, uint64(32), result)

	result = roundUp(uint64(1<<31) - 234)
	assert.Equal(t, uint64(1<<31), result)

	result = roundUp(uint64(1<<63) - 324)
	assert.Equal(t, uint64(1<<63), result)
} PrettyPrintBody:[{ result := roundUp(21) assert.Equal(t, uint64(32), result) result = roundUp(uint64(1<<31) - 234) assert.Equal(t, uint64(1<<31), result) result = roundUp(uint64(1<<63) - 324) assert.Equal(t, uint64(1<<63), result) }]} {Id:3 FileId:82 StartLine:34 StartColumn:1 EndLine:44 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)

	assert.True(t, hm.Exists(5))
	value, ok := hm.Get(5)
	assert.Equal(t, uint64(5), value)
	assert.True(t, ok)
	assert.Equal(t, uint64(16), hm.Cap())
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) assert.True(t, hm.Exists(5)) value, ok := hm.Get(5) assert.Equal(t, uint64(5), value) assert.True(t, ok) assert.Equal(t, uint64(16), hm.Cap()) }]} {Id:4 FileId:82 StartLine:46 StartColumn:1 EndLine:56 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(5, 10)

	assert.True(t, hm.Exists(5))
	value, ok := hm.Get(5)
	assert.Equal(t, uint64(10), value)
	assert.True(t, ok)
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(5, 10) assert.True(t, hm.Exists(5)) value, ok := hm.Get(5) assert.Equal(t, uint64(10), value) assert.True(t, ok) }]} {Id:5 FileId:82 StartLine:58 StartColumn:1 EndLine:64 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	value, ok := hm.Get(5)
	assert.False(t, ok)
	assert.Equal(t, uint64(0), value)
} PrettyPrintBody:[{ hm := New(10) value, ok := hm.Get(5) assert.False(t, ok) assert.Equal(t, uint64(0), value) }]} {Id:6 FileId:82 StartLine:66 StartColumn:1 EndLine:76 EndColumn:2 Name:TestMultipleInserts Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(6, 6)

	assert.True(t, hm.Exists(6))
	value, ok := hm.Get(6)
	assert.True(t, ok)
	assert.Equal(t, uint64(6), value)
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(6, 6) assert.True(t, hm.Exists(6)) value, ok := hm.Get(6) assert.True(t, ok) assert.Equal(t, uint64(6), value) }]} {Id:7 FileId:82 StartLine:78 StartColumn:1 EndLine:91 EndColumn:2 Name:TestRebuild Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100)

	hm := New(10)

	for i := uint64(0); i < numItems; i++ {
		hm.Set(i, i)
	}

	for i := uint64(0); i < numItems; i++ {
		value, _ := hm.Get(i)
		assert.Equal(t, i, value)
	}
} PrettyPrintBody:[{ numItems := uint64(100) hm := New(10) for i := uint64(0); i < numItems; i++ { hm.Set(i, i) } for i := uint64(0); i < numItems; i++ { value, _ := hm.Get(i) assert.Equal(t, i, value) } }]} {Id:8 FileId:82 StartLine:93 StartColumn:1 EndLine:107 EndColumn:2 Name:TestDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	hm := New(10)

	hm.Set(5, 5)
	hm.Set(6, 6)

	hm.Delete(5)

	assert.Equal(t, uint64(1), hm.Len())
	assert.False(t, hm.Exists(5))

	hm.Delete(6)
	assert.Equal(t, uint64(0), hm.Len())
	assert.False(t, hm.Exists(6))
} PrettyPrintBody:[{ hm := New(10) hm.Set(5, 5) hm.Set(6, 6) hm.Delete(5) assert.Equal(t, uint64(1), hm.Len()) assert.False(t, hm.Exists(5)) hm.Delete(6) assert.Equal(t, uint64(0), hm.Len()) assert.False(t, hm.Exists(6)) }]} {Id:9 FileId:82 StartLine:109 StartColumn:1 EndLine:122 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100)

	hm := New(10)

	for i := uint64(0); i < numItems; i++ {
		hm.Set(i, i)
	}

	for i := uint64(0); i < numItems; i++ {
		hm.Delete(i)
		assert.False(t, hm.Exists(i))
	}
} PrettyPrintBody:[{ numItems := uint64(100) hm := New(10) for i := uint64(0); i < numItems; i++ { hm.Set(i, i) } for i := uint64(0); i < numItems; i++ { hm.Delete(i) assert.False(t, hm.Exists(i)) } }]} {Id:10 FileId:82 StartLine:124 StartColumn:1 EndLine:139 EndColumn:2 Name:TestDeleteCollision Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{

	if hash(1)%32 != 12 || hash(27)%32 != 12 || hash(42)%32 != 12 {
		t.Error("test values don't hash to the same value")
	}

	m := New(32)
	m.Set(1, 1)
	m.Set(27, 27)
	m.Set(42, 42)

	m.Delete(27)
	value, ok := m.Get(42)
	assert.True(t, ok)
	assert.Equal(t, uint64(42), value)
} PrettyPrintBody:[{ if hash(1)%32 != 12 || hash(27)%32 != 12 || hash(42)%32 != 12 { t.Error("test values don't hash to the same value") } m := New(32) m.Set(1, 1) m.Set(27, 27) m.Set(42, 42) m.Delete(27) value, ok := m.Get(42) assert.True(t, ok) assert.Equal(t, uint64(42), value) }]} {Id:11 FileId:82 StartLine:141 StartColumn:1 EndLine:154 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := New(numItems * 2)
		for _, k := range keys {
			hm.Set(k, k)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) b.ResetTimer() for i := 0; i < b.N; i++ { hm := New(numItems * 2) for _, k := range keys { hm.Set(k, k) } } }]} {Id:12 FileId:82 StartLine:156 StartColumn:1 EndLine:169 EndColumn:2 Name:BenchmarkGoMapInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, numItems*2)
		for _, k := range keys {
			hm[k] = k
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) b.ResetTimer() for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, numItems*2) for _, k := range keys { hm[k] = k } } }]} {Id:13 FileId:82 StartLine:171 StartColumn:1 EndLine:187 EndColumn:2 Name:BenchmarkExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))
	hm := New(numItems * 2)
	for _, key := range keys {
		hm.Set(key, key)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			hm.Exists(key)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) hm := New(numItems * 2) for _, key := range keys { hm.Set(key, key) } b.ResetTimer() for i := 0; i < b.N; i++ { for _, key := range keys { hm.Exists(key) } } }]} {Id:14 FileId:82 StartLine:189 StartColumn:1 EndLine:210 EndColumn:2 Name:BenchmarkGoMapExists Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	keys := generateKeys(int(numItems))
	hm := make(map[uint64]uint64, numItems*2)
	for _, key := range keys {
		hm[key] = key
	}

	b.ResetTimer()

	var ok bool
	for i := 0; i < b.N; i++ {
		for _, key := range keys {
			_, ok = hm[key]
		}
	}

	b.StopTimer()
	if ok {
	}
} PrettyPrintBody:[{ numItems := uint64(1000) keys := generateKeys(int(numItems)) hm := make(map[uint64]uint64, numItems*2) for _, key := range keys { hm[key] = key } b.ResetTimer() var ok bool for i := 0; i < b.N; i++ { for _, key := range keys { _, ok = hm[key] } } b.StopTimer() if ok { } }]} {Id:15 FileId:82 StartLine:212 StartColumn:1 EndLine:232 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]*FastIntegerHashMap, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := New(numItems * 2)
		for j := uint64(0); j < numItems; j++ {
			hm.Set(j, j)
		}
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm.Delete(j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]*FastIntegerHashMap, 0, b.N) for i := 0; i < b.N; i++ { hm := New(numItems * 2) for j := uint64(0); j < numItems; j++ { hm.Set(j, j) } hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm.Delete(j) } } }]} {Id:16 FileId:82 StartLine:234 StartColumn:1 EndLine:254 EndColumn:2 Name:BenchmarkGoDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]map[uint64]uint64, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, numItems*2)
		for j := uint64(0); j < numItems; j++ {
			hm[j] = j
		}
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			delete(hm, j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]map[uint64]uint64, 0, b.N) for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, numItems*2) for j := uint64(0); j < numItems; j++ { hm[j] = j } hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { delete(hm, j) } } }]} {Id:17 FileId:82 StartLine:256 StartColumn:1 EndLine:273 EndColumn:2 Name:BenchmarkInsertWithExpand Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]*FastIntegerHashMap, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := New(10)
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm.Set(j, j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]*FastIntegerHashMap, 0, b.N) for i := 0; i < b.N; i++ { hm := New(10) hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm.Set(j, j) } } }]} {Id:18 FileId:82 StartLine:275 StartColumn:1 EndLine:292 EndColumn:2 Name:BenchmarkGoInsertWithExpand Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)

	hms := make([]map[uint64]uint64, 0, b.N)
	for i := 0; i < b.N; i++ {
		hm := make(map[uint64]uint64, 10)
		hms = append(hms, hm)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		hm := hms[i]
		for j := uint64(0); j < numItems; j++ {
			hm[j] = j
		}
	}
} PrettyPrintBody:[{ numItems := uint64(1000) hms := make([]map[uint64]uint64, 0, b.N) for i := 0; i < b.N; i++ { hm := make(map[uint64]uint64, 10) hms = append(hms, hm) } b.ResetTimer() for i := 0; i < b.N; i++ { hm := hms[i] for j := uint64(0); j < numItems; j++ { hm[j] = j } } }]} {Id:1 FileId:55 StartLine:26 StartColumn:1 EndLine:34 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:key Type:common.Comparator}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		n = parent.searchNode(key)
		parent = n
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { n = parent.searchNode(key) parent = n } return parent }]} {Id:3 FileId:55 StartLine:40 StartColumn:1 EndLine:42 EndColumn:2 Name:push Params:[{Name:n Type:*node}] Results:[] Receiver:0xc001032f60 Body:{
	ns.list = append(ns.list, n)
} PrettyPrintBody:[{ ns.list = append(ns.list, n) }]} {Id:4 FileId:55 StartLine:44 StartColumn:1 EndLine:53 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*nodes} {Name: Type:*nodes}] Receiver:0xc001408a00 Body:{
	i++
	right := make([]*node, uint64(len(ns.list))-i, capacity)
	copy(right, ns.list[i:])
	for j := i; j < uint64(len(ns.list)); j++ {
		ns.list[j] = nil
	}
	ns.list = ns.list[:i]
	return ns, &nodes{list: right}
} PrettyPrintBody:[{ i++ right := make([]*node, uint64(len(ns.list))-i, capacity) copy(right, ns.list[i:]) for j := i; j < uint64(len(ns.list)); j++ { ns.list[j] = nil } ns.list = ns.list[:i] return ns, &nodes{list: right} }]} {Id:5 FileId:55 StartLine:55 StartColumn:1 EndLine:61 EndColumn:2 Name:byPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0010bd840 Body:{
	if pos >= uint64(len(ns.list)) {
		return nil
	}

	return ns.list[pos]
} PrettyPrintBody:[{ if pos >= uint64(len(ns.list)) { return nil } return ns.list[pos] }]} {Id:6 FileId:55 StartLine:63 StartColumn:1 EndLine:67 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:n Type:*node}] Results:[] Receiver:0xc001309320 Body:{
	ns.list = append(ns.list, nil)
	copy(ns.list[i+1:], ns.list[i:])
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list = append(ns.list, nil) copy(ns.list[i+1:], ns.list[i:]) ns.list[i] = n }]} {Id:7 FileId:55 StartLine:69 StartColumn:1 EndLine:71 EndColumn:2 Name:replaceAt Params:[{Name:i Type:uint64} {Name:n Type:*node}] Results:[] Receiver:0xc001580ce0 Body:{
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list[i] = n }]} {Id:8 FileId:55 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001409980 Body:{
	return uint64(len(ns.list))
} PrettyPrintBody:[{ return uint64(len(ns.list)) }]} {Id:9 FileId:55 StartLine:77 StartColumn:1 EndLine:81 EndColumn:2 Name:newNodes Params:[{Name:size Type:uint64}] Results:[{Name: Type:*nodes}] Receiver:<nil> Body:{
	return &nodes{
		list: make([]*node, 0, size),
	}
} PrettyPrintBody:[{ return &nodes{ list: make([]*node, 0, size), } }]} {Id:11 FileId:55 StartLine:87 StartColumn:1 EndLine:96 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*keys} {Name: Type:*keys}] Receiver:0xc001241b80 Body:{
	i++
	right := make(common.Comparators, uint64(len(ks.list))-i, capacity)
	copy(right, ks.list[i:])
	for j := i; j < uint64(len(ks.list)); j++ {
		ks.list[j] = nil
	}
	ks.list = ks.list[:i]
	return ks, &keys{list: right}
} PrettyPrintBody:[{ i++ right := make(common.Comparators, uint64(len(ks.list))-i, capacity) copy(right, ks.list[i:]) for j := i; j < uint64(len(ks.list)); j++ { ks.list[j] = nil } ks.list = ks.list[:i] return ks, &keys{list: right} }]} {Id:12 FileId:55 StartLine:98 StartColumn:1 EndLine:100 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000a8a440 Body:{
	return uint64(len(ks.list))
} PrettyPrintBody:[{ return uint64(len(ks.list)) }]} {Id:13 FileId:55 StartLine:102 StartColumn:1 EndLine:107 EndColumn:2 Name:byPosition Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator}] Receiver:0xc001033b80 Body:{
	if i >= uint64(len(ks.list)) {
		return nil
	}
	return ks.list[i]
} PrettyPrintBody:[{ if i >= uint64(len(ks.list)) { return nil } return ks.list[i] }]} {Id:14 FileId:55 StartLine:109 StartColumn:1 EndLine:124 EndColumn:2 Name:delete Params:[{Name:k Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc001602760 Body:{
	i := ks.search(k)
	if i >= uint64(len(ks.list)) {
		return nil
	}

	if ks.list[i].Compare(k) != 0 {
		return nil
	}
	old := ks.list[i]

	copy(ks.list[i:], ks.list[i+1:])
	ks.list[len(ks.list)-1] = nil
	ks.list = ks.list[:len(ks.list)-1]
	return old
} PrettyPrintBody:[{ i := ks.search(k) if i >= uint64(len(ks.list)) { return nil } if ks.list[i].Compare(k) != 0 { return nil } old := ks.list[i] copy(ks.list[i:], ks.list[i+1:]) ks.list[len(ks.list)-1] = nil ks.list = ks.list[:len(ks.list)-1] return old }]} {Id:15 FileId:55 StartLine:126 StartColumn:1 EndLine:132 EndColumn:2 Name:search Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:uint64}] Receiver:0xc001581520 Body:{
	i := sort.Search(len(ks.list), func(i int) bool {
		return ks.list[i].Compare(key) > -1
	})

	return uint64(i)
} PrettyPrintBody:[{ i := sort.Search(len(ks.list), func(i int) bool { return ks.list[i].Compare(key) > -1 }) return uint64(i) }]} {Id:16 FileId:55 StartLine:134 StartColumn:1 EndLine:150 EndColumn:2 Name:insert Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc00095a680 Body:{
	i := ks.search(key)
	if i == uint64(len(ks.list)) {
		ks.list = append(ks.list, key)
		return nil, i
	}

	var old common.Comparator
	if ks.list[i].Compare(key) == 0 {
		old = ks.list[i]
		ks.list[i] = key
	} else {
		ks.insertAt(i, key)
	}

	return old, i
} PrettyPrintBody:[{ i := ks.search(key) if i == uint64(len(ks.list)) { ks.list = append(ks.list, key) return nil, i } var old common.Comparator if ks.list[i].Compare(key) == 0 { old = ks.list[i] ks.list[i] = key } else { ks.insertAt(i, key) } return old, i }]} {Id:17 FileId:55 StartLine:152 StartColumn:1 EndLine:154 EndColumn:2 Name:last Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc000a8a820 Body:{
	return ks.list[len(ks.list)-1]
} PrettyPrintBody:[{ return ks.list[len(ks.list)-1] }]} {Id:18 FileId:55 StartLine:156 StartColumn:1 EndLine:160 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:k Type:common.Comparator}] Results:[] Receiver:0xc000a8aae0 Body:{
	ks.list = append(ks.list, nil)
	copy(ks.list[i+1:], ks.list[i:])
	ks.list[i] = k
} PrettyPrintBody:[{ ks.list = append(ks.list, nil) copy(ks.list[i+1:], ks.list[i:]) ks.list[i] = k }]} {Id:19 FileId:55 StartLine:162 StartColumn:1 EndLine:172 EndColumn:2 Name:withPosition Params:[{Name:k Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc000a8b180 Body:{
	i := ks.search(k)
	if i == uint64(len(ks.list)) {
		return nil, i
	}
	if ks.list[i].Compare(k) == 0 {
		return ks.list[i], i
	}

	return nil, i
} PrettyPrintBody:[{ i := ks.search(k) if i == uint64(len(ks.list)) { return nil, i } if ks.list[i].Compare(k) == 0 { return ks.list[i], i } return nil, i }]} {Id:20 FileId:55 StartLine:174 StartColumn:1 EndLine:178 EndColumn:2 Name:newKeys Params:[{Name:size Type:uint64}] Results:[{Name: Type:*keys}] Receiver:<nil> Body:{
	return &keys{
		list: make(common.Comparators, 0, size),
	}
} PrettyPrintBody:[{ return &keys{ list: make(common.Comparators, 0, size), } }]} {Id:22 FileId:55 StartLine:187 StartColumn:1 EndLine:189 EndColumn:2 Name:needsSplit Params:[{Name:ary Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc0000ed7e0 Body:{
	return n.keys.len() >= ary
} PrettyPrintBody:[{ return n.keys.len() >= ary }]} {Id:23 FileId:55 StartLine:191 StartColumn:1 EndLine:202 EndColumn:2 Name:splitLeaf Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b120 Body:{
	key := n.keys.byPosition(i)
	_, rightKeys := n.keys.splitAt(i, capacity)
	nn := &node{
		keys:	rightKeys,
		nodes:	newNodes(uint64(cap(n.nodes.list))),
		isLeaf:	true,
		right:	n.right,
	}
	n.right = nn
	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) _, rightKeys := n.keys.splitAt(i, capacity) nn := &node{ keys:	rightKeys, nodes:	newNodes(uint64(cap(n.nodes.list))), isLeaf:	true, right:	n.right, } n.right = nn return key, n, nn }]} {Id:24 FileId:55 StartLine:204 StartColumn:1 EndLine:217 EndColumn:2 Name:splitInternal Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc0009921c0 Body:{
	key := n.keys.byPosition(i)
	n.keys.delete(key)

	_, rightKeys := n.keys.splitAt(i-1, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)

	nn := newNode(false, rightKeys, rightNodes)
	for _, n := range rightNodes.list {
		n.parent = nn
	}

	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) n.keys.delete(key) _, rightKeys := n.keys.splitAt(i-1, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := newNode(false, rightKeys, rightNodes) for _, n := range rightNodes.list { n.parent = nn } return key, n, nn }]} {Id:25 FileId:55 StartLine:219 StartColumn:1 EndLine:225 EndColumn:2 Name:split Params:[{Name:i Type:uint64}] Results:[{Name: Type:common.Comparator} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b4c0 Body:{
	if n.isLeaf {
		return n.splitLeaf(i, capacity)
	}

	return n.splitInternal(i, capacity)
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf(i, capacity) } return n.splitInternal(i, capacity) }]} {Id:26 FileId:55 StartLine:227 StartColumn:1 EndLine:229 EndColumn:2 Name:search Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:uint64}] Receiver:0xc00019e800 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]} {Id:27 FileId:55 StartLine:231 StartColumn:1 EndLine:235 EndColumn:2 Name:searchNode Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:*node}] Receiver:0xc001603960 Body:{
	i := n.search(key)

	return n.nodes.byPosition(uint64(i))
} PrettyPrintBody:[{ i := n.search(key) return n.nodes.byPosition(uint64(i)) }]} {Id:28 FileId:55 StartLine:237 StartColumn:1 EndLine:239 EndColumn:2 Name:key Params:[] Results:[{Name: Type:common.Comparator}] Receiver:0xc0009925c0 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]} {Id:29 FileId:55 StartLine:241 StartColumn:1 EndLine:256 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc000992600 Body:{
	output.Printf(`NODE: %+v, %p`, n, n)
	for _, k := range n.keys.list {
		output.Printf(`KEY: %+v`, k)
	}
	if !n.isLeaf {
		for _, n := range n.nodes.list {
			if n == nil {
				output.Println(`NIL NODE`)
				continue
			}

			n.print(output)
		}
	}
} PrettyPrintBody:[{ output.Printf(`NODE: %+v, %p`, n, n) for _, k := range n.keys.list { output.Printf(`KEY: %+v`, k) } if !n.isLeaf { for _, n := range n.nodes.list { if n == nil { output.Println(`NIL NODE`) continue } n.print(output) } } }]} {Id:30 FileId:55 StartLine:261 StartColumn:1 EndLine:263 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000992660 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:31 FileId:55 StartLine:265 StartColumn:1 EndLine:271 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:*keys} {Name:ns Type:*nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]} {Id:3 FileId:113 StartLine:51 StartColumn:1 EndLine:62 EndColumn:2 Name:Compare Params:[{Name:other Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000dceac0 Body:{
	otherSe := other.(skipEntry)
	if se == otherSe {
		return 0
	}

	if se > otherSe {
		return 1
	}

	return -1
} PrettyPrintBody:[{ otherSe := other.(skipEntry) if se == otherSe { return 0 } if se > otherSe { return 1 } return -1 }]} {Id:4 FileId:113 StartLine:64 StartColumn:1 EndLine:66 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001308ba0 Body:{
	return uint64(se)
} PrettyPrintBody:[{ return uint64(se) }]} {Id:5 FileId:113 StartLine:70 StartColumn:1 EndLine:76 EndColumn:2 Name:isLastDimension Params:[{Name:dimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if dimension >= lastDimension {
		panic(`Dimension is greater than possible dimensions.`)
	}

	return dimension == lastDimension-1
} PrettyPrintBody:[{ if dimension >= lastDimension { panic(`Dimension is greater than possible dimensions.`) } return dimension == lastDimension-1 }]} {Id:6 FileId:113 StartLine:80 StartColumn:1 EndLine:89 EndColumn:2 Name:needsDeletion Params:[{Name:value Type:int64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if number > 0 {
		return false
	}

	number = -number
	offset := value - index

	return offset >= 0 && offset < number
} PrettyPrintBody:[{ if number > 0 { return false } number = -number offset := value - index return offset >= 0 && offset < number }]} {Id:8 FileId:113 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc000a23640 Body:{
	keyed := e.(keyed)
	if db.id == keyed.key() {
		return 0
	}

	if db.id > keyed.key() {
		return 1
	}

	return -1
} PrettyPrintBody:[{ keyed := e.(keyed) if db.id == keyed.key() { return 0 } if db.id > keyed.key() { return 1 } return -1 }]} {Id:9 FileId:113 StartLine:114 StartColumn:1 EndLine:116 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001580e80 Body:{
	return db.id
} PrettyPrintBody:[{ return db.id }]} {Id:11 FileId:113 StartLine:127 StartColumn:1 EndLine:138 EndColumn:2 Name:Compare Params:[{Name:e Type:common.Comparator}] Results:[{Name: Type:int}] Receiver:0xc001580ee0 Body:{
	keyed := e.(keyed)
	if lb.id == keyed.key() {
		return 0
	}

	if lb.id > keyed.key() {
		return 1
	}

	return -1
} PrettyPrintBody:[{ keyed := e.(keyed) if lb.id == keyed.key() { return 0 } if lb.id > keyed.key() { return 1 } return -1 }]} {Id:12 FileId:113 StartLine:141 StartColumn:1 EndLine:143 EndColumn:2 Name:key Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00095a4e0 Body:{
	return lb.id
} PrettyPrintBody:[{ return lb.id }]} {Id:14 FileId:113 StartLine:150 StartColumn:1 EndLine:153 EndColumn:2 Name:init Params:[{Name:dimensions Type:uint64}] Results:[] Receiver:0xc001580f80 Body:{
	rt.dimensions = dimensions
	rt.top = skip.New(uint64(0))
} PrettyPrintBody:[{ rt.dimensions = dimensions rt.top = skip.New(uint64(0)) }]} {Id:15 FileId:113 StartLine:155 StartColumn:1 EndLine:193 EndColumn:2 Name:add Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc000a8a260 Body:{
	var (
		value	int64
		e	common.Comparator
		sl	= rt.top
		db	*dimensionalBundle
		lb	*lastBundle
	)

	for i := uint64(0); i < rt.dimensions; i++ {
		value = entry.ValueAtDimension(i)
		e = sl.Get(skipEntry(value))[0]
		if isLastDimension(i, rt.dimensions) {
			if e != nil {
				lb = e.(*lastBundle)
				oldEntry := lb.entry
				lb.entry = entry
				return oldEntry
			}

			lb = &lastBundle{id: uint64(value), entry: entry}
			rt.number++
			sl.Insert(lb)
			return nil
		}

		if e == nil {
			db = &dimensionalBundle{id: uint64(value), sl: skip.New(uint64(0))}
			sl.Insert(db)
		} else {
			db = e.(*dimensionalBundle)
		}

		sl = db.sl
	}

	panic(`Ran out of dimensions before for loop completed.`)
} PrettyPrintBody:[{ var ( value	int64 e	common.Comparator sl	= rt.top db	*dimensionalBundle lb	*lastBundle ) for i := uint64(0); i < rt.dimensions; i++ { value = entry.ValueAtDimension(i) e = sl.Get(skipEntry(value))[0] if isLastDimension(i, rt.dimensions) { if e != nil { lb = e.(*lastBundle) oldEntry := lb.entry lb.entry = entry return oldEntry } lb = &lastBundle{id: uint64(value), entry: entry} rt.number++ sl.Insert(lb) return nil } if e == nil { db = &dimensionalBundle{id: uint64(value), sl: skip.New(uint64(0))} sl.Insert(db) } else { db = e.(*dimensionalBundle) } sl = db.sl } panic(`Ran out of dimensions before for loop completed.`) }]} {Id:16 FileId:113 StartLine:200 StartColumn:1 EndLine:207 EndColumn:2 Name:Add Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc001602aa0 Body:{
	overwritten := make(rangetree.Entries, len(entries))
	for i, e := range entries {
		overwritten[i] = rt.add(e)
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(rangetree.Entries, len(entries)) for i, e := range entries { overwritten[i] = rt.add(e) } return overwritten }]} {Id:17 FileId:113 StartLine:209 StartColumn:1 EndLine:230 EndColumn:2 Name:get Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc0009920e0 Body:{
	var (
		sl	= rt.top
		e	common.Comparator
		value	uint64
	)
	for i := uint64(0); i < rt.dimensions; i++ {
		value = uint64(entry.ValueAtDimension(i))
		e = sl.Get(skipEntry(value))[0]
		if e == nil {
			return nil
		}

		if isLastDimension(i, rt.dimensions) {
			return e.(*lastBundle).entry
		}

		sl = e.(*dimensionalBundle).sl
	}

	panic(`Reached past for loop without finding last dimension.`)
} PrettyPrintBody:[{ var ( sl	= rt.top e	common.Comparator value	uint64 ) for i := uint64(0); i < rt.dimensions; i++ { value = uint64(entry.ValueAtDimension(i)) e = sl.Get(skipEntry(value))[0] if e == nil { return nil } if isLastDimension(i, rt.dimensions) { return e.(*lastBundle).entry } sl = e.(*dimensionalBundle).sl } panic(`Reached past for loop without finding last dimension.`) }]} {Id:18 FileId:113 StartLine:235 StartColumn:1 EndLine:242 EndColumn:2 Name:Get Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc0003e5100 Body:{
	results := make(rangetree.Entries, 0, len(entries))
	for _, e := range entries {
		results = append(results, rt.get(e))
	}

	return results
} PrettyPrintBody:[{ results := make(rangetree.Entries, 0, len(entries)) for _, e := range entries { results = append(results, rt.get(e)) } return results }]} {Id:19 FileId:113 StartLine:245 StartColumn:1 EndLine:247 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001602c60 Body:{
	return rt.number
} PrettyPrintBody:[{ return rt.number }]} {Id:20 FileId:113 StartLine:252 StartColumn:1 EndLine:281 EndColumn:2 Name:deleteRecursive Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc001602ca0 Body:{

	value := entry.ValueAtDimension(dimension)
	if isLastDimension(dimension, rt.dimensions) {
		entries := sl.Delete(skipEntry(value))
		if entries[0] == nil {
			return nil
		}

		rt.number--
		return entries[0].(*lastBundle).entry
	}

	db, ok := sl.Get(skipEntry(value))[0].(*dimensionalBundle)
	if !ok {
		return nil
	}

	result := rt.deleteRecursive(db.sl, dimension+1, entry)
	if result == nil {
		return nil
	}

	if db.sl.Len() == 0 {
		sl.Delete(db)
	}

	return result
} PrettyPrintBody:[{ value := entry.ValueAtDimension(dimension) if isLastDimension(dimension, rt.dimensions) { entries := sl.Delete(skipEntry(value)) if entries[0] == nil { return nil } rt.number-- return entries[0].(*lastBundle).entry } db, ok := sl.Get(skipEntry(value))[0].(*dimensionalBundle) if !ok { return nil } result := rt.deleteRecursive(db.sl, dimension+1, entry) if result == nil { return nil } if db.sl.Len() == 0 { sl.Delete(db) } return result }]} {Id:21 FileId:113 StartLine:283 StartColumn:1 EndLine:285 EndColumn:2 Name:delete Params:[{Name:entry Type:rangetree.Entry}] Results:[{Name: Type:rangetree.Entry}] Receiver:0xc000a8aa20 Body:{
	return rt.deleteRecursive(rt.top, 0, entry)
} PrettyPrintBody:[{ return rt.deleteRecursive(rt.top, 0, entry) }]} {Id:22 FileId:113 StartLine:291 StartColumn:1 EndLine:298 EndColumn:2 Name:Delete Params:[{Name:entries Type:...rangetree.Entry}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc000a8b1e0 Body:{
	deletedEntries := make(rangetree.Entries, len(entries))
	for i, e := range entries {
		deletedEntries[i] = rt.delete(e)
	}

	return deletedEntries
} PrettyPrintBody:[{ deletedEntries := make(rangetree.Entries, len(entries)) for i, e := range entries { deletedEntries[i] = rt.delete(e) } return deletedEntries }]} {Id:23 FileId:113 StartLine:300 StartColumn:1 EndLine:326 EndColumn:2 Name:apply Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[{Name: Type:bool}] Receiver:0xc001603220 Body:{

	lowValue, highValue := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension)

	var e common.Comparator

	for iter := sl.Iter(skipEntry(lowValue)); iter.Next(); {
		e = iter.Value()
		if int64(e.(keyed).key()) >= highValue {
			break
		}

		if isLastDimension(dimension, rt.dimensions) {
			if !fn(e.(*lastBundle).entry) {
				return false
			}
		} else {

			if !rt.apply(e.(*dimensionalBundle).sl, dimension+1, interval, fn) {
				return false
			}
		}
	}

	return true
} PrettyPrintBody:[{ lowValue, highValue := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension) var e common.Comparator for iter := sl.Iter(skipEntry(lowValue)); iter.Next(); { e = iter.Value() if int64(e.(keyed).key()) >= highValue { break } if isLastDimension(dimension, rt.dimensions) { if !fn(e.(*lastBundle).entry) { return false } } else { if !rt.apply(e.(*dimensionalBundle).sl, dimension+1, interval, fn) { return false } } } return true }]} {Id:24 FileId:113 StartLine:332 StartColumn:1 EndLine:334 EndColumn:2 Name:Apply Params:[{Name:interval Type:rangetree.Interval} {Name:fn Type:func(rangetree.Entry) bool}] Results:[] Receiver:0xc00095aea0 Body:{
	rt.apply(rt.top, 0, interval, fn)
} PrettyPrintBody:[{ rt.apply(rt.top, 0, interval, fn) }]} {Id:25 FileId:113 StartLine:338 StartColumn:1 EndLine:346 EndColumn:2 Name:Query Params:[{Name:interval Type:rangetree.Interval}] Results:[{Name: Type:rangetree.Entries}] Receiver:0xc00019e4e0 Body:{
	entries := make(rangetree.Entries, 0, 100)
	rt.apply(rt.top, 0, interval, func(e rangetree.Entry) bool {
		entries = append(entries, e)
		return true
	})

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, 100) rt.apply(rt.top, 0, interval, func(e rangetree.Entry) bool { entries = append(entries, e) return true }) return entries }]} {Id:26 FileId:113 StartLine:348 StartColumn:1 EndLine:357 EndColumn:2 Name:flatten Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:entries Type:*rangetree.Entries}] Results:[] Receiver:0xc001603320 Body:{
	lastDimension := isLastDimension(dimension, rt.dimensions)
	for iter := sl.Iter(skipEntry(0)); iter.Next(); {
		if lastDimension {
			*entries = append(*entries, iter.Value().(*lastBundle).entry)
		} else {
			rt.flatten(iter.Value().(*dimensionalBundle).sl, dimension+1, entries)
		}
	}
} PrettyPrintBody:[{ lastDimension := isLastDimension(dimension, rt.dimensions) for iter := sl.Iter(skipEntry(0)); iter.Next(); { if lastDimension { *entries = append(*entries, iter.Value().(*lastBundle).entry) } else { rt.flatten(iter.Value().(*dimensionalBundle).sl, dimension+1, entries) } } }]} {Id:27 FileId:113 StartLine:359 StartColumn:1 EndLine:410 EndColumn:2 Name:insert Params:[{Name:sl Type:*skip.SkipList} {Name:dimension Type:uint64} {Name:index Type:int64} {Name:deleted Type:*rangetree.Entries}] Results:[] Receiver:0xc00095b0c0 Body:{

	var e common.Comparator
	lastDimension := isLastDimension(dimension, rt.dimensions)
	affectedDimension := dimension == insertDimension
	var iter skip.Iterator
	if dimension == insertDimension {
		iter = sl.Iter(skipEntry(index))
	} else {
		iter = sl.Iter(skipEntry(0))
	}

	var toDelete common.Comparators
	if number < 0 {
		toDelete = make(common.Comparators, 0, 100)
	}

	for iter.Next() {
		e = iter.Value()
		if !affectedDimension {
			rt.insert(e.(*dimensionalBundle).sl, dimension+1,
				insertDimension, index, number, deleted, affected,
			)
			continue
		}
		if needsDeletion(int64(e.(keyed).key()), index, number) {
			toDelete = append(toDelete, e)
			continue
		}

		if lastDimension {
			e.(*lastBundle).id += uint64(number)
			*affected = append(*affected, e.(*lastBundle).entry)
		} else {
			e.(*dimensionalBundle).id += uint64(number)
			rt.flatten(e.(*dimensionalBundle).sl, dimension+1, affected)
		}
	}

	if len(toDelete) > 0 {
		for _, e := range toDelete {
			if lastDimension {
				*deleted = append(*deleted, e.(*lastBundle).entry)
			} else {
				rt.flatten(e.(*dimensionalBundle).sl, dimension+1, deleted)
			}
		}

		sl.Delete(toDelete...)
	}
} PrettyPrintBody:[{ var e common.Comparator lastDimension := isLastDimension(dimension, rt.dimensions) affectedDimension := dimension == insertDimension var iter skip.Iterator if dimension == insertDimension { iter = sl.Iter(skipEntry(index)) } else { iter = sl.Iter(skipEntry(0)) } var toDelete common.Comparators if number < 0 { toDelete = make(common.Comparators, 0, 100) } for iter.Next() { e = iter.Value() if !affectedDimension { rt.insert(e.(*dimensionalBundle).sl, dimension+1, insertDimension, index, number, deleted, affected, ) continue } if needsDeletion(int64(e.(keyed).key()), index, number) { toDelete = append(toDelete, e) continue } if lastDimension { e.(*lastBundle).id += uint64(number) *affected = append(*affected, e.(*lastBundle).entry) } else { e.(*dimensionalBundle).id += uint64(number) rt.flatten(e.(*dimensionalBundle).sl, dimension+1, affected) } } if len(toDelete) > 0 { for _, e := range toDelete { if lastDimension { *deleted = append(*deleted, e.(*lastBundle).entry) } else { rt.flatten(e.(*dimensionalBundle).sl, dimension+1, deleted) } } sl.Delete(toDelete...) } }]} {Id:28 FileId:113 StartLine:417 StartColumn:1 EndLine:433 EndColumn:2 Name:InsertAtDimension Params:[{Name:dimension Type:uint64} {Name:index Type:int64}] Results:[{Name: Type:rangetree.Entries} {Name: Type:rangetree.Entries}] Receiver:0xc0009923a0 Body:{

	if dimension >= rt.dimensions || number == 0 {
		return rangetree.Entries{}, rangetree.Entries{}
	}

	affected := make(rangetree.Entries, 0, 100)
	var deleted rangetree.Entries
	if number < 0 {
		deleted = make(rangetree.Entries, 0, 100)
	}

	rt.insert(rt.top, 0, dimension, index, number, &deleted, &affected)
	rt.number -= uint64(len(deleted))
	return affected, deleted
} PrettyPrintBody:[{ if dimension >= rt.dimensions || number == 0 { return rangetree.Entries{}, rangetree.Entries{} } affected := make(rangetree.Entries, 0, 100) var deleted rangetree.Entries if number < 0 { deleted = make(rangetree.Entries, 0, 100) } rt.insert(rt.top, 0, dimension, index, number, &deleted, &affected) rt.number -= uint64(len(deleted)) return affected, deleted }]} {Id:29 FileId:113 StartLine:435 StartColumn:1 EndLine:439 EndColumn:2 Name:new Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:*skipListRT}] Receiver:<nil> Body:{
	sl := &skipListRT{}
	sl.init(dimensions)
	return sl
} PrettyPrintBody:[{ sl := &skipListRT{} sl.init(dimensions) return sl }]} {Id:30 FileId:113 StartLine:443 StartColumn:1 EndLine:445 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:rangetree.RangeTree}] Receiver:<nil> Body:{
	return new(dimensions)
} PrettyPrintBody:[{ return new(dimensions) }]} {Id:1 FileId:163 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:generateEntries Params:[{Name:num Type:int}] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	entries := make(Entries, 0, num)
	for i := uint64(0); i < uint64(num); i++ {
		entries = append(entries, newMockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, num) for i := uint64(0); i < uint64(num); i++ { entries = append(entries, newMockEntry(i)) } return entries }]} {Id:2 FileId:163 StartLine:34 StartColumn:1 EndLine:56 EndColumn:2 Name:TestTrieSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)
	e3 := newMockEntry(8)

	yfast.Insert(e1, e2, e3)

	result := yfast.get(3)
	assert.Equal(t, e1, result)

	result = yfast.get(7)
	assert.Equal(t, e2, result)

	result = yfast.get(8)
	assert.Equal(t, e3, result)

	result = yfast.get(250)
	assert.Nil(t, result)

	assert.Equal(t, uint64(3), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(7) e3 := newMockEntry(8) yfast.Insert(e1, e2, e3) result := yfast.get(3) assert.Equal(t, e1, result) result = yfast.get(7) assert.Equal(t, e2, result) result = yfast.get(8) assert.Equal(t, e3, result) result = yfast.get(250) assert.Nil(t, result) assert.Equal(t, uint64(3), yfast.Len()) }]} {Id:3 FileId:163 StartLine:58 StartColumn:1 EndLine:68 EndColumn:2 Name:TestTrieOverwriteInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(3)
	yfast.Insert(e1)

	yfast.Insert(e2)
	assert.Equal(t, e2, yfast.Get(3))
	assert.Equal(t, uint64(1), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(3) yfast.Insert(e1) yfast.Insert(e2) assert.Equal(t, e2, yfast.Get(3)) assert.Equal(t, uint64(1), yfast.Len()) }]} {Id:4 FileId:163 StartLine:70 StartColumn:1 EndLine:97 EndColumn:2 Name:TestTrieDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)
	e3 := newMockEntry(8)

	yfast.Insert(e1, e2, e3)

	result := yfast.Delete(3)
	assert.Equal(t, Entries{e1}, result)
	assert.Nil(t, yfast.Get(3))
	assert.Equal(t, uint64(2), yfast.Len())

	result = yfast.Delete(7)
	assert.Equal(t, Entries{e2}, result)
	assert.Nil(t, yfast.Get(7))
	assert.Equal(t, uint64(1), yfast.Len())

	result = yfast.Delete(8)
	assert.Equal(t, Entries{e3}, result)
	assert.Nil(t, yfast.Get(8))
	assert.Equal(t, uint64(0), yfast.Len())

	result = yfast.Delete(5)
	assert.Equal(t, Entries{nil}, result)
	assert.Equal(t, uint64(0), yfast.Len())
} PrettyPrintBody:[{ yfast := New(uint8(0)) e1 := newMockEntry(3) e2 := newMockEntry(7) e3 := newMockEntry(8) yfast.Insert(e1, e2, e3) result := yfast.Delete(3) assert.Equal(t, Entries{e1}, result) assert.Nil(t, yfast.Get(3)) assert.Equal(t, uint64(2), yfast.Len()) result = yfast.Delete(7) assert.Equal(t, Entries{e2}, result) assert.Nil(t, yfast.Get(7)) assert.Equal(t, uint64(1), yfast.Len()) result = yfast.Delete(8) assert.Equal(t, Entries{e3}, result) assert.Nil(t, yfast.Get(8)) assert.Equal(t, uint64(0), yfast.Len()) result = yfast.Delete(5) assert.Equal(t, Entries{nil}, result) assert.Equal(t, uint64(0), yfast.Len()) }]} {Id:5 FileId:163 StartLine:99 StartColumn:1 EndLine:130 EndColumn:2 Name:TestTrieSuccessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	e3 := newMockEntry(13)
	yfast.Insert(e3)

	successor := yfast.Successor(0)
	assert.Equal(t, e3, successor)

	e1 := newMockEntry(3)
	e2 := newMockEntry(7)

	yfast.Insert(e1, e2)

	successor = yfast.Successor(0)
	assert.Equal(t, e1, successor)

	successor = yfast.Successor(3)
	assert.Equal(t, e1, successor)

	successor = yfast.Successor(4)
	assert.Equal(t, e2, successor)

	successor = yfast.Successor(8)
	assert.Equal(t, e3, successor)

	successor = yfast.Successor(14)
	assert.Nil(t, successor)

	successor = yfast.Successor(100)
	assert.Nil(t, successor)
} PrettyPrintBody:[{ yfast := New(uint8(0)) e3 := newMockEntry(13) yfast.Insert(e3) successor := yfast.Successor(0) assert.Equal(t, e3, successor) e1 := newMockEntry(3) e2 := newMockEntry(7) yfast.Insert(e1, e2) successor = yfast.Successor(0) assert.Equal(t, e1, successor) successor = yfast.Successor(3) assert.Equal(t, e1, successor) successor = yfast.Successor(4) assert.Equal(t, e2, successor) successor = yfast.Successor(8) assert.Equal(t, e3, successor) successor = yfast.Successor(14) assert.Nil(t, successor) successor = yfast.Successor(100) assert.Nil(t, successor) }]} {Id:6 FileId:163 StartLine:132 StartColumn:1 EndLine:158 EndColumn:2 Name:TestTriePredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	predecessor := yfast.Predecessor(5)
	assert.Nil(t, predecessor)

	e1 := newMockEntry(5)
	yfast.Insert(e1)

	predecessor = yfast.Predecessor(13)
	assert.Equal(t, e1, predecessor)

	e2 := newMockEntry(12)
	yfast.Insert(e2)

	predecessor = yfast.Predecessor(11)
	assert.Equal(t, e1, predecessor)

	predecessor = yfast.Predecessor(5)
	assert.Equal(t, e1, predecessor)

	predecessor = yfast.Predecessor(4)
	assert.Nil(t, predecessor)

	predecessor = yfast.Predecessor(100)
	assert.Equal(t, e2, predecessor)
} PrettyPrintBody:[{ yfast := New(uint8(0)) predecessor := yfast.Predecessor(5) assert.Nil(t, predecessor) e1 := newMockEntry(5) yfast.Insert(e1) predecessor = yfast.Predecessor(13) assert.Equal(t, e1, predecessor) e2 := newMockEntry(12) yfast.Insert(e2) predecessor = yfast.Predecessor(11) assert.Equal(t, e1, predecessor) predecessor = yfast.Predecessor(5) assert.Equal(t, e1, predecessor) predecessor = yfast.Predecessor(4) assert.Nil(t, predecessor) predecessor = yfast.Predecessor(100) assert.Equal(t, e2, predecessor) }]} {Id:7 FileId:163 StartLine:160 StartColumn:1 EndLine:192 EndColumn:2 Name:TestTrieIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint8(0))

	iter := yfast.Iter(5)
	assert.Equal(t, Entries{}, iter.exhaust())

	e1 := newMockEntry(5)
	yfast.Insert(e1)

	iter = yfast.Iter(5)
	assert.Equal(t, Entries{e1}, iter.exhaust())

	e2 := newMockEntry(12)
	yfast.Insert(e2)

	iter = yfast.Iter(5)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())

	iter = yfast.Iter(6)
	assert.Equal(t, Entries{e2}, iter.exhaust())

	e3 := newMockEntry(6)
	yfast.Insert(e3)

	iter = yfast.Iter(7)
	assert.Equal(t, Entries{e2}, iter.exhaust())

	iter = yfast.Iter(0)
	assert.Equal(t, Entries{e1, e3, e2}, iter.exhaust())

	iter = yfast.Iter(13)
	assert.Equal(t, Entries{}, iter.exhaust())
} PrettyPrintBody:[{ yfast := New(uint8(0)) iter := yfast.Iter(5) assert.Equal(t, Entries{}, iter.exhaust()) e1 := newMockEntry(5) yfast.Insert(e1) iter = yfast.Iter(5) assert.Equal(t, Entries{e1}, iter.exhaust()) e2 := newMockEntry(12) yfast.Insert(e2) iter = yfast.Iter(5) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) iter = yfast.Iter(6) assert.Equal(t, Entries{e2}, iter.exhaust()) e3 := newMockEntry(6) yfast.Insert(e3) iter = yfast.Iter(7) assert.Equal(t, Entries{e2}, iter.exhaust()) iter = yfast.Iter(0) assert.Equal(t, Entries{e1, e3, e2}, iter.exhaust()) iter = yfast.Iter(13) assert.Equal(t, Entries{}, iter.exhaust()) }]} {Id:8 FileId:163 StartLine:194 StartColumn:1 EndLine:203 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	yfast := New(uint64(0))
	entries := generateEntries(b.N)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Insert(entries[i])
	}
} PrettyPrintBody:[{ yfast := New(uint64(0)) entries := generateEntries(b.N) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Insert(entries[i]) } }]} {Id:9 FileId:163 StartLine:205 StartColumn:1 EndLine:218 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000

	entries := generateEntries(numItems)

	yfast := New(uint32(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Get(uint64(numItems / 2))
	}
} PrettyPrintBody:[{ numItems := 1000 entries := generateEntries(numItems) yfast := New(uint32(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Get(uint64(numItems / 2)) } }]} {Id:10 FileId:163 StartLine:220 StartColumn:1 EndLine:230 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	entries := generateEntries(b.N)
	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Delete(uint64(i))
	}
} PrettyPrintBody:[{ entries := generateEntries(b.N) yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Delete(uint64(i)) } }]} {Id:11 FileId:163 StartLine:232 StartColumn:1 EndLine:248 EndColumn:2 Name:BenchmarkSuccessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	entries := make(Entries, 0, numItems)
	for i := uint64(0); i < uint64(numItems); i++ {
		entries = append(entries, newMockEntry(i+uint64(b.N/2)))
	}

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Successor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { entries = append(entries, newMockEntry(i+uint64(b.N/2))) } yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Successor(uint64(i)) } }]} {Id:12 FileId:163 StartLine:250 StartColumn:1 EndLine:266 EndColumn:2 Name:BenchmarkPredecessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	entries := make(Entries, 0, numItems)
	for i := uint64(0); i < uint64(numItems); i++ {
		entries = append(entries, newMockEntry(i+uint64(b.N/2)))
	}

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		yfast.Predecessor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { entries = append(entries, newMockEntry(i+uint64(b.N/2))) } yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { yfast.Predecessor(uint64(i)) } }]} {Id:13 FileId:163 StartLine:268 StartColumn:1 EndLine:282 EndColumn:2 Name:BenchmarkIterator Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	entries := generateEntries(numItems)

	yfast := New(uint64(0))
	yfast.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for iter := yfast.Iter(0); iter.Next(); {
			iter.Value()
		}
	}
} PrettyPrintBody:[{ numItems := 1000 entries := generateEntries(numItems) yfast := New(uint64(0)) yfast.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { for iter := yfast.Iter(0); iter.Next(); { iter.Value() } } }]} {Id:1 FileId:155 StartLine:51 StartColumn:1 EndLine:56 EndColumn:2 Name:isInternal Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n == nil {
		return false
	}
	return n.entry == nil
} PrettyPrintBody:[{ if n == nil { return false } return n.entry == nil }]} {Id:2 FileId:155 StartLine:60 StartColumn:1 EndLine:62 EndColumn:2 Name:hasInternal Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return isInternal(n.children[0]) || isInternal(n.children[1])
} PrettyPrintBody:[{ return isInternal(n.children[0]) || isInternal(n.children[1]) }]} {Id:3 FileId:155 StartLine:66 StartColumn:1 EndLine:71 EndColumn:2 Name:isLeaf Params:[{Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n == nil {
		return false
	}
	return !isInternal(n)
} PrettyPrintBody:[{ if n == nil { return false } return !isInternal(n) }]} {Id:8 FileId:155 StartLine:131 StartColumn:1 EndLine:137 EndColumn:2 Name:newNode Params:[{Name:parent Type:*node} {Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		children:	[2]*node{},
		entry:		entry,
		parent:		parent,
	}
} PrettyPrintBody:[{ return &node{ children:	[2]*node{}, entry:		entry, parent:		parent, } }]} {Id:9 FileId:155 StartLine:144 StartColumn:1 EndLine:161 EndColumn:2 Name:binarySearchHashMaps Params:[{Name:layers Type:[]map[uint64]*node} {Name:key Type:uint64}] Results:[{Name: Type:int} {Name: Type:*node}] Receiver:<nil> Body:{
	low, high := 0, len(layers)-1
	diff := 64 - len(layers)
	var mid int
	var node *node
	for low <= high {
		mid = (low + high) / 2
		n, ok := layers[mid][key&masks[diff+mid]]
		if ok {
			node = n
			low = mid + 1
		} else {
			high = mid - 1
		}
	}

	return low, node
} PrettyPrintBody:[{ low, high := 0, len(layers)-1 diff := 64 - len(layers) var mid int var node *node for low <= high { mid = (low + high) / 2 n, ok := layers[mid][key&masks[diff+mid]] if ok { node = n low = mid + 1 } else { high = mid - 1 } } return low, node }]} {Id:10 FileId:155 StartLine:168 StartColumn:1 EndLine:178 EndColumn:2 Name:whichSide Params:[{Name:n Type:*node}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if parent.children[0] == n {
		return 0
	}

	if parent.children[1] == n {
		return 1
	}

	panic(fmt.Sprintf(`Node: %+v, %p not a child of: %+v, %p`, n, n, parent, parent))
} PrettyPrintBody:[{ if parent.children[0] == n { return 0 } if parent.children[1] == n { return 1 } panic(fmt.Sprintf(`Node: %+v, %p not a child of: %+v, %p`, n, n, parent, parent)) }]} {Id:12 FileId:155 StartLine:216 StartColumn:1 EndLine:240 EndColumn:2 Name:init Params:[{Name:intType Type:interface{}}] Results:[] Receiver:0xc000df7c80 Body:{
	bits := uint8(0)
	switch intType.(type) {
	case uint8:
		bits = 8
	case uint16:
		bits = 16
	case uint32:
		bits = 32
	case uint, uint64:
		bits = 64
	default:

		panic(`Invalid universe size provided.`)
	}

	xft.layers = make([]map[uint64]*node, bits)
	xft.bits = bits
	xft.diff = 64 - bits
	for i := uint8(0); i < bits; i++ {
		xft.layers[i] = make(map[uint64]*node, 50)
	}
	xft.num = 0
	xft.root = newNode(nil, nil)
} PrettyPrintBody:[{ bits := uint8(0) switch intType.(type) { case uint8: bits = 8 case uint16: bits = 16 case uint32: bits = 32 case uint, uint64: bits = 64 default: panic(`Invalid universe size provided.`) } xft.layers = make([]map[uint64]*node, bits) xft.bits = bits xft.diff = 64 - bits for i := uint8(0); i < bits; i++ { xft.layers[i] = make(map[uint64]*node, 50) } xft.num = 0 xft.root = newNode(nil, nil) }]} {Id:13 FileId:155 StartLine:244 StartColumn:1 EndLine:249 EndColumn:2 Name:Exists Params:[{Name:key Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc001581040 Body:{

	_, ok := xft.layers[xft.bits-1][key]
	return ok
} PrettyPrintBody:[{ _, ok := xft.layers[xft.bits-1][key] return ok }]} {Id:14 FileId:155 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001033a80 Body:{
	return xft.num
} PrettyPrintBody:[{ return xft.num }]} {Id:15 FileId:155 StartLine:259 StartColumn:1 EndLine:265 EndColumn:2 Name:Max Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001033ac0 Body:{
	if xft.max == nil {
		return nil
	}

	return xft.max.entry
} PrettyPrintBody:[{ if xft.max == nil { return nil } return xft.max.entry }]} {Id:16 FileId:155 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:Min Params:[] Results:[{Name: Type:Entry}] Receiver:0xc001581260 Body:{
	if xft.min == nil {
		return nil
	}

	return xft.min.entry
} PrettyPrintBody:[{ if xft.min == nil { return nil } return xft.min.entry }]} {Id:17 FileId:155 StartLine:279 StartColumn:1 EndLine:378 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[] Receiver:0xc001309c40 Body:{
	key := entry.Key()
	n := xft.layers[xft.bits-1][key]
	if n != nil {
		n.entry = entry
		return
	}

	var predecessor, successor *node
	if xft.min != nil && key < xft.min.entry.Key() {
		successor = xft.min
	} else {
		successor = xft.successor(key)
	}

	if successor == nil {
		if xft.max != nil && key > xft.max.entry.Key() {
			predecessor = xft.max
		} else {
			predecessor = xft.predecessor(key)
		}
	}

	layer, root := binarySearchHashMaps(xft.layers, key)
	if root == nil {
		n = xft.root
		layer = 0
	} else {
		n = root
	}

	var leftOrRight uint64

	for i := uint8(layer); i < xft.bits; i++ {

		leftOrRight = (key & positions[xft.diff+i]) >> (xft.bits - 1 - i)
		if n.children[leftOrRight] == nil || isLeaf(n.children[leftOrRight]) {
			var nn *node
			if i < xft.bits-1 {
				nn = newNode(n, nil)
			} else {
				nn = newNode(n, entry)
				xft.num++
			}

			n.children[leftOrRight] = nn
			xft.layers[i][key&masks[xft.diff+i]] = nn
		}

		n = n.children[leftOrRight]
	}

	if successor != nil {
		predecessor = successor.children[0]
		if predecessor != nil {
			predecessor.children[1] = n
			n.children[0] = predecessor
		}
		n.children[1] = successor
		successor.children[0] = n
	} else if predecessor != nil {
		n.children[0] = predecessor
		predecessor.children[1] = n
	}

	if successor != nil {
		xft.walkUpSuccessor(root, n, successor)
	}

	if predecessor != nil {
		xft.walkUpPredecessor(root, n, predecessor)
	}

	xft.walkUpNode(root, n, predecessor, successor)

	if xft.max == nil || key > xft.max.entry.Key() {
		xft.max = n
	}

	if xft.min == nil || key < xft.min.entry.Key() {
		xft.min = n
	}
} PrettyPrintBody:[{ key := entry.Key() n := xft.layers[xft.bits-1][key] if n != nil { n.entry = entry return } var predecessor, successor *node if xft.min != nil && key < xft.min.entry.Key() { successor = xft.min } else { successor = xft.successor(key) } if successor == nil { if xft.max != nil && key > xft.max.entry.Key() { predecessor = xft.max } else { predecessor = xft.predecessor(key) } } layer, root := binarySearchHashMaps(xft.layers, key) if root == nil { n = xft.root layer = 0 } else { n = root } var leftOrRight uint64 for i := uint8(layer); i < xft.bits; i++ { leftOrRight = (key & positions[xft.diff+i]) >> (xft.bits - 1 - i) if n.children[leftOrRight] == nil || isLeaf(n.children[leftOrRight]) { var nn *node if i < xft.bits-1 { nn = newNode(n, nil) } else { nn = newNode(n, entry) xft.num++ } n.children[leftOrRight] = nn xft.layers[i][key&masks[xft.diff+i]] = nn } n = n.children[leftOrRight] } if successor != nil { predecessor = successor.children[0] if predecessor != nil { predecessor.children[1] = n n.children[0] = predecessor } n.children[1] = successor successor.children[0] = n } else if predecessor != nil { n.children[0] = predecessor predecessor.children[1] = n } if successor != nil { xft.walkUpSuccessor(root, n, successor) } if predecessor != nil { xft.walkUpPredecessor(root, n, predecessor) } xft.walkUpNode(root, n, predecessor, successor) if xft.max == nil || key > xft.max.entry.Key() { xft.max = n } if xft.min == nil || key < xft.min.entry.Key() { xft.min = n } }]} {Id:18 FileId:155 StartLine:383 StartColumn:1 EndLine:393 EndColumn:2 Name:walkUpSuccessor Params:[{Name:root Type:*node}] Results:[] Receiver:0xc001602ba0 Body:{
	n := successor.parent
	for n != nil && n != root {

		if !isInternal(n.children[0]) && n.children[0] != successor {
			n.children[0] = node
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := successor.parent for n != nil && n != root { if !isInternal(n.children[0]) && n.children[0] != successor { n.children[0] = node } n = n.parent } }]} {Id:19 FileId:155 StartLine:398 StartColumn:1 EndLine:406 EndColumn:2 Name:walkUpPredecessor Params:[{Name:root Type:*node}] Results:[] Receiver:0xc001033ee0 Body:{
	n := predecessor.parent
	for n != nil && n != root {
		if !isInternal(n.children[1]) && n.children[1] != predecessor {
			n.children[1] = node
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := predecessor.parent for n != nil && n != root { if !isInternal(n.children[1]) && n.children[1] != predecessor { n.children[1] = node } n = n.parent } }]} {Id:20 FileId:155 StartLine:411 StartColumn:1 EndLine:422 EndColumn:2 Name:walkUpNode Params:[{Name:root Type:*node}] Results:[] Receiver:0xc0003e5380 Body:{
	n := node.parent
	for n != nil && n != root {
		if !isInternal(n.children[1]) && n.children[1] != successor && n.children[1] != node {
			n.children[1] = successor
		}
		if !isInternal(n.children[0]) && n.children[0] != predecessor && n.children[0] != node {
			n.children[0] = predecessor
		}
		n = n.parent
	}
} PrettyPrintBody:[{ n := node.parent for n != nil && n != root { if !isInternal(n.children[1]) && n.children[1] != successor && n.children[1] != node { n.children[1] = successor } if !isInternal(n.children[0]) && n.children[0] != predecessor && n.children[0] != node { n.children[0] = predecessor } n = n.parent } }]} {Id:21 FileId:155 StartLine:427 StartColumn:1 EndLine:431 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[] Receiver:0xc001033f80 Body:{
	for _, e := range entries {
		xft.insert(e)
	}
} PrettyPrintBody:[{ for _, e := range entries { xft.insert(e) } }]} {Id:22 FileId:155 StartLine:433 StartColumn:1 EndLine:497 EndColumn:2 Name:delete Params:[{Name:key Type:uint64}] Results:[] Receiver:0xc001173dc0 Body:{
	n := xft.layers[xft.bits-1][key]
	if n == nil {
		return
	}

	successor, predecessor := n.children[1], n.children[0]

	i := uint8(1)
	delete(xft.layers[xft.bits-1], key)
	leftOrRight := whichSide(n, n.parent)
	n.parent.children[leftOrRight] = nil
	n.children[0], n.children[1] = nil, nil
	n = n.parent
	hasImmediateSibling := false
	if successor != nil && successor.parent == n {
		hasImmediateSibling = true
	}
	if predecessor != nil && predecessor.parent == n {
		hasImmediateSibling = true
	}

	for n != nil && n.parent != nil {

		if hasInternal(n) || (i == 1 && hasImmediateSibling) {
			n = n.parent
			break
		}

		leftOrRight = whichSide(n, n.parent)
		n.parent.children[leftOrRight] = nil
		n.children[0], n.children[1] = nil, nil
		delete(xft.layers[xft.bits-i-1], key&masks[len(masks)-1-int(i)])
		n = n.parent
		i++
	}

	if predecessor != nil {
		predecessor.children[1] = successor
		xft.walkUpPredecessor(n, successor, predecessor)
	}

	if successor != nil {
		successor.children[0] = predecessor
		xft.walkUpSuccessor(n, predecessor, successor)
	}

	if xft.max.entry.Key() == key {
		xft.max = predecessor
	}

	if xft.min.entry.Key() == key {
		xft.min = successor
	}

	xft.num--
} PrettyPrintBody:[{ n := xft.layers[xft.bits-1][key] if n == nil { return } successor, predecessor := n.children[1], n.children[0] i := uint8(1) delete(xft.layers[xft.bits-1], key) leftOrRight := whichSide(n, n.parent) n.parent.children[leftOrRight] = nil n.children[0], n.children[1] = nil, nil n = n.parent hasImmediateSibling := false if successor != nil && successor.parent == n { hasImmediateSibling = true } if predecessor != nil && predecessor.parent == n { hasImmediateSibling = true } for n != nil && n.parent != nil { if hasInternal(n) || (i == 1 && hasImmediateSibling) { n = n.parent break } leftOrRight = whichSide(n, n.parent) n.parent.children[leftOrRight] = nil n.children[0], n.children[1] = nil, nil delete(xft.layers[xft.bits-i-1], key&masks[len(masks)-1-int(i)]) n = n.parent i++ } if predecessor != nil { predecessor.children[1] = successor xft.walkUpPredecessor(n, successor, predecessor) } if successor != nil { successor.children[0] = predecessor xft.walkUpSuccessor(n, predecessor, successor) } if xft.max.entry.Key() == key { xft.max = predecessor } if xft.min.entry.Key() == key { xft.min = successor } xft.num-- }]} {Id:23 FileId:155 StartLine:502 StartColumn:1 EndLine:506 EndColumn:2 Name:Delete Params:[{Name:keys Type:...uint64}] Results:[] Receiver:0xc00019e720 Body:{
	for _, key := range keys {
		xft.delete(key)
	}
} PrettyPrintBody:[{ for _, key := range keys { xft.delete(key) } }]} {Id:24 FileId:155 StartLine:510 StartColumn:1 EndLine:539 EndColumn:2 Name:predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc001603820 Body:{
	if xft.root == nil || xft.max == nil {
		return nil
	}

	if key >= xft.max.entry.Key() {
		return xft.max
	}

	if key < xft.min.entry.Key() {
		return nil
	}

	n := xft.layers[xft.bits-1][key]
	if n != nil {
		return n
	}

	layer, n := binarySearchHashMaps(xft.layers, key)
	if n == nil && layer > 1 {
		return nil
	} else if n == nil {
		n = xft.root
	}

	if isInternal(n.children[0]) && isLeaf(n.children[1]) {
		return n.children[1].children[0]
	}
	return n.children[0]
} PrettyPrintBody:[{ if xft.root == nil || xft.max == nil { return nil } if key >= xft.max.entry.Key() { return xft.max } if key < xft.min.entry.Key() { return nil } n := xft.layers[xft.bits-1][key] if n != nil { return n } layer, n := binarySearchHashMaps(xft.layers, key) if n == nil && layer > 1 { return nil } else if n == nil { n = xft.root } if isInternal(n.children[0]) && isLeaf(n.children[1]) { return n.children[1].children[0] } return n.children[0] }]} {Id:25 FileId:155 StartLine:543 StartColumn:1 EndLine:572 EndColumn:2 Name:successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0001e6ba0 Body:{
	if xft.root == nil || xft.min == nil {
		return nil
	}

	if key <= xft.min.entry.Key() {
		return xft.min
	}

	if key > xft.max.entry.Key() {
		return nil
	}

	n := xft.layers[xft.bits-1][key]
	if n != nil {
		return n
	}

	layer, n := binarySearchHashMaps(xft.layers, key)
	if n == nil && layer > 1 {
		return nil
	} else if n == nil {
		n = xft.root
	}

	if isInternal(n.children[1]) && isLeaf(n.children[0]) {
		return n.children[0].children[1]
	}
	return n.children[1]
} PrettyPrintBody:[{ if xft.root == nil || xft.min == nil { return nil } if key <= xft.min.entry.Key() { return xft.min } if key > xft.max.entry.Key() { return nil } n := xft.layers[xft.bits-1][key] if n != nil { return n } layer, n := binarySearchHashMaps(xft.layers, key) if n == nil && layer > 1 { return nil } else if n == nil { n = xft.root } if isInternal(n.children[1]) && isLeaf(n.children[0]) { return n.children[0].children[1] } return n.children[1] }]} {Id:26 FileId:155 StartLine:577 StartColumn:1 EndLine:584 EndColumn:2 Name:Successor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0016039e0 Body:{
	n := xft.successor(key)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.successor(key) if n == nil { return nil } return n.entry }]} {Id:27 FileId:155 StartLine:589 StartColumn:1 EndLine:596 EndColumn:2 Name:Predecessor Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc0009927e0 Body:{
	n := xft.predecessor(key)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.predecessor(key) if n == nil { return nil } return n.entry }]} {Id:28 FileId:155 StartLine:601 StartColumn:1 EndLine:606 EndColumn:2 Name:Iter Params:[{Name:key Type:uint64}] Results:[{Name: Type:*Iterator}] Receiver:0xc000992840 Body:{
	return &Iterator{
		n:	xft.successor(key),
		first:	true,
	}
} PrettyPrintBody:[{ return &Iterator{ n:	xft.successor(key), first:	true, } }]} {Id:29 FileId:155 StartLine:611 StartColumn:1 EndLine:620 EndColumn:2 Name:Get Params:[{Name:key Type:uint64}] Results:[{Name: Type:Entry}] Receiver:0xc00019e9c0 Body:{

	n := xft.layers[xft.bits-1][key]
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n := xft.layers[xft.bits-1][key] if n == nil { return nil } return n.entry }]} {Id:30 FileId:155 StartLine:627 StartColumn:1 EndLine:631 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*XFastTrie}] Receiver:<nil> Body:{
	xft := &XFastTrie{}
	xft.init(ifc)
	return xft
} PrettyPrintBody:[{ xft := &XFastTrie{} xft.init(ifc) return xft }]} {Id:2 FileId:150 StartLine:43 StartColumn:1 EndLine:43 EndColumn:48 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00111ebe0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:3 FileId:150 StartLine:44 StartColumn:1 EndLine:44 EndColumn:50 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc00111ec20 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:4 FileId:150 StartLine:45 StartColumn:1 EndLine:45 EndColumn:50 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0010dbf00 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:5 FileId:150 StartLine:47 StartColumn:1 EndLine:49 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00123c0e0 Body:{
	return fmt.Sprint(n.entries)
} PrettyPrintBody:[{ return fmt.Sprint(n.entries) }]} {Id:7 FileId:150 StartLine:55 StartColumn:1 EndLine:55 EndColumn:57 Name:KeyHash Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00123c580 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:8 FileId:150 StartLine:56 StartColumn:1 EndLine:56 EndColumn:59 Name:Key Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc001227d60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:9 FileId:150 StartLine:57 StartColumn:1 EndLine:57 EndColumn:59 Name:Value Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000e7e720 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:10 FileId:150 StartLine:59 StartColumn:1 EndLine:61 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc000e7e980 Body:{
	return fmt.Sprintf("<COLLISIONS %v>%v", len(n.entries), n.entries)
} PrettyPrintBody:[{ return fmt.Sprintf("<COLLISIONS %v>%v", len(n.entries), n.entries) }]} {Id:12 FileId:150 StartLine:70 StartColumn:1 EndLine:72 EndColumn:2 Name:emptyNode Params:[{Name:level Type:uint8} {Name:capacity Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{entries: make([]Entry, capacity), level: level}
} PrettyPrintBody:[{ return &node{entries: make([]Entry, capacity), level: level} }]} {Id:13 FileId:150 StartLine:74 StartColumn:1 EndLine:125 EndColumn:2 Name:insert Params:[{Name:n Type:*node} {Name:entry Type:Entry}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	index := uint(mask(entry.KeyHash(), n.level))
	newNode := n
	if newNode.level == 6 {
		if newNode.entries[index] == nil {
			newNode.entries[index] = entry
			newNode.dataMap = newNode.dataMap.SetBit(index)
			return newNode
		}
		if newNode.dataMap.GetBit(index) {
			if newNode.entries[index].Key() == entry.Key() {
				newNode.entries[index] = entry
				return newNode
			}
			cNode := &collisionNode{entries: make([]Entry, 2)}
			cNode.entries[0] = newNode.entries[index]
			cNode.entries[1] = entry
			newNode.entries[index] = cNode
			newNode.dataMap = newNode.dataMap.ClearBit(index)
			return newNode
		}
		cNode := newNode.entries[index].(*collisionNode)
		cNode.entries = append(cNode.entries, entry)
		return newNode
	}
	if !newNode.dataMap.GetBit(index) && !newNode.nodeMap.GetBit(index) {
		newNode.entries[index] = entry
		newNode.dataMap = newNode.dataMap.SetBit(index)
		return newNode
	}
	if newNode.nodeMap.GetBit(index) {
		newNode.entries[index] = insert(newNode.entries[index].(*node), entry)
		return newNode
	}
	if newNode.entries[index].Key() == entry.Key() {
		newNode.entries[index] = entry
		return newNode
	}

	var subNode *node
	if newNode.level == 5 {
		subNode = emptyNode(newNode.level+1, 4)
	} else {
		subNode = emptyNode(newNode.level+1, 32)
	}
	subNode = insert(subNode, newNode.entries[index])
	subNode = insert(subNode, entry)
	newNode.dataMap = newNode.dataMap.ClearBit(index)
	newNode.nodeMap = newNode.nodeMap.SetBit(index)
	newNode.entries[index] = subNode
	return newNode
} PrettyPrintBody:[{ index := uint(mask(entry.KeyHash(), n.level)) newNode := n if newNode.level == 6 { if newNode.entries[index] == nil { newNode.entries[index] = entry newNode.dataMap = newNode.dataMap.SetBit(index) return newNode } if newNode.dataMap.GetBit(index) { if newNode.entries[index].Key() == entry.Key() { newNode.entries[index] = entry return newNode } cNode := &collisionNode{entries: make([]Entry, 2)} cNode.entries[0] = newNode.entries[index] cNode.entries[1] = entry newNode.entries[index] = cNode newNode.dataMap = newNode.dataMap.ClearBit(index) return newNode } cNode := newNode.entries[index].(*collisionNode) cNode.entries = append(cNode.entries, entry) return newNode } if !newNode.dataMap.GetBit(index) && !newNode.nodeMap.GetBit(index) { newNode.entries[index] = entry newNode.dataMap = newNode.dataMap.SetBit(index) return newNode } if newNode.nodeMap.GetBit(index) { newNode.entries[index] = insert(newNode.entries[index].(*node), entry) return newNode } if newNode.entries[index].Key() == entry.Key() { newNode.entries[index] = entry return newNode } var subNode *node if newNode.level == 5 { subNode = emptyNode(newNode.level+1, 4) } else { subNode = emptyNode(newNode.level+1, 32) } subNode = insert(subNode, newNode.entries[index]) subNode = insert(subNode, entry) newNode.dataMap = newNode.dataMap.ClearBit(index) newNode.nodeMap = newNode.nodeMap.SetBit(index) newNode.entries[index] = subNode return newNode }]} {Id:14 FileId:150 StartLine:128 StartColumn:1 EndLine:148 EndColumn:2 Name:get Params:[{Name:n Type:*node} {Name:keyHash Type:uint32} {Name:key Type:interface{}}] Results:[{Name: Type:Entry}] Receiver:<nil> Body:{
	index := uint(mask(keyHash, n.level))
	if n.dataMap.GetBit(index) {
		return n.entries[index]
	}
	if n.nodeMap.GetBit(index) {
		return get(n.entries[index].(*node), keyHash, key)
	}
	if n.level == 6 {
		if n.entries[index] == nil {
			return nil
		}
		cNode := n.entries[index].(*collisionNode)
		for _, e := range cNode.entries {
			if e.Key() == key {
				return e
			}
		}
	}
	return nil
} PrettyPrintBody:[{ index := uint(mask(keyHash, n.level)) if n.dataMap.GetBit(index) { return n.entries[index] } if n.nodeMap.GetBit(index) { return get(n.entries[index].(*node), keyHash, key) } if n.level == 6 { if n.entries[index] == nil { return nil } cNode := n.entries[index].(*collisionNode) for _, e := range cNode.entries { if e.Key() == key { return e } } } return nil }]} {Id:15 FileId:150 StartLine:150 StartColumn:1 EndLine:193 EndColumn:2 Name:remove Params:[{Name:n Type:*node} {Name:keyHash Type:uint32} {Name:key Type:interface{}}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	index := uint(mask(keyHash, n.level))
	newNode := n
	if n.dataMap.GetBit(index) {
		newNode.entries[index] = nil
		newNode.dataMap = newNode.dataMap.ClearBit(index)
		return newNode
	}
	if n.nodeMap.GetBit(index) {
		subNode := newNode.entries[index].(*node)
		subNode = remove(subNode, keyHash, key)

		if subNode.nodeMap.PopCount() == 0 && subNode.dataMap.PopCount() == 1 {
			var e Entry
			for i := uint(0); i < 32; i++ {
				if subNode.dataMap.GetBit(i) {
					e = subNode.entries[i]
					break
				}
			}
			newNode.entries[index] = e
			newNode.nodeMap = newNode.nodeMap.ClearBit(index)
			newNode.dataMap = newNode.dataMap.SetBit(index)
		}
		newNode.entries[index] = subNode
		return newNode
	}
	if n.level == 6 {
		cNode := newNode.entries[index].(*collisionNode)
		for i, e := range cNode.entries {
			if e.Key() == key {
				cNode.entries = append(cNode.entries[:i], cNode.entries[i+1:]...)
				break
			}
		}

		if len(cNode.entries) == 1 {
			newNode.entries[index] = cNode.entries[0]
			newNode.dataMap = newNode.dataMap.SetBit(index)
		}
		return newNode
	}
	return n
} PrettyPrintBody:[{ index := uint(mask(keyHash, n.level)) newNode := n if n.dataMap.GetBit(index) { newNode.entries[index] = nil newNode.dataMap = newNode.dataMap.ClearBit(index) return newNode } if n.nodeMap.GetBit(index) { subNode := newNode.entries[index].(*node) subNode = remove(subNode, keyHash, key) if subNode.nodeMap.PopCount() == 0 && subNode.dataMap.PopCount() == 1 { var e Entry for i := uint(0); i < 32; i++ { if subNode.dataMap.GetBit(i) { e = subNode.entries[i] break } } newNode.entries[index] = e newNode.nodeMap = newNode.nodeMap.ClearBit(index) newNode.dataMap = newNode.dataMap.SetBit(index) } newNode.entries[index] = subNode return newNode } if n.level == 6 { cNode := newNode.entries[index].(*collisionNode) for i, e := range cNode.entries { if e.Key() == key { cNode.entries = append(cNode.entries[:i], cNode.entries[i+1:]...) break } } if len(cNode.entries) == 1 { newNode.entries[index] = cNode.entries[0] newNode.dataMap = newNode.dataMap.SetBit(index) } return newNode } return n }]} {Id:16 FileId:150 StartLine:195 StartColumn:1 EndLine:202 EndColumn:2 Name:iterate Params:[{Name:n Type:*node} {Name:stop Type:<-chan struct{}}] Results:[{Name: Type:<-chan Entry}] Receiver:<nil> Body:{
	out := make(chan Entry)
	go func() {
		defer close(out)
		pushEntries(n, stop, out)
	}()
	return out
} PrettyPrintBody:[{ out := make(chan Entry) go func() { defer close(out) pushEntries(n, stop, out) }() return out }]} {Id:17 FileId:150 StartLine:204 StartColumn:1 EndLine:234 EndColumn:2 Name:pushEntries Params:[{Name:n Type:*node} {Name:stop Type:<-chan struct{}} {Name:out Type:chan Entry}] Results:[] Receiver:<nil> Body:{
	var wg sync.WaitGroup
	for i, e := range n.entries {
		select {
		case <-stop:
			return
		default:
			index := uint(i)
			switch {
			case n.dataMap.GetBit(index):
				out <- e
			case n.nodeMap.GetBit(index):
				wg.Add(1)
				go func() {
					defer wg.Done()
					pushEntries(e.(*node), stop, out)
				}()
				wg.Wait()
			case n.level == 6 && e != nil:
				for _, ce := range n.entries[index].(*collisionNode).entries {
					select {
					case <-stop:
						return
					default:
						out <- ce
					}
				}
			}
		}
	}
} PrettyPrintBody:[{ var wg sync.WaitGroup for i, e := range n.entries { select { case <-stop: return default: index := uint(i) switch { case n.dataMap.GetBit(index): out <- e case n.nodeMap.GetBit(index): wg.Add(1) go func() { defer wg.Done() pushEntries(e.(*node), stop, out) }() wg.Wait() case n.level == 6 && e != nil: for _, ce := range n.entries[index].(*collisionNode).entries { select { case <-stop: return default: out <- ce } } } } } }]} {Id:18 FileId:72 StartLine:126 StartColumn:1 EndLine:150 EndColumn:2 Name:TestEnqueueDequeueMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence1); i++ {
		heap.Enqueue(NumberSequence1[i])
	}

	var min *Entry
	var err error
	for heap.Size() > 0 {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		if heap.Size() == 199 {
			assert.Equal(t, Seq1FirstMinimum, min.Priority)
		}
		if heap.Size() == 197 {
			assert.Equal(t, Seq1ThirdMinimum, min.Priority)
		}
		if heap.Size() == 195 {
			assert.Equal(t, Seq1FifthMinimum, min.Priority)
		}
		if heap.Size() == 0 {
			assert.Equal(t, Seq1LastMinimum, min.Priority)
		}
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < len(NumberSequence1); i++ { heap.Enqueue(NumberSequence1[i]) } var min *Entry var err error for heap.Size() > 0 { min, err = heap.DequeueMin() require.NoError(t, err) if heap.Size() == 199 { assert.Equal(t, Seq1FirstMinimum, min.Priority) } if heap.Size() == 197 { assert.Equal(t, Seq1ThirdMinimum, min.Priority) } if heap.Size() == 195 { assert.Equal(t, Seq1FifthMinimum, min.Priority) } if heap.Size() == 0 { assert.Equal(t, Seq1LastMinimum, min.Priority) } } }]} {Id:19 FileId:72 StartLine:152 StartColumn:1 EndLine:161 EndColumn:2 Name:TestFibHeap_Enqueue_Min Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence1); i++ {
		heap.Enqueue(NumberSequence1[i])
	}

	min, err := heap.Min()
	require.NoError(t, err)
	assert.Equal(t, Seq1FirstMinimum, min.Priority)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < len(NumberSequence1); i++ { heap.Enqueue(NumberSequence1[i]) } min, err := heap.Min() require.NoError(t, err) assert.Equal(t, Seq1FirstMinimum, min.Priority) }]} {Id:20 FileId:72 StartLine:163 StartColumn:1 EndLine:176 EndColumn:2 Name:TestFibHeap_Min_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	heap.Enqueue(0)
	min, err := heap.DequeueMin()
	require.NoError(t, err)

	min, err = heap.Min()

	assert.EqualError(t, err, "Trying to get minimum element of empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(0) min, err := heap.DequeueMin() require.NoError(t, err) min, err = heap.Min() assert.EqualError(t, err, "Trying to get minimum element of empty heap") assert.Nil(t, min) }]} {Id:21 FileId:72 StartLine:178 StartColumn:1 EndLine:185 EndColumn:2 Name:TestFibHeap_DequeueMin_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	min, err := heap.DequeueMin()

	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot dequeue minimum of empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() min, err := heap.DequeueMin() assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot dequeue minimum of empty heap") assert.Nil(t, min) }]} {Id:22 FileId:72 StartLine:187 StartColumn:1 EndLine:219 EndColumn:2 Name:TestEnqueueDecreaseKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	var e1, e2, e3 *Entry
	for i := 0; i < len(NumberSequence2); i++ {
		if NumberSequence2[i] == Seq2DecreaseKey1Orig {
			e1 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey2Orig {
			e2 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey3Orig {
			e3 = heap.Enqueue(NumberSequence2[i])
		} else {
			heap.Enqueue(NumberSequence2[i])
		}
	}

	require.NotNil(t, e1)
	require.NotNil(t, e2)
	require.NotNil(t, e3)

	_, err := heap.DecreaseKey(e1, Seq2DecreaseKey1Trgt)
	require.NoError(t, err)
	_, err = heap.DecreaseKey(e2, Seq2DecreaseKey2Trgt)
	require.NoError(t, err)
	_, err = heap.DecreaseKey(e3, Seq2DecreaseKey3Trgt)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequence2Sorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequence2Sorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() var e1, e2, e3 *Entry for i := 0; i < len(NumberSequence2); i++ { if NumberSequence2[i] == Seq2DecreaseKey1Orig { e1 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey2Orig { e2 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey3Orig { e3 = heap.Enqueue(NumberSequence2[i]) } else { heap.Enqueue(NumberSequence2[i]) } } require.NotNil(t, e1) require.NotNil(t, e2) require.NotNil(t, e3) _, err := heap.DecreaseKey(e1, Seq2DecreaseKey1Trgt) require.NoError(t, err) _, err = heap.DecreaseKey(e2, Seq2DecreaseKey2Trgt) require.NoError(t, err) _, err = heap.DecreaseKey(e3, Seq2DecreaseKey3Trgt) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequence2Sorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequence2Sorted[i], min.Priority) } }]} {Id:23 FileId:72 StartLine:221 StartColumn:1 EndLine:233 EndColumn:2 Name:TestFibHeap_DecreaseKey_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	elem := heap.Enqueue(15)
	heap.DequeueMin()

	min, err := heap.DecreaseKey(elem, 0)

	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot decrease key in an empty heap")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() elem := heap.Enqueue(15) heap.DequeueMin() min, err := heap.DecreaseKey(elem, 0) assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot decrease key in an empty heap") assert.Nil(t, min) }]} {Id:24 FileId:72 StartLine:235 StartColumn:1 EndLine:243 EndColumn:2 Name:TestFibHeap_DecreaseKey_NilNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(1)
	min, err := heap.DecreaseKey(nil, 0)

	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "Cannot decrease key: given node is nil")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(1) min, err := heap.DecreaseKey(nil, 0) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "Cannot decrease key: given node is nil") assert.Nil(t, min) }]} {Id:25 FileId:72 StartLine:245 StartColumn:1 EndLine:252 EndColumn:2 Name:TestFibHeap_DecreaseKey_LargerNewPriority Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	node := heap.Enqueue(1)
	min, err := heap.DecreaseKey(node, 20)

	assert.EqualError(t, err, "The given new priority: 20, is larger than or equal to the old: 1")
	assert.Nil(t, min)
} PrettyPrintBody:[{ heap := NewFloatFibHeap() node := heap.Enqueue(1) min, err := heap.DecreaseKey(node, 20) assert.EqualError(t, err, "The given new priority: 20, is larger than or equal to the old: 1") assert.Nil(t, min) }]} {Id:26 FileId:72 StartLine:254 StartColumn:1 EndLine:288 EndColumn:2 Name:TestEnqueueDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	var e1, e2, e3 *Entry
	for i := 0; i < len(NumberSequence2); i++ {
		if NumberSequence2[i] == Seq2DecreaseKey1Orig {
			e1 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey2Orig {
			e2 = heap.Enqueue(NumberSequence2[i])
		} else if NumberSequence2[i] == Seq2DecreaseKey3Orig {
			e3 = heap.Enqueue(NumberSequence2[i])
		} else {
			heap.Enqueue(NumberSequence2[i])
		}
	}

	assert.NotNil(t, e1)
	assert.NotNil(t, e2)
	assert.NotNil(t, e3)

	var err error

	err = heap.Delete(e1)
	require.NoError(t, err)
	err = heap.Delete(e2)
	require.NoError(t, err)
	err = heap.Delete(e3)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequence2Deleted3ElemSorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequence2Deleted3ElemSorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() var e1, e2, e3 *Entry for i := 0; i < len(NumberSequence2); i++ { if NumberSequence2[i] == Seq2DecreaseKey1Orig { e1 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey2Orig { e2 = heap.Enqueue(NumberSequence2[i]) } else if NumberSequence2[i] == Seq2DecreaseKey3Orig { e3 = heap.Enqueue(NumberSequence2[i]) } else { heap.Enqueue(NumberSequence2[i]) } } assert.NotNil(t, e1) assert.NotNil(t, e2) assert.NotNil(t, e3) var err error err = heap.Delete(e1) require.NoError(t, err) err = heap.Delete(e2) require.NoError(t, err) err = heap.Delete(e3) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequence2Deleted3ElemSorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequence2Deleted3ElemSorted[i], min.Priority) } }]} {Id:27 FileId:72 StartLine:290 StartColumn:1 EndLine:300 EndColumn:2 Name:TestFibHeap_Delete_EmptyHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()

	elem := heap.Enqueue(15)
	heap.DequeueMin()

	err := heap.Delete(elem)
	assert.IsType(t, EmptyHeapError(""), err)
	assert.EqualError(t, err, "Cannot delete element from an empty heap")
} PrettyPrintBody:[{ heap := NewFloatFibHeap() elem := heap.Enqueue(15) heap.DequeueMin() err := heap.Delete(elem) assert.IsType(t, EmptyHeapError(""), err) assert.EqualError(t, err, "Cannot delete element from an empty heap") }]} {Id:28 FileId:72 StartLine:302 StartColumn:1 EndLine:308 EndColumn:2 Name:TestFibHeap_Delete_NilNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	heap.Enqueue(1)
	err := heap.Delete(nil)
	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "Cannot delete node: given node is nil")
} PrettyPrintBody:[{ heap := NewFloatFibHeap() heap.Enqueue(1) err := heap.Delete(nil) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "Cannot delete node: given node is nil") }]} {Id:29 FileId:72 StartLine:310 StartColumn:1 EndLine:330 EndColumn:2 Name:TestMerge Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence3); i++ {
		heap1.Enqueue(NumberSequence3[i])
	}

	heap2 := NewFloatFibHeap()
	for i := 0; i < len(NumberSequence4); i++ {
		heap1.Enqueue(NumberSequence4[i])
	}

	heap, err := heap1.Merge(&heap2)
	require.NoError(t, err)

	var min *Entry
	for i := 0; i < len(NumberSequenceMerged3And4Sorted); i++ {
		min, err = heap.DequeueMin()
		require.NoError(t, err)
		assert.Equal(t, NumberSequenceMerged3And4Sorted[i], min.Priority)
	}
} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() for i := 0; i < len(NumberSequence3); i++ { heap1.Enqueue(NumberSequence3[i]) } heap2 := NewFloatFibHeap() for i := 0; i < len(NumberSequence4); i++ { heap1.Enqueue(NumberSequence4[i]) } heap, err := heap1.Merge(&heap2) require.NoError(t, err) var min *Entry for i := 0; i < len(NumberSequenceMerged3And4Sorted); i++ { min, err = heap.DequeueMin() require.NoError(t, err) assert.Equal(t, NumberSequenceMerged3And4Sorted[i], min.Priority) } }]} {Id:30 FileId:72 StartLine:332 StartColumn:1 EndLine:339 EndColumn:2 Name:TestFibHeap_Merge_NilHeap Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	var heap FloatingFibonacciHeap
	heap = NewFloatFibHeap()
	newHeap, err := heap.Merge(nil)
	assert.IsType(t, NilError(""), err)
	assert.EqualError(t, err, "One of the heaps to merge is nil. Cannot merge")
	assert.Equal(t, newHeap, FloatingFibonacciHeap{})
} PrettyPrintBody:[{ var heap FloatingFibonacciHeap heap = NewFloatFibHeap() newHeap, err := heap.Merge(nil) assert.IsType(t, NilError(""), err) assert.EqualError(t, err, "One of the heaps to merge is nil. Cannot merge") assert.Equal(t, newHeap, FloatingFibonacciHeap{}) }]} {Id:31 FileId:72 StartLine:361 StartColumn:1 EndLine:368 EndColumn:2 Name:BenchmarkFibHeap_Enqueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{

	heap := NewFloatFibHeap()

	for i := 0; i < b.N; i++ {
		heap.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() for i := 0; i < b.N; i++ { heap.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) } }]} {Id:32 FileId:72 StartLine:371 StartColumn:1 EndLine:386 EndColumn:2 Name:BenchmarkFibHeap_DequeueMin Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{

	heap := NewFloatFibHeap()
	N := 1000000

	slice := make([]float64, 0, N)
	for i := 0; i < N; i++ {
		slice = append(slice, 2*1E10*(rand.Float64()-0.5))
		heap.Enqueue(slice[i])
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		heap.DequeueMin()
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 1000000 slice := make([]float64, 0, N) for i := 0; i < N; i++ { slice = append(slice, 2*1E10*(rand.Float64()-0.5)) heap.Enqueue(slice[i]) } b.ResetTimer() for i := 0; i < b.N; i++ { heap.DequeueMin() } }]} {Id:33 FileId:72 StartLine:389 StartColumn:1 EndLine:410 EndColumn:2 Name:BenchmarkFibHeap_DecreaseKey Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	N := 10000000

	sliceFlt := make([]float64, 0, N)
	sliceE := make([]*Entry, 0, N)
	for i := 0; i < N; i++ {
		sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5))
		sliceE = append(sliceE, heap.Enqueue(sliceFlt[i]))
	}

	b.ResetTimer()
	offset := float64(2)
	for i := 0; i < b.N; i++ {

		if i%N == 0 && i > 0 {
			offset *= float64(i / N)
		}

		heap.DecreaseKey(sliceE[i%N], sliceFlt[i%N]-offset)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 10000000 sliceFlt := make([]float64, 0, N) sliceE := make([]*Entry, 0, N) for i := 0; i < N; i++ { sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5)) sliceE = append(sliceE, heap.Enqueue(sliceFlt[i])) } b.ResetTimer() offset := float64(2) for i := 0; i < b.N; i++ { if i%N == 0 && i > 0 { offset *= float64(i / N) } heap.DecreaseKey(sliceE[i%N], sliceFlt[i%N]-offset) } }]} {Id:34 FileId:72 StartLine:413 StartColumn:1 EndLine:431 EndColumn:2 Name:BenchmarkFibHeap_Delete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap := NewFloatFibHeap()
	N := 1000000

	sliceFlt := make([]float64, 0, N)
	sliceE := make([]*Entry, 0, N)
	for i := 0; i < N; i++ {
		sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5))
		sliceE = append(sliceE, heap.Enqueue(sliceFlt[i]))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := heap.Delete(sliceE[i])
		assert.NoError(b, err)
	}
} PrettyPrintBody:[{ heap := NewFloatFibHeap() N := 1000000 sliceFlt := make([]float64, 0, N) sliceE := make([]*Entry, 0, N) for i := 0; i < N; i++ { sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5)) sliceE = append(sliceE, heap.Enqueue(sliceFlt[i])) } b.ResetTimer() for i := 0; i < b.N; i++ { err := heap.Delete(sliceE[i]) assert.NoError(b, err) } }]} {Id:35 FileId:72 StartLine:434 StartColumn:1 EndLine:444 EndColumn:2 Name:BenchmarkFibHeap_Merge Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	heap1 := NewFloatFibHeap()
	heap2 := NewFloatFibHeap()

	for i := 0; i < b.N; i++ {
		heap1.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
		heap2.Enqueue(2 * 1E10 * (rand.Float64() - 0.5))
		_, err := heap1.Merge(&heap2)
		assert.NoError(b, err)
	}
} PrettyPrintBody:[{ heap1 := NewFloatFibHeap() heap2 := NewFloatFibHeap() for i := 0; i < b.N; i++ { heap1.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) heap2.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)) _, err := heap1.Merge(&heap2) assert.NoError(b, err) } }]} {Id:0 FileId:1 StartLine:19 StartColumn:1 EndLine:35 EndColumn:2 Name:intervalOverlaps Params:[{Name:n Type:*node} {Name:low Type:int64} {Name:interval Type:Interval} {Name:maxDimension Type:uint64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if !overlaps(n.interval.HighAtDimension(1), high, n.interval.LowAtDimension(1), low) {
		return false
	}

	if interval == nil {
		return true
	}

	for i := uint64(2); i <= maxDimension; i++ {
		if !n.interval.OverlapsAtDimension(interval, i) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if !overlaps(n.interval.HighAtDimension(1), high, n.interval.LowAtDimension(1), low) { return false } if interval == nil { return true } for i := uint64(2); i <= maxDimension; i++ { if !n.interval.OverlapsAtDimension(interval, i) { return false } } return true }]} {Id:1 FileId:1 StartLine:37 StartColumn:1 EndLine:39 EndColumn:2 Name:overlaps Params:[{Name:high Type:int64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return high >= otherLow && low <= otherHigh
} PrettyPrintBody:[{ return high >= otherLow && low <= otherHigh }]} {Id:2 FileId:1 StartLine:43 StartColumn:1 EndLine:53 EndColumn:2 Name:compare Params:[{Name:nodeLow Type:int64} {Name:nodeID Type:uint64}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if ivLow > nodeLow {
		return 1
	}

	if ivLow < nodeLow {
		return 0
	}

	return intFromBool(ivID > nodeID)
} PrettyPrintBody:[{ if ivLow > nodeLow { return 1 } if ivLow < nodeLow { return 0 } return intFromBool(ivID > nodeID) }]} {Id:4 FileId:1 StartLine:63 StartColumn:1 EndLine:75 EndColumn:2 Name:query Params:[{Name:low Type:int64} {Name:interval Type:Interval} {Name:maxDimension Type:uint64} {Name:fn Type:func(node *node)}] Results:[] Receiver:0xc001580ca0 Body:{
	if n.children[0] != nil && overlaps(n.children[0].max, high, n.children[0].min, low) {
		n.children[0].query(low, high, interval, maxDimension, fn)
	}

	if intervalOverlaps(n, low, high, interval, maxDimension) {
		fn(n)
	}

	if n.children[1] != nil && overlaps(n.children[1].max, high, n.children[1].min, low) {
		n.children[1].query(low, high, interval, maxDimension, fn)
	}
} PrettyPrintBody:[{ if n.children[0] != nil && overlaps(n.children[0].max, high, n.children[0].min, low) { n.children[0].query(low, high, interval, maxDimension, fn) } if intervalOverlaps(n, low, high, interval, maxDimension) { fn(n) } if n.children[1] != nil && overlaps(n.children[1].max, high, n.children[1].min, low) { n.children[1].query(low, high, interval, maxDimension, fn) } }]} {Id:5 FileId:1 StartLine:77 StartColumn:1 EndLine:85 EndColumn:2 Name:adjustRanges Params:[] Results:[] Receiver:0xc000118720 Body:{
	for i := 0; i <= 1; i++ {
		if n.children[i] != nil {
			n.children[i].adjustRanges()
		}
	}

	n.adjustRange()
} PrettyPrintBody:[{ for i := 0; i <= 1; i++ { if n.children[i] != nil { n.children[i].adjustRanges() } } n.adjustRange() }]} {Id:6 FileId:1 StartLine:87 StartColumn:1 EndLine:90 EndColumn:2 Name:adjustRange Params:[] Results:[] Receiver:0xc001033380 Body:{
	setMin(n)
	setMax(n)
} PrettyPrintBody:[{ setMin(n) setMax(n) }]} {Id:7 FileId:1 StartLine:92 StartColumn:1 EndLine:96 EndColumn:2 Name:newDummy Params:[] Results:[{Name: Type:node}] Receiver:<nil> Body:{
	return node{
		children: [2]*node{},
	}
} PrettyPrintBody:[{ return node{ children: [2]*node{}, } }]} {Id:8 FileId:1 StartLine:98 StartColumn:1 EndLine:111 EndColumn:2 Name:newNode Params:[{Name:interval Type:Interval} {Name:min Type:int64} {Name:dimension Type:uint64}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	itn := &node{
		interval:	interval,
		min:		min,
		max:		max,
		red:		true,
		children:	[2]*node{},
	}
	if interval != nil {
		itn.id = interval.ID()
	}

	return itn
} PrettyPrintBody:[{ itn := &node{ interval:	interval, min:		min, max:		max, red:		true, children:	[2]*node{}, } if interval != nil { itn.id = interval.ID() } return itn }]} {Id:10 FileId:1 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:Traverse Params:[{Name:fn Type:func(id Interval)}] Results:[] Receiver:0xc001580e40 Body:{
	nodes := []*node{t.root}

	for len(nodes) != 0 {
		c := nodes[len(nodes)-1]
		nodes = nodes[:len(nodes)-1]
		if c != nil {
			fn(c.interval)
			if c.children[0] != nil {
				nodes = append(nodes, c.children[0])
			}
			if c.children[1] != nil {
				nodes = append(nodes, c.children[1])
			}
		}
	}
} PrettyPrintBody:[{ nodes := []*node{t.root} for len(nodes) != 0 { c := nodes[len(nodes)-1] nodes = nodes[:len(nodes)-1] if c != nil { fn(c.interval) if c.children[0] != nil { nodes = append(nodes, c.children[0]) } if c.children[1] != nil { nodes = append(nodes, c.children[1]) } } } }]} {Id:11 FileId:1 StartLine:137 StartColumn:1 EndLine:140 EndColumn:2 Name:resetDummy Params:[] Results:[] Receiver:0xc001409b00 Body:{
	tree.dummy.children[0], tree.dummy.children[1] = nil, nil
	tree.dummy.red = false
} PrettyPrintBody:[{ tree.dummy.children[0], tree.dummy.children[1] = nil, nil tree.dummy.red = false }]} {Id:12 FileId:1 StartLine:143 StartColumn:1 EndLine:145 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000a8a160 Body:{
	return tree.number
} PrettyPrintBody:[{ return tree.number }]} {Id:13 FileId:1 StartLine:148 StartColumn:1 EndLine:219 EndColumn:2 Name:add Params:[{Name:iv Type:Interval}] Results:[] Receiver:0xc0016025c0 Body:{
	if tree.root == nil {
		tree.root = newNode(
			iv, iv.LowAtDimension(1),
			iv.HighAtDimension(1),
			1,
		)
		tree.root.red = false
		tree.number++
		return
	}

	tree.resetDummy()
	var (
		dummy			= tree.dummy
		parent, grandParent	*node
		node			= tree.root
		dir, last		int
		otherLast		= 1
		id			= iv.ID()
		max			= iv.HighAtDimension(1)
		ivLow			= iv.LowAtDimension(1)
		helper			= &dummy
	)

	helper.children[1] = tree.root
	for {
		if node == nil {
			node = newNode(iv, ivLow, max, 1)
			parent.children[dir] = node
			tree.number++
		} else if isRed(node.children[0]) && isRed(node.children[1]) {
			node.red = true
			node.children[0].red = false
			node.children[1].red = false
		}
		if max > node.max {
			node.max = max
		}

		if ivLow < node.min {
			node.min = ivLow
		}

		if isRed(parent) && isRed(node) {
			localDir := intFromBool(helper.children[1] == grandParent)

			if node == parent.children[last] {
				helper.children[localDir] = rotate(grandParent, otherLast)
			} else {
				helper.children[localDir] = doubleRotate(grandParent, otherLast)
			}
		}

		if node.id == id {
			break
		}

		last = dir
		otherLast = takeOpposite(last)
		dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id)

		if grandParent != nil {
			helper = grandParent
		}
		grandParent, parent, node = parent, node, node.children[dir]
	}

	tree.root = dummy.children[1]
	tree.root.red = false
} PrettyPrintBody:[{ if tree.root == nil { tree.root = newNode( iv, iv.LowAtDimension(1), iv.HighAtDimension(1), 1, ) tree.root.red = false tree.number++ return } tree.resetDummy() var ( dummy			= tree.dummy parent, grandParent	*node node			= tree.root dir, last		int otherLast		= 1 id			= iv.ID() max			= iv.HighAtDimension(1) ivLow			= iv.LowAtDimension(1) helper			= &dummy ) helper.children[1] = tree.root for { if node == nil { node = newNode(iv, ivLow, max, 1) parent.children[dir] = node tree.number++ } else if isRed(node.children[0]) && isRed(node.children[1]) { node.red = true node.children[0].red = false node.children[1].red = false } if max > node.max { node.max = max } if ivLow < node.min { node.min = ivLow } if isRed(parent) && isRed(node) { localDir := intFromBool(helper.children[1] == grandParent) if node == parent.children[last] { helper.children[localDir] = rotate(grandParent, otherLast) } else { helper.children[localDir] = doubleRotate(grandParent, otherLast) } } if node.id == id { break } last = dir otherLast = takeOpposite(last) dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id) if grandParent != nil { helper = grandParent } grandParent, parent, node = parent, node, node.children[dir] } tree.root = dummy.children[1] tree.root.red = false }]} {Id:14 FileId:1 StartLine:222 StartColumn:1 EndLine:226 EndColumn:2 Name:Add Params:[{Name:intervals Type:...Interval}] Results:[] Receiver:0xc001581620 Body:{
	for _, iv := range intervals {
		tree.add(iv)
	}
} PrettyPrintBody:[{ for _, iv := range intervals { tree.add(iv) } }]} {Id:15 FileId:1 StartLine:229 StartColumn:1 EndLine:307 EndColumn:2 Name:delete Params:[{Name:iv Type:Interval}] Results:[] Receiver:0xc001581660 Body:{
	if tree.root == nil {
		return
	}

	tree.resetDummy()
	var (
		dummy				= tree.dummy
		found, parent, grandParent	*node
		last, otherDir, otherLast	int
		id				= iv.ID()
		dir				= 1
		node				= &dummy
		ivLow				= iv.LowAtDimension(1)
	)

	node.children[1] = tree.root
	for node.children[dir] != nil {
		last = dir
		otherLast = takeOpposite(last)

		grandParent, parent, node = parent, node, node.children[dir]

		dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id)
		otherDir = takeOpposite(dir)

		if node.id == id {
			found = node
		}

		if !isRed(node) && !isRed(node.children[dir]) {
			if isRed(node.children[otherDir]) {
				parent.children[last] = rotate(node, dir)
				parent = parent.children[last]
			} else if !isRed(node.children[otherDir]) {
				t := parent.children[otherLast]

				if t != nil {
					if !isRed(t.children[otherLast]) && !isRed(t.children[last]) {
						parent.red = false
						node.red = true
						t.red = true
					} else {
						localDir := intFromBool(grandParent.children[1] == parent)

						if isRed(t.children[last]) {
							grandParent.children[localDir] = doubleRotate(
								parent, last,
							)
						} else if isRed(t.children[otherLast]) {
							grandParent.children[localDir] = rotate(
								parent, last,
							)
						}

						node.red = true
						grandParent.children[localDir].red = true
						grandParent.children[localDir].children[0].red = false
						grandParent.children[localDir].children[1].red = false
					}
				}
			}
		}
	}

	if found != nil {
		tree.number--
		found.interval, found.max, found.min, found.id = node.interval, node.max, node.min, node.id
		parentDir := intFromBool(parent.children[1] == node)
		childDir := intFromBool(node.children[0] == nil)

		parent.children[parentDir] = node.children[childDir]
	}

	tree.root = dummy.children[1]
	if tree.root != nil {
		tree.root.red = false
	}
} PrettyPrintBody:[{ if tree.root == nil { return } tree.resetDummy() var ( dummy				= tree.dummy found, parent, grandParent	*node last, otherDir, otherLast	int id				= iv.ID() dir				= 1 node				= &dummy ivLow				= iv.LowAtDimension(1) ) node.children[1] = tree.root for node.children[dir] != nil { last = dir otherLast = takeOpposite(last) grandParent, parent, node = parent, node, node.children[dir] dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id) otherDir = takeOpposite(dir) if node.id == id { found = node } if !isRed(node) && !isRed(node.children[dir]) { if isRed(node.children[otherDir]) { parent.children[last] = rotate(node, dir) parent = parent.children[last] } else if !isRed(node.children[otherDir]) { t := parent.children[otherLast] if t != nil { if !isRed(t.children[otherLast]) && !isRed(t.children[last]) { parent.red = false node.red = true t.red = true } else { localDir := intFromBool(grandParent.children[1] == parent) if isRed(t.children[last]) { grandParent.children[localDir] = doubleRotate( parent, last, ) } else if isRed(t.children[otherLast]) { grandParent.children[localDir] = rotate( parent, last, ) } node.red = true grandParent.children[localDir].red = true grandParent.children[localDir].children[0].red = false grandParent.children[localDir].children[1].red = false } } } } } if found != nil { tree.number-- found.interval, found.max, found.min, found.id = node.interval, node.max, node.min, node.id parentDir := intFromBool(parent.children[1] == node) childDir := intFromBool(node.children[0] == nil) parent.children[parentDir] = node.children[childDir] } tree.root = dummy.children[1] if tree.root != nil { tree.root.red = false } }]} {Id:16 FileId:1 StartLine:310 StartColumn:1 EndLine:317 EndColumn:2 Name:Delete Params:[{Name:intervals Type:...Interval}] Results:[] Receiver:0xc0016037a0 Body:{
	for _, iv := range intervals {
		tree.delete(iv)
	}
	if tree.root != nil {
		tree.root.adjustRanges()
	}
} PrettyPrintBody:[{ for _, iv := range intervals { tree.delete(iv) } if tree.root != nil { tree.root.adjustRanges() } }]} {Id:17 FileId:1 StartLine:322 StartColumn:1 EndLine:338 EndColumn:2 Name:Query Params:[{Name:interval Type:Interval}] Results:[{Name: Type:Intervals}] Receiver:0xc0001e68e0 Body:{
	if tree.root == nil {
		return nil
	}

	var (
		Intervals	= intervalsPool.Get().(Intervals)
		ivLow		= interval.LowAtDimension(1)
		ivHigh		= interval.HighAtDimension(1)
	)

	tree.root.query(ivLow, ivHigh, interval, tree.maxDimension, func(node *node) {
		Intervals = append(Intervals, node.interval)
	})

	return Intervals
} PrettyPrintBody:[{ if tree.root == nil { return nil } var ( Intervals	= intervalsPool.Get().(Intervals) ivLow		= interval.LowAtDimension(1) ivHigh		= interval.HighAtDimension(1) ) tree.root.query(ivLow, ivHigh, interval, tree.maxDimension, func(node *node) { Intervals = append(Intervals, node.interval) }) return Intervals }]} {Id:18 FileId:1 StartLine:340 StartColumn:1 EndLine:342 EndColumn:2 Name:isRed Params:[{Name:node Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return node != nil && node.red
} PrettyPrintBody:[{ return node != nil && node.red }]} {Id:19 FileId:1 StartLine:344 StartColumn:1 EndLine:354 EndColumn:2 Name:setMax Params:[{Name:parent Type:*node}] Results:[] Receiver:<nil> Body:{
	parent.max = parent.interval.HighAtDimension(1)

	if parent.children[0] != nil && parent.children[0].max > parent.max {
		parent.max = parent.children[0].max
	}

	if parent.children[1] != nil && parent.children[1].max > parent.max {
		parent.max = parent.children[1].max
	}
} PrettyPrintBody:[{ parent.max = parent.interval.HighAtDimension(1) if parent.children[0] != nil && parent.children[0].max > parent.max { parent.max = parent.children[0].max } if parent.children[1] != nil && parent.children[1].max > parent.max { parent.max = parent.children[1].max } }]} {Id:20 FileId:1 StartLine:356 StartColumn:1 EndLine:369 EndColumn:2 Name:setMin Params:[{Name:parent Type:*node}] Results:[] Receiver:<nil> Body:{
	parent.min = parent.interval.LowAtDimension(1)
	if parent.children[0] != nil && parent.children[0].min < parent.min {
		parent.min = parent.children[0].min
	}

	if parent.children[1] != nil && parent.children[1].min < parent.min {
		parent.min = parent.children[1].min
	}

	if parent.interval.LowAtDimension(1) < parent.min {
		parent.min = parent.interval.LowAtDimension(1)
	}
} PrettyPrintBody:[{ parent.min = parent.interval.LowAtDimension(1) if parent.children[0] != nil && parent.children[0].min < parent.min { parent.min = parent.children[0].min } if parent.children[1] != nil && parent.children[1].min < parent.min { parent.min = parent.children[1].min } if parent.interval.LowAtDimension(1) < parent.min { parent.min = parent.interval.LowAtDimension(1) } }]} {Id:21 FileId:1 StartLine:371 StartColumn:1 EndLine:386 EndColumn:2 Name:rotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	child := parent.children[otherDir]
	parent.children[otherDir] = child.children[dir]
	child.children[dir] = parent
	parent.red = true
	child.red = false
	child.max = parent.max
	setMax(child)
	setMax(parent)
	setMin(child)
	setMin(parent)

	return child
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) child := parent.children[otherDir] parent.children[otherDir] = child.children[dir] child.children[dir] = parent parent.red = true child.red = false child.max = parent.max setMax(child) setMax(parent) setMin(child) setMin(parent) return child }]} {Id:22 FileId:1 StartLine:388 StartColumn:1 EndLine:393 EndColumn:2 Name:doubleRotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	parent.children[otherDir] = rotate(parent.children[otherDir], otherDir)
	return rotate(parent, dir)
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) parent.children[otherDir] = rotate(parent.children[otherDir], otherDir) return rotate(parent, dir) }]} {Id:23 FileId:1 StartLine:395 StartColumn:1 EndLine:401 EndColumn:2 Name:intFromBool Params:[{Name:value Type:bool}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if value {
		return 1
	}

	return 0
} PrettyPrintBody:[{ if value { return 1 } return 0 }]} {Id:24 FileId:1 StartLine:403 StartColumn:1 EndLine:405 EndColumn:2 Name:takeOpposite Params:[{Name:value Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	return 1 - value
} PrettyPrintBody:[{ return 1 - value }]} {Id:25 FileId:1 StartLine:407 StartColumn:1 EndLine:412 EndColumn:2 Name:newTree Params:[{Name:maxDimension Type:uint64}] Results:[{Name: Type:*tree}] Receiver:<nil> Body:{
	return &tree{
		maxDimension:	maxDimension,
		dummy:		newDummy(),
	}
} PrettyPrintBody:[{ return &tree{ maxDimension:	maxDimension, dummy:		newDummy(), } }]} {Id:26 FileId:1 StartLine:416 StartColumn:1 EndLine:418 EndColumn:2 Name:New Params:[{Name:dimensions Type:uint64}] Results:[{Name: Type:Tree}] Receiver:<nil> Body:{
	return newTree(dimensions)
} PrettyPrintBody:[{ return newTree(dimensions) }]} {Id:5 FileId:56 StartLine:45 StartColumn:1 EndLine:51 EndColumn:2 Name:dispose Params:[{Name:ptree Type:*ptree}] Results:[] Receiver:0xc0012622c0 Body:{
	if ptree.kbRing.Len() == ptree.kbRing.Cap() {
		return
	}
	kb.key, kb.left, kb.right = nil, nil, nil
	ptree.kbRing.Put(kb)
} PrettyPrintBody:[{ if ptree.kbRing.Len() == ptree.kbRing.Cap() { return } kb.key, kb.left, kb.right = nil, nil, nil ptree.kbRing.Put(kb) }]} {Id:7 FileId:56 StartLine:71 StartColumn:1 EndLine:117 EndColumn:2 Name:checkAndRun Params:[{Name:action Type:action}] Results:[] Receiver:0xc001238920 Body:{
	if ptree.actions.Len() > 0 {
		if action != nil {
			ptree.actions.Put(action)
		}
		if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) {
			var a interface{}
			var err error
			for ptree.actions.Len() > 0 {
				a, err = ptree.actions.Get()
				if err != nil {
					return
				}
				ptree.cache = append(ptree.cache, a)
				if uint64(len(ptree.cache)) >= ptree.bufferSize {
					break
				}
			}

			go ptree.operationRunner(ptree.cache, true)
		}
	} else if action != nil {
		if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) {
			switch action.operation() {
			case get:
				ptree.read(action)
				action.complete()
				ptree.reset()
			case add, remove:
				if len(action.keys()) > multiThreadAt {
					ptree.operationRunner(interfaces{action}, true)
				} else {
					ptree.operationRunner(interfaces{action}, false)
				}
			case apply:
				q := action.(*applyAction)
				n := getParent(ptree.root, q.start)
				ptree.apply(n, q)
				q.complete()
				ptree.reset()
			}
		} else {
			ptree.actions.Put(action)
			ptree.checkAndRun(nil)
		}
	}
} PrettyPrintBody:[{ if ptree.actions.Len() > 0 { if action != nil { ptree.actions.Put(action) } if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) { var a interface{} var err error for ptree.actions.Len() > 0 { a, err = ptree.actions.Get() if err != nil { return } ptree.cache = append(ptree.cache, a) if uint64(len(ptree.cache)) >= ptree.bufferSize { break } } go ptree.operationRunner(ptree.cache, true) } } else if action != nil { if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) { switch action.operation() { case get: ptree.read(action) action.complete() ptree.reset() case add, remove: if len(action.keys()) > multiThreadAt { ptree.operationRunner(interfaces{action}, true) } else { ptree.operationRunner(interfaces{action}, false) } case apply: q := action.(*applyAction) n := getParent(ptree.root, q.start) ptree.apply(n, q) q.complete() ptree.reset() } } else { ptree.actions.Put(action) ptree.checkAndRun(nil) } } }]} {Id:8 FileId:56 StartLine:119 StartColumn:1 EndLine:135 EndColumn:2 Name:init Params:[{Name:bufferSize Type:uint64}] Results:[] Receiver:0xc0012468c0 Body:{
	ptree.bufferSize = bufferSize
	ptree.ary = ary
	ptree.cache = make([]interface{}, 0, bufferSize)
	ptree.root = newNode(true, newKeys(ary), newNodes(ary))
	ptree.actions = queue.NewRingBuffer(ptree.bufferSize)
	ptree.kbRing = queue.NewRingBuffer(1024)
	for i := uint64(0); i < ptree.kbRing.Cap(); i++ {
		ptree.kbRing.Put(&keyBundle{})
	}
	ptree.disposeChannel = make(chan bool)
	ptree.mpChannel = make(chan map[*node][]*keyBundle, 1024)
	var wg sync.WaitGroup
	wg.Add(1)
	go ptree.disposer(&wg)
	wg.Wait()
} PrettyPrintBody:[{ ptree.bufferSize = bufferSize ptree.ary = ary ptree.cache = make([]interface{}, 0, bufferSize) ptree.root = newNode(true, newKeys(ary), newNodes(ary)) ptree.actions = queue.NewRingBuffer(ptree.bufferSize) ptree.kbRing = queue.NewRingBuffer(1024) for i := uint64(0); i < ptree.kbRing.Cap(); i++ { ptree.kbRing.Put(&keyBundle{}) } ptree.disposeChannel = make(chan bool) ptree.mpChannel = make(chan map[*node][]*keyBundle, 1024) var wg sync.WaitGroup wg.Add(1) go ptree.disposer(&wg) wg.Wait() }]} {Id:9 FileId:56 StartLine:137 StartColumn:1 EndLine:148 EndColumn:2 Name:newKeyBundle Params:[{Name:key Type:common.Comparator}] Results:[{Name: Type:*keyBundle}] Receiver:0xc000a23860 Body:{
	if ptree.kbRing.Len() == 0 {
		return &keyBundle{key: key}
	}
	ifc, err := ptree.kbRing.Get()
	if err != nil {
		return nil
	}
	kb := ifc.(*keyBundle)
	kb.key = key
	return kb
} PrettyPrintBody:[{ if ptree.kbRing.Len() == 0 { return &keyBundle{key: key} } ifc, err := ptree.kbRing.Get() if err != nil { return nil } kb := ifc.(*keyBundle) kb.key = key return kb }]} {Id:10 FileId:56 StartLine:150 StartColumn:1 EndLine:158 EndColumn:2 Name:operationRunner Params:[{Name:xns Type:interfaces} {Name:threaded Type:bool}] Results:[] Receiver:0xc000e7ffe0 Body:{
	writeOperations, deleteOperations, toComplete := ptree.fetchKeys(xns, threaded)
	ptree.recursiveMutate(writeOperations, deleteOperations, false, threaded)
	for _, a := range toComplete {
		a.complete()
	}

	ptree.reset()
} PrettyPrintBody:[{ writeOperations, deleteOperations, toComplete := ptree.fetchKeys(xns, threaded) ptree.recursiveMutate(writeOperations, deleteOperations, false, threaded) for _, a := range toComplete { a.complete() } ptree.reset() }]} {Id:11 FileId:56 StartLine:160 StartColumn:1 EndLine:174 EndColumn:2 Name:read Params:[{Name:action Type:action}] Results:[] Receiver:0xc001309840 Body:{
	for i, k := range action.keys() {
		n := getParent(ptree.root, k)
		if n == nil {
			action.keys()[i] = nil
		} else {
			key, _ := n.keys.withPosition(k)
			if key == nil {
				action.keys()[i] = nil
			} else {
				action.keys()[i] = key
			}
		}
	}
} PrettyPrintBody:[{ for i, k := range action.keys() { n := getParent(ptree.root, k) if n == nil { action.keys()[i] = nil } else { key, _ := n.keys.withPosition(k) if key == nil { action.keys()[i] = nil } else { action.keys()[i] = key } } } }]} {Id:12 FileId:56 StartLine:176 StartColumn:1 EndLine:205 EndColumn:2 Name:fetchKeys Params:[{Name:xns Type:interfaces} {Name:inParallel Type:bool}] Results:[{Name: Type:map[*node][]*keyBundle} {Name: Type:map[*node][]*keyBundle} {Name: Type:actions}] Receiver:0xc001602680 Body:{
	if inParallel {
		ptree.fetchKeysInParallel(xns)
	} else {
		ptree.fetchKeysInSerial(xns)
	}

	writeOperations := make(map[*node][]*keyBundle)
	deleteOperations := make(map[*node][]*keyBundle)
	toComplete := make(actions, 0, len(xns)/2)
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add:
			for i, n := range action.nodes() {
				writeOperations[n] = append(writeOperations[n], ptree.newKeyBundle(action.keys()[i]))
			}
			toComplete = append(toComplete, action)
		case remove:
			for i, n := range action.nodes() {
				deleteOperations[n] = append(deleteOperations[n], ptree.newKeyBundle(action.keys()[i]))
			}
			toComplete = append(toComplete, action)
		case get, apply:
			action.complete()
		}
	}

	return writeOperations, deleteOperations, toComplete
} PrettyPrintBody:[{ if inParallel { ptree.fetchKeysInParallel(xns) } else { ptree.fetchKeysInSerial(xns) } writeOperations := make(map[*node][]*keyBundle) deleteOperations := make(map[*node][]*keyBundle) toComplete := make(actions, 0, len(xns)/2) for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add: for i, n := range action.nodes() { writeOperations[n] = append(writeOperations[n], ptree.newKeyBundle(action.keys()[i])) } toComplete = append(toComplete, action) case remove: for i, n := range action.nodes() { deleteOperations[n] = append(deleteOperations[n], ptree.newKeyBundle(action.keys()[i])) } toComplete = append(toComplete, action) case get, apply: action.complete() } } return writeOperations, deleteOperations, toComplete }]} {Id:13 FileId:56 StartLine:207 StartColumn:1 EndLine:224 EndColumn:2 Name:apply Params:[{Name:n Type:*node} {Name:aa Type:*applyAction}] Results:[] Receiver:0xc001602ac0 Body:{
	i := n.search(aa.start)
	if i == n.keys.len() {
		return
	}

	var k common.Comparator
	for n != nil {
		for j := i; j < n.keys.len(); j++ {
			k = n.keys.byPosition(j)
			if aa.stop.Compare(k) < 1 || !aa.fn(k) {
				return
			}
		}
		n = n.right
		i = 0
	}
} PrettyPrintBody:[{ i := n.search(aa.start) if i == n.keys.len() { return } var k common.Comparator for n != nil { for j := i; j < n.keys.len(); j++ { k = n.keys.byPosition(j) if aa.stop.Compare(k) < 1 || !aa.fn(k) { return } } n = n.right i = 0 } }]} {Id:14 FileId:56 StartLine:226 StartColumn:1 EndLine:237 EndColumn:2 Name:disposer Params:[{Name:wg Type:*sync.WaitGroup}] Results:[] Receiver:0xc001602b20 Body:{
	wg.Done()

	for {
		select {
		case mp := <-ptree.mpChannel:
			ptree.cleanMap(mp)
		case <-ptree.disposeChannel:
			return
		}
	}
} PrettyPrintBody:[{ wg.Done() for { select { case mp := <-ptree.mpChannel: ptree.cleanMap(mp) case <-ptree.disposeChannel: return } } }]} {Id:15 FileId:56 StartLine:239 StartColumn:1 EndLine:264 EndColumn:2 Name:fetchKeysInSerial Params:[{Name:xns Type:interfaces}] Results:[] Receiver:0xc001602b80 Body:{
	for _, ifc := range xns {
		action := ifc.(action)
		for i, key := range action.keys() {
			n := getParent(ptree.root, key)
			switch action.operation() {
			case add, remove:
				action.addNode(int64(i), n)
			case get:
				if n == nil {
					action.keys()[i] = nil
				} else {
					k, _ := n.keys.withPosition(key)
					if k == nil {
						action.keys()[i] = nil
					} else {
						action.keys()[i] = k
					}
				}
			case apply:
				q := action.(*applyAction)
				ptree.apply(n, q)
			}
		}
	}
} PrettyPrintBody:[{ for _, ifc := range xns { action := ifc.(action) for i, key := range action.keys() { n := getParent(ptree.root, key) switch action.operation() { case add, remove: action.addNode(int64(i), n) case get: if n == nil { action.keys()[i] = nil } else { k, _ := n.keys.withPosition(key) if k == nil { action.keys()[i] = nil } else { action.keys()[i] = k } } case apply: q := action.(*applyAction) ptree.apply(n, q) } } } }]} {Id:16 FileId:56 StartLine:266 StartColumn:1 EndLine:274 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001602d40 Body:{
	for i := range ptree.cache {
		ptree.cache[i] = nil
	}

	ptree.cache = ptree.cache[:0]
	atomic.StoreUint64(&ptree.running, 0)
	ptree.checkAndRun(nil)
} PrettyPrintBody:[{ for i := range ptree.cache { ptree.cache[i] = nil } ptree.cache = ptree.cache[:0] atomic.StoreUint64(&ptree.running, 0) ptree.checkAndRun(nil) }]} {Id:17 FileId:56 StartLine:276 StartColumn:1 EndLine:334 EndColumn:2 Name:fetchKeysInParallel Params:[{Name:xns Type:[]interface{}}] Results:[] Receiver:0xc001602de0 Body:{
	var forCache struct {
		i	int64
		buffer	[8]uint64
		js	[]int64
	}

	for j := 0; j < len(xns); j++ {
		forCache.js = append(forCache.js, -1)
	}
	numCPU := runtime.NumCPU()
	if numCPU > 1 {
		numCPU--
	}
	var wg sync.WaitGroup
	wg.Add(numCPU)

	for k := 0; k < numCPU; k++ {
		go func() {
			for {
				index := atomic.LoadInt64(&forCache.i)
				if index >= int64(len(xns)) {
					break
				}
				action := xns[index].(action)

				j := atomic.AddInt64(&forCache.js[index], 1)
				if j > int64(len(action.keys())) {
					continue
				} else if j == int64(len(action.keys())) {
					atomic.StoreInt64(&forCache.i, index+1)
					continue
				}

				n := getParent(ptree.root, action.keys()[j])
				switch action.operation() {
				case add, remove:
					action.addNode(j, n)
				case get:
					if n == nil {
						action.keys()[j] = nil
					} else {
						k, _ := n.keys.withPosition(action.keys()[j])
						if k == nil {
							action.keys()[j] = nil
						} else {
							action.keys()[j] = k
						}
					}
				case apply:
					q := action.(*applyAction)
					ptree.apply(n, q)
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
} PrettyPrintBody:[{ var forCache struct { i	int64 buffer	[8]uint64 js	[]int64 } for j := 0; j < len(xns); j++ { forCache.js = append(forCache.js, -1) } numCPU := runtime.NumCPU() if numCPU > 1 { numCPU-- } var wg sync.WaitGroup wg.Add(numCPU) for k := 0; k < numCPU; k++ { go func() { for { index := atomic.LoadInt64(&forCache.i) if index >= int64(len(xns)) { break } action := xns[index].(action) j := atomic.AddInt64(&forCache.js[index], 1) if j > int64(len(action.keys())) { continue } else if j == int64(len(action.keys())) { atomic.StoreInt64(&forCache.i, index+1) continue } n := getParent(ptree.root, action.keys()[j]) switch action.operation() { case add, remove: action.addNode(j, n) case get: if n == nil { action.keys()[j] = nil } else { k, _ := n.keys.withPosition(action.keys()[j]) if k == nil { action.keys()[j] = nil } else { action.keys()[j] = k } } case apply: q := action.(*applyAction) ptree.apply(n, q) } } wg.Done() }() } wg.Wait() }]} {Id:18 FileId:56 StartLine:336 StartColumn:1 EndLine:353 EndColumn:2 Name:splitNode Params:[{Name:n Type:*node} {Name:nodes Type:*[]*node} {Name:keys Type:*common.Comparators}] Results:[] Receiver:0xc00095aaa0 Body:{
	if !n.needsSplit(ptree.ary) {
		return
	}

	length := n.keys.len()
	splitAt := ptree.ary - 1

	for i := splitAt; i < length; i += splitAt {
		offset := length - i
		k, left, right := n.split(offset, ptree.ary)
		left.right = right
		*keys = append(*keys, k)
		*nodes = append(*nodes, left, right)
		left.parent = parent
		right.parent = parent
	}
} PrettyPrintBody:[{ if !n.needsSplit(ptree.ary) { return } length := n.keys.len() splitAt := ptree.ary - 1 for i := splitAt; i < length; i += splitAt { offset := length - i k, left, right := n.split(offset, ptree.ary) left.right = right *keys = append(*keys, k) *nodes = append(*nodes, left, right) left.parent = parent right.parent = parent } }]} {Id:19 FileId:56 StartLine:355 StartColumn:1 EndLine:389 EndColumn:2 Name:applyNode Params:[{Name:n Type:*node} {Name:adds Type:[]*keyBundle}] Results:[] Receiver:0xc0003e5420 Body:{
	for _, kb := range deletes {
		if n.keys.len() == 0 {
			break
		}

		deleted := n.keys.delete(kb.key)
		if deleted != nil {
			atomic.AddUint64(&ptree.number, ^uint64(0))
		}
	}

	for _, kb := range adds {
		if n.keys.len() == 0 {
			oldKey, _ := n.keys.insert(kb.key)
			if n.isLeaf && oldKey == nil {
				atomic.AddUint64(&ptree.number, 1)
			}
			if kb.left != nil {
				n.nodes.push(kb.left)
				n.nodes.push(kb.right)
			}
			continue
		}

		oldKey, index := n.keys.insert(kb.key)
		if n.isLeaf && oldKey == nil {
			atomic.AddUint64(&ptree.number, 1)
		}
		if kb.left != nil {
			n.nodes.replaceAt(index, kb.left)
			n.nodes.insertAt(index+1, kb.right)
		}
	}
} PrettyPrintBody:[{ for _, kb := range deletes { if n.keys.len() == 0 { break } deleted := n.keys.delete(kb.key) if deleted != nil { atomic.AddUint64(&ptree.number, ^uint64(0)) } } for _, kb := range adds { if n.keys.len() == 0 { oldKey, _ := n.keys.insert(kb.key) if n.isLeaf && oldKey == nil { atomic.AddUint64(&ptree.number, 1) } if kb.left != nil { n.nodes.push(kb.left) n.nodes.push(kb.right) } continue } oldKey, index := n.keys.insert(kb.key) if n.isLeaf && oldKey == nil { atomic.AddUint64(&ptree.number, 1) } if kb.left != nil { n.nodes.replaceAt(index, kb.left) n.nodes.insertAt(index+1, kb.right) } } }]} {Id:20 FileId:56 StartLine:391 StartColumn:1 EndLine:397 EndColumn:2 Name:cleanMap Params:[{Name:op Type:map[*node][]*keyBundle}] Results:[] Receiver:0xc0001e64a0 Body:{
	for _, bundles := range op {
		for _, kb := range bundles {
			kb.dispose(ptree)
		}
	}
} PrettyPrintBody:[{ for _, bundles := range op { for _, kb := range bundles { kb.dispose(ptree) } } }]} {Id:21 FileId:56 StartLine:399 StartColumn:1 EndLine:485 EndColumn:2 Name:recursiveMutate Params:[{Name:adds Type:map[*node][]*keyBundle} {Name:setRoot Type:bool}] Results:[] Receiver:0xc0000ed660 Body:{
	if len(adds) == 0 && len(deletes) == 0 {
		return
	}

	if setRoot && len(adds) > 1 {
		panic(`SHOULD ONLY HAVE ONE ROOT`)
	}

	ifs := make(interfaces, 0, len(adds))
	for n := range adds {
		if n.parent == nil {
			setRoot = true
		}
		ifs = append(ifs, n)
	}

	for n := range deletes {
		if n.parent == nil {
			setRoot = true
		}

		if _, ok := adds[n]; !ok {
			ifs = append(ifs, n)
		}
	}

	var dummyRoot *node
	if setRoot {
		dummyRoot = &node{
			keys:	newKeys(ptree.ary),
			nodes:	newNodes(ptree.ary),
		}
	}

	var write sync.Mutex
	nextLayerWrite := make(map[*node][]*keyBundle)
	nextLayerDelete := make(map[*node][]*keyBundle)

	var mutate func(interfaces, func(interface{}))
	if inParallel {
		mutate = executeInterfacesInParallel
	} else {
		mutate = executeInterfacesInSerial
	}

	mutate(ifs, func(ifc interface{}) {
		n := ifc.(*node)
		adds := adds[n]
		deletes := deletes[n]

		if len(adds) == 0 && len(deletes) == 0 {
			return
		}

		if setRoot {
			ptree.root = n
		}

		parent := n.parent
		if parent == nil {
			parent = dummyRoot
			setRoot = true
		}

		ptree.applyNode(n, adds, deletes)

		if n.needsSplit(ptree.ary) {
			keys := make(common.Comparators, 0, n.keys.len())
			nodes := make([]*node, 0, n.nodes.len())
			ptree.splitNode(n, parent, &nodes, &keys)
			write.Lock()
			for i, k := range keys {
				kb := ptree.newKeyBundle(k)
				kb.left = nodes[i*2]
				kb.right = nodes[i*2+1]
				nextLayerWrite[parent] = append(nextLayerWrite[parent], kb)
			}
			write.Unlock()
		}
	})

	ptree.mpChannel <- adds
	ptree.mpChannel <- deletes

	ptree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel)
} PrettyPrintBody:[{ if len(adds) == 0 && len(deletes) == 0 { return } if setRoot && len(adds) > 1 { panic(`SHOULD ONLY HAVE ONE ROOT`) } ifs := make(interfaces, 0, len(adds)) for n := range adds { if n.parent == nil { setRoot = true } ifs = append(ifs, n) } for n := range deletes { if n.parent == nil { setRoot = true } if _, ok := adds[n]; !ok { ifs = append(ifs, n) } } var dummyRoot *node if setRoot { dummyRoot = &node{ keys:	newKeys(ptree.ary), nodes:	newNodes(ptree.ary), } } var write sync.Mutex nextLayerWrite := make(map[*node][]*keyBundle) nextLayerDelete := make(map[*node][]*keyBundle) var mutate func(interfaces, func(interface{})) if inParallel { mutate = executeInterfacesInParallel } else { mutate = executeInterfacesInSerial } mutate(ifs, func(ifc interface{}) { n := ifc.(*node) adds := adds[n] deletes := deletes[n] if len(adds) == 0 && len(deletes) == 0 { return } if setRoot { ptree.root = n } parent := n.parent if parent == nil { parent = dummyRoot setRoot = true } ptree.applyNode(n, adds, deletes) if n.needsSplit(ptree.ary) { keys := make(common.Comparators, 0, n.keys.len()) nodes := make([]*node, 0, n.nodes.len()) ptree.splitNode(n, parent, &nodes, &keys) write.Lock() for i, k := range keys { kb := ptree.newKeyBundle(k) kb.left = nodes[i*2] kb.right = nodes[i*2+1] nextLayerWrite[parent] = append(nextLayerWrite[parent], kb) } write.Unlock() } }) ptree.mpChannel <- adds ptree.mpChannel <- deletes ptree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel) }]} {Id:22 FileId:56 StartLine:488 StartColumn:1 EndLine:492 EndColumn:2 Name:Insert Params:[{Name:keys Type:...common.Comparator}] Results:[] Receiver:0xc0001e6c00 Body:{
	ia := newInsertAction(keys)
	ptree.checkAndRun(ia)
	ia.completer.Wait()
} PrettyPrintBody:[{ ia := newInsertAction(keys) ptree.checkAndRun(ia) ia.completer.Wait() }]} {Id:23 FileId:56 StartLine:496 StartColumn:1 EndLine:500 EndColumn:2 Name:Delete Params:[{Name:keys Type:...common.Comparator}] Results:[] Receiver:0xc0001e6c40 Body:{
	ra := newRemoveAction(keys)
	ptree.checkAndRun(ra)
	ra.completer.Wait()
} PrettyPrintBody:[{ ra := newRemoveAction(keys) ptree.checkAndRun(ra) ra.completer.Wait() }]} {Id:24 FileId:56 StartLine:503 StartColumn:1 EndLine:508 EndColumn:2 Name:Get Params:[{Name:keys Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0001e6c80 Body:{
	ga := newGetAction(keys)
	ptree.checkAndRun(ga)
	ga.completer.Wait()
	return ga.result
} PrettyPrintBody:[{ ga := newGetAction(keys) ptree.checkAndRun(ga) ga.completer.Wait() return ga.result }]} {Id:25 FileId:56 StartLine:511 StartColumn:1 EndLine:513 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc00019e940 Body:{
	return atomic.LoadUint64(&ptree.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&ptree.number) }]} {Id:26 FileId:56 StartLine:518 StartColumn:1 EndLine:527 EndColumn:2 Name:Query Params:[{Name:start Type:common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0009926e0 Body:{
	cmps := make(common.Comparators, 0, 32)
	aa := newApplyAction(func(cmp common.Comparator) bool {
		cmps = append(cmps, cmp)
		return true
	}, start, stop)
	ptree.checkAndRun(aa)
	aa.completer.Wait()
	return cmps
} PrettyPrintBody:[{ cmps := make(common.Comparators, 0, 32) aa := newApplyAction(func(cmp common.Comparator) bool { cmps = append(cmps, cmp) return true }, start, stop) ptree.checkAndRun(aa) aa.completer.Wait() return cmps }]} {Id:27 FileId:56 StartLine:531 StartColumn:1 EndLine:538 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0009928e0 Body:{
	if atomic.LoadUint64(&ptree.disposed) == 1 {
		return
	}
	ptree.actions.Dispose()
	atomic.StoreUint64(&ptree.disposed, 1)
	close(ptree.disposeChannel)
} PrettyPrintBody:[{ if atomic.LoadUint64(&ptree.disposed) == 1 { return } ptree.actions.Dispose() atomic.StoreUint64(&ptree.disposed, 1) close(ptree.disposeChannel) }]} {Id:28 FileId:56 StartLine:540 StartColumn:1 EndLine:547 EndColumn:2 Name:print Params:[{Name:output Type:*log.Logger}] Results:[] Receiver:0xc00095b880 Body:{
	println(`PRINTING TREE`)
	if ptree.root == nil {
		return
	}

	ptree.root.print(output)
} PrettyPrintBody:[{ println(`PRINTING TREE`) if ptree.root == nil { return } ptree.root.print(output) }]} {Id:29 FileId:56 StartLine:549 StartColumn:1 EndLine:553 EndColumn:2 Name:newTree Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:*ptree}] Receiver:<nil> Body:{
	ptree := &ptree{}
	ptree.init(bufferSize, ary)
	return ptree
} PrettyPrintBody:[{ ptree := &ptree{} ptree.init(bufferSize, ary) return ptree }]} {Id:30 FileId:56 StartLine:558 StartColumn:1 EndLine:560 EndColumn:2 Name:New Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:BTree}] Receiver:<nil> Body:{
	return newTree(bufferSize, ary)
} PrettyPrintBody:[{ return newTree(bufferSize, ary) }]} {Id:1 FileId:99 StartLine:28 StartColumn:1 EndLine:43 EndColumn:2 Name:TestRingInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)
	assert.Equal(t, uint64(8), rb.Cap())

	err := rb.Put(5)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 5, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) assert.Equal(t, uint64(8), rb.Cap()) err := rb.Put(5) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 5, result) }]} {Id:2 FileId:99 StartLine:45 StartColumn:1 EndLine:71 EndColumn:2 Name:TestRingMultipleInserts Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)

	err := rb.Put(1)
	if !assert.Nil(t, err) {
		return
	}

	err = rb.Put(2)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 1, result)

	result, err = rb.Get()
	if assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 2, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) err := rb.Put(1) if !assert.Nil(t, err) { return } err = rb.Put(2) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 1, result) result, err = rb.Get() if assert.Nil(t, err) { return } assert.Equal(t, 2, result) }]} {Id:3 FileId:99 StartLine:73 StartColumn:1 EndLine:98 EndColumn:2 Name:TestIntertwinedGetAndPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(5)
	err := rb.Put(1)
	if !assert.Nil(t, err) {
		return
	}

	result, err := rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 1, result)

	err = rb.Put(2)
	if !assert.Nil(t, err) {
		return
	}

	result, err = rb.Get()
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, 2, result)
} PrettyPrintBody:[{ rb := NewRingBuffer(5) err := rb.Put(1) if !assert.Nil(t, err) { return } result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 1, result) err = rb.Put(2) if !assert.Nil(t, err) { return } result, err = rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 2, result) }]} {Id:4 FileId:99 StartLine:100 StartColumn:1 EndLine:130 EndColumn:2 Name:TestPutToFull Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	for i := 0; i < 4; i++ {
		err := rb.Put(i)
		if !assert.Nil(t, err) {
			return
		}
	}

	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		err := rb.Put(4)
		assert.Nil(t, err)
		wg.Done()
	}()

	go func() {
		defer wg.Done()
		result, err := rb.Get()
		if !assert.Nil(t, err) {
			return
		}

		assert.Equal(t, 0, result)
	}()

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(3) for i := 0; i < 4; i++ { err := rb.Put(i) if !assert.Nil(t, err) { return } } var wg sync.WaitGroup wg.Add(2) go func() { err := rb.Put(4) assert.Nil(t, err) wg.Done() }() go func() { defer wg.Done() result, err := rb.Get() if !assert.Nil(t, err) { return } assert.Equal(t, 0, result) }() wg.Wait() }]} {Id:5 FileId:99 StartLine:132 StartColumn:1 EndLine:151 EndColumn:2 Name:TestOffer Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(2)

	ok, err := rb.Offer("foo")
	assert.True(t, ok)
	assert.Nil(t, err)
	ok, err = rb.Offer("bar")
	assert.True(t, ok)
	assert.Nil(t, err)
	ok, err = rb.Offer("baz")
	assert.False(t, ok)
	assert.Nil(t, err)

	item, err := rb.Get()
	assert.Nil(t, err)
	assert.Equal(t, "foo", item)
	item, err = rb.Get()
	assert.Nil(t, err)
	assert.Equal(t, "bar", item)
} PrettyPrintBody:[{ rb := NewRingBuffer(2) ok, err := rb.Offer("foo") assert.True(t, ok) assert.Nil(t, err) ok, err = rb.Offer("bar") assert.True(t, ok) assert.Nil(t, err) ok, err = rb.Offer("baz") assert.False(t, ok) assert.Nil(t, err) item, err := rb.Get() assert.Nil(t, err) assert.Equal(t, "foo", item) item, err = rb.Get() assert.Nil(t, err) assert.Equal(t, "bar", item) }]} {Id:6 FileId:99 StartLine:153 StartColumn:1 EndLine:178 EndColumn:2 Name:TestRingGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		wg.Done()
		result, err := rb.Get()
		assert.Nil(t, err)
		assert.Equal(t, 0, result)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	go func() {
		defer wg.Done()
		err := rb.Put(0)
		assert.Nil(t, err)
	}()

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(3) var wg sync.WaitGroup wg.Add(1) go func() { wg.Done() result, err := rb.Get() assert.Nil(t, err) assert.Equal(t, 0, result) wg.Done() }() wg.Wait() wg.Add(2) go func() { defer wg.Done() err := rb.Put(0) assert.Nil(t, err) }() wg.Wait() }]} {Id:7 FileId:99 StartLine:180 StartColumn:1 EndLine:185 EndColumn:2 Name:TestRingPollEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(3)

	_, err := rb.Poll(1)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ rb := NewRingBuffer(3) _, err := rb.Poll(1) assert.Equal(t, ErrTimeout, err) }]} {Id:8 FileId:99 StartLine:187 StartColumn:1 EndLine:226 EndColumn:2 Name:TestRingPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(10)

	rb.Poll(time.Millisecond)

	rb.Put(`test`)
	result, err := rb.Poll(0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `test`, result)
	assert.Equal(t, uint64(0), rb.Len())

	rb.Put(`1`)
	rb.Put(`2`)

	result, err = rb.Poll(time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `1`, result)
	assert.Equal(t, uint64(1), rb.Len())

	result, err = rb.Poll(time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result)

	before := time.Now()
	_, err = rb.Poll(5 * time.Millisecond)

	assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ rb := NewRingBuffer(10) rb.Poll(time.Millisecond) rb.Put(`test`) result, err := rb.Poll(0) if !assert.Nil(t, err) { return } assert.Equal(t, `test`, result) assert.Equal(t, uint64(0), rb.Len()) rb.Put(`1`) rb.Put(`2`) result, err = rb.Poll(time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `1`, result) assert.Equal(t, uint64(1), rb.Len()) result, err = rb.Poll(time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result) before := time.Now() _, err = rb.Poll(5 * time.Millisecond) assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10) assert.Equal(t, ErrTimeout, err) }]} {Id:9 FileId:99 StartLine:228 StartColumn:1 EndLine:245 EndColumn:2 Name:TestRingLen Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(4)
	assert.Equal(t, uint64(0), rb.Len())

	rb.Put(1)
	assert.Equal(t, uint64(1), rb.Len())

	rb.Get()
	assert.Equal(t, uint64(0), rb.Len())

	for i := 0; i < 4; i++ {
		rb.Put(1)
	}
	assert.Equal(t, uint64(4), rb.Len())

	rb.Get()
	assert.Equal(t, uint64(3), rb.Len())
} PrettyPrintBody:[{ rb := NewRingBuffer(4) assert.Equal(t, uint64(0), rb.Len()) rb.Put(1) assert.Equal(t, uint64(1), rb.Len()) rb.Get() assert.Equal(t, uint64(0), rb.Len()) for i := 0; i < 4; i++ { rb.Put(1) } assert.Equal(t, uint64(4), rb.Len()) rb.Get() assert.Equal(t, uint64(3), rb.Len()) }]} {Id:10 FileId:99 StartLine:247 StartColumn:1 EndLine:269 EndColumn:2 Name:TestDisposeOnGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numThreads := 8
	var wg sync.WaitGroup
	wg.Add(numThreads)
	rb := NewRingBuffer(4)
	var spunUp sync.WaitGroup
	spunUp.Add(numThreads)

	for i := 0; i < numThreads; i++ {
		go func() {
			spunUp.Done()
			defer wg.Done()
			_, err := rb.Get()
			assert.NotNil(t, err)
		}()
	}

	spunUp.Wait()
	rb.Dispose()

	wg.Wait()
	assert.True(t, rb.IsDisposed())
} PrettyPrintBody:[{ numThreads := 8 var wg sync.WaitGroup wg.Add(numThreads) rb := NewRingBuffer(4) var spunUp sync.WaitGroup spunUp.Add(numThreads) for i := 0; i < numThreads; i++ { go func() { spunUp.Done() defer wg.Done() _, err := rb.Get() assert.NotNil(t, err) }() } spunUp.Wait() rb.Dispose() wg.Wait() assert.True(t, rb.IsDisposed()) }]} {Id:11 FileId:99 StartLine:271 StartColumn:1 EndLine:301 EndColumn:2 Name:TestDisposeOnPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numThreads := 8
	var wg sync.WaitGroup
	wg.Add(numThreads)
	rb := NewRingBuffer(4)
	var spunUp sync.WaitGroup
	spunUp.Add(numThreads)

	for i := 0; i < 4; i++ {
		rb.Put(i)
	}

	for i := 0; i < numThreads; i++ {
		go func(i int) {
			spunUp.Done()
			defer wg.Done()
			err := rb.Put(i)
			assert.NotNil(t, err)
		}(i)
	}

	spunUp.Wait()

	rb.Dispose()

	wg.Wait()

	assert.True(t, rb.IsDisposed())
} PrettyPrintBody:[{ numThreads := 8 var wg sync.WaitGroup wg.Add(numThreads) rb := NewRingBuffer(4) var spunUp sync.WaitGroup spunUp.Add(numThreads) for i := 0; i < 4; i++ { rb.Put(i) } for i := 0; i < numThreads; i++ { go func(i int) { spunUp.Done() defer wg.Done() err := rb.Put(i) assert.NotNil(t, err) }(i) } spunUp.Wait() rb.Dispose() wg.Wait() assert.True(t, rb.IsDisposed()) }]} {Id:12 FileId:99 StartLine:303 StartColumn:1 EndLine:329 EndColumn:2 Name:BenchmarkRBLifeCycle Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(64)

	counter := uint64(0)
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		for {
			_, err := rb.Get()
			assert.Nil(b, err)

			if atomic.AddUint64(&counter, 1) == uint64(b.N) {
				return
			}
		}
	}()

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rb.Put(i)
	}

	wg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(64) counter := uint64(0) var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() for { _, err := rb.Get() assert.Nil(b, err) if atomic.AddUint64(&counter, 1) == uint64(b.N) { return } } }() b.ResetTimer() for i := 0; i < b.N; i++ { rb.Put(i) } wg.Wait() }]} {Id:13 FileId:99 StartLine:331 StartColumn:1 EndLine:367 EndColumn:2 Name:BenchmarkRBLifeCycleContention Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(64)

	var wwg sync.WaitGroup
	var rwg sync.WaitGroup
	wwg.Add(10)
	rwg.Add(10)

	for i := 0; i < 10; i++ {
		go func() {
			for {
				_, err := rb.Get()
				if err == ErrDisposed {
					rwg.Done()
					return
				} else {
					assert.Nil(b, err)
				}
			}
		}()
	}

	b.ResetTimer()

	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < b.N; j++ {
				rb.Put(j)
			}
			wwg.Done()
		}()
	}

	wwg.Wait()
	rb.Dispose()
	rwg.Wait()
} PrettyPrintBody:[{ rb := NewRingBuffer(64) var wwg sync.WaitGroup var rwg sync.WaitGroup wwg.Add(10) rwg.Add(10) for i := 0; i < 10; i++ { go func() { for { _, err := rb.Get() if err == ErrDisposed { rwg.Done() return } else { assert.Nil(b, err) } } }() } b.ResetTimer() for i := 0; i < 10; i++ { go func() { for j := 0; j < b.N; j++ { rb.Put(j) } wwg.Done() }() } wwg.Wait() rb.Dispose() rwg.Wait() }]} {Id:14 FileId:99 StartLine:369 StartColumn:1 EndLine:384 EndColumn:2 Name:BenchmarkRBPut Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(uint64(b.N))

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ok, err := rb.Offer(i)
		if !ok {
			b.Fail()
		}
		if err != nil {
			b.Log(err)
			b.Fail()
		}
	}
} PrettyPrintBody:[{ rb := NewRingBuffer(uint64(b.N)) b.ResetTimer() for i := 0; i < b.N; i++ { ok, err := rb.Offer(i) if !ok { b.Fail() } if err != nil { b.Log(err) b.Fail() } } }]} {Id:15 FileId:99 StartLine:386 StartColumn:1 EndLine:398 EndColumn:2 Name:BenchmarkRBGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	rb := NewRingBuffer(uint64(b.N))

	for i := 0; i < b.N; i++ {
		rb.Offer(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rb.Get()
	}
} PrettyPrintBody:[{ rb := NewRingBuffer(uint64(b.N)) for i := 0; i < b.N; i++ { rb.Offer(i) } b.ResetTimer() for i := 0; i < b.N; i++ { rb.Get() } }]} {Id:16 FileId:99 StartLine:400 StartColumn:1 EndLine:404 EndColumn:2 Name:BenchmarkRBAllocation Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		NewRingBuffer(1024)
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { NewRingBuffer(1024) } }]} {Id:3 FileId:118 StartLine:29 StartColumn:1 EndLine:61 EndColumn:2 Name:getParent Params:[{Name:parent Type:*node} {Name:key Type:hilbert} {Name:r1 Type:rtree.Rectangle}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	var n *node
	for parent != nil && !parent.isLeaf {
		n = parent.searchNode(key)
		parent = n
	}

	if parent != nil && r1 != nil {

		i := parent.search(key)
		for parent.keys.byPosition(i) == key {
			if equal(parent.nodes.list[i], r1) {
				break
			}

			i++
			if i == parent.keys.len() {
				if parent.right == nil {
					break
				}

				if parent.right.keys.byPosition(0) != key {
					break
				}

				parent = parent.right
				i = 0
			}
		}
	}

	return parent
} PrettyPrintBody:[{ var n *node for parent != nil && !parent.isLeaf { n = parent.searchNode(key) parent = n } if parent != nil && r1 != nil { i := parent.search(key) for parent.keys.byPosition(i) == key { if equal(parent.nodes.list[i], r1) { break } i++ if i == parent.keys.len() { if parent.right == nil { break } if parent.right.keys.byPosition(0) != key { break } parent = parent.right i = 0 } } } return parent }]} {Id:5 FileId:118 StartLine:67 StartColumn:1 EndLine:69 EndColumn:2 Name:push Params:[{Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc000e7fec0 Body:{
	ns.list = append(ns.list, n)
} PrettyPrintBody:[{ ns.list = append(ns.list, n) }]} {Id:6 FileId:118 StartLine:71 StartColumn:1 EndLine:80 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*nodes} {Name: Type:*nodes}] Receiver:0xc000e7ff00 Body:{
	i++
	right := make(rtree.Rectangles, uint64(len(ns.list))-i, capacity)
	copy(right, ns.list[i:])
	for j := i; j < uint64(len(ns.list)); j++ {
		ns.list[j] = nil
	}
	ns.list = ns.list[:i]
	return ns, &nodes{list: right}
} PrettyPrintBody:[{ i++ right := make(rtree.Rectangles, uint64(len(ns.list))-i, capacity) copy(right, ns.list[i:]) for j := i; j < uint64(len(ns.list)); j++ { ns.list[j] = nil } ns.list = ns.list[:i] return ns, &nodes{list: right} }]} {Id:7 FileId:118 StartLine:82 StartColumn:1 EndLine:88 EndColumn:2 Name:byPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*node}] Receiver:0xc0001187a0 Body:{
	if pos >= uint64(len(ns.list)) {
		return nil
	}

	return ns.list[pos].(*node)
} PrettyPrintBody:[{ if pos >= uint64(len(ns.list)) { return nil } return ns.list[pos].(*node) }]} {Id:8 FileId:118 StartLine:90 StartColumn:1 EndLine:94 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc0010333e0 Body:{
	ns.list = append(ns.list, nil)
	copy(ns.list[i+1:], ns.list[i:])
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list = append(ns.list, nil) copy(ns.list[i+1:], ns.list[i:]) ns.list[i] = n }]} {Id:9 FileId:118 StartLine:96 StartColumn:1 EndLine:98 EndColumn:2 Name:replaceAt Params:[{Name:i Type:uint64} {Name:n Type:rtree.Rectangle}] Results:[] Receiver:0xc001309860 Body:{
	ns.list[i] = n
} PrettyPrintBody:[{ ns.list[i] = n }]} {Id:10 FileId:118 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0013098a0 Body:{
	return uint64(len(ns.list))
} PrettyPrintBody:[{ return uint64(len(ns.list)) }]} {Id:11 FileId:118 StartLine:104 StartColumn:1 EndLine:107 EndColumn:2 Name:deleteAt Params:[{Name:i Type:uint64}] Results:[] Receiver:0xc001581120 Body:{
	copy(ns.list[i:], ns.list[i+1:])
	ns.list = ns.list[:len(ns.list)-1]
} PrettyPrintBody:[{ copy(ns.list[i:], ns.list[i+1:]) ns.list = ns.list[:len(ns.list)-1] }]} {Id:12 FileId:118 StartLine:109 StartColumn:1 EndLine:113 EndColumn:2 Name:newNodes Params:[{Name:size Type:uint64}] Results:[{Name: Type:*nodes}] Receiver:<nil> Body:{
	return &nodes{
		list: make(rtree.Rectangles, 0, size),
	}
} PrettyPrintBody:[{ return &nodes{ list: make(rtree.Rectangles, 0, size), } }]} {Id:14 FileId:118 StartLine:119 StartColumn:1 EndLine:125 EndColumn:2 Name:splitAt Params:[{Name:i Type:uint64}] Results:[{Name: Type:*keys} {Name: Type:*keys}] Receiver:0xc0010dfc80 Body:{
	i++
	right := make(hilberts, uint64(len(ks.list))-i, capacity)
	copy(right, ks.list[i:])
	ks.list = ks.list[:i]
	return ks, &keys{list: right}
} PrettyPrintBody:[{ i++ right := make(hilberts, uint64(len(ks.list))-i, capacity) copy(right, ks.list[i:]) ks.list = ks.list[:i] return ks, &keys{list: right} }]} {Id:15 FileId:118 StartLine:127 StartColumn:1 EndLine:129 EndColumn:2 Name:len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc000993a40 Body:{
	return uint64(len(ks.list))
} PrettyPrintBody:[{ return uint64(len(ks.list)) }]} {Id:16 FileId:118 StartLine:131 StartColumn:1 EndLine:136 EndColumn:2 Name:byPosition Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert}] Receiver:0xc0003e52c0 Body:{
	if i >= uint64(len(ks.list)) {
		return -1
	}
	return ks.list[i]
} PrettyPrintBody:[{ if i >= uint64(len(ks.list)) { return -1 } return ks.list[i] }]} {Id:17 FileId:118 StartLine:138 StartColumn:1 EndLine:141 EndColumn:2 Name:deleteAt Params:[{Name:i Type:uint64}] Results:[] Receiver:0xc0003e5300 Body:{
	copy(ks.list[i:], ks.list[i+1:])
	ks.list = ks.list[:len(ks.list)-1]
} PrettyPrintBody:[{ copy(ks.list[i:], ks.list[i+1:]) ks.list = ks.list[:len(ks.list)-1] }]} {Id:18 FileId:118 StartLine:143 StartColumn:1 EndLine:155 EndColumn:2 Name:delete Params:[{Name:k Type:hilbert}] Results:[{Name: Type:hilbert}] Receiver:0xc001409e20 Body:{
	i := ks.search(k)
	if i >= uint64(len(ks.list)) {
		return -1
	}

	if ks.list[i] != k {
		return -1
	}
	old := ks.list[i]
	ks.deleteAt(i)
	return old
} PrettyPrintBody:[{ i := ks.search(k) if i >= uint64(len(ks.list)) { return -1 } if ks.list[i] != k { return -1 } old := ks.list[i] ks.deleteAt(i) return old }]} {Id:19 FileId:118 StartLine:157 StartColumn:1 EndLine:163 EndColumn:2 Name:search Params:[{Name:key Type:hilbert}] Results:[{Name: Type:uint64}] Receiver:0xc000a8a960 Body:{
	i := sort.Search(len(ks.list), func(i int) bool {
		return ks.list[i] >= key
	})

	return uint64(i)
} PrettyPrintBody:[{ i := sort.Search(len(ks.list), func(i int) bool { return ks.list[i] >= key }) return uint64(i) }]} {Id:20 FileId:118 StartLine:165 StartColumn:1 EndLine:181 EndColumn:2 Name:insert Params:[{Name:key Type:hilbert}] Results:[{Name: Type:hilbert} {Name: Type:uint64}] Receiver:0xc001409fe0 Body:{
	i := ks.search(key)
	if i == uint64(len(ks.list)) {
		ks.list = append(ks.list, key)
		return -1, i
	}

	var old hilbert
	if ks.list[i] == key {
		old = ks.list[i]
		ks.list[i] = key
	} else {
		ks.insertAt(i, key)
	}

	return old, i
} PrettyPrintBody:[{ i := ks.search(key) if i == uint64(len(ks.list)) { ks.list = append(ks.list, key) return -1, i } var old hilbert if ks.list[i] == key { old = ks.list[i] ks.list[i] = key } else { ks.insertAt(i, key) } return old, i }]} {Id:21 FileId:118 StartLine:183 StartColumn:1 EndLine:185 EndColumn:2 Name:last Params:[] Results:[{Name: Type:hilbert}] Receiver:0xc00095ae80 Body:{
	return ks.list[len(ks.list)-1]
} PrettyPrintBody:[{ return ks.list[len(ks.list)-1] }]} {Id:22 FileId:118 StartLine:187 StartColumn:1 EndLine:191 EndColumn:2 Name:insertAt Params:[{Name:i Type:uint64} {Name:k Type:hilbert}] Results:[] Receiver:0xc001603360 Body:{
	ks.list = append(ks.list, -1)
	copy(ks.list[i+1:], ks.list[i:])
	ks.list[i] = k
} PrettyPrintBody:[{ ks.list = append(ks.list, -1) copy(ks.list[i+1:], ks.list[i:]) ks.list[i] = k }]} {Id:23 FileId:118 StartLine:193 StartColumn:1 EndLine:203 EndColumn:2 Name:withPosition Params:[{Name:k Type:hilbert}] Results:[{Name: Type:hilbert} {Name: Type:uint64}] Receiver:0xc0016033e0 Body:{
	i := ks.search(k)
	if i == uint64(len(ks.list)) {
		return -1, i
	}
	if ks.list[i] == k {
		return ks.list[i], i
	}

	return -1, i
} PrettyPrintBody:[{ i := ks.search(k) if i == uint64(len(ks.list)) { return -1, i } if ks.list[i] == k { return ks.list[i], i } return -1, i }]} {Id:24 FileId:118 StartLine:205 StartColumn:1 EndLine:209 EndColumn:2 Name:newKeys Params:[{Name:size Type:uint64}] Results:[{Name: Type:*keys}] Receiver:<nil> Body:{
	return &keys{
		list: make(hilberts, 0, size),
	}
} PrettyPrintBody:[{ return &keys{ list: make(hilberts, 0, size), } }]} {Id:26 FileId:118 StartLine:220 StartColumn:1 EndLine:256 EndColumn:2 Name:insert Params:[{Name:kb Type:*keyBundle}] Results:[{Name: Type:rtree.Rectangle}] Receiver:0xc00095b000 Body:{
	i := n.keys.search(kb.key)
	if n.isLeaf {
		for i < n.keys.len() && n.keys.list[i] == kb.key {
			if equal(n.nodes.list[i], kb.left) {
				old := n.nodes.list[i]
				n.nodes.list[i] = kb.left
				return old
			}
			i++
		}
	}

	if i == n.keys.len() {
		n.maxHilbert = kb.key
	}

	n.keys.insertAt(i, kb.key)
	if n.isLeaf {
		n.nodes.insertAt(i, kb.left)
	} else {
		if n.nodes.len() == 0 {
			n.nodes.push(kb.left)
			n.nodes.push(kb.right)
		} else {
			n.nodes.replaceAt(i, kb.left)
			n.nodes.insertAt(i+1, kb.right)
		}
		n.mbr.adjust(kb.left)
		n.mbr.adjust(kb.right)
		if kb.right.(*node).maxHilbert > n.maxHilbert {
			n.maxHilbert = kb.right.(*node).maxHilbert
		}
	}

	return nil
} PrettyPrintBody:[{ i := n.keys.search(kb.key) if n.isLeaf { for i < n.keys.len() && n.keys.list[i] == kb.key { if equal(n.nodes.list[i], kb.left) { old := n.nodes.list[i] n.nodes.list[i] = kb.left return old } i++ } } if i == n.keys.len() { n.maxHilbert = kb.key } n.keys.insertAt(i, kb.key) if n.isLeaf { n.nodes.insertAt(i, kb.left) } else { if n.nodes.len() == 0 { n.nodes.push(kb.left) n.nodes.push(kb.right) } else { n.nodes.replaceAt(i, kb.left) n.nodes.insertAt(i+1, kb.right) } n.mbr.adjust(kb.left) n.mbr.adjust(kb.right) if kb.right.(*node).maxHilbert > n.maxHilbert { n.maxHilbert = kb.right.(*node).maxHilbert } } return nil }]} {Id:27 FileId:118 StartLine:258 StartColumn:1 EndLine:272 EndColumn:2 Name:delete Params:[{Name:kb Type:*keyBundle}] Results:[{Name: Type:rtree.Rectangle}] Receiver:0xc000a8ba00 Body:{
	i := n.keys.search(kb.key)
	if n.keys.byPosition(i) != kb.key {
		return nil
	}

	if !equal(n.nodes.list[i], kb.left) {
		return nil
	}

	old := n.nodes.list[i]
	n.keys.deleteAt(i)
	n.nodes.deleteAt(i)
	return old
} PrettyPrintBody:[{ i := n.keys.search(kb.key) if n.keys.byPosition(i) != kb.key { return nil } if !equal(n.nodes.list[i], kb.left) { return nil } old := n.nodes.list[i] n.keys.deleteAt(i) n.nodes.deleteAt(i) return old }]} {Id:28 FileId:118 StartLine:274 StartColumn:1 EndLine:276 EndColumn:2 Name:LowerLeft Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc0009923e0 Body:{
	return n.mbr.xlow, n.mbr.ylow
} PrettyPrintBody:[{ return n.mbr.xlow, n.mbr.ylow }]} {Id:29 FileId:118 StartLine:278 StartColumn:1 EndLine:280 EndColumn:2 Name:UpperRight Params:[] Results:[{Name: Type:int32} {Name: Type:int32}] Receiver:0xc000a8bc80 Body:{
	return n.mbr.xhigh, n.mbr.yhigh
} PrettyPrintBody:[{ return n.mbr.xhigh, n.mbr.yhigh }]} {Id:30 FileId:118 StartLine:282 StartColumn:1 EndLine:284 EndColumn:2 Name:needsSplit Params:[{Name:ary Type:uint64}] Results:[{Name: Type:bool}] Receiver:0xc0009924e0 Body:{
	return n.keys.len() >= ary
} PrettyPrintBody:[{ return n.keys.len() >= ary }]} {Id:31 FileId:118 StartLine:286 StartColumn:1 EndLine:303 EndColumn:2 Name:splitLeaf Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc000992520 Body:{
	key := n.keys.byPosition(i)
	_, rightKeys := n.keys.splitAt(i, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)
	nn := &node{
		keys:	rightKeys,
		nodes:	rightNodes,
		isLeaf:	true,
		right:	n.right,
		parent:	n.parent,
	}
	n.right = nn
	nn.mbr = newRectangleFromRects(rightNodes.list)
	n.mbr = newRectangleFromRects(n.nodes.list)
	nn.maxHilbert = rightKeys.last()
	n.maxHilbert = n.keys.last()
	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) _, rightKeys := n.keys.splitAt(i, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := &node{ keys:	rightKeys, nodes:	rightNodes, isLeaf:	true, right:	n.right, parent:	n.parent, } n.right = nn nn.mbr = newRectangleFromRects(rightNodes.list) n.mbr = newRectangleFromRects(n.nodes.list) nn.maxHilbert = rightKeys.last() n.maxHilbert = n.keys.last() return key, n, nn }]} {Id:32 FileId:118 StartLine:305 StartColumn:1 EndLine:322 EndColumn:2 Name:splitInternal Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc000992780 Body:{
	key := n.keys.byPosition(i)
	n.keys.delete(key)

	_, rightKeys := n.keys.splitAt(i-1, capacity)
	_, rightNodes := n.nodes.splitAt(i, capacity)

	nn := newNode(false, rightKeys, rightNodes)
	for _, n := range rightNodes.list {
		n.(*node).parent = nn
	}
	nn.mbr = newRectangleFromRects(rightNodes.list)
	n.mbr = newRectangleFromRects(n.nodes.list)
	nn.maxHilbert = nn.keys.last()
	n.maxHilbert = n.keys.last()

	return key, n, nn
} PrettyPrintBody:[{ key := n.keys.byPosition(i) n.keys.delete(key) _, rightKeys := n.keys.splitAt(i-1, capacity) _, rightNodes := n.nodes.splitAt(i, capacity) nn := newNode(false, rightKeys, rightNodes) for _, n := range rightNodes.list { n.(*node).parent = nn } nn.mbr = newRectangleFromRects(rightNodes.list) n.mbr = newRectangleFromRects(n.nodes.list) nn.maxHilbert = nn.keys.last() n.maxHilbert = n.keys.last() return key, n, nn }]} {Id:33 FileId:118 StartLine:324 StartColumn:1 EndLine:330 EndColumn:2 Name:split Params:[{Name:i Type:uint64}] Results:[{Name: Type:hilbert} {Name: Type:*node} {Name: Type:*node}] Receiver:0xc00095b940 Body:{
	if n.isLeaf {
		return n.splitLeaf(i, capacity)
	}

	return n.splitInternal(i, capacity)
} PrettyPrintBody:[{ if n.isLeaf { return n.splitLeaf(i, capacity) } return n.splitInternal(i, capacity) }]} {Id:34 FileId:118 StartLine:332 StartColumn:1 EndLine:334 EndColumn:2 Name:search Params:[{Name:key Type:hilbert}] Results:[{Name: Type:uint64}] Receiver:0xc0001e7e40 Body:{
	return n.keys.search(key)
} PrettyPrintBody:[{ return n.keys.search(key) }]} {Id:35 FileId:118 StartLine:336 StartColumn:1 EndLine:340 EndColumn:2 Name:searchNode Params:[{Name:key Type:hilbert}] Results:[{Name: Type:*node}] Receiver:0xc0000ed980 Body:{
	i := n.search(key)

	return n.nodes.byPosition(uint64(i))
} PrettyPrintBody:[{ i := n.search(key) return n.nodes.byPosition(uint64(i)) }]} {Id:36 FileId:118 StartLine:342 StartColumn:1 EndLine:351 EndColumn:2 Name:searchRects Params:[{Name:r Type:*rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc00019ea80 Body:{
	rects := make(rtree.Rectangles, 0, n.nodes.len())
	for _, child := range n.nodes.list {
		if intersect(r, child) {
			rects = append(rects, child)
		}
	}

	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, n.nodes.len()) for _, child := range n.nodes.list { if intersect(r, child) { rects = append(rects, child) } } return rects }]} {Id:37 FileId:118 StartLine:353 StartColumn:1 EndLine:355 EndColumn:2 Name:key Params:[] Results:[{Name: Type:hilbert}] Receiver:0xc00019eb80 Body:{
	return n.keys.last()
} PrettyPrintBody:[{ return n.keys.last() }]} {Id:38 FileId:118 StartLine:357 StartColumn:1 EndLine:363 EndColumn:2 Name:newNode Params:[{Name:isLeaf Type:bool} {Name:keys Type:*keys} {Name:ns Type:*nodes}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	return &node{
		isLeaf:	isLeaf,
		keys:	keys,
		nodes:	ns,
	}
} PrettyPrintBody:[{ return &node{ isLeaf:	isLeaf, keys:	keys, nodes:	ns, } }]} {Id:1 FileId:13 StartLine:25 StartColumn:1 EndLine:78 EndColumn:2 Name:TestBitOperations Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}
	if !result {
		t.Errorf(`Expected true at position: %d`, 5)
	}

	result, err = ba.GetBit(3)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position %d`, 3)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position: %d`, 5)
	}

	ba = newBitArray(24)
	err = ba.SetBit(16)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(16)
	if err != nil {
		t.Fatal(err)
	}

	if !result {
		t.Errorf(`Expected true at position: %d`, 16)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 5) } result, err = ba.GetBit(3) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position %d`, 3) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } result, err = ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position: %d`, 5) } ba = newBitArray(24) err = ba.SetBit(16) if err != nil { t.Fatal(err) } result, err = ba.GetBit(16) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 16) } }]} {Id:2 FileId:13 StartLine:80 StartColumn:1 EndLine:120 EndColumn:2 Name:TestDuplicateOperation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if !result {
		t.Errorf(`Expected true at position: %d`, 5)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.ClearBit(5)
	if err != nil {
		t.Fatal(err)
	}

	result, err = ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`Expected false at position: %d`, 5)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } err = ba.SetBit(5) if err != nil { t.Fatal(err) } result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if !result { t.Errorf(`Expected true at position: %d`, 5) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } err = ba.ClearBit(5) if err != nil { t.Fatal(err) } result, err = ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`Expected false at position: %d`, 5) } }]} {Id:3 FileId:13 StartLine:122 StartColumn:1 EndLine:135 EndColumn:2 Name:TestOutOfBounds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(4)

	err := ba.SetBit(s + 1)

	if _, ok := err.(OutOfRangeError); !ok {
		t.Errorf(`Expected out of range error.`)
	}

	_, err = ba.GetBit(s + 1)
	if _, ok := err.(OutOfRangeError); !ok {
		t.Errorf(`Expected out of range error.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(4) err := ba.SetBit(s + 1) if _, ok := err.(OutOfRangeError); !ok { t.Errorf(`Expected out of range error.`) } _, err = ba.GetBit(s + 1) if _, ok := err.(OutOfRangeError); !ok { t.Errorf(`Expected out of range error.`) } }]} {Id:4 FileId:13 StartLine:137 StartColumn:1 EndLine:143 EndColumn:2 Name:TestIsEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	assert.True(t, ba.IsEmpty())

	ba.SetBit(5)
	assert.False(t, ba.IsEmpty())
} PrettyPrintBody:[{ ba := newBitArray(10) assert.True(t, ba.IsEmpty()) ba.SetBit(5) assert.False(t, ba.IsEmpty()) }]} {Id:5 FileId:13 StartLine:145 StartColumn:1 EndLine:178 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	err := ba.SetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	err = ba.SetBit(9)
	if err != nil {
		t.Fatal(err)
	}

	ba.Reset()

	assert.False(t, ba.anyset)
	result, err := ba.GetBit(5)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`BA not reset.`)
	}

	result, err = ba.GetBit(9)
	if err != nil {
		t.Fatal(err)
	}

	if result {
		t.Errorf(`BA not reset.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) err := ba.SetBit(5) if err != nil { t.Fatal(err) } err = ba.SetBit(9) if err != nil { t.Fatal(err) } ba.Reset() assert.False(t, ba.anyset) result, err := ba.GetBit(5) if err != nil { t.Fatal(err) } if result { t.Errorf(`BA not reset.`) } result, err = ba.GetBit(9) if err != nil { t.Fatal(err) } if result { t.Errorf(`BA not reset.`) } }]} {Id:6 FileId:13 StartLine:180 StartColumn:1 EndLine:196 EndColumn:2 Name:BenchmarkGetBit Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(168000)

	ba := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for j := uint64(0); j < numItems; j++ {
			ba.GetBit(j)
		}
	}
} PrettyPrintBody:[{ numItems := uint64(168000) ba := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { ba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { for j := uint64(0); j < numItems; j++ { ba.GetBit(j) } } }]} {Id:7 FileId:13 StartLine:198 StartColumn:1 EndLine:218 EndColumn:2 Name:TestEquality Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s + 1)
	other := newBitArray(s + 1)

	if !ba.Equals(other) {
		t.Errorf(`Expected equality.`)
	}

	ba.SetBit(s + 1)
	other.SetBit(s + 1)

	if !ba.Equals(other) {
		t.Errorf(`Expected equality.`)
	}

	other.SetBit(0)

	if ba.Equals(other) {
		t.Errorf(`Expected inequality.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(s + 1) other := newBitArray(s + 1) if !ba.Equals(other) { t.Errorf(`Expected equality.`) } ba.SetBit(s + 1) other.SetBit(s + 1) if !ba.Equals(other) { t.Errorf(`Expected equality.`) } other.SetBit(0) if ba.Equals(other) { t.Errorf(`Expected inequality.`) } }]} {Id:8 FileId:13 StartLine:220 StartColumn:1 EndLine:229 EndColumn:2 Name:BenchmarkEquality Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(160000)
	other := newBitArray(ba.Capacity())

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Equals(other)
	}
} PrettyPrintBody:[{ ba := newBitArray(160000) other := newBitArray(ba.Capacity()) b.ResetTimer() for i := 0; i < b.N; i++ { ba.Equals(other) } }]} {Id:9 FileId:13 StartLine:231 StartColumn:1 EndLine:256 EndColumn:2 Name:TestIntersects Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	other := newBitArray(ba.Capacity())

	ba.SetBit(1)
	ba.SetBit(2)

	other.SetBit(1)

	if !ba.Intersects(other) {
		t.Errorf(`Is intersecting.`)
	}

	other.SetBit(5)

	if ba.Intersects(other) {
		t.Errorf(`Is not intersecting.`)
	}

	other = newBitArray(ba.Capacity() + 1)
	other.SetBit(1)

	if ba.Intersects(other) {
		t.Errorf(`Is not intersecting.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) other := newBitArray(ba.Capacity()) ba.SetBit(1) ba.SetBit(2) other.SetBit(1) if !ba.Intersects(other) { t.Errorf(`Is intersecting.`) } other.SetBit(5) if ba.Intersects(other) { t.Errorf(`Is not intersecting.`) } other = newBitArray(ba.Capacity() + 1) other.SetBit(1) if ba.Intersects(other) { t.Errorf(`Is not intersecting.`) } }]} {Id:10 FileId:13 StartLine:258 StartColumn:1 EndLine:270 EndColumn:2 Name:BenchmarkIntersects Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(162432)
	other := newBitArray(ba.Capacity())

	ba.SetBit(159999)
	other.SetBit(159999)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.Intersects(other)
	}
} PrettyPrintBody:[{ ba := newBitArray(162432) other := newBitArray(ba.Capacity()) ba.SetBit(159999) other.SetBit(159999) b.ResetTimer() for i := 0; i < b.N; i++ { ba.Intersects(other) } }]} {Id:11 FileId:13 StartLine:272 StartColumn:1 EndLine:286 EndColumn:2 Name:TestComplement Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	ba.SetBit(5)

	ba.complement()

	if ok, _ := ba.GetBit(5); ok {
		t.Errorf(`Expected clear.`)
	}

	if ok, _ := ba.GetBit(4); !ok {
		t.Errorf(`Expected set.`)
	}
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.complement() if ok, _ := ba.GetBit(5); ok { t.Errorf(`Expected clear.`) } if ok, _ := ba.GetBit(4); !ok { t.Errorf(`Expected set.`) } }]} {Id:12 FileId:13 StartLine:288 StartColumn:1 EndLine:296 EndColumn:2 Name:BenchmarkComplement Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(160000)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.complement()
	}
} PrettyPrintBody:[{ ba := newBitArray(160000) b.ResetTimer() for i := 0; i < b.N; i++ { ba.complement() } }]} {Id:13 FileId:13 StartLine:298 StartColumn:1 EndLine:314 EndColumn:2 Name:TestSetHighestLowest Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)

	ba.SetBit(5)

	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(5), ba.highest)

	ba.SetBit(8)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(8), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(10) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) ba.SetBit(5) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(5), ba.highest) ba.SetBit(8) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(8), ba.highest) }]} {Id:14 FileId:13 StartLine:316 StartColumn:1 EndLine:320 EndColumn:2 Name:TestGetBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	_, err := ba.GetBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) _, err := ba.GetBit(s * 2) assert.Error(t, err) }]} {Id:15 FileId:13 StartLine:322 StartColumn:1 EndLine:326 EndColumn:2 Name:TestSetBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	err := ba.SetBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) err := ba.SetBit(s * 2) assert.Error(t, err) }]} {Id:16 FileId:13 StartLine:328 StartColumn:1 EndLine:332 EndColumn:2 Name:TestClearBitAtCapacity Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	err := ba.ClearBit(s * 2)
	assert.Error(t, err)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) err := ba.ClearBit(s * 2) assert.Error(t, err) }]} {Id:17 FileId:13 StartLine:334 StartColumn:1 EndLine:368 EndColumn:2 Name:TestClearHighestLowest Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)

	ba.SetBit(5)
	ba.ClearBit(5)

	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)

	ba.SetBit(3)
	ba.SetBit(5)
	ba.SetBit(7)

	ba.ClearBit(7)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.highest)
	assert.Equal(t, uint64(3), ba.lowest)

	ba.SetBit(7)
	ba.ClearBit(3)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(7), ba.highest)

	ba.ClearBit(7)
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(5), ba.lowest)
	assert.Equal(t, uint64(5), ba.highest)

	ba.ClearBit(5)
	assert.False(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(0), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.ClearBit(5) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) ba.SetBit(3) ba.SetBit(5) ba.SetBit(7) ba.ClearBit(7) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.highest) assert.Equal(t, uint64(3), ba.lowest) ba.SetBit(7) ba.ClearBit(3) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(7), ba.highest) ba.ClearBit(7) assert.True(t, ba.anyset) assert.Equal(t, uint64(5), ba.lowest) assert.Equal(t, uint64(5), ba.highest) ba.ClearBit(5) assert.False(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(0), ba.highest) }]} {Id:18 FileId:13 StartLine:370 StartColumn:1 EndLine:377 EndColumn:2 Name:TestComplementResetsBounds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(5)

	ba.complement()
	assert.True(t, ba.anyset)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.Equal(t, uint64(s-1), ba.highest)
} PrettyPrintBody:[{ ba := newBitArray(5) ba.complement() assert.True(t, ba.anyset) assert.Equal(t, uint64(0), ba.lowest) assert.Equal(t, uint64(s-1), ba.highest) }]} {Id:19 FileId:13 StartLine:379 StartColumn:1 EndLine:396 EndColumn:2 Name:TestBitArrayIntersectsSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	cba := newSparseBitArray()

	assert.True(t, ba.Intersects(cba))

	cba.SetBit(5)
	assert.False(t, ba.Intersects(cba))

	ba.SetBit(5)
	assert.True(t, ba.Intersects(cba))

	cba.SetBit(s + 1)
	assert.False(t, ba.Intersects(cba))

	ba.SetBit(s + 1)
	assert.True(t, ba.Intersects(cba))
} PrettyPrintBody:[{ ba := newBitArray(s * 2) cba := newSparseBitArray() assert.True(t, ba.Intersects(cba)) cba.SetBit(5) assert.False(t, ba.Intersects(cba)) ba.SetBit(5) assert.True(t, ba.Intersects(cba)) cba.SetBit(s + 1) assert.False(t, ba.Intersects(cba)) ba.SetBit(s + 1) assert.True(t, ba.Intersects(cba)) }]} {Id:20 FileId:13 StartLine:398 StartColumn:1 EndLine:415 EndColumn:2 Name:TestBitArrayEqualsSparse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)
	cba := newSparseBitArray()

	assert.True(t, ba.Equals(cba))

	ba.SetBit(5)
	assert.False(t, ba.Equals(cba))

	cba.SetBit(5)
	assert.True(t, ba.Equals(cba))

	ba.SetBit(s + 1)
	assert.False(t, ba.Equals(cba))

	cba.SetBit(s + 1)
	assert.True(t, ba.Equals(cba))
} PrettyPrintBody:[{ ba := newBitArray(s * 2) cba := newSparseBitArray() assert.True(t, ba.Equals(cba)) ba.SetBit(5) assert.False(t, ba.Equals(cba)) cba.SetBit(5) assert.True(t, ba.Equals(cba)) ba.SetBit(s + 1) assert.False(t, ba.Equals(cba)) cba.SetBit(s + 1) assert.True(t, ba.Equals(cba)) }]} {Id:21 FileId:13 StartLine:417 StartColumn:1 EndLine:426 EndColumn:2 Name:TestConstructorSetBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(8, true)

	result, err := ba.GetBit(7)
	assert.Nil(t, err)
	assert.True(t, result)
	assert.Equal(t, s-1, ba.highest)
	assert.Equal(t, uint64(0), ba.lowest)
	assert.True(t, ba.anyset)
} PrettyPrintBody:[{ ba := newBitArray(8, true) result, err := ba.GetBit(7) assert.Nil(t, err) assert.True(t, result) assert.Equal(t, s-1, ba.highest) assert.Equal(t, uint64(0), ba.lowest) assert.True(t, ba.anyset) }]} {Id:22 FileId:13 StartLine:428 StartColumn:1 EndLine:438 EndColumn:2 Name:TestCopyBitArray Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(10)
	ba.SetBit(5)
	ba.SetBit(1)

	result := ba.copy().(*bitArray)
	assert.Equal(t, ba.anyset, result.anyset)
	assert.Equal(t, ba.lowest, result.lowest)
	assert.Equal(t, ba.highest, result.highest)
	assert.Equal(t, ba.blocks, result.blocks)
} PrettyPrintBody:[{ ba := newBitArray(10) ba.SetBit(5) ba.SetBit(1) result := ba.copy().(*bitArray) assert.Equal(t, ba.anyset, result.anyset) assert.Equal(t, ba.lowest, result.lowest) assert.Equal(t, ba.highest, result.highest) assert.Equal(t, ba.blocks, result.blocks) }]} {Id:23 FileId:13 StartLine:440 StartColumn:1 EndLine:455 EndColumn:2 Name:BenchmarkDenseIntersectsCompressed Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numBits := uint64(162432)
	ba := newBitArray(numBits)
	other := newSparseBitArray()

	for i := uint64(0); i < numBits; i++ {
		ba.SetBit(i)
		other.SetBit(i)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ba.intersectsSparseBitArray(other)
	}
} PrettyPrintBody:[{ numBits := uint64(162432) ba := newBitArray(numBits) other := newSparseBitArray() for i := uint64(0); i < numBits; i++ { ba.SetBit(i) other.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.intersectsSparseBitArray(other) } }]} {Id:24 FileId:13 StartLine:457 StartColumn:1 EndLine:468 EndColumn:2 Name:TestBitArrayToNums Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ba := newBitArray(s * 2)

	ba.SetBit(s - 1)
	ba.SetBit(s + 1)

	expected := []uint64{s - 1, s + 1}

	result := ba.ToNums()

	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ ba := newBitArray(s * 2) ba.SetBit(s - 1) ba.SetBit(s + 1) expected := []uint64{s - 1, s + 1} result := ba.ToNums() assert.Equal(t, expected, result) }]} {Id:25 FileId:13 StartLine:470 StartColumn:1 EndLine:482 EndColumn:2 Name:BenchmarkBitArrayToNums Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	ba := newBitArray(numItems)

	for i := uint64(0); i < numItems; i++ {
		ba.SetBit(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ba.ToNums()
	}
} PrettyPrintBody:[{ numItems := uint64(1000) ba := newBitArray(numItems) for i := uint64(0); i < numItems; i++ { ba.SetBit(i) } b.ResetTimer() for i := 0; i < b.N; i++ { ba.ToNums() } }]} {Id:1 FileId:91 StartLine:10 StartColumn:1 EndLine:22 EndColumn:2 Name:TestNelderMead Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		return vars[0] * vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	float64(9),
		Fn:	fn,
		Vars:	[]float64{2, 4},
	}

	result, _ := fn(NelderMead(config))
	assert.True(t, math.Abs(result-config.Target) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return vars[0] * vars[1], true } config := NelderMeadConfiguration{ Target:	float64(9), Fn:	fn, Vars:	[]float64{2, 4}, } result, _ := fn(NelderMead(config)) assert.True(t, math.Abs(result-config.Target) <= .01) }]} {Id:2 FileId:91 StartLine:24 StartColumn:1 EndLine:40 EndColumn:2 Name:TestNelderMeadPolynomial Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	float64(-100),
		Fn:	fn,
		Vars:	[]float64{-10, 10},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(7-math.Abs(calced)) <= .01)
	assert.True(t, math.Abs(3-result[0]) <= .1)
	assert.True(t, math.Abs(2-result[1]) <= .1)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(-100), Fn:	fn, Vars:	[]float64{-10, 10}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(7-math.Abs(calced)) <= .01) assert.True(t, math.Abs(3-result[0]) <= .1) assert.True(t, math.Abs(2-result[1]) <= .1) }]} {Id:3 FileId:91 StartLine:42 StartColumn:1 EndLine:58 EndColumn:2 Name:TestNelderMeadPolynomialMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}
	config := NelderMeadConfiguration{
		Target:	math.Inf(-1),
		Fn:	fn,
		Vars:	[]float64{-10, 10},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(7-math.Abs(calced)) <= .01)
	assert.True(t, math.Abs(3-result[0]) <= .01)
	assert.True(t, math.Abs(2-result[1]) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	math.Inf(-1), Fn:	fn, Vars:	[]float64{-10, 10}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(7-math.Abs(calced)) <= .01) assert.True(t, math.Abs(3-result[0]) <= .01) assert.True(t, math.Abs(2-result[1]) <= .01) }]} {Id:4 FileId:91 StartLine:60 StartColumn:1 EndLine:75 EndColumn:2 Name:TestNelderMeadPolynomialMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {

		return 3 + math.Sin(vars[0]) + 2*math.Pow(math.Cos(vars[1]), 2), true
	}

	config := NelderMeadConfiguration{
		Target:	math.Inf(1),
		Fn:	fn,
		Vars:	[]float64{-5, 5},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(6-math.Abs(calced)) <= .01)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { return 3 + math.Sin(vars[0]) + 2*math.Pow(math.Cos(vars[1]), 2), true } config := NelderMeadConfiguration{ Target:	math.Inf(1), Fn:	fn, Vars:	[]float64{-5, 5}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(6-math.Abs(calced)) <= .01) }]} {Id:5 FileId:91 StartLine:77 StartColumn:1 EndLine:123 EndColumn:2 Name:TestNelderMeadConstrained Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		if vars[0] < 1 || vars[1] < 1 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config := NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{6, 3},
	}

	result := NelderMead(config)
	calced, _ := fn(result)
	assert.True(t, math.Abs(14-math.Abs(calced)) <= .01)
	assert.True(t, result[0] >= 1)
	assert.True(t, result[1] >= 1)

	fn = func(vars []float64) (float64, bool) {
		if vars[0] < 6 || vars[0] > 8 {
			return 0, false
		}

		if vars[1] < 0 || vars[1] > 2 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config = NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{6, .5},
	}

	result = NelderMead(config)
	calced, _ = fn(result)

	assert.True(t, math.Abs(14-math.Abs(calced)) <= .01 || math.Abs(8.75-math.Abs(calced)) <= .01)
	assert.True(t, result[0] >= 6 && result[0] <= 8)
	assert.True(t, result[1] >= 0 && result[1] <= 2)
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { if vars[0] < 1 || vars[1] < 1 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{6, 3}, } result := NelderMead(config) calced, _ := fn(result) assert.True(t, math.Abs(14-math.Abs(calced)) <= .01) assert.True(t, result[0] >= 1) assert.True(t, result[1] >= 1) fn = func(vars []float64) (float64, bool) { if vars[0] < 6 || vars[0] > 8 { return 0, false } if vars[1] < 0 || vars[1] > 2 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config = NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{6, .5}, } result = NelderMead(config) calced, _ = fn(result) assert.True(t, math.Abs(14-math.Abs(calced)) <= .01 || math.Abs(8.75-math.Abs(calced)) <= .01) assert.True(t, result[0] >= 6 && result[0] <= 8) assert.True(t, result[1] >= 0 && result[1] <= 2) }]} {Id:6 FileId:91 StartLine:125 StartColumn:1 EndLine:144 EndColumn:2 Name:TestNelderMeadConstrainedBadGuess Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	fn := func(vars []float64) (float64, bool) {
		if vars[0] < 1 || vars[1] < 1 {
			return 0, false
		}
		return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true
	}

	config := NelderMeadConfiguration{
		Target:	float64(14),
		Fn:	fn,
		Vars:	[]float64{0, 3},
	}

	result := NelderMead(config)
	assert.Equal(t, float64(0), result[0])
	assert.Equal(t, float64(3), result[1])
} PrettyPrintBody:[{ fn := func(vars []float64) (float64, bool) { if vars[0] < 1 || vars[1] < 1 { return 0, false } return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true } config := NelderMeadConfiguration{ Target:	float64(14), Fn:	fn, Vars:	[]float64{0, 3}, } result := NelderMead(config) assert.Equal(t, float64(0), result[0]) assert.Equal(t, float64(3), result[1]) }]} {Id:6 FileId:120 StartLine:72 StartColumn:1 EndLine:114 EndColumn:2 Name:checkAndRun Params:[{Name:action Type:action}] Results:[] Receiver:0xc0011dbc40 Body:{
	if tree.actions.Len() > 0 {
		if action != nil {
			tree.actions.Put(action)
		}
		if atomic.CompareAndSwapUint64(&tree.running, 0, 1) {
			var a interface{}
			var err error
			for tree.actions.Len() > 0 {
				a, err = tree.actions.Get()
				if err != nil {
					return
				}
				tree.cache = append(tree.cache, a)
				if uint64(len(tree.cache)) >= tree.bufferSize {
					break
				}
			}

			go tree.operationRunner(tree.cache, true)
		}
	} else if action != nil {
		if atomic.CompareAndSwapUint64(&tree.running, 0, 1) {
			switch action.operation() {
			case get:
				ga := action.(*getAction)
				result := tree.search(ga.lookup)
				ga.result = result
				action.complete()
				tree.reset()
			case add, remove:
				if len(action.keys()) > multiThreadAt {
					tree.operationRunner(interfaces{action}, true)
				} else {
					tree.operationRunner(interfaces{action}, false)
				}
			}
		} else {
			tree.actions.Put(action)
			tree.checkAndRun(nil)
		}
	}
} PrettyPrintBody:[{ if tree.actions.Len() > 0 { if action != nil { tree.actions.Put(action) } if atomic.CompareAndSwapUint64(&tree.running, 0, 1) { var a interface{} var err error for tree.actions.Len() > 0 { a, err = tree.actions.Get() if err != nil { return } tree.cache = append(tree.cache, a) if uint64(len(tree.cache)) >= tree.bufferSize { break } } go tree.operationRunner(tree.cache, true) } } else if action != nil { if atomic.CompareAndSwapUint64(&tree.running, 0, 1) { switch action.operation() { case get: ga := action.(*getAction) result := tree.search(ga.lookup) ga.result = result action.complete() tree.reset() case add, remove: if len(action.keys()) > multiThreadAt { tree.operationRunner(interfaces{action}, true) } else { tree.operationRunner(interfaces{action}, false) } } } else { tree.actions.Put(action) tree.checkAndRun(nil) } } }]} {Id:7 FileId:120 StartLine:116 StartColumn:1 EndLine:123 EndColumn:2 Name:init Params:[{Name:bufferSize Type:uint64}] Results:[] Receiver:0xc0015016c0 Body:{
	tree.bufferSize = bufferSize
	tree.ary = ary
	tree.cache = make([]interface{}, 0, bufferSize)
	tree.root = newNode(true, newKeys(ary), newNodes(ary))
	tree.root.mbr = &rectangle{}
	tree.actions = queue.NewRingBuffer(tree.bufferSize)
} PrettyPrintBody:[{ tree.bufferSize = bufferSize tree.ary = ary tree.cache = make([]interface{}, 0, bufferSize) tree.root = newNode(true, newKeys(ary), newNodes(ary)) tree.root.mbr = &rectangle{} tree.actions = queue.NewRingBuffer(tree.bufferSize) }]} {Id:8 FileId:120 StartLine:125 StartColumn:1 EndLine:133 EndColumn:2 Name:operationRunner Params:[{Name:xns Type:interfaces} {Name:threaded Type:bool}] Results:[] Receiver:0xc001409ae0 Body:{
	writeOperations, deleteOperations, toComplete := tree.fetchKeys(xns, threaded)
	tree.recursiveMutate(writeOperations, deleteOperations, false, threaded)
	for _, a := range toComplete {
		a.complete()
	}

	tree.reset()
} PrettyPrintBody:[{ writeOperations, deleteOperations, toComplete := tree.fetchKeys(xns, threaded) tree.recursiveMutate(writeOperations, deleteOperations, false, threaded) for _, a := range toComplete { a.complete() } tree.reset() }]} {Id:9 FileId:120 StartLine:135 StartColumn:1 EndLine:164 EndColumn:2 Name:fetchKeys Params:[{Name:xns Type:interfaces} {Name:inParallel Type:bool}] Results:[{Name: Type:map[*node][]*keyBundle} {Name: Type:map[*node][]*keyBundle} {Name: Type:actions}] Receiver:0xc001409c40 Body:{
	if inParallel {
		tree.fetchKeysInParallel(xns)
	} else {
		tree.fetchKeysInSerial(xns)
	}

	writeOperations := make(map[*node][]*keyBundle)
	deleteOperations := make(map[*node][]*keyBundle)
	toComplete := make(actions, 0, len(xns)/2)
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add:
			for i, n := range action.nodes() {
				writeOperations[n] = append(writeOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect})
			}
			toComplete = append(toComplete, action)
		case remove:
			for i, n := range action.nodes() {
				deleteOperations[n] = append(deleteOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect})
			}
			toComplete = append(toComplete, action)
		case get:
			action.complete()
		}
	}

	return writeOperations, deleteOperations, toComplete
} PrettyPrintBody:[{ if inParallel { tree.fetchKeysInParallel(xns) } else { tree.fetchKeysInSerial(xns) } writeOperations := make(map[*node][]*keyBundle) deleteOperations := make(map[*node][]*keyBundle) toComplete := make(actions, 0, len(xns)/2) for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add: for i, n := range action.nodes() { writeOperations[n] = append(writeOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}) } toComplete = append(toComplete, action) case remove: for i, n := range action.nodes() { deleteOperations[n] = append(deleteOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}) } toComplete = append(toComplete, action) case get: action.complete() } } return writeOperations, deleteOperations, toComplete }]} {Id:10 FileId:120 StartLine:166 StartColumn:1 EndLine:181 EndColumn:2 Name:fetchKeysInSerial Params:[{Name:xns Type:interfaces}] Results:[] Receiver:0xc000a8a360 Body:{
	for _, ifc := range xns {
		action := ifc.(action)
		switch action.operation() {
		case add, remove:
			for i, key := range action.rects() {
				n := getParent(tree.root, key.hilbert, key.rect)
				action.addNode(int64(i), n)
			}
		case get:
			ga := action.(*getAction)
			rects := tree.search(ga.lookup)
			ga.result = rects
		}
	}
} PrettyPrintBody:[{ for _, ifc := range xns { action := ifc.(action) switch action.operation() { case add, remove: for i, key := range action.rects() { n := getParent(tree.root, key.hilbert, key.rect) action.addNode(int64(i), n) } case get: ga := action.(*getAction) rects := tree.search(ga.lookup) ga.result = rects } } }]} {Id:11 FileId:120 StartLine:183 StartColumn:1 EndLine:191 EndColumn:2 Name:reset Params:[] Results:[] Receiver:0xc001581280 Body:{
	for i := range tree.cache {
		tree.cache[i] = nil
	}

	tree.cache = tree.cache[:0]
	atomic.StoreUint64(&tree.running, 0)
	tree.checkAndRun(nil)
} PrettyPrintBody:[{ for i := range tree.cache { tree.cache[i] = nil } tree.cache = tree.cache[:0] atomic.StoreUint64(&tree.running, 0) tree.checkAndRun(nil) }]} {Id:12 FileId:120 StartLine:193 StartColumn:1 EndLine:242 EndColumn:2 Name:fetchKeysInParallel Params:[{Name:xns Type:[]interface{}}] Results:[] Receiver:0xc0010df5a0 Body:{
	var forCache struct {
		i	int64
		buffer	[8]uint64
		js	[]int64
	}

	for j := 0; j < len(xns); j++ {
		forCache.js = append(forCache.js, -1)
	}
	numCPU := runtime.NumCPU()
	if numCPU > 1 {
		numCPU--
	}
	var wg sync.WaitGroup
	wg.Add(numCPU)

	for k := 0; k < numCPU; k++ {
		go func() {
			for {
				index := atomic.LoadInt64(&forCache.i)
				if index >= int64(len(xns)) {
					break
				}
				action := xns[index].(action)

				j := atomic.AddInt64(&forCache.js[index], 1)
				if j > int64(len(action.rects())) {
					continue
				} else if j == int64(len(action.rects())) {
					atomic.StoreInt64(&forCache.i, index+1)
					continue
				}

				switch action.operation() {
				case add, remove:
					hb := action.rects()[j]
					n := getParent(tree.root, hb.hilbert, hb.rect)
					action.addNode(j, n)
				case get:
					ga := action.(*getAction)
					result := tree.search(ga.lookup)
					ga.result = result
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
} PrettyPrintBody:[{ var forCache struct { i	int64 buffer	[8]uint64 js	[]int64 } for j := 0; j < len(xns); j++ { forCache.js = append(forCache.js, -1) } numCPU := runtime.NumCPU() if numCPU > 1 { numCPU-- } var wg sync.WaitGroup wg.Add(numCPU) for k := 0; k < numCPU; k++ { go func() { for { index := atomic.LoadInt64(&forCache.i) if index >= int64(len(xns)) { break } action := xns[index].(action) j := atomic.AddInt64(&forCache.js[index], 1) if j > int64(len(action.rects())) { continue } else if j == int64(len(action.rects())) { atomic.StoreInt64(&forCache.i, index+1) continue } switch action.operation() { case add, remove: hb := action.rects()[j] n := getParent(tree.root, hb.hilbert, hb.rect) action.addNode(j, n) case get: ga := action.(*getAction) result := tree.search(ga.lookup) ga.result = result } } wg.Done() }() } wg.Wait() }]} {Id:13 FileId:120 StartLine:244 StartColumn:1 EndLine:261 EndColumn:2 Name:splitNode Params:[{Name:n Type:*node} {Name:nodes Type:*[]*node} {Name:keys Type:*hilberts}] Results:[] Receiver:0xc000a8a6c0 Body:{
	if !n.needsSplit(tree.ary) {
		return
	}

	length := n.keys.len()
	splitAt := tree.ary - 1

	for i := splitAt; i < length; i += splitAt {
		offset := length - i
		k, left, right := n.split(offset, tree.ary)
		left.right = right
		*keys = append(*keys, k)
		*nodes = append(*nodes, left, right)
		left.parent = parent
		right.parent = parent
	}
} PrettyPrintBody:[{ if !n.needsSplit(tree.ary) { return } length := n.keys.len() splitAt := tree.ary - 1 for i := splitAt; i < length; i += splitAt { offset := length - i k, left, right := n.split(offset, tree.ary) left.right = right *keys = append(*keys, k) *nodes = append(*nodes, left, right) left.parent = parent right.parent = parent } }]} {Id:14 FileId:120 StartLine:263 StartColumn:1 EndLine:281 EndColumn:2 Name:applyNode Params:[{Name:n Type:*node} {Name:adds Type:[]*keyBundle}] Results:[] Receiver:0xc0003e5440 Body:{
	for _, kb := range deletes {
		if n.keys.len() == 0 {
			break
		}

		deleted := n.delete(kb)
		if deleted != nil {
			atomic.AddUint64(&tree.number, ^uint64(0))
		}
	}

	for _, kb := range adds {
		old := n.insert(kb)
		if n.isLeaf && old == nil {
			atomic.AddUint64(&tree.number, 1)
		}
	}
} PrettyPrintBody:[{ for _, kb := range deletes { if n.keys.len() == 0 { break } deleted := n.delete(kb) if deleted != nil { atomic.AddUint64(&tree.number, ^uint64(0)) } } for _, kb := range adds { old := n.insert(kb) if n.isLeaf && old == nil { atomic.AddUint64(&tree.number, 1) } } }]} {Id:15 FileId:120 StartLine:283 StartColumn:1 EndLine:364 EndColumn:2 Name:recursiveMutate Params:[{Name:adds Type:map[*node][]*keyBundle} {Name:setRoot Type:bool}] Results:[] Receiver:0xc00019e4c0 Body:{
	if len(adds) == 0 && len(deletes) == 0 {
		return
	}

	if setRoot && len(adds) > 1 {
		panic(`SHOULD ONLY HAVE ONE ROOT`)
	}

	ifs := make(interfaces, 0, len(adds))
	for n := range adds {
		if n.parent == nil {
			setRoot = true
		}
		ifs = append(ifs, n)
	}

	for n := range deletes {
		if n.parent == nil {
			setRoot = true
		}

		if _, ok := adds[n]; !ok {
			ifs = append(ifs, n)
		}
	}

	var dummyRoot *node
	if setRoot {
		dummyRoot = &node{
			keys:	newKeys(tree.ary),
			nodes:	newNodes(tree.ary),
			mbr:	&rectangle{},
		}
	}

	var write sync.Mutex
	nextLayerWrite := make(map[*node][]*keyBundle)
	nextLayerDelete := make(map[*node][]*keyBundle)

	var mutate func(interfaces, func(interface{}))
	if inParallel {
		mutate = executeInterfacesInParallel
	} else {
		mutate = executeInterfacesInSerial
	}

	mutate(ifs, func(ifc interface{}) {
		n := ifc.(*node)
		adds := adds[n]
		deletes := deletes[n]

		if len(adds) == 0 && len(deletes) == 0 {
			return
		}

		if setRoot {
			tree.root = n
		}

		parent := n.parent
		if parent == nil {
			parent = dummyRoot
			setRoot = true
		}

		tree.applyNode(n, adds, deletes)

		if n.needsSplit(tree.ary) {
			keys := make(hilberts, 0, n.keys.len())
			nodes := make([]*node, 0, n.nodes.len())
			tree.splitNode(n, parent, &nodes, &keys)
			write.Lock()
			for i, k := range keys {
				nextLayerWrite[parent] = append(nextLayerWrite[parent], &keyBundle{key: k, left: nodes[i*2], right: nodes[i*2+1]})
			}
			write.Unlock()
		}
	})

	tree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel)
} PrettyPrintBody:[{ if len(adds) == 0 && len(deletes) == 0 { return } if setRoot && len(adds) > 1 { panic(`SHOULD ONLY HAVE ONE ROOT`) } ifs := make(interfaces, 0, len(adds)) for n := range adds { if n.parent == nil { setRoot = true } ifs = append(ifs, n) } for n := range deletes { if n.parent == nil { setRoot = true } if _, ok := adds[n]; !ok { ifs = append(ifs, n) } } var dummyRoot *node if setRoot { dummyRoot = &node{ keys:	newKeys(tree.ary), nodes:	newNodes(tree.ary), mbr:	&rectangle{}, } } var write sync.Mutex nextLayerWrite := make(map[*node][]*keyBundle) nextLayerDelete := make(map[*node][]*keyBundle) var mutate func(interfaces, func(interface{})) if inParallel { mutate = executeInterfacesInParallel } else { mutate = executeInterfacesInSerial } mutate(ifs, func(ifc interface{}) { n := ifc.(*node) adds := adds[n] deletes := deletes[n] if len(adds) == 0 && len(deletes) == 0 { return } if setRoot { tree.root = n } parent := n.parent if parent == nil { parent = dummyRoot setRoot = true } tree.applyNode(n, adds, deletes) if n.needsSplit(tree.ary) { keys := make(hilberts, 0, n.keys.len()) nodes := make([]*node, 0, n.nodes.len()) tree.splitNode(n, parent, &nodes, &keys) write.Lock() for i, k := range keys { nextLayerWrite[parent] = append(nextLayerWrite[parent], &keyBundle{key: k, left: nodes[i*2], right: nodes[i*2+1]}) } write.Unlock() } }) tree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel) }]} {Id:16 FileId:120 StartLine:367 StartColumn:1 EndLine:371 EndColumn:2 Name:Insert Params:[{Name:rects Type:...rtree.Rectangle}] Results:[] Receiver:0xc000259960 Body:{
	ia := newInsertAction(rects)
	tree.checkAndRun(ia)
	ia.completer.Wait()
} PrettyPrintBody:[{ ia := newInsertAction(rects) tree.checkAndRun(ia) ia.completer.Wait() }]} {Id:17 FileId:120 StartLine:375 StartColumn:1 EndLine:379 EndColumn:2 Name:Delete Params:[{Name:rects Type:...rtree.Rectangle}] Results:[] Receiver:0xc000259b60 Body:{
	ra := newRemoveAction(rects)
	tree.checkAndRun(ra)
	ra.completer.Wait()
} PrettyPrintBody:[{ ra := newRemoveAction(rects) tree.checkAndRun(ra) ra.completer.Wait() }]} {Id:18 FileId:120 StartLine:381 StartColumn:1 EndLine:399 EndColumn:2 Name:search Params:[{Name:r Type:*rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc0009929a0 Body:{
	if tree.root == nil {
		return rtree.Rectangles{}
	}

	result := make(rtree.Rectangles, 0, 10)
	whs := tree.root.searchRects(r)
	for len(whs) > 0 {
		wh := whs[0]
		if n, ok := wh.(*node); ok {
			whs = append(whs, n.searchRects(r)...)
		} else {
			result = append(result, wh)
		}
		whs = whs[1:]
	}

	return result
} PrettyPrintBody:[{ if tree.root == nil { return rtree.Rectangles{} } result := make(rtree.Rectangles, 0, 10) whs := tree.root.searchRects(r) for len(whs) > 0 { wh := whs[0] if n, ok := wh.(*node); ok { whs = append(whs, n.searchRects(r)...) } else { result = append(result, wh) } whs = whs[1:] } return result }]} {Id:19 FileId:120 StartLine:403 StartColumn:1 EndLine:408 EndColumn:2 Name:Search Params:[{Name:rect Type:rtree.Rectangle}] Results:[{Name: Type:rtree.Rectangles}] Receiver:0xc001581780 Body:{
	ga := newGetAction(rect)
	tree.checkAndRun(ga)
	ga.completer.Wait()
	return ga.result
} PrettyPrintBody:[{ ga := newGetAction(rect) tree.checkAndRun(ga) ga.completer.Wait() return ga.result }]} {Id:20 FileId:120 StartLine:411 StartColumn:1 EndLine:413 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc0015817c0 Body:{
	return atomic.LoadUint64(&tree.number)
} PrettyPrintBody:[{ return atomic.LoadUint64(&tree.number) }]} {Id:21 FileId:120 StartLine:417 StartColumn:1 EndLine:420 EndColumn:2 Name:Dispose Params:[] Results:[] Receiver:0xc0015817e0 Body:{
	tree.actions.Dispose()
	atomic.StoreUint64(&tree.disposed, 1)
} PrettyPrintBody:[{ tree.actions.Dispose() atomic.StoreUint64(&tree.disposed, 1) }]} {Id:22 FileId:120 StartLine:422 StartColumn:1 EndLine:426 EndColumn:2 Name:newTree Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:*tree}] Receiver:<nil> Body:{
	tree := &tree{}
	tree.init(bufferSize, ary)
	return tree
} PrettyPrintBody:[{ tree := &tree{} tree.init(bufferSize, ary) return tree }]} {Id:23 FileId:120 StartLine:429 StartColumn:1 EndLine:431 EndColumn:2 Name:New Params:[{Name:bufferSize Type:uint64}] Results:[{Name: Type:rtree.RTree}] Receiver:<nil> Body:{
	return newTree(bufferSize, ary)
} PrettyPrintBody:[{ return newTree(bufferSize, ary) }]} {Id:1 FileId:36 StartLine:28 StartColumn:1 EndLine:30 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]} {Id:2 FileId:36 StartLine:32 StartColumn:1 EndLine:39 EndColumn:2 Name:generateRandomKeys Params:[{Name:num Type:int}] Results:[{Name: Type:Keys}] Receiver:<nil> Body:{
	keys := make(Keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(uint64(rand.Uint32()%uint32(100))))
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(uint64(rand.Uint32()%uint32(100)))) } return keys }]} {Id:3 FileId:36 StartLine:41 StartColumn:1 EndLine:48 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:Keys}] Receiver:<nil> Body:{
	keys := make(Keys, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(uint64(i)))
	}

	return keys
} PrettyPrintBody:[{ keys := make(Keys, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(uint64(i))) } return keys }]} {Id:4 FileId:36 StartLine:50 StartColumn:1 EndLine:60 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := mockKey(5)

	tree := newTree(8, 1)
	result := tree.Insert(k1)
	assert.Equal(t, Keys{nil}, result)
	assert.Equal(t, uint64(1), tree.Len())
	if !assert.Equal(t, Keys{k1}, tree.Get(k1)) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ k1 := mockKey(5) tree := newTree(8, 1) result := tree.Insert(k1) assert.Equal(t, Keys{nil}, result) assert.Equal(t, uint64(1), tree.Len()) if !assert.Equal(t, Keys{k1}, tree.Get(k1)) { tree.print(getConsoleLogger()) } }]} {Id:5 FileId:36 StartLine:62 StartColumn:1 EndLine:72 EndColumn:2 Name:TestMultipleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1 := mockKey(10)
	k2 := mockKey(5)
	tree := newTree(8, 1)

	result := tree.Insert(k1, k2)
	assert.Equal(t, Keys{nil, nil}, result)
	assert.Equal(t, uint64(2), tree.Len())
	assert.Equal(t, Keys{k1, k2}, tree.Get(k1, k2))
	checkTree(t, tree)
} PrettyPrintBody:[{ k1 := mockKey(10) k2 := mockKey(5) tree := newTree(8, 1) result := tree.Insert(k1, k2) assert.Equal(t, Keys{nil, nil}, result) assert.Equal(t, uint64(2), tree.Len()) assert.Equal(t, Keys{k1, k2}, tree.Get(k1, k2)) checkTree(t, tree) }]} {Id:6 FileId:36 StartLine:74 StartColumn:1 EndLine:85 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(15), mockKey(10), mockKey(5)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(15), mockKey(10), mockKey(5) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:7 FileId:36 StartLine:87 StartColumn:1 EndLine:98 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(5), mockKey(10), mockKey(15)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(5), mockKey(10), mockKey(15) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:8 FileId:36 StartLine:100 StartColumn:1 EndLine:111 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3 := mockKey(10), mockKey(5), mockKey(15)
	tree := newTree(3, 1)

	result := tree.Insert(k1, k2, k3)
	assert.Equal(t, Keys{nil, nil, nil}, result)
	assert.Equal(t, uint64(3), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3 := mockKey(10), mockKey(5), mockKey(15) tree := newTree(3, 1) result := tree.Insert(k1, k2, k3) assert.Equal(t, Keys{nil, nil, nil}, result) assert.Equal(t, uint64(3), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:9 FileId:36 StartLine:113 StartColumn:1 EndLine:125 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(20), mockKey(15), mockKey(10), mockKey(5)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())

	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(20), mockKey(15), mockKey(10), mockKey(5) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:10 FileId:36 StartLine:127 StartColumn:1 EndLine:138 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(5), mockKey(10), mockKey(15), mockKey(20)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(5), mockKey(10), mockKey(15), mockKey(20) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:11 FileId:36 StartLine:140 StartColumn:1 EndLine:151 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	k1, k2, k3, k4 := mockKey(10), mockKey(15), mockKey(20), mockKey(5)
	tree := newTree(4, 1)

	result := tree.Insert(k1, k2, k3, k4)
	assert.Equal(t, Keys{nil, nil, nil, nil}, result)
	assert.Equal(t, uint64(4), tree.Len())
	if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ k1, k2, k3, k4 := mockKey(10), mockKey(15), mockKey(20), mockKey(5) tree := newTree(4, 1) result := tree.Insert(k1, k2, k3, k4) assert.Equal(t, Keys{nil, nil, nil, nil}, result) assert.Equal(t, uint64(4), tree.Len()) if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:12 FileId:36 StartLine:153 StartColumn:1 EndLine:163 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryMultiThreaded Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(16)
	tree := newTree(16, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateRandomKeys(16) tree := newTree(16, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:13 FileId:36 StartLine:165 StartColumn:1 EndLine:177 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(1600)
	tree := newTree(9, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	checkTree(t, tree)

	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateRandomKeys(1600) tree := newTree(9, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) checkTree(t, tree) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:14 FileId:36 StartLine:179 StartColumn:1 EndLine:193 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateKeys(30000)
	tree := newTree(17, 8)

	reversed := keys.reverse()

	result := tree.Insert(reversed...)

	assert.Len(t, result, len(keys))

	if !assert.Equal(t, keys, tree.Get(keys...)) {

	}
	checkTree(t, tree)
} PrettyPrintBody:[{ keys := generateKeys(30000) tree := newTree(17, 8) reversed := keys.reverse() result := tree.Insert(reversed...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { } checkTree(t, tree) }]} {Id:15 FileId:36 StartLine:195 StartColumn:1 EndLine:204 EndColumn:2 Name:TestMultipleInsertCausesCascadingSplitsEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(200)
	tree := newTree(12, 8)

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ keys := generateRandomKeys(200) tree := newTree(12, 8) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } }]} {Id:16 FileId:36 StartLine:206 StartColumn:1 EndLine:218 EndColumn:2 Name:TestOverwriteOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(15)
	tree := newTree(3, 8)
	duplicate := mockKey(uint64(keys[0].(mockKey)))

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	oldLength := tree.Len()

	result = tree.Insert(duplicate)
	assert.Equal(t, Keys{keys[0]}, result)
	assert.Equal(t, oldLength, tree.Len())
} PrettyPrintBody:[{ keys := generateRandomKeys(15) tree := newTree(3, 8) duplicate := mockKey(uint64(keys[0].(mockKey))) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) oldLength := tree.Len() result = tree.Insert(duplicate) assert.Equal(t, Keys{keys[0]}, result) assert.Equal(t, oldLength, tree.Len()) }]} {Id:17 FileId:36 StartLine:220 StartColumn:1 EndLine:232 EndColumn:2 Name:TestOverwriteEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := generateRandomKeys(15)
	tree := newTree(12, 8)
	duplicate := mockKey(uint64(keys[0].(mockKey)))

	result := tree.Insert(keys...)
	assert.Len(t, result, len(keys))
	oldLength := tree.Len()

	result = tree.Insert(duplicate)
	assert.Equal(t, Keys{keys[0]}, result)
	assert.Equal(t, oldLength, tree.Len())
} PrettyPrintBody:[{ keys := generateRandomKeys(15) tree := newTree(12, 8) duplicate := mockKey(uint64(keys[0].(mockKey))) result := tree.Insert(keys...) assert.Len(t, result, len(keys)) oldLength := tree.Len() result = tree.Insert(duplicate) assert.Equal(t, Keys{keys[0]}, result) assert.Equal(t, oldLength, tree.Len()) }]} {Id:18 FileId:36 StartLine:234 StartColumn:1 EndLine:244 EndColumn:2 Name:BenchmarkSimpleAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := generateRandomKeys(numItems)
	tree := newTree(16, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 1000 keys := generateRandomKeys(numItems) tree := newTree(16, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]} {Id:19 FileId:36 StartLine:246 StartColumn:1 EndLine:257 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := generateRandomKeys(numItems)
	tree := newTree(16, 4)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 1000 keys := generateRandomKeys(numItems) tree := newTree(16, 4) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]} {Id:20 FileId:36 StartLine:259 StartColumn:1 EndLine:269 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newTree(64, 1)
		tree.Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newTree(64, 1) tree.Insert(keys...) } }]} {Id:2 FileId:141 StartLine:47 StartColumn:1 EndLine:58 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*Immutable}] Receiver:0xc0011dba40 Body:{
	var root *node
	if immutable.root != nil {
		root = immutable.root.copy()
	}
	cp := &Immutable{
		root:	root,
		number:	immutable.number,
		dummy:	*newNode(nil),
	}
	return cp
} PrettyPrintBody:[{ var root *node if immutable.root != nil { root = immutable.root.copy() } cp := &Immutable{ root:	root, number:	immutable.number, dummy:	*newNode(nil), } return cp }]} {Id:3 FileId:141 StartLine:60 StartColumn:1 EndLine:63 EndColumn:2 Name:resetDummy Params:[] Results:[] Receiver:0xc001033060 Body:{
	immutable.dummy.children[0], immutable.dummy.children[1] = nil, nil
	immutable.dummy.balance = 0
} PrettyPrintBody:[{ immutable.dummy.children[0], immutable.dummy.children[1] = nil, nil immutable.dummy.balance = 0 }]} {Id:4 FileId:141 StartLine:65 StartColumn:1 EndLine:69 EndColumn:2 Name:init Params:[] Results:[] Receiver:0xc0010330a0 Body:{
	immutable.dummy = node{
		children: [2]*node{},
	}
} PrettyPrintBody:[{ immutable.dummy = node{ children: [2]*node{}, } }]} {Id:5 FileId:141 StartLine:71 StartColumn:1 EndLine:86 EndColumn:2 Name:get Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc001580d00 Body:{
	n := immutable.root
	var result int
	for n != nil {
		switch result = n.entry.Compare(entry); {
		case result == 0:
			return n.entry
		case result > 0:
			n = n.children[0]
		case result < 0:
			n = n.children[1]
		}
	}

	return nil
} PrettyPrintBody:[{ n := immutable.root var result int for n != nil { switch result = n.entry.Compare(entry); { case result == 0: return n.entry case result > 0: n = n.children[0] case result < 0: n = n.children[1] } } return nil }]} {Id:6 FileId:141 StartLine:90 StartColumn:1 EndLine:97 EndColumn:2 Name:Get Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:Entries}] Receiver:0xc00095a1c0 Body:{
	result := make(Entries, 0, len(entries))
	for _, e := range entries {
		result = append(result, immutable.get(e))
	}

	return result
} PrettyPrintBody:[{ result := make(Entries, 0, len(entries)) for _, e := range entries { result = append(result, immutable.get(e)) } return result }]} {Id:7 FileId:141 StartLine:100 StartColumn:1 EndLine:102 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001033740 Body:{
	return immutable.number
} PrettyPrintBody:[{ return immutable.number }]} {Id:8 FileId:141 StartLine:104 StartColumn:1 EndLine:185 EndColumn:2 Name:insert Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc000a8a0e0 Body:{

	if immutable.root == nil {
		immutable.root = newNode(entry)
		immutable.number++
		return nil
	}

	immutable.resetDummy()
	var (
		dummy		= immutable.dummy
		p, s, q		*node
		dir, normalized	int
		helper		= &dummy
	)

	helper.children[1] = immutable.root

	for s, p = helper.children[1], helper.children[1]; ; {
		dir = p.entry.Compare(entry)

		normalized = normalizeComparison(dir)
		if dir > 0 {
			if p.children[0] != nil {
				q = p.children[0].copy()
				p.children[0] = q
			} else {
				q = nil
			}
		} else if dir < 0 {
			if p.children[1] != nil {
				q = p.children[1].copy()
				p.children[1] = q
			} else {
				q = nil
			}
		} else {
			oldEntry := p.entry
			p.entry = entry
			return oldEntry
		}
		if q == nil {
			break
		}

		if q.balance != 0 {
			helper = p
			s = q
		}
		p = q
	}

	immutable.number++
	q = newNode(entry)
	p.children[normalized] = q

	immutable.root = dummy.children[1]
	for p = s; p != q; p = p.children[normalized] {
		normalized = normalizeComparison(p.entry.Compare(entry))
		if normalized == 0 {
			p.balance--
		} else {
			p.balance++
		}
	}

	q = s

	if math.Abs(float64(s.balance)) > 1 {
		normalized = normalizeComparison(s.entry.Compare(entry))
		s = insertBalance(s, normalized)
	}

	if q == dummy.children[1] {
		immutable.root = s
	} else {
		helper.children[intFromBool(helper.children[1] == q)] = s
	}
	return nil
} PrettyPrintBody:[{ if immutable.root == nil { immutable.root = newNode(entry) immutable.number++ return nil } immutable.resetDummy() var ( dummy		= immutable.dummy p, s, q		*node dir, normalized	int helper		= &dummy ) helper.children[1] = immutable.root for s, p = helper.children[1], helper.children[1]; ; { dir = p.entry.Compare(entry) normalized = normalizeComparison(dir) if dir > 0 { if p.children[0] != nil { q = p.children[0].copy() p.children[0] = q } else { q = nil } } else if dir < 0 { if p.children[1] != nil { q = p.children[1].copy() p.children[1] = q } else { q = nil } } else { oldEntry := p.entry p.entry = entry return oldEntry } if q == nil { break } if q.balance != 0 { helper = p s = q } p = q } immutable.number++ q = newNode(entry) p.children[normalized] = q immutable.root = dummy.children[1] for p = s; p != q; p = p.children[normalized] { normalized = normalizeComparison(p.entry.Compare(entry)) if normalized == 0 { p.balance-- } else { p.balance++ } } q = s if math.Abs(float64(s.balance)) > 1 { normalized = normalizeComparison(s.entry.Compare(entry)) s = insertBalance(s, normalized) } if q == dummy.children[1] { immutable.root = s } else { helper.children[intFromBool(helper.children[1] == q)] = s } return nil }]} {Id:9 FileId:141 StartLine:190 StartColumn:1 EndLine:202 EndColumn:2 Name:Insert Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*Immutable} {Name: Type:Entries}] Receiver:0xc00019e2c0 Body:{
	if len(entries) == 0 {
		return immutable, Entries{}
	}

	overwritten := make(Entries, 0, len(entries))
	cp := immutable.copy()
	for _, e := range entries {
		overwritten = append(overwritten, cp.insert(e))
	}

	return cp, overwritten
} PrettyPrintBody:[{ if len(entries) == 0 { return immutable, Entries{} } overwritten := make(Entries, 0, len(entries)) cp := immutable.copy() for _, e := range entries { overwritten = append(overwritten, cp.insert(e)) } return cp, overwritten }]} {Id:10 FileId:141 StartLine:204 StartColumn:1 EndLine:309 EndColumn:2 Name:delete Params:[{Name:entry Type:Entry}] Results:[{Name: Type:Entry}] Receiver:0xc00095ae60 Body:{

	if immutable.root == nil {
		return nil
	}

	var (
		cache				= make(nodes, 64)
		it, p, q			*node
		top, done, dir, normalized	int
		dirs				= make([]int, 64)
		oldEntry			Entry
	)

	it = immutable.root

	for {
		if it == nil {
			return nil
		}

		dir = it.entry.Compare(entry)
		if dir == 0 {
			break
		}
		normalized = normalizeComparison(dir)
		dirs[top] = normalized
		cache[top] = it
		top++
		it = it.children[normalized]
	}
	immutable.number--
	oldEntry = it.entry

	for i := 0; i < top; i++ {
		p = cache[i]
		if p.children[dirs[i]] != nil {
			q = p.children[dirs[i]].copy()
			p.children[dirs[i]] = q
			if i != top-1 {
				cache[i+1] = q
			}
		}
	}
	it = it.copy()

	oldTop := top
	if it.children[0] == nil || it.children[1] == nil {
		dir = intFromBool(it.children[0] == nil)
		if top != 0 {
			cache[top-1].children[dirs[top-1]] = it.children[dir]
		} else {
			immutable.root = it.children[dir]
		}
	} else {
		heir := it.children[1]
		dirs[top] = 1
		cache[top] = it
		top++

		for heir.children[0] != nil {
			dirs[top] = 0
			cache[top] = heir
			top++
			heir = heir.children[0]
		}

		it.entry = heir.entry
		if oldTop != 0 {
			cache[oldTop-1].children[dirs[oldTop-1]] = it
		} else {
			immutable.root = it
		}
		cache[top-1].children[intFromBool(cache[top-1] == it)] = heir.children[1]
	}

	for top-1 >= 0 && done == 0 {
		top--

		if dirs[top] != 0 {
			cache[top].balance--
		} else {
			cache[top].balance++
		}

		if math.Abs(float64(cache[top].balance)) == 1 {
			break
		} else if math.Abs(float64(cache[top].balance)) > 1 {

			cache[top] = removeBalance(cache[top], dirs[top], &done)

			if top != 0 {
				cache[top-1].children[dirs[top-1]] = cache[top]
			} else {
				immutable.root = cache[0]
			}
		}

	}

	return oldEntry
} PrettyPrintBody:[{ if immutable.root == nil { return nil } var ( cache				= make(nodes, 64) it, p, q			*node top, done, dir, normalized	int dirs				= make([]int, 64) oldEntry			Entry ) it = immutable.root for { if it == nil { return nil } dir = it.entry.Compare(entry) if dir == 0 { break } normalized = normalizeComparison(dir) dirs[top] = normalized cache[top] = it top++ it = it.children[normalized] } immutable.number-- oldEntry = it.entry for i := 0; i < top; i++ { p = cache[i] if p.children[dirs[i]] != nil { q = p.children[dirs[i]].copy() p.children[dirs[i]] = q if i != top-1 { cache[i+1] = q } } } it = it.copy() oldTop := top if it.children[0] == nil || it.children[1] == nil { dir = intFromBool(it.children[0] == nil) if top != 0 { cache[top-1].children[dirs[top-1]] = it.children[dir] } else { immutable.root = it.children[dir] } } else { heir := it.children[1] dirs[top] = 1 cache[top] = it top++ for heir.children[0] != nil { dirs[top] = 0 cache[top] = heir top++ heir = heir.children[0] } it.entry = heir.entry if oldTop != 0 { cache[oldTop-1].children[dirs[oldTop-1]] = it } else { immutable.root = it } cache[top-1].children[intFromBool(cache[top-1] == it)] = heir.children[1] } for top-1 >= 0 && done == 0 { top-- if dirs[top] != 0 { cache[top].balance-- } else { cache[top].balance++ } if math.Abs(float64(cache[top].balance)) == 1 { break } else if math.Abs(float64(cache[top].balance)) > 1 { cache[top] = removeBalance(cache[top], dirs[top], &done) if top != 0 { cache[top-1].children[dirs[top-1]] = cache[top] } else { immutable.root = cache[0] } } } return oldEntry }]} {Id:11 FileId:141 StartLine:314 StartColumn:1 EndLine:326 EndColumn:2 Name:Delete Params:[{Name:entries Type:...Entry}] Results:[{Name: Type:*Immutable} {Name: Type:Entries}] Receiver:0xc0000ed900 Body:{
	if len(entries) == 0 {
		return immutable, Entries{}
	}

	deleted := make(Entries, 0, len(entries))
	cp := immutable.copy()
	for _, e := range entries {
		deleted = append(deleted, cp.delete(e))
	}

	return cp, deleted
} PrettyPrintBody:[{ if len(entries) == 0 { return immutable, Entries{} } deleted := make(Entries, 0, len(entries)) cp := immutable.copy() for _, e := range entries { deleted = append(deleted, cp.delete(e)) } return cp, deleted }]} {Id:12 FileId:141 StartLine:328 StartColumn:1 EndLine:346 EndColumn:2 Name:insertBalance Params:[{Name:root Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := root.children[dir]
	var bal int8
	if dir == 0 {
		bal = -1
	} else {
		bal = 1
	}

	if n.balance == bal {
		root.balance, n.balance = 0, 0
		root = rotate(root, takeOpposite(dir))
	} else {
		adjustBalance(root, dir, int(bal))
		root = doubleRotate(root, takeOpposite(dir))
	}

	return root
} PrettyPrintBody:[{ n := root.children[dir] var bal int8 if dir == 0 { bal = -1 } else { bal = 1 } if n.balance == bal { root.balance, n.balance = 0, 0 root = rotate(root, takeOpposite(dir)) } else { adjustBalance(root, dir, int(bal)) root = doubleRotate(root, takeOpposite(dir)) } return root }]} {Id:13 FileId:141 StartLine:348 StartColumn:1 EndLine:372 EndColumn:2 Name:removeBalance Params:[{Name:root Type:*node} {Name:dir Type:int} {Name:done Type:*int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	n := root.children[takeOpposite(dir)].copy()
	root.children[takeOpposite(dir)] = n
	var bal int8
	if dir == 0 {
		bal = -1
	} else {
		bal = 1
	}

	if n.balance == -bal {
		root.balance, n.balance = 0, 0
		root = rotate(root, dir)
	} else if n.balance == bal {
		adjustBalance(root, takeOpposite(dir), int(-bal))
		root = doubleRotate(root, dir)
	} else {
		root.balance = -bal
		n.balance = bal
		root = rotate(root, dir)
		*done = 1
	}

	return root
} PrettyPrintBody:[{ n := root.children[takeOpposite(dir)].copy() root.children[takeOpposite(dir)] = n var bal int8 if dir == 0 { bal = -1 } else { bal = 1 } if n.balance == -bal { root.balance, n.balance = 0, 0 root = rotate(root, dir) } else if n.balance == bal { adjustBalance(root, takeOpposite(dir), int(-bal)) root = doubleRotate(root, dir) } else { root.balance = -bal n.balance = bal root = rotate(root, dir) *done = 1 } return root }]} {Id:14 FileId:141 StartLine:374 StartColumn:1 EndLine:380 EndColumn:2 Name:intFromBool Params:[{Name:value Type:bool}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if value {
		return 1
	}

	return 0
} PrettyPrintBody:[{ if value { return 1 } return 0 }]} {Id:15 FileId:141 StartLine:382 StartColumn:1 EndLine:384 EndColumn:2 Name:takeOpposite Params:[{Name:value Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	return 1 - value
} PrettyPrintBody:[{ return 1 - value }]} {Id:16 FileId:141 StartLine:386 StartColumn:1 EndLine:400 EndColumn:2 Name:adjustBalance Params:[{Name:root Type:*node} {Name:dir Type:int}] Results:[] Receiver:<nil> Body:{
	n := root.children[dir]
	nn := n.children[takeOpposite(dir)]

	if nn.balance == 0 {
		root.balance, n.balance = 0, 0
	} else if int(nn.balance) == bal {
		root.balance = int8(-bal)
		n.balance = 0
	} else {
		root.balance = 0
		n.balance = int8(bal)
	}
	nn.balance = 0
} PrettyPrintBody:[{ n := root.children[dir] nn := n.children[takeOpposite(dir)] if nn.balance == 0 { root.balance, n.balance = 0, 0 } else if int(nn.balance) == bal { root.balance = int8(-bal) n.balance = 0 } else { root.balance = 0 n.balance = int8(bal) } nn.balance = 0 }]} {Id:17 FileId:141 StartLine:402 StartColumn:1 EndLine:410 EndColumn:2 Name:rotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	child := parent.children[otherDir]
	parent.children[otherDir] = child.children[dir]
	child.children[dir] = parent

	return child
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) child := parent.children[otherDir] parent.children[otherDir] = child.children[dir] child.children[dir] = parent return child }]} {Id:18 FileId:141 StartLine:412 StartColumn:1 EndLine:417 EndColumn:2 Name:doubleRotate Params:[{Name:parent Type:*node} {Name:dir Type:int}] Results:[{Name: Type:*node}] Receiver:<nil> Body:{
	otherDir := takeOpposite(dir)

	parent.children[otherDir] = rotate(parent.children[otherDir], otherDir)
	return rotate(parent, dir)
} PrettyPrintBody:[{ otherDir := takeOpposite(dir) parent.children[otherDir] = rotate(parent.children[otherDir], otherDir) return rotate(parent, dir) }]} {Id:19 FileId:141 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:normalizeComparison Params:[{Name:i Type:int}] Results:[{Name: Type:int}] Receiver:<nil> Body:{
	if i < 0 {
		return 1
	}

	if i > 0 {
		return 0
	}

	return -1
} PrettyPrintBody:[{ if i < 0 { return 1 } if i > 0 { return 0 } return -1 }]} {Id:20 FileId:141 StartLine:435 StartColumn:1 EndLine:439 EndColumn:2 Name:NewImmutable Params:[] Results:[{Name: Type:*Immutable}] Receiver:<nil> Body:{
	immutable := &Immutable{}
	immutable.init()
	return immutable
} PrettyPrintBody:[{ immutable := &Immutable{} immutable.init() return immutable }]} {Id:3 FileId:132 StartLine:86 StartColumn:1 EndLine:91 EndColumn:2 Name:Int63 Params:[] Results:[{Name:n Type:int64}] Receiver:0xc000e7fd60 Body:{
	ls.mu.Lock()
	n = ls.src.Int63()
	ls.mu.Unlock()
	return
} PrettyPrintBody:[{ ls.mu.Lock() n = ls.src.Int63() ls.mu.Unlock() return }]} {Id:4 FileId:132 StartLine:94 StartColumn:1 EndLine:98 EndColumn:2 Name:Seed Params:[{Name:seed Type:int64}] Results:[] Receiver:0xc00095a3a0 Body:{
	ls.mu.Lock()
	ls.src.Seed(seed)
	ls.mu.Unlock()
} PrettyPrintBody:[{ ls.mu.Lock() ls.src.Seed(seed) ls.mu.Unlock() }]} {Id:6 FileId:132 StartLine:106 StartColumn:1 EndLine:116 EndColumn:2 Name:generateLevel Params:[{Name:maxLevel Type:uint8}] Results:[{Name: Type:uint8}] Receiver:<nil> Body:{
	var level uint8
	for level = uint8(1); level < maxLevel-1; level++ {
		if generator.Float64() >= p {

			return level
		}
	}

	return level
} PrettyPrintBody:[{ var level uint8 for level = uint8(1); level < maxLevel-1; level++ { if generator.Float64() >= p { return level } } return level }]} {Id:7 FileId:132 StartLine:118 StartColumn:1 EndLine:158 EndColumn:2 Name:insertNode Params:[{Name:sl Type:*SkipList} {Name:n Type:*node} {Name:cmp Type:common.Comparator} {Name:pos Type:uint64} {Name:cache Type:nodes} {Name:posCache Type:widths} {Name:allowDuplicate Type:bool}] Results:[{Name: Type:common.Comparator}] Receiver:<nil> Body:{
	if !allowDuplicate && n != nil && n.Compare(cmp) == 0 {
		oldEntry := n.entry
		n.entry = cmp
		return oldEntry
	}
	atomic.AddUint64(&sl.num, 1)

	nodeLevel := generateLevel(sl.maxLevel)
	if nodeLevel > sl.level {
		for i := sl.level; i < nodeLevel; i++ {
			cache[i] = sl.head
		}
		sl.level = nodeLevel
	}

	nn := newNode(cmp, nodeLevel)
	for i := uint8(0); i < nodeLevel; i++ {
		nn.forward[i] = cache[i].forward[i]
		cache[i].forward[i] = nn
		formerWidth := cache[i].widths[i]
		if formerWidth == 0 {
			nn.widths[i] = 0
		} else {
			nn.widths[i] = posCache[i] + formerWidth + 1 - pos
		}

		if cache[i].forward[i] != nil {
			cache[i].widths[i] = pos - posCache[i]
		}

	}

	for i := nodeLevel; i < sl.level; i++ {
		if cache[i].forward[i] == nil {
			continue
		}
		cache[i].widths[i]++
	}
	return nil
} PrettyPrintBody:[{ if !allowDuplicate && n != nil && n.Compare(cmp) == 0 { oldEntry := n.entry n.entry = cmp return oldEntry } atomic.AddUint64(&sl.num, 1) nodeLevel := generateLevel(sl.maxLevel) if nodeLevel > sl.level { for i := sl.level; i < nodeLevel; i++ { cache[i] = sl.head } sl.level = nodeLevel } nn := newNode(cmp, nodeLevel) for i := uint8(0); i < nodeLevel; i++ { nn.forward[i] = cache[i].forward[i] cache[i].forward[i] = nn formerWidth := cache[i].widths[i] if formerWidth == 0 { nn.widths[i] = 0 } else { nn.widths[i] = posCache[i] + formerWidth + 1 - pos } if cache[i].forward[i] != nil { cache[i].widths[i] = pos - posCache[i] } } for i := nodeLevel; i < sl.level; i++ { if cache[i].forward[i] == nil { continue } cache[i].widths[i]++ } return nil }]} {Id:8 FileId:132 StartLine:160 StartColumn:1 EndLine:185 EndColumn:2 Name:splitAt Params:[{Name:sl Type:*SkipList} {Name:index Type:uint64}] Results:[{Name: Type:*SkipList} {Name: Type:*SkipList}] Receiver:<nil> Body:{
	right := &SkipList{}
	right.maxLevel = sl.maxLevel
	right.level = sl.level
	right.cache = make(nodes, sl.maxLevel)
	right.posCache = make(widths, sl.maxLevel)
	right.head = newNode(nil, sl.maxLevel)
	sl.searchByPosition(index, sl.cache, sl.posCache)

	for i := uint8(0); i <= sl.level; i++ {
		right.head.forward[i] = sl.cache[i].forward[i]
		if sl.cache[i].forward[i] != nil {
			right.head.widths[i] = sl.cache[i].widths[i] - (index - sl.posCache[i])
		}
		sl.cache[i].widths[i] = 0
		sl.cache[i].forward[i] = nil
	}

	right.num = sl.Len() - index
	atomic.AddUint64(&sl.num, -right.num)

	sl.resetMaxLevel()
	right.resetMaxLevel()

	return sl, right
} PrettyPrintBody:[{ right := &SkipList{} right.maxLevel = sl.maxLevel right.level = sl.level right.cache = make(nodes, sl.maxLevel) right.posCache = make(widths, sl.maxLevel) right.head = newNode(nil, sl.maxLevel) sl.searchByPosition(index, sl.cache, sl.posCache) for i := uint8(0); i <= sl.level; i++ { right.head.forward[i] = sl.cache[i].forward[i] if sl.cache[i].forward[i] != nil { right.head.widths[i] = sl.cache[i].widths[i] - (index - sl.posCache[i]) } sl.cache[i].widths[i] = 0 sl.cache[i].forward[i] = nil } right.num = sl.Len() - index atomic.AddUint64(&sl.num, -right.num) sl.resetMaxLevel() right.resetMaxLevel() return sl, right }]} {Id:10 FileId:132 StartLine:204 StartColumn:1 EndLine:218 EndColumn:2 Name:init Params:[{Name:ifc Type:interface{}}] Results:[] Receiver:0xc000993980 Body:{
	switch ifc.(type) {
	case uint8:
		sl.maxLevel = 8
	case uint16:
		sl.maxLevel = 16
	case uint32:
		sl.maxLevel = 32
	case uint64, uint:
		sl.maxLevel = 64
	}
	sl.cache = make(nodes, sl.maxLevel)
	sl.posCache = make(widths, sl.maxLevel)
	sl.head = newNode(nil, sl.maxLevel)
} PrettyPrintBody:[{ switch ifc.(type) { case uint8: sl.maxLevel = 8 case uint16: sl.maxLevel = 16 case uint32: sl.maxLevel = 32 case uint64, uint: sl.maxLevel = 64 } sl.cache = make(nodes, sl.maxLevel) sl.posCache = make(widths, sl.maxLevel) sl.head = newNode(nil, sl.maxLevel) }]} {Id:11 FileId:132 StartLine:220 StartColumn:1 EndLine:244 EndColumn:2 Name:search Params:[{Name:cmp Type:common.Comparator} {Name:update Type:nodes} {Name:widths Type:widths}] Results:[{Name: Type:*node} {Name: Type:uint64}] Receiver:0xc001173ec0 Body:{
	if sl.Len() == 0 {
		return nil, 1
	}

	var pos uint64 = 0
	var offset uint8
	var alreadyChecked *node
	n := sl.head
	for i := uint8(0); i <= sl.level; i++ {
		offset = sl.level - i
		for n.forward[offset] != nil && n.forward[offset] != alreadyChecked && n.forward[offset].Compare(cmp) < 0 {
			pos += n.widths[offset]
			n = n.forward[offset]
		}

		alreadyChecked = n
		if update != nil {
			update[offset] = n
			widths[offset] = pos
		}
	}

	return n.forward[0], pos + 1
} PrettyPrintBody:[{ if sl.Len() == 0 { return nil, 1 } var pos uint64 = 0 var offset uint8 var alreadyChecked *node n := sl.head for i := uint8(0); i <= sl.level; i++ { offset = sl.level - i for n.forward[offset] != nil && n.forward[offset] != alreadyChecked && n.forward[offset].Compare(cmp) < 0 { pos += n.widths[offset] n = n.forward[offset] } alreadyChecked = n if update != nil { update[offset] = n widths[offset] = pos } } return n.forward[0], pos + 1 }]} {Id:12 FileId:132 StartLine:246 StartColumn:1 EndLine:254 EndColumn:2 Name:resetMaxLevel Params:[] Results:[] Receiver:0xc000a8a8e0 Body:{
	if sl.level < 1 {
		sl.level = 1
		return
	}
	for sl.head.forward[sl.level-1] == nil && sl.level > 1 {
		sl.level--
	}
} PrettyPrintBody:[{ if sl.level < 1 { sl.level = 1 return } for sl.head.forward[sl.level-1] == nil && sl.level > 1 { sl.level-- } }]} {Id:13 FileId:132 StartLine:256 StartColumn:1 EndLine:282 EndColumn:2 Name:searchByPosition Params:[{Name:position Type:uint64} {Name:update Type:nodes} {Name:widths Type:widths}] Results:[{Name: Type:*node} {Name: Type:uint64}] Receiver:0xc00019e340 Body:{
	if sl.Len() == 0 {
		return nil, 1
	}

	if position > sl.Len() {
		return nil, 1
	}

	var pos uint64 = 0
	var offset uint8
	n := sl.head
	for i := uint8(0); i <= sl.level; i++ {
		offset = sl.level - i
		for n.forward[offset] != nil && pos+n.widths[offset] <= position {
			pos += n.widths[offset]
			n = n.forward[offset]
		}

		if update != nil {
			update[offset] = n
			widths[offset] = pos
		}
	}

	return n, pos + 1
} PrettyPrintBody:[{ if sl.Len() == 0 { return nil, 1 } if position > sl.Len() { return nil, 1 } var pos uint64 = 0 var offset uint8 n := sl.head for i := uint8(0); i <= sl.level; i++ { offset = sl.level - i for n.forward[offset] != nil && pos+n.widths[offset] <= position { pos += n.widths[offset] n = n.forward[offset] } if update != nil { update[offset] = n widths[offset] = pos } } return n, pos + 1 }]} {Id:14 FileId:132 StartLine:287 StartColumn:1 EndLine:301 EndColumn:2 Name:Get Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc000993ec0 Body:{
	result := make(common.Comparators, 0, len(comparators))

	var n *node
	for _, cmp := range comparators {
		n, _ = sl.search(cmp, nil, nil)
		if n != nil && n.Compare(cmp) == 0 {
			result = append(result, n.entry)
		} else {
			result = append(result, nil)
		}
	}

	return result
} PrettyPrintBody:[{ result := make(common.Comparators, 0, len(comparators)) var n *node for _, cmp := range comparators { n, _ = sl.search(cmp, nil, nil) if n != nil && n.Compare(cmp) == 0 { result = append(result, n.entry) } else { result = append(result, nil) } } return result }]} {Id:15 FileId:132 StartLine:306 StartColumn:1 EndLine:313 EndColumn:2 Name:GetWithPosition Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator} {Name: Type:uint64}] Receiver:0xc0003e5780 Body:{
	n, pos := sl.search(cmp, nil, nil)
	if n == nil {
		return nil, 0
	}

	return n.entry, pos - 1
} PrettyPrintBody:[{ n, pos := sl.search(cmp, nil, nil) if n == nil { return nil, 0 } return n.entry, pos - 1 }]} {Id:16 FileId:132 StartLine:316 StartColumn:1 EndLine:323 EndColumn:2 Name:ByPosition Params:[{Name:position Type:uint64}] Results:[{Name: Type:common.Comparator}] Receiver:0xc0001e6840 Body:{
	n, _ := sl.searchByPosition(position+1, nil, nil)
	if n == nil {
		return nil
	}

	return n.entry
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(position+1, nil, nil) if n == nil { return nil } return n.entry }]} {Id:17 FileId:132 StartLine:325 StartColumn:1 EndLine:328 EndColumn:2 Name:insert Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc000a8bc20 Body:{
	n, pos := sl.search(cmp, sl.cache, sl.posCache)
	return insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, false)
} PrettyPrintBody:[{ n, pos := sl.search(cmp, sl.cache, sl.posCache) return insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, false) }]} {Id:18 FileId:132 StartLine:333 StartColumn:1 EndLine:340 EndColumn:2 Name:Insert Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0009928c0 Body:{
	overwritten := make(common.Comparators, 0, len(comparators))
	for _, cmp := range comparators {
		overwritten = append(overwritten, sl.insert(cmp))
	}

	return overwritten
} PrettyPrintBody:[{ overwritten := make(common.Comparators, 0, len(comparators)) for _, cmp := range comparators { overwritten = append(overwritten, sl.insert(cmp)) } return overwritten }]} {Id:19 FileId:132 StartLine:342 StartColumn:1 EndLine:348 EndColumn:2 Name:insertAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc0001e7060 Body:{
	if position > sl.Len() {
		position = sl.Len()
	}
	n, pos := sl.searchByPosition(position, sl.cache, sl.posCache)
	insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, true)
} PrettyPrintBody:[{ if position > sl.Len() { position = sl.Len() } n, pos := sl.searchByPosition(position, sl.cache, sl.posCache) insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, true) }]} {Id:20 FileId:132 StartLine:354 StartColumn:1 EndLine:356 EndColumn:2 Name:InsertAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc0001e7400 Body:{
	sl.insertAtPosition(position, cmp)
} PrettyPrintBody:[{ sl.insertAtPosition(position, cmp) }]} {Id:21 FileId:132 StartLine:358 StartColumn:1 EndLine:365 EndColumn:2 Name:replaceAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc00095b8e0 Body:{
	n, _ := sl.searchByPosition(position+1, nil, nil)
	if n == nil {
		return
	}

	n.entry = cmp
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(position+1, nil, nil) if n == nil { return } n.entry = cmp }]} {Id:22 FileId:132 StartLine:370 StartColumn:1 EndLine:372 EndColumn:2 Name:ReplaceAtPosition Params:[{Name:position Type:uint64} {Name:cmp Type:common.Comparator}] Results:[] Receiver:0xc000258880 Body:{
	sl.replaceAtPosition(position, cmp)
} PrettyPrintBody:[{ sl.replaceAtPosition(position, cmp) }]} {Id:23 FileId:132 StartLine:374 StartColumn:1 EndLine:401 EndColumn:2 Name:delete Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:common.Comparator}] Receiver:0xc000258c00 Body:{
	n, _ := sl.search(cmp, sl.cache, sl.posCache)

	if n == nil || n.Compare(cmp) != 0 {
		return nil
	}

	atomic.AddUint64(&sl.num, ^uint64(0))

	for i := uint8(0); i <= sl.level; i++ {
		if sl.cache[i].forward[i] != n {
			if sl.cache[i].forward[i] != nil {
				sl.cache[i].widths[i]--
			}
			continue
		}

		sl.cache[i].widths[i] += n.widths[i] - 1
		sl.cache[i].forward[i] = n.forward[i]
	}

	for sl.level > 1 && sl.head.forward[sl.level-1] == nil {
		sl.head.widths[sl.level] = 0
		sl.level--
	}

	return n.entry
} PrettyPrintBody:[{ n, _ := sl.search(cmp, sl.cache, sl.posCache) if n == nil || n.Compare(cmp) != 0 { return nil } atomic.AddUint64(&sl.num, ^uint64(0)) for i := uint8(0); i <= sl.level; i++ { if sl.cache[i].forward[i] != n { if sl.cache[i].forward[i] != nil { sl.cache[i].widths[i]-- } continue } sl.cache[i].widths[i] += n.widths[i] - 1 sl.cache[i].forward[i] = n.forward[i] } for sl.level > 1 && sl.head.forward[sl.level-1] == nil { sl.head.widths[sl.level] = 0 sl.level-- } return n.entry }]} {Id:24 FileId:132 StartLine:406 StartColumn:1 EndLine:414 EndColumn:2 Name:Delete Params:[{Name:comparators Type:...common.Comparator}] Results:[{Name: Type:common.Comparators}] Receiver:0xc0000edb80 Body:{
	deleted := make(common.Comparators, 0, len(comparators))

	for _, cmp := range comparators {
		deleted = append(deleted, sl.delete(cmp))
	}

	return deleted
} PrettyPrintBody:[{ deleted := make(common.Comparators, 0, len(comparators)) for _, cmp := range comparators { deleted = append(deleted, sl.delete(cmp)) } return deleted }]} {Id:25 FileId:132 StartLine:417 StartColumn:1 EndLine:419 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:uint64}] Receiver:0xc001603b80 Body:{
	return atomic.LoadUint64(&sl.num)
} PrettyPrintBody:[{ return atomic.LoadUint64(&sl.num) }]} {Id:26 FileId:132 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:iterAtPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:*iterator}] Receiver:0xc0000edc20 Body:{
	n, _ := sl.searchByPosition(pos, nil, nil)
	if n == nil || n.entry == nil {
		return nilIterator()
	}

	return &iterator{
		first:	true,
		n:	n,
	}
} PrettyPrintBody:[{ n, _ := sl.searchByPosition(pos, nil, nil) if n == nil || n.entry == nil { return nilIterator() } return &iterator{ first:	true, n:	n, } }]} {Id:27 FileId:132 StartLine:435 StartColumn:1 EndLine:437 EndColumn:2 Name:IterAtPosition Params:[{Name:pos Type:uint64}] Results:[{Name: Type:Iterator}] Receiver:0xc0000edd40 Body:{
	return sl.iterAtPosition(pos + 1)
} PrettyPrintBody:[{ return sl.iterAtPosition(pos + 1) }]} {Id:28 FileId:132 StartLine:439 StartColumn:1 EndLine:449 EndColumn:2 Name:iter Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:*iterator}] Receiver:0xc00019ede0 Body:{
	n, _ := sl.search(cmp, nil, nil)
	if n == nil {
		return nilIterator()
	}

	return &iterator{
		first:	true,
		n:	n,
	}
} PrettyPrintBody:[{ n, _ := sl.search(cmp, nil, nil) if n == nil { return nilIterator() } return &iterator{ first:	true, n:	n, } }]} {Id:29 FileId:132 StartLine:454 StartColumn:1 EndLine:456 EndColumn:2 Name:Iter Params:[{Name:cmp Type:common.Comparator}] Results:[{Name: Type:Iterator}] Receiver:0xc0000ede60 Body:{
	return sl.iter(cmp)
} PrettyPrintBody:[{ return sl.iter(cmp) }]} {Id:30 FileId:132 StartLine:464 StartColumn:1 EndLine:470 EndColumn:2 Name:SplitAt Params:[{Name:index Type:uint64}] Results:[{Name: Type:*SkipList} {Name: Type:*SkipList}] Receiver:0xc0000edea0 Body:{
	index++
	if index >= sl.Len() {
		return sl, nil
	}
	return splitAt(sl, index)
} PrettyPrintBody:[{ index++ if index >= sl.Len() { return sl, nil } return splitAt(sl, index) }]} {Id:31 FileId:132 StartLine:477 StartColumn:1 EndLine:481 EndColumn:2 Name:New Params:[{Name:ifc Type:interface{}}] Results:[{Name: Type:*SkipList}] Receiver:<nil> Body:{
	sl := &SkipList{}
	sl.init(ifc)
	return sl
} PrettyPrintBody:[{ sl := &SkipList{} sl.init(ifc) return sl }]} {Id:1 FileId:44 StartLine:27 StartColumn:1 EndLine:36 EndColumn:2 Name:newID Params:[] Results:[{Name: Type:[]byte}] Receiver:<nil> Body:{
	id := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, id)
	if err != nil {

		panic("reading random: " + err.Error())
	}
	return id
} PrettyPrintBody:[{ id := make([]byte, 16) _, err := io.ReadFull(rand.Reader, id) if err != nil { panic("reading random: " + err.Error()) } return id }]} {Id:4 FileId:44 StartLine:51 StartColumn:1 EndLine:53 EndColumn:2 Name:ID Params:[] Results:[{Name: Type:[]byte}] Receiver:0xc001308ec0 Body:{
	return k.UUID[:16]
} PrettyPrintBody:[{ return k.UUID[:16] }]} {Id:5 FileId:44 StartLine:55 StartColumn:1 EndLine:60 EndColumn:2 Name:ToItem Params:[] Results:[{Name: Type:*Item}] Receiver:0xc000e5b8a0 Body:{
	return &Item{
		Value:		k.Value,
		Payload:	k.Payload,
	}
} PrettyPrintBody:[{ return &Item{ Value:		k.Value, Payload:	k.Payload, } }]} {Id:7 FileId:44 StartLine:64 StartColumn:1 EndLine:71 EndColumn:2 Name:toItems Params:[] Results:[{Name: Type:items}] Receiver:0xc000c56ca0 Body:{
	items := make(items, 0, len(k))
	for _, key := range k {
		items = append(items, key.ToItem())
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, len(k)) for _, key := range k { items = append(items, key.ToItem()) } return items }]} {Id:8 FileId:44 StartLine:73 StartColumn:1 EndLine:75 EndColumn:2 Name:sort Params:[{Name:comparator Type:Comparator}] Results:[{Name: Type:Keys}] Receiver:0xc0013090e0 Body:{
	return (&keySortWrapper{comparator, k}).sort()
} PrettyPrintBody:[{ return (&keySortWrapper{comparator, k}).sort() }]} {Id:10 FileId:44 StartLine:82 StartColumn:1 EndLine:84 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0014082e0 Body:{
	return len(sw.keys)
} PrettyPrintBody:[{ return len(sw.keys) }]} {Id:11 FileId:44 StartLine:86 StartColumn:1 EndLine:88 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001408660 Body:{
	sw.keys[i], sw.keys[j] = sw.keys[j], sw.keys[i]
} PrettyPrintBody:[{ sw.keys[i], sw.keys[j] = sw.keys[j], sw.keys[i] }]} {Id:12 FileId:44 StartLine:90 StartColumn:1 EndLine:92 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc00123d480 Body:{
	return sw.comparator(sw.keys[i].Value, sw.keys[j].Value) < 0
} PrettyPrintBody:[{ return sw.comparator(sw.keys[i].Value, sw.keys[j].Value) < 0 }]} {Id:13 FileId:44 StartLine:94 StartColumn:1 EndLine:97 EndColumn:2 Name:sort Params:[] Results:[{Name: Type:Keys}] Receiver:0xc000f53f60 Body:{
	sort.Sort(sw)
	return sw.keys
} PrettyPrintBody:[{ sort.Sort(sw) return sw.keys }]} {Id:14 FileId:44 StartLine:99 StartColumn:1 EndLine:105 EndColumn:2 Name:splitKeys Params:[{Name:keys Type:Keys} {Name:numParts Type:int}] Results:[{Name: Type:[]Keys}] Receiver:<nil> Body:{
	parts := make([]Keys, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = keys[i*int64(len(keys))/int64(numParts) : (i+1)*int64(len(keys))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([]Keys, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = keys[i*int64(len(keys))/int64(numParts) : (i+1)*int64(len(keys))/int64(numParts)] } return parts }]} {Id:16 FileId:44 StartLine:127 StartColumn:1 EndLine:139 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:*Node}] Receiver:0xc001241e40 Body:{
	cpValues := make([]interface{}, len(n.ChildValues))
	copy(cpValues, n.ChildValues)
	cpKeys := make(Keys, len(n.ChildKeys))
	copy(cpKeys, n.ChildKeys)

	return &Node{
		ID:		newID(),
		IsLeaf:		n.IsLeaf,
		ChildValues:	cpValues,
		ChildKeys:	cpKeys,
	}
} PrettyPrintBody:[{ cpValues := make([]interface{}, len(n.ChildValues)) copy(cpValues, n.ChildValues) cpKeys := make(Keys, len(n.ChildKeys)) copy(cpKeys, n.ChildKeys) return &Node{ ID:		newID(), IsLeaf:		n.IsLeaf, ChildValues:	cpValues, ChildKeys:	cpKeys, } }]} {Id:17 FileId:44 StartLine:145 StartColumn:1 EndLine:161 EndColumn:2 Name:searchKey Params:[{Name:comparator Type:Comparator} {Name:value Type:interface{}}] Results:[{Name: Type:*Key} {Name: Type:int}] Receiver:0xc00095a6e0 Body:{
	i := n.search(comparator, value)

	if n.IsLeaf && i == len(n.ChildValues) {
		return nil, i
	}

	if n.IsLeaf {
		return n.ChildKeys[i], i
	}

	if i == len(n.ChildValues) {
		return n.ChildKeys[len(n.ChildKeys)-1], i
	}

	return n.ChildKeys[i], i
} PrettyPrintBody:[{ i := n.search(comparator, value) if n.IsLeaf && i == len(n.ChildValues) { return nil, i } if n.IsLeaf { return n.ChildKeys[i], i } if i == len(n.ChildValues) { return n.ChildKeys[len(n.ChildKeys)-1], i } return n.ChildKeys[i], i }]} {Id:18 FileId:44 StartLine:165 StartColumn:1 EndLine:191 EndColumn:2 Name:insert Params:[{Name:comparator Type:Comparator} {Name:key Type:*Key}] Results:[{Name: Type:*Key}] Receiver:0xc0003e4fc0 Body:{
	var overwrittenKey *Key
	i := n.search(comparator, key.Value)
	if i == len(n.ChildValues) {
		n.ChildValues = append(n.ChildValues, key.Value)
	} else {
		if n.ChildValues[i] == key.Value {
			overwrittenKey = n.ChildKeys[i]
			n.ChildKeys[i] = key
			return overwrittenKey
		} else {
			n.ChildValues = append(n.ChildValues, 0)
			copy(n.ChildValues[i+1:], n.ChildValues[i:])
			n.ChildValues[i] = key.Value
		}
	}

	if n.IsLeaf && i == len(n.ChildKeys) {
		n.ChildKeys = append(n.ChildKeys, key)
	} else {
		n.ChildKeys = append(n.ChildKeys, nil)
		copy(n.ChildKeys[i+1:], n.ChildKeys[i:])
		n.ChildKeys[i] = key
	}

	return overwrittenKey
} PrettyPrintBody:[{ var overwrittenKey *Key i := n.search(comparator, key.Value) if i == len(n.ChildValues) { n.ChildValues = append(n.ChildValues, key.Value) } else { if n.ChildValues[i] == key.Value { overwrittenKey = n.ChildKeys[i] n.ChildKeys[i] = key return overwrittenKey } else { n.ChildValues = append(n.ChildValues, 0) copy(n.ChildValues[i+1:], n.ChildValues[i:]) n.ChildValues[i] = key.Value } } if n.IsLeaf && i == len(n.ChildKeys) { n.ChildKeys = append(n.ChildKeys, key) } else { n.ChildKeys = append(n.ChildKeys, nil) copy(n.ChildKeys[i+1:], n.ChildKeys[i:]) n.ChildKeys[i] = key } return overwrittenKey }]} {Id:19 FileId:44 StartLine:195 StartColumn:1 EndLine:205 EndColumn:2 Name:delete Params:[{Name:comparator Type:Comparator} {Name:key Type:*Key}] Results:[{Name: Type:*Key}] Receiver:0xc0001e6560 Body:{
	i := n.search(comparator, key.Value)
	if i == len(n.ChildValues) {
		return nil
	}

	n.deleteValueAt(i)
	n.deleteKeyAt(i)

	return key
} PrettyPrintBody:[{ i := n.search(comparator, key.Value) if i == len(n.ChildValues) { return nil } n.deleteValueAt(i) n.deleteKeyAt(i) return key }]} {Id:20 FileId:44 StartLine:207 StartColumn:1 EndLine:241 EndColumn:2 Name:multiDelete Params:[{Name:comparator Type:Comparator} {Name:keys Type:...*Key}] Results:[] Receiver:0xc000a8ab00 Body:{
	indices := make([]int, 0, len(keys))
	for _, k := range keys {
		i := n.search(comparator, k.Value)
		if i < len(n.ChildValues) {
			indices = append(indices, i)
		}
	}

	for _, i := range indices {
		n.ChildValues[i] = nil
		n.ChildKeys[i] = nil
	}

	if len(indices) == len(n.ChildValues) {
		n.ChildKeys = n.ChildKeys[:0]
		n.ChildValues = n.ChildValues[:0]
		return
	}

	sort.Ints(indices)

	for i, j := range indices {
		index := j - i
		copy(n.ChildValues[index:], n.ChildValues[index+1:])
		copy(n.ChildKeys[index:], n.ChildKeys[index+1:])
	}

	n.ChildValues = n.ChildValues[:len(n.ChildValues)-len(indices)]
	n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-len(indices)]
} PrettyPrintBody:[{ indices := make([]int, 0, len(keys)) for _, k := range keys { i := n.search(comparator, k.Value) if i < len(n.ChildValues) { indices = append(indices, i) } } for _, i := range indices { n.ChildValues[i] = nil n.ChildKeys[i] = nil } if len(indices) == len(n.ChildValues) { n.ChildKeys = n.ChildKeys[:0] n.ChildValues = n.ChildValues[:0] return } sort.Ints(indices) for i, j := range indices { index := j - i copy(n.ChildValues[index:], n.ChildValues[index+1:]) copy(n.ChildKeys[index:], n.ChildKeys[index+1:]) } n.ChildValues = n.ChildValues[:len(n.ChildValues)-len(indices)] n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-len(indices)] }]} {Id:21 FileId:44 StartLine:245 StartColumn:1 EndLine:247 EndColumn:2 Name:replaceKeyAt Params:[{Name:key Type:*Key} {Name:i Type:int}] Results:[] Receiver:0xc0016031e0 Body:{
	n.ChildKeys[i] = key
} PrettyPrintBody:[{ n.ChildKeys[i] = key }]} {Id:22 FileId:44 StartLine:250 StartColumn:1 EndLine:252 EndColumn:2 Name:flatten Params:[] Results:[{Name: Type:[]interface{}} {Name: Type:Keys}] Receiver:0xc00019e440 Body:{
	return n.ChildValues, n.ChildKeys
} PrettyPrintBody:[{ return n.ChildValues, n.ChildKeys }]} {Id:23 FileId:44 StartLine:256 StartColumn:1 EndLine:265 EndColumn:2 Name:iter Params:[{Name:comparator Type:Comparator} {Name:start Type:interface{}}] Results:[{Name: Type:iterator}] Receiver:0xc001603260 Body:{
	pointer := n.search(comparator, start)
	pointer--
	return &sliceIterator{
		stop:		stop,
		n:		n,
		pointer:	pointer,
		comparator:	comparator,
	}
} PrettyPrintBody:[{ pointer := n.search(comparator, start) pointer-- return &sliceIterator{ stop:		stop, n:		n, pointer:	pointer, comparator:	comparator, } }]} {Id:24 FileId:44 StartLine:267 StartColumn:1 EndLine:269 EndColumn:2 Name:valueAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}}] Receiver:0xc000a8b840 Body:{
	return n.ChildValues[i]
} PrettyPrintBody:[{ return n.ChildValues[i] }]} {Id:25 FileId:44 StartLine:271 StartColumn:1 EndLine:273 EndColumn:2 Name:keyAt Params:[{Name:i Type:int}] Results:[{Name: Type:*Key}] Receiver:0xc001603560 Body:{
	return n.ChildKeys[i]
} PrettyPrintBody:[{ return n.ChildKeys[i] }]} {Id:26 FileId:44 StartLine:275 StartColumn:1 EndLine:277 EndColumn:2 Name:needsSplit Params:[{Name:max Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0016035c0 Body:{
	return n.lenValues() > max
} PrettyPrintBody:[{ return n.lenValues() > max }]} {Id:27 FileId:44 StartLine:279 StartColumn:1 EndLine:281 EndColumn:2 Name:lastValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc0001e67a0 Body:{
	return n.ChildValues[len(n.ChildValues)-1]
} PrettyPrintBody:[{ return n.ChildValues[len(n.ChildValues)-1] }]} {Id:28 FileId:44 StartLine:283 StartColumn:1 EndLine:285 EndColumn:2 Name:firstValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc00095b160 Body:{
	return n.ChildValues[0]
} PrettyPrintBody:[{ return n.ChildValues[0] }]} {Id:29 FileId:44 StartLine:287 StartColumn:1 EndLine:290 EndColumn:2 Name:append Params:[{Name:other Type:*Node}] Results:[] Receiver:0xc001603660 Body:{
	n.ChildValues = append(n.ChildValues, other.ChildValues...)
	n.ChildKeys = append(n.ChildKeys, other.ChildKeys...)
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, other.ChildValues...) n.ChildKeys = append(n.ChildKeys, other.ChildKeys...) }]} {Id:30 FileId:44 StartLine:292 StartColumn:1 EndLine:294 EndColumn:2 Name:replaceValueAt Params:[{Name:i Type:int} {Name:value Type:interface{}}] Results:[] Receiver:0xc00095b180 Body:{
	n.ChildValues[i] = value
} PrettyPrintBody:[{ n.ChildValues[i] = value }]} {Id:31 FileId:44 StartLine:296 StartColumn:1 EndLine:300 EndColumn:2 Name:deleteValueAt Params:[{Name:i Type:int}] Results:[] Receiver:0xc0003e56a0 Body:{
	copy(n.ChildValues[i:], n.ChildValues[i+1:])
	n.ChildValues[len(n.ChildValues)-1] = 0
	n.ChildValues = n.ChildValues[:len(n.ChildValues)-1]
} PrettyPrintBody:[{ copy(n.ChildValues[i:], n.ChildValues[i+1:]) n.ChildValues[len(n.ChildValues)-1] = 0 n.ChildValues = n.ChildValues[:len(n.ChildValues)-1] }]} {Id:32 FileId:44 StartLine:302 StartColumn:1 EndLine:306 EndColumn:2 Name:deleteKeyAt Params:[{Name:i Type:int}] Results:[] Receiver:0xc000a8ba40 Body:{
	copy(n.ChildKeys[i:], n.ChildKeys[i+1:])
	n.ChildKeys[len(n.ChildKeys)-1] = nil
	n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-1]
} PrettyPrintBody:[{ copy(n.ChildKeys[i:], n.ChildKeys[i+1:]) n.ChildKeys[len(n.ChildKeys)-1] = nil n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-1] }]} {Id:33 FileId:44 StartLine:308 StartColumn:1 EndLine:326 EndColumn:2 Name:splitLeafAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc0003e5800 Body:{
	left := newNode()
	left.IsLeaf = n.IsLeaf
	left.ID = newID()

	value := n.ChildValues[i]
	leftValues := make([]interface{}, i+1)
	copy(leftValues, n.ChildValues[:i+1])
	n.ChildValues = n.ChildValues[i+1:]
	leftKeys := make(Keys, i+1)
	copy(leftKeys, n.ChildKeys[:i+1])
	for j := 0; j <= i; j++ {
		n.ChildKeys[j] = nil
	}
	n.ChildKeys = n.ChildKeys[i+1:]
	left.ChildValues = leftValues
	left.ChildKeys = leftKeys
	return value, left
} PrettyPrintBody:[{ left := newNode() left.IsLeaf = n.IsLeaf left.ID = newID() value := n.ChildValues[i] leftValues := make([]interface{}, i+1) copy(leftValues, n.ChildValues[:i+1]) n.ChildValues = n.ChildValues[i+1:] leftKeys := make(Keys, i+1) copy(leftKeys, n.ChildKeys[:i+1]) for j := 0; j <= i; j++ { n.ChildKeys[j] = nil } n.ChildKeys = n.ChildKeys[i+1:] left.ChildValues = leftValues left.ChildKeys = leftKeys return value, left }]} {Id:34 FileId:44 StartLine:331 StartColumn:1 EndLine:348 EndColumn:2 Name:splitInternalAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc00095b3c0 Body:{
	left := newNode()
	left.IsLeaf = n.IsLeaf
	left.ID = newID()
	value := n.ChildValues[i]
	leftValues := make([]interface{}, i)
	copy(leftValues, n.ChildValues[:i])
	n.ChildValues = n.ChildValues[i+1:]
	leftKeys := make(Keys, i+1)
	copy(leftKeys, n.ChildKeys[:i+1])
	for j := 0; j <= i; j++ {
		n.ChildKeys[j] = nil
	}
	n.ChildKeys = n.ChildKeys[i+1:]
	left.ChildKeys = leftKeys
	left.ChildValues = leftValues
	return value, left
} PrettyPrintBody:[{ left := newNode() left.IsLeaf = n.IsLeaf left.ID = newID() value := n.ChildValues[i] leftValues := make([]interface{}, i) copy(leftValues, n.ChildValues[:i]) n.ChildValues = n.ChildValues[i+1:] leftKeys := make(Keys, i+1) copy(leftKeys, n.ChildKeys[:i+1]) for j := 0; j <= i; j++ { n.ChildKeys[j] = nil } n.ChildKeys = n.ChildKeys[i+1:] left.ChildKeys = leftKeys left.ChildValues = leftValues return value, left }]} {Id:35 FileId:44 StartLine:352 StartColumn:1 EndLine:358 EndColumn:2 Name:splitAt Params:[{Name:i Type:int}] Results:[{Name: Type:interface{}} {Name: Type:*Node}] Receiver:0xc0001e6b00 Body:{
	if n.IsLeaf {
		return n.splitLeafAt(i)
	}

	return n.splitInternalAt(i)
} PrettyPrintBody:[{ if n.IsLeaf { return n.splitLeafAt(i) } return n.splitInternalAt(i) }]} {Id:36 FileId:44 StartLine:360 StartColumn:1 EndLine:362 EndColumn:2 Name:lenKeys Params:[] Results:[{Name: Type:int}] Receiver:0xc00095b5e0 Body:{
	return len(n.ChildKeys)
} PrettyPrintBody:[{ return len(n.ChildKeys) }]} {Id:37 FileId:44 StartLine:364 StartColumn:1 EndLine:366 EndColumn:2 Name:lenValues Params:[] Results:[{Name: Type:int}] Receiver:0xc00095b620 Body:{
	return len(n.ChildValues)
} PrettyPrintBody:[{ return len(n.ChildValues) }]} {Id:38 FileId:44 StartLine:368 StartColumn:1 EndLine:370 EndColumn:2 Name:appendChild Params:[{Name:key Type:*Key}] Results:[] Receiver:0xc00095b6a0 Body:{
	n.ChildKeys = append(n.ChildKeys, key)
} PrettyPrintBody:[{ n.ChildKeys = append(n.ChildKeys, key) }]} {Id:39 FileId:44 StartLine:372 StartColumn:1 EndLine:374 EndColumn:2 Name:appendValue Params:[{Name:value Type:interface{}}] Results:[] Receiver:0xc00095b6e0 Body:{
	n.ChildValues = append(n.ChildValues, value)
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, value) }]} {Id:40 FileId:44 StartLine:376 StartColumn:1 EndLine:380 EndColumn:2 Name:popFirstKey Params:[] Results:[{Name: Type:*Key}] Receiver:0xc00095b720 Body:{
	key := n.ChildKeys[0]
	n.deleteKeyAt(0)
	return key
} PrettyPrintBody:[{ key := n.ChildKeys[0] n.deleteKeyAt(0) return key }]} {Id:41 FileId:44 StartLine:382 StartColumn:1 EndLine:386 EndColumn:2 Name:popFirstValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000992420 Body:{
	value := n.ChildValues[0]
	n.deleteValueAt(0)
	return value
} PrettyPrintBody:[{ value := n.ChildValues[0] n.deleteValueAt(0) return value }]} {Id:42 FileId:44 StartLine:388 StartColumn:1 EndLine:392 EndColumn:2 Name:popKey Params:[] Results:[{Name: Type:*Key}] Receiver:0xc00019e7a0 Body:{
	key := n.ChildKeys[len(n.ChildKeys)-1]
	n.deleteKeyAt(len(n.ChildKeys) - 1)
	return key
} PrettyPrintBody:[{ key := n.ChildKeys[len(n.ChildKeys)-1] n.deleteKeyAt(len(n.ChildKeys) - 1) return key }]} {Id:43 FileId:44 StartLine:394 StartColumn:1 EndLine:398 EndColumn:2 Name:popValue Params:[] Results:[{Name: Type:interface{}}] Receiver:0xc000a8bd00 Body:{
	value := n.ChildValues[len(n.ChildValues)-1]
	n.deleteValueAt(len(n.ChildValues) - 1)
	return value
} PrettyPrintBody:[{ value := n.ChildValues[len(n.ChildValues)-1] n.deleteValueAt(len(n.ChildValues) - 1) return value }]} {Id:44 FileId:44 StartLine:400 StartColumn:1 EndLine:404 EndColumn:2 Name:prependKey Params:[{Name:key Type:*Key}] Results:[] Receiver:0xc0000ed860 Body:{
	n.ChildKeys = append(n.ChildKeys, nil)
	copy(n.ChildKeys[1:], n.ChildKeys)
	n.ChildKeys[0] = key
} PrettyPrintBody:[{ n.ChildKeys = append(n.ChildKeys, nil) copy(n.ChildKeys[1:], n.ChildKeys) n.ChildKeys[0] = key }]} {Id:45 FileId:44 StartLine:406 StartColumn:1 EndLine:410 EndColumn:2 Name:prependValue Params:[{Name:value Type:interface{}}] Results:[] Receiver:0xc00095b820 Body:{
	n.ChildValues = append(n.ChildValues, nil)
	copy(n.ChildValues[1:], n.ChildValues)
	n.ChildValues[0] = value
} PrettyPrintBody:[{ n.ChildValues = append(n.ChildValues, nil) copy(n.ChildValues[1:], n.ChildValues) n.ChildValues[0] = value }]} {Id:46 FileId:44 StartLine:412 StartColumn:1 EndLine:416 EndColumn:2 Name:search Params:[{Name:comparator Type:Comparator} {Name:value Type:interface{}}] Results:[{Name: Type:int}] Receiver:0xc000992720 Body:{
	return sort.Search(len(n.ChildValues), func(i int) bool {
		return comparator(n.ChildValues[i], value) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(n.ChildValues), func(i int) bool { return comparator(n.ChildValues[i], value) >= 0 }) }]} {Id:47 FileId:44 StartLine:420 StartColumn:1 EndLine:429 EndColumn:2 Name:nodeFromBytes Params:[{Name:t Type:*Tr} {Name:data Type:[]byte}] Results:[{Name: Type:*Node} {Name: Type:error}] Receiver:<nil> Body:{
	n := &Node{}
	_, err := n.UnmarshalMsg(data)
	if err != nil {
		panic(err)
		return nil, err
	}

	return n, nil
} PrettyPrintBody:[{ n := &Node{} _, err := n.UnmarshalMsg(data) if err != nil { panic(err) return nil, err } return n, nil }]} {Id:48 FileId:44 StartLine:433 StartColumn:1 EndLine:437 EndColumn:2 Name:newNode Params:[] Results:[{Name: Type:*Node}] Receiver:<nil> Body:{
	return &Node{
		ID: newID(),
	}
} PrettyPrintBody:[{ return &Node{ ID: newID(), } }]} {Id:50 FileId:44 StartLine:446 StartColumn:1 EndLine:464 EndColumn:2 Name:next Params:[] Results:[{Name: Type:bool}] Receiver:0xc001581720 Body:{
	s.pointer++
	if s.n.IsLeaf {
		return s.pointer < len(s.n.ChildValues) && s.comparator(s.stop, s.n.ChildValues[s.pointer]) >= 0
	} else {
		if s.pointer >= len(s.n.ChildKeys) {
			return false
		}
		if s.pointer == len(s.n.ChildValues) {
			return true
		}

		if s.comparator(s.stop, s.n.ChildValues[s.pointer]) < 0 {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ s.pointer++ if s.n.IsLeaf { return s.pointer < len(s.n.ChildValues) && s.comparator(s.stop, s.n.ChildValues[s.pointer]) >= 0 } else { if s.pointer >= len(s.n.ChildKeys) { return false } if s.pointer == len(s.n.ChildValues) { return true } if s.comparator(s.stop, s.n.ChildValues[s.pointer]) < 0 { return false } } return true }]} {Id:51 FileId:44 StartLine:466 StartColumn:1 EndLine:468 EndColumn:2 Name:value Params:[] Results:[{Name: Type:*Key} {Name: Type:int}] Receiver:0xc0000edda0 Body:{
	return s.n.ChildKeys[s.pointer], s.pointer
} PrettyPrintBody:[{ return s.n.ChildKeys[s.pointer], s.pointer }]} {Id:55 FileId:44 StartLine:486 StartColumn:1 EndLine:488 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc0000edde0 Body:{
	return len(n.values)
} PrettyPrintBody:[{ return len(n.values) }]} {Id:56 FileId:44 StartLine:490 StartColumn:1 EndLine:493 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc00019ee40 Body:{
	n.values[i], n.values[j] = n.values[j], n.values[i]
	n.keys[i], n.keys[j] = n.keys[j], n.keys[i]
} PrettyPrintBody:[{ n.values[i], n.values[j] = n.values[j], n.values[i] n.keys[i], n.keys[j] = n.keys[j], n.keys[i] }]} {Id:57 FileId:44 StartLine:495 StartColumn:1 EndLine:497 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc00019f000 Body:{
	return n.comparator(n.values[i], n.values[j]) < 0
} PrettyPrintBody:[{ return n.comparator(n.values[i], n.values[j]) < 0 }]} {Id:58 FileId:44 StartLine:499 StartColumn:1 EndLine:505 EndColumn:2 Name:splitValues Params:[{Name:values Type:[]interface{}} {Name:numParts Type:int}] Results:[{Name: Type:[][]interface{}}] Receiver:<nil> Body:{
	parts := make([][]interface{}, numParts)
	for i := int64(0); i < int64(numParts); i++ {
		parts[i] = values[i*int64(len(values))/int64(numParts) : (i+1)*int64(len(values))/int64(numParts)]
	}
	return parts
} PrettyPrintBody:[{ parts := make([][]interface{}, numParts) for i := int64(0); i < int64(numParts); i++ { parts[i] = values[i*int64(len(values))/int64(numParts) : (i+1)*int64(len(values))/int64(numParts)] } return parts }]} {Id:1 FileId:121 StartLine:31 StartColumn:1 EndLine:33 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]} {Id:2 FileId:121 StartLine:35 StartColumn:1 EndLine:48 EndColumn:2 Name:print Params:[{Name:log Type:*log.Logger}] Results:[] Receiver:0xc00110bd40 Body:{
	log.Printf(`NODE: %+v, MBR: %+v, %p`, n, n.mbr, n)
	if n.isLeaf {
		for i, wh := range n.nodes.list {
			xlow, ylow := wh.LowerLeft()
			xhigh, yhigh := wh.UpperRight()
			log.Printf(`KEY: %+v, XLOW: %+v, YLOW: %+v, XHIGH: %+v, YHIGH: %+v`, n.keys.list[i], xlow, ylow, xhigh, yhigh)
		}
	} else {
		for _, wh := range n.nodes.list {
			wh.(*node).print(log)
		}
	}
} PrettyPrintBody:[{ log.Printf(`NODE: %+v, MBR: %+v, %p`, n, n.mbr, n) if n.isLeaf { for i, wh := range n.nodes.list { xlow, ylow := wh.LowerLeft() xhigh, yhigh := wh.UpperRight() log.Printf(`KEY: %+v, XLOW: %+v, YLOW: %+v, XHIGH: %+v, YHIGH: %+v`, n.keys.list[i], xlow, ylow, xhigh, yhigh) } } else { for _, wh := range n.nodes.list { wh.(*node).print(log) } } }]} {Id:3 FileId:121 StartLine:50 StartColumn:1 EndLine:58 EndColumn:2 Name:print Params:[{Name:log Type:*log.Logger}] Results:[] Receiver:0xc001032d40 Body:{
	log.Println(`PRINTING TREE`)
	if t.root == nil {
		log.Println(`EMPTY TREE.`)
		return
	}

	t.root.print(log)
} PrettyPrintBody:[{ log.Println(`PRINTING TREE`) if t.root == nil { log.Println(`EMPTY TREE.`) return } t.root.print(log) }]} {Id:4 FileId:121 StartLine:60 StartColumn:1 EndLine:66 EndColumn:2 Name:constructMockPoints Params:[{Name:num Type:int}] Results:[{Name: Type:rtree.Rectangles}] Receiver:<nil> Body:{
	rects := make(rtree.Rectangles, 0, num)
	for i := int32(0); i < int32(num); i++ {
		rects = append(rects, newMockRectangle(i, i, i, i))
	}
	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, num) for i := int32(0); i < int32(num); i++ { rects = append(rects, newMockRectangle(i, i, i, i)) } return rects }]} {Id:5 FileId:121 StartLine:68 StartColumn:1 EndLine:76 EndColumn:2 Name:constructRandomMockPoints Params:[{Name:num Type:int}] Results:[{Name: Type:rtree.Rectangles}] Receiver:<nil> Body:{
	rects := make(rtree.Rectangles, 0, num)
	for i := 0; i < num; i++ {
		r := rand.Int31()
		rects = append(rects, newMockRectangle(r, r, r, r))
	}

	return rects
} PrettyPrintBody:[{ rects := make(rtree.Rectangles, 0, num) for i := 0; i < num; i++ { r := rand.Int31() rects = append(rects, newMockRectangle(r, r, r, r)) } return rects }]} {Id:6 FileId:121 StartLine:78 StartColumn:1 EndLine:80 EndColumn:2 Name:constructInfiniteRect Params:[] Results:[{Name: Type:rtree.Rectangle}] Receiver:<nil> Body:{
	return newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
} PrettyPrintBody:[{ return newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) }]} {Id:7 FileId:121 StartLine:82 StartColumn:1 EndLine:92 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	tree := newTree(3, 3)

	tree.Insert(r1)
	assert.Equal(t, uint64(1), tree.Len())

	q := newMockRectangle(5, 5, 15, 15)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) tree := newTree(3, 3) tree.Insert(r1) assert.Equal(t, uint64(1), tree.Len()) q := newMockRectangle(5, 5, 15, 15) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) }]} {Id:8 FileId:121 StartLine:94 StartColumn:1 EndLine:104 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	tree := newTree(3, 3)
	tree.Insert(r1)

	tree.Delete(r1)
	assert.Equal(t, uint64(0), tree.Len())
	q := newMockRectangle(5, 5, 15, 15)
	result := tree.Search(q)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) tree := newTree(3, 3) tree.Insert(r1) tree.Delete(r1) assert.Equal(t, uint64(0), tree.Len()) q := newMockRectangle(5, 5, 15, 15) result := tree.Search(q) assert.Len(t, result, 0) }]} {Id:9 FileId:121 StartLine:106 StartColumn:1 EndLine:121 EndColumn:2 Name:TestDeleteIdenticalHilbergNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)
	tree.Insert(r1)

	tree.Delete(r2)
	assert.Equal(t, uint64(1), tree.Len())
	result := tree.Search(r2)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	tree.Delete(r1)
	assert.Equal(t, uint64(0), tree.Len())
	result = tree.Search(r1)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1) tree.Delete(r2) assert.Equal(t, uint64(1), tree.Len()) result := tree.Search(r2) assert.Equal(t, rtree.Rectangles{r1}, result) tree.Delete(r1) assert.Equal(t, uint64(0), tree.Len()) result = tree.Search(r1) assert.Len(t, result, 0) }]} {Id:10 FileId:121 StartLine:123 StartColumn:1 EndLine:133 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(3)
	tree := newTree(3, 3)
	tree.Insert(points...)
	assert.Equal(t, uint64(len(points)), tree.Len())

	tree.Delete(points...)
	assert.Equal(t, uint64(0), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ points := constructRandomMockPoints(3) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) tree.Delete(points...) assert.Equal(t, uint64(0), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Len(t, result, 0) }]} {Id:11 FileId:121 StartLine:135 StartColumn:1 EndLine:154 EndColumn:2 Name:TestTwoInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)

	tree.Insert(r1, r2)
	assert.Equal(t, uint64(2), tree.Len())

	q := newMockRectangle(0, 0, 20, 20)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(0, 0, 4, 4)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(11, 11, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1, r2) assert.Equal(t, uint64(2), tree.Len()) q := newMockRectangle(0, 0, 20, 20) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(0, 0, 4, 4) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(11, 11, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) }]} {Id:12 FileId:121 StartLine:156 StartColumn:1 EndLine:170 EndColumn:2 Name:TestInsertCausesRootSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	r3 := newMockRectangle(10, 10, 20, 20)
	tree := newTree(3, 3)

	tree.Insert(r1, r2, r3)
	assert.Equal(t, uint64(3), tree.Len())

	q := newMockRectangle(0, 0, 20, 20)
	result := tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) r3 := newMockRectangle(10, 10, 20, 20) tree := newTree(3, 3) tree.Insert(r1, r2, r3) assert.Equal(t, uint64(3), tree.Len()) q := newMockRectangle(0, 0, 20, 20) result := tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) }]} {Id:13 FileId:121 StartLine:172 StartColumn:1 EndLine:188 EndColumn:2 Name:TestInsertCausesRootSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	r3 := newMockRectangle(10, 10, 20, 20)
	r4 := newMockRectangle(15, 15, 25, 25)
	tree := newTree(4, 4)

	tree.Insert(r1, r2, r3, r4)
	assert.Equal(t, uint64(4), tree.Len())

	q := newMockRectangle(0, 0, 25, 25)
	result := tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
	assert.Contains(t, result, r4)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) r3 := newMockRectangle(10, 10, 20, 20) r4 := newMockRectangle(15, 15, 25, 25) tree := newTree(4, 4) tree.Insert(r1, r2, r3, r4) assert.Equal(t, uint64(4), tree.Len()) q := newMockRectangle(0, 0, 25, 25) result := tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) assert.Contains(t, result, r4) }]} {Id:14 FileId:121 StartLine:190 StartColumn:1 EndLine:235 EndColumn:2 Name:TestQueryWithLine Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 10, 10)
	r2 := newMockRectangle(5, 5, 15, 15)
	tree := newTree(3, 3)
	tree.Insert(r1, r2)

	q := newMockRectangle(5, 0, 5, 10)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(0, 5, 10, 5)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1, r2}, result)

	q = newMockRectangle(15, 0, 15, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(0, 15, 20, 15)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(0, 0, 0, 10)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(0, 0, 10, 0)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(20, 0, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)

	q = newMockRectangle(0, 20, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 10, 10) r2 := newMockRectangle(5, 5, 15, 15) tree := newTree(3, 3) tree.Insert(r1, r2) q := newMockRectangle(5, 0, 5, 10) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(0, 5, 10, 5) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1, r2}, result) q = newMockRectangle(15, 0, 15, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(0, 15, 20, 15) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(0, 0, 0, 10) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(0, 0, 10, 0) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(20, 0, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) q = newMockRectangle(0, 20, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) }]} {Id:15 FileId:121 StartLine:237 StartColumn:1 EndLine:259 EndColumn:2 Name:TestQueryForPoint Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(5, 5, 5, 5)
	r2 := newMockRectangle(10, 10, 10, 10)
	tree := newTree(3, 3)
	tree.Insert(r1, r2)

	q := newMockRectangle(0, 0, 5, 5)
	result := tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r1}, result)

	q = newMockRectangle(0, 0, 20, 20)
	result = tree.Search(q)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)

	q = newMockRectangle(6, 6, 20, 20)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{r2}, result)

	q = newMockRectangle(20, 20, 30, 30)
	result = tree.Search(q)
	assert.Equal(t, rtree.Rectangles{}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(5, 5, 5, 5) r2 := newMockRectangle(10, 10, 10, 10) tree := newTree(3, 3) tree.Insert(r1, r2) q := newMockRectangle(0, 0, 5, 5) result := tree.Search(q) assert.Equal(t, rtree.Rectangles{r1}, result) q = newMockRectangle(0, 0, 20, 20) result = tree.Search(q) assert.Contains(t, result, r1) assert.Contains(t, result, r2) q = newMockRectangle(6, 6, 20, 20) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{r2}, result) q = newMockRectangle(20, 20, 30, 30) result = tree.Search(q) assert.Equal(t, rtree.Rectangles{}, result) }]} {Id:16 FileId:121 StartLine:261 StartColumn:1 EndLine:281 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructMockPoints(100)
	tree := newTree(3, 3)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, int32(len(points)), int32(len(points)))
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructMockPoints(100) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, int32(len(points)), int32(len(points))) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]} {Id:17 FileId:121 StartLine:283 StartColumn:1 EndLine:303 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitOddAryRandomPoints Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(100)
	tree := newTree(3, 3)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructRandomMockPoints(100) tree := newTree(3, 3) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]} {Id:18 FileId:121 StartLine:305 StartColumn:1 EndLine:325 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructMockPoints(100)
	tree := newTree(4, 4)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructMockPoints(100) tree := newTree(4, 4) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]} {Id:19 FileId:121 StartLine:327 StartColumn:1 EndLine:347 EndColumn:2 Name:TestMultipleInsertsCauseInternalSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	points := constructRandomMockPoints(100)
	tree := newTree(4, 4)

	tree.Insert(points...)

	assert.Equal(t, uint64(len(points)), tree.Len())

	q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32)
	result := tree.Search(q)
	succeeded := true
	for _, p := range points {
		if !assert.Contains(t, result, p) {
			succeeded = false
		}
	}

	if !succeeded {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ points := constructRandomMockPoints(100) tree := newTree(4, 4) tree.Insert(points...) assert.Equal(t, uint64(len(points)), tree.Len()) q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32) result := tree.Search(q) succeeded := true for _, p := range points { if !assert.Contains(t, result, p) { succeeded = false } } if !succeeded { tree.print(getConsoleLogger()) } }]} {Id:20 FileId:121 StartLine:349 StartColumn:1 EndLine:368 EndColumn:2 Name:TestInsertDuplicateHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(1, 1, 19, 19)
	r3 := newMockRectangle(2, 2, 18, 18)
	r4 := newMockRectangle(3, 3, 17, 17)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)
	tree.Insert(r3)
	tree.Insert(r4)

	assert.Equal(t, uint64(4), tree.Len())
	q := newMockRectangle(0, 0, 30, 30)
	result := tree.Search(q)
	assert.Len(t, result, 4)
	assert.Contains(t, result, r1)
	assert.Contains(t, result, r2)
	assert.Contains(t, result, r3)
	assert.Contains(t, result, r4)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(1, 1, 19, 19) r3 := newMockRectangle(2, 2, 18, 18) r4 := newMockRectangle(3, 3, 17, 17) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) tree.Insert(r3) tree.Insert(r4) assert.Equal(t, uint64(4), tree.Len()) q := newMockRectangle(0, 0, 30, 30) result := tree.Search(q) assert.Len(t, result, 4) assert.Contains(t, result, r1) assert.Contains(t, result, r2) assert.Contains(t, result, r3) assert.Contains(t, result, r4) }]} {Id:21 FileId:121 StartLine:370 StartColumn:1 EndLine:385 EndColumn:2 Name:TestDeleteAllDuplicateHilbert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(1, 1, 19, 19)
	r3 := newMockRectangle(2, 2, 18, 18)
	r4 := newMockRectangle(3, 3, 17, 17)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)
	tree.Insert(r3)
	tree.Insert(r4)

	tree.Delete(r1, r2, r3, r4)
	assert.Equal(t, uint64(0), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(1, 1, 19, 19) r3 := newMockRectangle(2, 2, 18, 18) r4 := newMockRectangle(3, 3, 17, 17) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) tree.Insert(r3) tree.Insert(r4) tree.Delete(r1, r2, r3, r4) assert.Equal(t, uint64(0), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Len(t, result, 0) }]} {Id:22 FileId:121 StartLine:387 StartColumn:1 EndLine:397 EndColumn:2 Name:TestInsertDuplicateRect Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	r1 := newMockRectangle(0, 0, 20, 20)
	r2 := newMockRectangle(0, 0, 20, 20)
	tree := newTree(3, 3)
	tree.Insert(r1)
	tree.Insert(r2)

	assert.Equal(t, uint64(1), tree.Len())
	result := tree.Search(constructInfiniteRect())
	assert.Equal(t, rtree.Rectangles{r2}, result)
} PrettyPrintBody:[{ r1 := newMockRectangle(0, 0, 20, 20) r2 := newMockRectangle(0, 0, 20, 20) tree := newTree(3, 3) tree.Insert(r1) tree.Insert(r2) assert.Equal(t, uint64(1), tree.Len()) result := tree.Search(constructInfiniteRect()) assert.Equal(t, rtree.Rectangles{r2}, result) }]} {Id:23 FileId:121 StartLine:399 StartColumn:1 EndLine:409 EndColumn:2 Name:BenchmarkBulkAddPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	points := constructMockPoints(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newTree(8, 8)
		tree.Insert(points...)
	}
} PrettyPrintBody:[{ numItems := 1000 points := constructMockPoints(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree := newTree(8, 8) tree.Insert(points...) } }]} {Id:24 FileId:121 StartLine:411 StartColumn:1 EndLine:422 EndColumn:2 Name:BenchmarkBulkUpdatePoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(points...)
	}
} PrettyPrintBody:[{ numItems := 1000 points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(points...) } }]} {Id:25 FileId:121 StartLine:424 StartColumn:1 EndLine:434 EndColumn:2 Name:BenchmarkPointInsertion Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(points[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(points[i%numItems]) } }]} {Id:26 FileId:121 StartLine:436 StartColumn:1 EndLine:447 EndColumn:2 Name:BenchmarkQueryPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := int32(0); i < int32(b.N); i++ {
		tree.Search(newMockRectangle(i, i, i+10, i+10))
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := int32(0); i < int32(b.N); i++ { tree.Search(newMockRectangle(i, i, i+10, i+10)) } }]} {Id:27 FileId:121 StartLine:449 StartColumn:1 EndLine:460 EndColumn:2 Name:BenchmarkQueryBulkPoints Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := int32(0); i < int32(b.N); i++ {
		tree.Search(newMockRectangle(i, i, int32(numItems), int32(numItems)))
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := int32(0); i < int32(b.N); i++ { tree.Search(newMockRectangle(i, i, int32(numItems), int32(numItems))) } }]} {Id:28 FileId:121 StartLine:462 StartColumn:1 EndLine:473 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	points := constructMockPoints(numItems)
	tree := newTree(8, 8)
	tree.Insert(points...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Delete(points[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N points := constructMockPoints(numItems) tree := newTree(8, 8) tree.Insert(points...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Delete(points[i%numItems]) } }]} {Id:3 FileId:90 StartLine:29 StartColumn:1 EndLine:82 EndColumn:2 Name:generateRandomVerticesFromGuess Params:[{Name:guess Type:*nmVertex} {Name:num Type:int}] Results:[{Name: Type:vertices}] Receiver:<nil> Body:{

	summed := make(map[float64]vertices, num)
	dimensions := len(guess.vars)
	vs := make(vertices, 0, num)
	i := 0
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

Guess:
	for i < num {
		sum := float64(0)
		vars := make([]float64, 0, dimensions)
		for j := 0; j < dimensions; j++ {
			v := r.Float64() * 1000

			if r.Float64() > .5 {
				v = -v
			}
			sum += v
			vars = append(vars, v)
		}

		guess := &nmVertex{
			vars: vars,
		}

		if vs, ok := summed[sum]; !ok {
			vs = make(vertices, 0, dimensions)
			vs = append(vs, guess)
			summed[sum] = vs
		} else {
			for _, vertex := range vs {

				if guess.equalToVertex(vertex) {
					continue Guess
				}
			}
			vs = append(vs, guess)
		}

		vs = append(vs, guess)
		i++
	}

	return vs
} PrettyPrintBody:[{ summed := make(map[float64]vertices, num) dimensions := len(guess.vars) vs := make(vertices, 0, num) i := 0 r := rand.New(rand.NewSource(time.Now().UnixNano())) Guess: for i < num { sum := float64(0) vars := make([]float64, 0, dimensions) for j := 0; j < dimensions; j++ { v := r.Float64() * 1000 if r.Float64() > .5 { v = -v } sum += v vars = append(vars, v) } guess := &nmVertex{ vars: vars, } if vs, ok := summed[sum]; !ok { vs = make(vertices, 0, dimensions) vs = append(vs, guess) summed[sum] = vs } else { for _, vertex := range vs { if guess.equalToVertex(vertex) { continue Guess } } vs = append(vs, guess) } vs = append(vs, guess) i++ } return vs }]} {Id:4 FileId:90 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:isInf Params:[{Name:num Type:float64}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return math.IsInf(num, -1) || math.IsInf(num, 1)
} PrettyPrintBody:[{ return math.IsInf(num, -1) || math.IsInf(num, 1) }]} {Id:5 FileId:90 StartLine:88 StartColumn:1 EndLine:97 EndColumn:2 Name:findMin Params:[{Name:vertices Type:...*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:<nil> Body:{
	min := vertices[0]
	for _, v := range vertices[1:] {
		if v.distance < min.distance {
			min = v
		}
	}

	return min
} PrettyPrintBody:[{ min := vertices[0] for _, v := range vertices[1:] { if v.distance < min.distance { min = v } } return min }]} {Id:6 FileId:90 StartLine:101 StartColumn:1 EndLine:116 EndColumn:2 Name:findMidpoint Params:[{Name:vertices Type:...*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:<nil> Body:{
	num := len(vertices)
	vars := make([]float64, 0, num)

	for i := 0; i < num; i++ {
		sum := float64(0)
		for _, v := range vertices {
			sum += v.vars[i]
		}
		vars = append(vars, sum/float64(num))
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ num := len(vertices) vars := make([]float64, 0, num) for i := 0; i < num; i++ { sum := float64(0) for _, v := range vertices { sum += v.vars[i] } vars = append(vars, sum/float64(num)) } return &nmVertex{ vars: vars, } }]} {Id:7 FileId:90 StartLine:121 StartColumn:1 EndLine:129 EndColumn:2 Name:determineDistance Params:[{Name:value Type:float64}] Results:[{Name: Type:float64}] Receiver:<nil> Body:{
	if math.IsInf(target, 1) {
		target = math.MaxFloat64
	} else if math.IsInf(target, -1) {
		target = -math.MaxFloat64
	}

	return math.Abs(target - value)
} PrettyPrintBody:[{ if math.IsInf(target, 1) { target = math.MaxFloat64 } else if math.IsInf(target, -1) { target = -math.MaxFloat64 } return math.Abs(target - value) }]} {Id:9 FileId:90 StartLine:135 StartColumn:1 EndLine:141 EndColumn:2 Name:evaluate Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc000a8a6a0 Body:{
	for _, v := range vertices {
		v.evaluate(config)
	}

	vertices.sort(config)
} PrettyPrintBody:[{ for _, v := range vertices { v.evaluate(config) } vertices.sort(config) }]} {Id:10 FileId:90 StartLine:143 StartColumn:1 EndLine:149 EndColumn:2 Name:sort Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc0001e6220 Body:{
	sorter := sorter{
		config:		config,
		vertices:	vertices,
	}
	sorter.sort()
} PrettyPrintBody:[{ sorter := sorter{ config:		config, vertices:	vertices, } sorter.sort() }]} {Id:12 FileId:90 StartLine:156 StartColumn:1 EndLine:158 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc0001e6040 Body:{
	sort.Sort(sorter)
} PrettyPrintBody:[{ sort.Sort(sorter) }]} {Id:13 FileId:90 StartLine:166 StartColumn:1 EndLine:168 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc000993620 Body:{
	return sorter.vertices[i].less(sorter.config, sorter.vertices[j])
} PrettyPrintBody:[{ return sorter.vertices[i].less(sorter.config, sorter.vertices[j]) }]} {Id:14 FileId:90 StartLine:170 StartColumn:1 EndLine:172 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc00095a820 Body:{
	return len(sorter.vertices)
} PrettyPrintBody:[{ return len(sorter.vertices) }]} {Id:15 FileId:90 StartLine:174 StartColumn:1 EndLine:176 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc00095a880 Body:{
	sorter.vertices[i], sorter.vertices[j] = sorter.vertices[j], sorter.vertices[i]
} PrettyPrintBody:[{ sorter.vertices[i], sorter.vertices[j] = sorter.vertices[j], sorter.vertices[i] }]} {Id:16 FileId:90 StartLine:180 StartColumn:1 EndLine:188 EndColumn:2 Name:String Params:[] Results:[{Name: Type:string}] Receiver:0xc00095a9c0 Body:{
	result := ``
	for i, v := range vertices {
		result += fmt.Sprintf(`VERTEX INDEX: %+v, VERTEX: %+v`, i, v)
		result += fmt.Sprintln(``)
	}

	return result
} PrettyPrintBody:[{ result := `` for i, v := range vertices { result += fmt.Sprintf(`VERTEX INDEX: %+v, VERTEX: %+v`, i, v) result += fmt.Sprintln(``) } return result }]} {Id:19 FileId:90 StartLine:231 StartColumn:1 EndLine:234 EndColumn:2 Name:evaluate Params:[{Name:config Type:NelderMeadConfiguration}] Results:[] Receiver:0xc00095ad20 Body:{
	nm.result, nm.good = config.Fn(nm.vars)
	nm.distance = determineDistance(nm.result, config.Target)
} PrettyPrintBody:[{ nm.result, nm.good = config.Fn(nm.vars) nm.distance = determineDistance(nm.result, config.Target) }]} {Id:20 FileId:90 StartLine:236 StartColumn:1 EndLine:245 EndColumn:2 Name:add Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0016030c0 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]+other.vars[i])
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]+other.vars[i]) } return &nmVertex{ vars: vars, } }]} {Id:21 FileId:90 StartLine:247 StartColumn:1 EndLine:256 EndColumn:2 Name:multiply Params:[{Name:scalar Type:float64}] Results:[{Name: Type:*nmVertex}] Receiver:0xc001603700 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]*scalar)
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]*scalar) } return &nmVertex{ vars: vars, } }]} {Id:22 FileId:90 StartLine:258 StartColumn:1 EndLine:267 EndColumn:2 Name:subtract Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0001e6920 Body:{
	vars := make([]float64, 0, len(nm.vars))
	for i := 0; i < len(nm.vars); i++ {
		vars = append(vars, nm.vars[i]-other.vars[i])
	}

	return &nmVertex{
		vars: vars,
	}
} PrettyPrintBody:[{ vars := make([]float64, 0, len(nm.vars)) for i := 0; i < len(nm.vars); i++ { vars = append(vars, nm.vars[i]-other.vars[i]) } return &nmVertex{ vars: vars, } }]} {Id:23 FileId:90 StartLine:279 StartColumn:1 EndLine:288 EndColumn:2 Name:less Params:[{Name:config Type:NelderMeadConfiguration} {Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc000a8bbc0 Body:{
	if config.Target == min {
		return nm.result < other.result
	}
	if config.Target == max {
		return nm.result > other.result
	}

	return nm.distance < other.distance
} PrettyPrintBody:[{ if config.Target == min { return nm.result < other.result } if config.Target == max { return nm.result > other.result } return nm.distance < other.distance }]} {Id:24 FileId:90 StartLine:290 StartColumn:1 EndLine:298 EndColumn:2 Name:equal Params:[{Name:config Type:NelderMeadConfiguration} {Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc000a8bc60 Body:{
	if isInf(config.Target) {

		return nm.result == other.result
	}

	return nm.distance == other.distance
} PrettyPrintBody:[{ if isInf(config.Target) { return nm.result == other.result } return nm.distance == other.distance }]} {Id:25 FileId:90 StartLine:301 StartColumn:1 EndLine:310 EndColumn:2 Name:euclideanDistance Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:float64}] Receiver:0xc00019e880 Body:{
	sum := float64(0)

	for i, otherPoint := range other.vars {

		sum += math.Pow(otherPoint-nm.vars[i], 2)
	}

	return math.Sqrt(sum)
} PrettyPrintBody:[{ sum := float64(0) for i, otherPoint := range other.vars { sum += math.Pow(otherPoint-nm.vars[i], 2) } return math.Sqrt(sum) }]} {Id:26 FileId:90 StartLine:315 StartColumn:1 EndLine:323 EndColumn:2 Name:equalToVertex Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc001603920 Body:{
	for i, n := range nm.vars {
		if n != other.vars[i] {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ for i, n := range nm.vars { if n != other.vars[i] { return false } } return true }]} {Id:27 FileId:90 StartLine:331 StartColumn:1 EndLine:333 EndColumn:2 Name:approximatelyEqualToVertex Params:[{Name:other Type:*nmVertex}] Results:[{Name: Type:bool}] Receiver:0xc0001e6e40 Body:{
	return math.Abs(nm.result-other.result) < 2*delta
} PrettyPrintBody:[{ return math.Abs(nm.result-other.result) < 2*delta }]} {Id:29 FileId:90 StartLine:346 StartColumn:1 EndLine:361 EndColumn:2 Name:evaluateWithConstraints Params:[{Name:vertices Type:vertices} {Name:vertex Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000ed8e0 Body:{
	vertex.evaluate(nm.config)
	return vertex
	if vertex.good {
		return vertex
	}
	best := vertices[0]
	for i := 0; i < 5; i++ {
		vertex = best.add((vertex.subtract(best).multiply(alpha)))
		if vertex.good {
			return vertex
		}
	}

	return best
} PrettyPrintBody:[{ vertex.evaluate(nm.config) return vertex if vertex.good { return vertex } best := vertices[0] for i := 0; i < 5; i++ { vertex = best.add((vertex.subtract(best).multiply(alpha))) if vertex.good { return vertex } } return best }]} {Id:30 FileId:90 StartLine:365 StartColumn:1 EndLine:370 EndColumn:2 Name:reflect Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000ed940 Body:{
	toScalar := midpoint.subtract(nm.lastVertex(vertices))
	toScalar = toScalar.multiply(alpha)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := midpoint.subtract(nm.lastVertex(vertices)) toScalar = toScalar.multiply(alpha) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]} {Id:31 FileId:90 StartLine:372 StartColumn:1 EndLine:377 EndColumn:2 Name:expand Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00019eb40 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(beta)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(beta) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]} {Id:32 FileId:90 StartLine:382 StartColumn:1 EndLine:384 EndColumn:2 Name:lastDimensionVertex Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00095bb40 Body:{
	return vertices[len(vertices)-2]
} PrettyPrintBody:[{ return vertices[len(vertices)-2] }]} {Id:33 FileId:90 StartLine:389 StartColumn:1 EndLine:391 EndColumn:2 Name:lastVertex Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00095bba0 Body:{
	return vertices[len(vertices)-1]
} PrettyPrintBody:[{ return vertices[len(vertices)-1] }]} {Id:34 FileId:90 StartLine:393 StartColumn:1 EndLine:398 EndColumn:2 Name:outsideContract Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc00019ed40 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(gamma)
	toScalar = midpoint.add(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(gamma) toScalar = midpoint.add(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]} {Id:35 FileId:90 StartLine:400 StartColumn:1 EndLine:405 EndColumn:2 Name:insideContract Params:[{Name:vertices Type:vertices} {Name:midpoint Type:*nmVertex}] Results:[{Name: Type:*nmVertex}] Receiver:0xc0000edd80 Body:{
	toScalar := reflection.subtract(midpoint)
	toScalar = toScalar.multiply(gamma)
	toScalar = midpoint.subtract(toScalar)
	return nm.evaluateWithConstraints(vertices, toScalar)
} PrettyPrintBody:[{ toScalar := reflection.subtract(midpoint) toScalar = toScalar.multiply(gamma) toScalar = midpoint.subtract(toScalar) return nm.evaluateWithConstraints(vertices, toScalar) }]} {Id:36 FileId:90 StartLine:407 StartColumn:1 EndLine:414 EndColumn:2 Name:shrink Params:[{Name:vertices Type:vertices}] Results:[] Receiver:0xc001603d00 Body:{
	one := vertices[0]
	for i := 1; i < len(vertices); i++ {
		toScalar := vertices[i].subtract(one)
		toScalar = toScalar.multiply(sigma)
		vertices[i] = one.add(toScalar)
	}
} PrettyPrintBody:[{ one := vertices[0] for i := 1; i < len(vertices); i++ { toScalar := vertices[i].subtract(one) toScalar = toScalar.multiply(sigma) vertices[i] = one.add(toScalar) } }]} {Id:37 FileId:90 StartLine:419 StartColumn:1 EndLine:452 EndColumn:2 Name:checkIteration Params:[{Name:vertices Type:vertices}] Results:[{Name: Type:bool}] Receiver:0xc001603d80 Body:{

	if math.Abs(vertices[0].result-nm.config.Target) < delta {
		return false
	}

	best := vertices[0]

	if !isInf(nm.config.Target) {
		for _, v := range vertices[1:] {
			if math.Abs(best.distance-v.distance) >= delta {
				return true
			}
		}
	}

	for _, v := range vertices[1:] {
		if best.euclideanDistance(v) >= delta {
			return true
		}
	}

	return false
} PrettyPrintBody:[{ if math.Abs(vertices[0].result-nm.config.Target) < delta { return false } best := vertices[0] if !isInf(nm.config.Target) { for _, v := range vertices[1:] { if math.Abs(best.distance-v.distance) >= delta { return true } } } for _, v := range vertices[1:] { if best.euclideanDistance(v) >= delta { return true } } return false }]} {Id:38 FileId:90 StartLine:454 StartColumn:1 EndLine:540 EndColumn:2 Name:evaluate Params:[] Results:[] Receiver:0xc0006b8060 Body:{
	vertices := nm.results.grab(len(nm.config.Vars) + 1)

	vertices[0].evaluate(nm.config)
	if !vertices[0].good {
		nm.results.insert(vertices[0])
		return
	}

	for i := 0; i < maxIterations; i++ {

		for j := 0; j < maxRuns; j++ {

			vertices.evaluate(nm.config)
			best := vertices[0]
			if !nm.checkIteration(vertices) {
				break
			}

			midpoint := findMidpoint(vertices[:len(vertices)-1]...)

			reflection := nm.reflect(vertices, midpoint)

			if reflection == best {
				break
			}

			if reflection.less(nm.config, nm.lastDimensionVertex(vertices)) &&
				!vertices[0].less(nm.config, reflection) {

				vertices[len(vertices)-1] = reflection
			}

			if reflection.less(nm.config, vertices[0]) {
				expanded := nm.expand(vertices, midpoint, reflection)

				if expanded == best {
					break
				}

				if expanded.less(nm.config, reflection) {
					vertices[len(vertices)-1] = expanded
				} else {
					vertices[len(vertices)-1] = reflection
				}
				continue
			}

			if reflection.less(nm.config, nm.lastVertex(vertices)) {
				oc := nm.outsideContract(vertices, midpoint, reflection)
				if oc == best {
					break
				}
				if oc.less(nm.config, reflection) || oc.equal(nm.config, reflection) {
					vertices[len(vertices)-1] = oc
					continue
				}
			} else if !reflection.less(nm.config, nm.lastVertex(vertices)) {
				ic := nm.insideContract(vertices, midpoint, reflection)
				if ic == best {
					break
				}
				if ic.less(nm.config, nm.lastVertex(vertices)) {
					vertices[len(vertices)-1] = ic
					continue
				}
			}

			nm.shrink(vertices)
		}
		nm.results.reSort(vertices[0])
		vertices = nm.results.grab(len(nm.config.Vars) + 1)
	}
} PrettyPrintBody:[{ vertices := nm.results.grab(len(nm.config.Vars) + 1) vertices[0].evaluate(nm.config) if !vertices[0].good { nm.results.insert(vertices[0]) return } for i := 0; i < maxIterations; i++ { for j := 0; j < maxRuns; j++ { vertices.evaluate(nm.config) best := vertices[0] if !nm.checkIteration(vertices) { break } midpoint := findMidpoint(vertices[:len(vertices)-1]...) reflection := nm.reflect(vertices, midpoint) if reflection == best { break } if reflection.less(nm.config, nm.lastDimensionVertex(vertices)) && !vertices[0].less(nm.config, reflection) { vertices[len(vertices)-1] = reflection } if reflection.less(nm.config, vertices[0]) { expanded := nm.expand(vertices, midpoint, reflection) if expanded == best { break } if expanded.less(nm.config, reflection) { vertices[len(vertices)-1] = expanded } else { vertices[len(vertices)-1] = reflection } continue } if reflection.less(nm.config, nm.lastVertex(vertices)) { oc := nm.outsideContract(vertices, midpoint, reflection) if oc == best { break } if oc.less(nm.config, reflection) || oc.equal(nm.config, reflection) { vertices[len(vertices)-1] = oc continue } } else if !reflection.less(nm.config, nm.lastVertex(vertices)) { ic := nm.insideContract(vertices, midpoint, reflection) if ic == best { break } if ic.less(nm.config, nm.lastVertex(vertices)) { vertices[len(vertices)-1] = ic continue } } nm.shrink(vertices) } nm.results.reSort(vertices[0]) vertices = nm.results.grab(len(nm.config.Vars) + 1) } }]} {Id:39 FileId:90 StartLine:542 StartColumn:1 EndLine:550 EndColumn:2 Name:newNelderMead Params:[{Name:config Type:NelderMeadConfiguration}] Results:[{Name: Type:*nelderMead}] Receiver:<nil> Body:{
	v := &nmVertex{vars: config.Vars}
	results := newResults(v, config, 1000)

	return &nelderMead{
		config:		config,
		results:	results,
	}
} PrettyPrintBody:[{ v := &nmVertex{vars: config.Vars} results := newResults(v, config, 1000) return &nelderMead{ config:		config, results:	results, } }]} {Id:40 FileId:90 StartLine:555 StartColumn:1 EndLine:559 EndColumn:2 Name:NelderMead Params:[{Name:config Type:NelderMeadConfiguration}] Results:[{Name: Type:[]float64}] Receiver:<nil> Body:{
	nm := newNelderMead(config)
	nm.evaluate()
	return nm.results.vertices[0].vars
} PrettyPrintBody:[{ nm := newNelderMead(config) nm.evaluate() return nm.results.vertices[0].vars }]} {Id:1 FileId:57 StartLine:31 StartColumn:1 EndLine:39 EndColumn:2 Name:checkTree Params:[{Name:t Type:testing.TB} {Name:tree Type:*ptree}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	return true

	if tree.root == nil {
		return true
	}

	return checkNode(t, tree.root)
} PrettyPrintBody:[{ return true if tree.root == nil { return true } return checkNode(t, tree.root) }]} {Id:2 FileId:57 StartLine:41 StartColumn:1 EndLine:84 EndColumn:2 Name:checkNode Params:[{Name:t Type:testing.TB} {Name:n Type:*node}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	if n.keys.len() == 0 {
		assert.Equal(t, uint64(0), n.nodes.len())
		return false
	}

	if n.isLeaf {
		assert.Equal(t, uint64(0), n.nodes.len())
		return false
	}

	if !assert.Equal(t, n.keys.len()+1, n.nodes.len()) {
		return false
	}

	for i, k := range n.keys.list {
		nd := n.nodes.list[i]
		if !assert.NotNil(t, nd) {
			return false
		}

		if !assert.True(t, k.Compare(nd.key()) >= 0) {
			t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, k, nd)
			return false
		}
	}

	k := n.keys.last()
	nd := n.nodes.byPosition(n.nodes.len() - 1)
	if !assert.True(t, k.Compare(nd.key()) < 0) {
		t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, nd, k)
		return false
	}
	for _, child := range n.nodes.list {
		if !assert.NotNil(t, child) {
			return false
		}
		if !checkNode(t, child) {
			return false
		}
	}

	return true
} PrettyPrintBody:[{ if n.keys.len() == 0 { assert.Equal(t, uint64(0), n.nodes.len()) return false } if n.isLeaf { assert.Equal(t, uint64(0), n.nodes.len()) return false } if !assert.Equal(t, n.keys.len()+1, n.nodes.len()) { return false } for i, k := range n.keys.list { nd := n.nodes.list[i] if !assert.NotNil(t, nd) { return false } if !assert.True(t, k.Compare(nd.key()) >= 0) { t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, k, nd) return false } } k := n.keys.last() nd := n.nodes.byPosition(n.nodes.len() - 1) if !assert.True(t, k.Compare(nd.key()) < 0) { t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, nd, k) return false } for _, child := range n.nodes.list { if !assert.NotNil(t, child) { return false } if !checkNode(t, child) { return false } } return true }]} {Id:3 FileId:57 StartLine:86 StartColumn:1 EndLine:88 EndColumn:2 Name:getConsoleLogger Params:[] Results:[{Name: Type:*log.Logger}] Receiver:<nil> Body:{
	return log.New(os.Stderr, "", log.LstdFlags)
} PrettyPrintBody:[{ return log.New(os.Stderr, "", log.LstdFlags) }]} {Id:4 FileId:57 StartLine:90 StartColumn:1 EndLine:97 EndColumn:2 Name:generateRandomKeys Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	keys := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		m := rand.Int()
		keys = append(keys, mockKey(m%50))
	}
	return keys
} PrettyPrintBody:[{ keys := make(common.Comparators, 0, num) for i := 0; i < num; i++ { m := rand.Int() keys = append(keys, mockKey(m%50)) } return keys }]} {Id:5 FileId:57 StartLine:99 StartColumn:1 EndLine:106 EndColumn:2 Name:generateKeys Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	keys := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		keys = append(keys, mockKey(i))
	}

	return keys
} PrettyPrintBody:[{ keys := make(common.Comparators, 0, num) for i := 0; i < num; i++ { keys = append(keys, mockKey(i)) } return keys }]} {Id:6 FileId:57 StartLine:108 StartColumn:1 EndLine:117 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)

	tree.Insert(m1)
	assert.Equal(t, common.Comparators{m1}, tree.Get(m1))
	assert.Equal(t, uint64(1), tree.Len())
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) assert.Equal(t, common.Comparators{m1}, tree.Get(m1)) assert.Equal(t, uint64(1), tree.Len()) checkTree(t, tree) }]} {Id:7 FileId:57 StartLine:119 StartColumn:1 EndLine:129 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(8, 8)
	defer tree.Dispose()
	m1 := mockKey(1)
	tree.Insert(m1)

	tree.Delete(m1)
	assert.Equal(t, uint64(0), tree.Len())
	assert.Equal(t, common.Comparators{nil}, tree.Get(m1))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(8, 8) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) tree.Delete(m1) assert.Equal(t, uint64(0), tree.Len()) assert.Equal(t, common.Comparators{nil}, tree.Get(m1)) checkTree(t, tree) }]} {Id:8 FileId:57 StartLine:131 StartColumn:1 EndLine:143 EndColumn:2 Name:TestMultipleAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(10)

	tree.Insert(m1, m2)
	if !assert.Equal(t, common.Comparators{m1, m2}, tree.Get(m1, m2)) {
		tree.print(getConsoleLogger())
	}
	assert.Equal(t, uint64(2), tree.Len())
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(10) tree.Insert(m1, m2) if !assert.Equal(t, common.Comparators{m1, m2}, tree.Get(m1, m2)) { tree.print(getConsoleLogger()) } assert.Equal(t, uint64(2), tree.Len()) checkTree(t, tree) }]} {Id:9 FileId:57 StartLine:145 StartColumn:1 EndLine:156 EndColumn:2 Name:TestMultipleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(16, 16)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(10)
	tree.Insert(m1, m2)

	tree.Delete(m1, m2)
	assert.Equal(t, uint64(0), tree.Len())
	assert.Equal(t, common.Comparators{nil, nil}, tree.Get(m1, m2))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(16, 16) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(10) tree.Insert(m1, m2) tree.Delete(m1, m2) assert.Equal(t, uint64(0), tree.Len()) assert.Equal(t, common.Comparators{nil, nil}, tree.Get(m1, m2)) checkTree(t, tree) }]} {Id:10 FileId:57 StartLine:158 StartColumn:1 EndLine:169 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)

	tree.Insert(reversed...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:11 FileId:57 StartLine:171 StartColumn:1 EndLine:185 EndColumn:2 Name:TestMultipleDeleteOddAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)
	tree.Insert(reversed...)
	assert.Equal(t, uint64(100), tree.Len())

	tree.Delete(reversed...)
	assert.Equal(t, uint64(0), tree.Len())
	for _, k := range reversed {
		assert.Equal(t, common.Comparators{nil}, tree.Get(k))
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) assert.Equal(t, uint64(100), tree.Len()) tree.Delete(reversed...) assert.Equal(t, uint64(0), tree.Len()) for _, k := range reversed { assert.Equal(t, common.Comparators{nil}, tree.Get(k)) } checkTree(t, tree) }]} {Id:12 FileId:57 StartLine:187 StartColumn:1 EndLine:197 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:13 FileId:57 StartLine:199 StartColumn:1 EndLine:209 EndColumn:2 Name:TestMultipleInsertCausesSplitOddAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateRandomKeys(10)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateRandomKeys(10) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:14 FileId:57 StartLine:211 StartColumn:1 EndLine:229 EndColumn:2 Name:TestMultipleBulkInsertOddAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys1 := generateRandomKeys(100)
	keys2 := generateRandomKeys(100)

	tree.Insert(keys1...)

	if !assert.Equal(t, keys1, tree.Get(keys1...)) {
		tree.print(getConsoleLogger())
	}

	tree.Insert(keys2...)

	if !assert.Equal(t, keys2, tree.Get(keys2...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys1 := generateRandomKeys(100) keys2 := generateRandomKeys(100) tree.Insert(keys1...) if !assert.Equal(t, keys1, tree.Get(keys1...)) { tree.print(getConsoleLogger()) } tree.Insert(keys2...) if !assert.Equal(t, keys2, tree.Get(keys2...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:15 FileId:57 StartLine:231 StartColumn:1 EndLine:248 EndColumn:2 Name:TestMultipleBulkInsertEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys1 := generateRandomKeys(100)
	keys2 := generateRandomKeys(100)

	tree.Insert(keys1...)
	tree.Insert(keys2...)

	if !assert.Equal(t, keys1, tree.Get(keys1...)) {
		tree.print(getConsoleLogger())
	}

	if !assert.Equal(t, keys2, tree.Get(keys2...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys1 := generateRandomKeys(100) keys2 := generateRandomKeys(100) tree.Insert(keys1...) tree.Insert(keys2...) if !assert.Equal(t, keys1, tree.Get(keys1...)) { tree.print(getConsoleLogger()) } if !assert.Equal(t, keys2, tree.Get(keys2...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:16 FileId:57 StartLine:250 StartColumn:1 EndLine:261 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(100)
	reversed := reverseKeys(keys)

	tree.Insert(reversed...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(100) reversed := reverseKeys(keys) tree.Insert(reversed...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:17 FileId:57 StartLine:263 StartColumn:1 EndLine:273 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAry Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:18 FileId:57 StartLine:275 StartColumn:1 EndLine:285 EndColumn:2 Name:TestMultipleInsertCausesSplitEvenAryRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateRandomKeys(100)

	tree.Insert(keys...)
	if !assert.Equal(t, keys, tree.Get(keys...)) {
		tree.print(getConsoleLogger())
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateRandomKeys(100) tree.Insert(keys...) if !assert.Equal(t, keys, tree.Get(keys...)) { tree.print(getConsoleLogger()) } checkTree(t, tree) }]} {Id:19 FileId:57 StartLine:287 StartColumn:1 EndLine:297 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(4, 4)
	defer tree.Dispose()
	keys := generateKeys(10)
	duplicate := mockKey(0)
	tree.Insert(keys...)

	tree.Insert(duplicate)
	assert.Equal(t, common.Comparators{duplicate}, tree.Get(duplicate))
	checkTree(t, tree)
} PrettyPrintBody:[{ tree := newTree(4, 4) defer tree.Dispose() keys := generateKeys(10) duplicate := mockKey(0) tree.Insert(keys...) tree.Insert(duplicate) assert.Equal(t, common.Comparators{duplicate}, tree.Get(duplicate)) checkTree(t, tree) }]} {Id:20 FileId:57 StartLine:299 StartColumn:1 EndLine:324 EndColumn:2 Name:TestSimultaneousReadsAndWrites Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numLoops := 3
	keys := make([]common.Comparators, 0, numLoops)
	for i := 0; i < numLoops; i++ {
		keys = append(keys, generateRandomKeys(10))
	}

	tree := newTree(16, 16)
	defer tree.Dispose()
	var wg sync.WaitGroup
	wg.Add(numLoops)
	for i := 0; i < numLoops; i++ {
		go func(i int) {
			tree.Insert(keys[i]...)
			tree.Get(keys[i]...)
			wg.Done()
		}(i)
	}

	wg.Wait()

	for i := 0; i < numLoops; i++ {
		assert.Equal(t, keys[i], tree.Get(keys[i]...))
	}
	checkTree(t, tree)
} PrettyPrintBody:[{ numLoops := 3 keys := make([]common.Comparators, 0, numLoops) for i := 0; i < numLoops; i++ { keys = append(keys, generateRandomKeys(10)) } tree := newTree(16, 16) defer tree.Dispose() var wg sync.WaitGroup wg.Add(numLoops) for i := 0; i < numLoops; i++ { go func(i int) { tree.Insert(keys[i]...) tree.Get(keys[i]...) wg.Done() }(i) } wg.Wait() for i := 0; i < numLoops; i++ { assert.Equal(t, keys[i], tree.Get(keys[i]...)) } checkTree(t, tree) }]} {Id:21 FileId:57 StartLine:326 StartColumn:1 EndLine:352 EndColumn:2 Name:TestInsertAndDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1024, 1024)
	defer tree.Dispose()

	keys := generateKeys(100)
	keys1 := keys[:50]
	keys2 := keys[50:]
	tree.Insert(keys1...)
	assert.Equal(t, uint64(len(keys1)), tree.Len())
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		tree.Insert(keys2...)
		wg.Done()
	}()

	go func() {
		tree.Delete(keys1...)
		wg.Done()
	}()

	wg.Wait()

	assert.Equal(t, uint64(len(keys2)), tree.Len())
	assert.Equal(t, keys2, tree.Get(keys2...))
} PrettyPrintBody:[{ tree := newTree(1024, 1024) defer tree.Dispose() keys := generateKeys(100) keys1 := keys[:50] keys2 := keys[50:] tree.Insert(keys1...) assert.Equal(t, uint64(len(keys1)), tree.Len()) var wg sync.WaitGroup wg.Add(2) go func() { tree.Insert(keys2...) wg.Done() }() go func() { tree.Delete(keys1...) wg.Done() }() wg.Wait() assert.Equal(t, uint64(len(keys2)), tree.Len()) assert.Equal(t, keys2, tree.Get(keys2...)) }]} {Id:22 FileId:57 StartLine:354 StartColumn:1 EndLine:380 EndColumn:2 Name:TestInsertAndDeletesWithSplits Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()

	keys := generateKeys(100)
	keys1 := keys[:50]
	keys2 := keys[50:]
	tree.Insert(keys1...)
	assert.Equal(t, uint64(len(keys1)), tree.Len())
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		tree.Insert(keys2...)
		wg.Done()
	}()

	go func() {
		tree.Delete(keys1...)
		wg.Done()
	}()

	wg.Wait()

	assert.Equal(t, uint64(len(keys2)), tree.Len())
	assert.Equal(t, keys2, tree.Get(keys2...))
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) keys1 := keys[:50] keys2 := keys[50:] tree.Insert(keys1...) assert.Equal(t, uint64(len(keys1)), tree.Len()) var wg sync.WaitGroup wg.Add(2) go func() { tree.Insert(keys2...) wg.Done() }() go func() { tree.Delete(keys1...) wg.Done() }() wg.Wait() assert.Equal(t, uint64(len(keys2)), tree.Len()) assert.Equal(t, keys2, tree.Get(keys2...)) }]} {Id:23 FileId:57 StartLine:382 StartColumn:1 EndLine:399 EndColumn:2 Name:TestSimpleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	m1 := mockKey(1)
	tree.Insert(m1)

	result := tree.Query(mockKey(0), mockKey(5))
	assert.Equal(t, common.Comparators{m1}, result)

	result = tree.Query(mockKey(0), mockKey(1))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(2), mockKey(10))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(1), mockKey(10))
	assert.Equal(t, common.Comparators{m1}, result)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() m1 := mockKey(1) tree.Insert(m1) result := tree.Query(mockKey(0), mockKey(5)) assert.Equal(t, common.Comparators{m1}, result) result = tree.Query(mockKey(0), mockKey(1)) assert.Len(t, result, 0) result = tree.Query(mockKey(2), mockKey(10)) assert.Len(t, result, 0) result = tree.Query(mockKey(1), mockKey(10)) assert.Equal(t, common.Comparators{m1}, result) }]} {Id:24 FileId:57 StartLine:401 StartColumn:1 EndLine:419 EndColumn:2 Name:TestMultipleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	m1 := mockKey(1)
	m2 := mockKey(5)
	tree.Insert(m1, m2)

	result := tree.Query(mockKey(0), mockKey(10))
	assert.Equal(t, common.Comparators{m1, m2}, result)

	result = tree.Query(mockKey(1), mockKey(5))
	assert.Equal(t, common.Comparators{m1}, result)

	result = tree.Query(mockKey(6), mockKey(10))
	assert.Len(t, result, 0)

	result = tree.Query(mockKey(5), mockKey(10))
	assert.Equal(t, common.Comparators{m2}, result)
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() m1 := mockKey(1) m2 := mockKey(5) tree.Insert(m1, m2) result := tree.Query(mockKey(0), mockKey(10)) assert.Equal(t, common.Comparators{m1, m2}, result) result = tree.Query(mockKey(1), mockKey(5)) assert.Equal(t, common.Comparators{m1}, result) result = tree.Query(mockKey(6), mockKey(10)) assert.Len(t, result, 0) result = tree.Query(mockKey(5), mockKey(10)) assert.Equal(t, common.Comparators{m2}, result) }]} {Id:25 FileId:57 StartLine:421 StartColumn:1 EndLine:431 EndColumn:2 Name:TestCrossNodeQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(3, 3)
	defer tree.Dispose()
	keys := generateKeys(100)
	tree.Insert(keys...)

	result := tree.Query(mockKey(0), mockKey(len(keys)))
	if !assert.Equal(t, keys, result) {
		tree.print(getConsoleLogger())
	}
} PrettyPrintBody:[{ tree := newTree(3, 3) defer tree.Dispose() keys := generateKeys(100) tree.Insert(keys...) result := tree.Query(mockKey(0), mockKey(len(keys))) if !assert.Equal(t, keys, result) { tree.print(getConsoleLogger()) } }]} {Id:26 FileId:57 StartLine:433 StartColumn:1 EndLine:447 EndColumn:2 Name:BenchmarkReadAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	keys := make([]common.Comparators, 0, b.N)
	for i := 0; i < b.N; i++ {
		keys = append(keys, generateRandomKeys(numItems))
	}

	tree := newTree(8, 8)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i]...)
		tree.Get(keys[i]...)
	}
} PrettyPrintBody:[{ numItems := 1000 keys := make([]common.Comparators, 0, b.N) for i := 0; i < b.N; i++ { keys = append(keys, generateRandomKeys(numItems)) } tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i]...) tree.Get(keys[i]...) } }]} {Id:27 FileId:57 StartLine:449 StartColumn:1 EndLine:475 EndColumn:2 Name:BenchmarkSimultaneousReadsAndWrites Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	numRoutines := 8
	keys := generateRandomKeys(numItems)
	chunks := chunkKeys(keys, int64(numRoutines))

	trees := make([]*ptree, 0, numItems)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newTree(8, 8))
	}

	var wg sync.WaitGroup
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		wg.Add(numRoutines)
		for j := 0; j < numRoutines; j++ {
			go func(i, j int) {
				trees[i].Insert(chunks[j]...)
				trees[i].Get(chunks[j]...)
				wg.Done()
			}(i, j)
		}

		wg.Wait()
	}
} PrettyPrintBody:[{ numItems := 10000 numRoutines := 8 keys := generateRandomKeys(numItems) chunks := chunkKeys(keys, int64(numRoutines)) trees := make([]*ptree, 0, numItems) for i := 0; i < b.N; i++ { trees = append(trees, newTree(8, 8)) } var wg sync.WaitGroup b.ResetTimer() for i := 0; i < b.N; i++ { wg.Add(numRoutines) for j := 0; j < numRoutines; j++ { go func(i, j int) { trees[i].Insert(chunks[j]...) trees[i].Get(chunks[j]...) wg.Done() }(i, j) } wg.Wait() } }]} {Id:28 FileId:57 StartLine:477 StartColumn:1 EndLine:490 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	trees := make([]*ptree, 0, b.N)
	for i := 0; i < b.N; i++ {
		trees = append(trees, newTree(8, 8))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Insert(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) trees := make([]*ptree, 0, b.N) for i := 0; i < b.N; i++ { trees = append(trees, newTree(8, 8)) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Insert(keys...) } }]} {Id:29 FileId:57 StartLine:492 StartColumn:1 EndLine:502 EndColumn:2 Name:BenchmarkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keys[i%numItems]) } }]} {Id:30 FileId:57 StartLine:504 StartColumn:1 EndLine:518 EndColumn:2 Name:BenchmarkBulkAddToExisting Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000
	keySet := make([]common.Comparators, 0, b.N)
	for i := 0; i < b.N; i++ {
		keySet = append(keySet, generateRandomKeys(numItems))
	}

	tree := newTree(8, 8)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Insert(keySet[i]...)
	}
} PrettyPrintBody:[{ numItems := 100000 keySet := make([]common.Comparators, 0, b.N) for i := 0; i < b.N; i++ { keySet = append(keySet, generateRandomKeys(numItems)) } tree := newTree(8, 8) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Insert(keySet[i]...) } }]} {Id:31 FileId:57 StartLine:520 StartColumn:1 EndLine:531 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys[i%numItems]) } }]} {Id:32 FileId:57 StartLine:533 StartColumn:1 EndLine:544 EndColumn:2 Name:BenchmarkBulkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(keys...)
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(keys...) } }]} {Id:33 FileId:57 StartLine:546 StartColumn:1 EndLine:557 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateRandomKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Delete(keys[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateRandomKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Delete(keys[i%numItems]) } }]} {Id:34 FileId:57 StartLine:559 StartColumn:1 EndLine:574 EndColumn:2 Name:BenchmarkBulkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	keys := generateRandomKeys(numItems)
	trees := make([]*ptree, 0, b.N)
	for i := 0; i < b.N; i++ {
		tree := newTree(8, 8)
		tree.Insert(keys...)
		trees = append(trees, tree)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(keys...)
	}
} PrettyPrintBody:[{ numItems := 10000 keys := generateRandomKeys(numItems) trees := make([]*ptree, 0, b.N) for i := 0; i < b.N; i++ { tree := newTree(8, 8) tree.Insert(keys...) trees = append(trees, tree) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(keys...) } }]} {Id:35 FileId:57 StartLine:576 StartColumn:1 EndLine:587 EndColumn:2 Name:BenchmarkFindQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(mockKey(numItems/2), mockKey(numItems/2+1))
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(mockKey(numItems/2), mockKey(numItems/2+1)) } }]} {Id:36 FileId:57 StartLine:589 StartColumn:1 EndLine:600 EndColumn:2 Name:BenchmarkExecuteQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	keys := generateKeys(numItems)
	tree := newTree(8, 8)
	tree.Insert(keys...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(mockKey(0), mockKey(numItems))
	}
} PrettyPrintBody:[{ numItems := b.N keys := generateKeys(numItems) tree := newTree(8, 8) tree.Insert(keys...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(mockKey(0), mockKey(numItems)) } }]} {Id:1 FileId:147 StartLine:30 StartColumn:1 EndLine:81 EndColumn:2 Name:TestCtrie Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)

	_, ok := ctrie.Lookup([]byte("foo"))
	assert.False(ok)

	ctrie.Insert([]byte("foo"), "bar")
	val, ok := ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)

	ctrie.Insert([]byte("fooooo"), "baz")
	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)
	val, ok = ctrie.Lookup([]byte("fooooo"))
	assert.True(ok)
	assert.Equal("baz", val)

	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), "blah")
	}
	for i := 0; i < 100; i++ {
		val, ok = ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal("blah", val)
	}

	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("bar", val)
	ctrie.Insert([]byte("foo"), "qux")
	val, ok = ctrie.Lookup([]byte("foo"))
	assert.True(ok)
	assert.Equal("qux", val)

	val, ok = ctrie.Remove([]byte("foo"))
	assert.True(ok)
	assert.Equal("qux", val)

	_, ok = ctrie.Remove([]byte("foo"))
	assert.False(ok)

	val, ok = ctrie.Remove([]byte("fooooo"))
	assert.True(ok)
	assert.Equal("baz", val)

	for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) _, ok := ctrie.Lookup([]byte("foo")) assert.False(ok) ctrie.Insert([]byte("foo"), "bar") val, ok := ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) ctrie.Insert([]byte("fooooo"), "baz") val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) val, ok = ctrie.Lookup([]byte("fooooo")) assert.True(ok) assert.Equal("baz", val) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), "blah") } for i := 0; i < 100; i++ { val, ok = ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal("blah", val) } val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("bar", val) ctrie.Insert([]byte("foo"), "qux") val, ok = ctrie.Lookup([]byte("foo")) assert.True(ok) assert.Equal("qux", val) val, ok = ctrie.Remove([]byte("foo")) assert.True(ok) assert.Equal("qux", val) _, ok = ctrie.Remove([]byte("foo")) assert.False(ok) val, ok = ctrie.Remove([]byte("fooooo")) assert.True(ok) assert.Equal("baz", val) for i := 0; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } }]} {Id:3 FileId:147 StartLine:87 StartColumn:1 EndLine:89 EndColumn:2 Name:Sum32 Params:[] Results:[{Name: Type:uint32}] Receiver:0xc000a8b7e0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:4 FileId:147 StartLine:91 StartColumn:1 EndLine:93 EndColumn:2 Name:mockHashFactory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return &mockHash32{fnv.New32a()}
} PrettyPrintBody:[{ return &mockHash32{fnv.New32a()} }]} {Id:5 FileId:147 StartLine:95 StartColumn:1 EndLine:116 EndColumn:2 Name:TestInsertLNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(mockHashFactory)

	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
	_, ok := ctrie.Lookup([]byte("11"))
	assert.False(ok)

	for i := 0; i < 10; i++ {
		val, ok := ctrie.Remove([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(mockHashFactory) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 10; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } _, ok := ctrie.Lookup([]byte("11")) assert.False(ok) for i := 0; i < 10; i++ { val, ok := ctrie.Remove([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } }]} {Id:6 FileId:147 StartLine:118 StartColumn:1 EndLine:139 EndColumn:2 Name:TestInsertTNode Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 5000; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10000; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 5000; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } }]} {Id:7 FileId:147 StartLine:141 StartColumn:1 EndLine:170 EndColumn:2 Name:TestConcurrency Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
				assert.Equal(i, val)
			}
		}
		wg.Done()
	}()

	for i := 0; i < 10000; i++ {
		time.Sleep(5)
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	wg.Wait()
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) var wg sync.WaitGroup wg.Add(2) go func() { for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } wg.Done() }() go func() { for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) if ok { assert.Equal(i, val) } } wg.Done() }() for i := 0; i < 10000; i++ { time.Sleep(5) ctrie.Remove([]byte(strconv.Itoa(i))) } wg.Wait() }]} {Id:8 FileId:147 StartLine:172 StartColumn:1 EndLine:211 EndColumn:2 Name:TestConcurrency2 Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	var wg sync.WaitGroup
	wg.Add(4)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
				assert.Equal(i, val)
			}
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Snapshot()
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.ReadOnlySnapshot()
		}
		wg.Done()
	}()

	wg.Wait()
	assert.Equal(uint(10000), ctrie.Size())
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) var wg sync.WaitGroup wg.Add(4) go func() { for i := 0; i < 10000; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } wg.Done() }() go func() { for i := 0; i < 10000; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) if ok { assert.Equal(i, val) } } wg.Done() }() go func() { for i := 0; i < 10000; i++ { ctrie.Snapshot() } wg.Done() }() go func() { for i := 0; i < 10000; i++ { ctrie.ReadOnlySnapshot() } wg.Done() }() wg.Wait() assert.Equal(uint(10000), ctrie.Size()) }]} {Id:9 FileId:147 StartLine:213 StartColumn:1 EndLine:287 EndColumn:2 Name:TestSnapshot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	snapshot := ctrie.Snapshot()

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	ctrie = New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	snapshot = ctrie.Snapshot()

	for i := 0; i < 100; i++ {
		snapshot.Remove([]byte(strconv.Itoa(i)))
	}
	snapshot.Insert([]byte("bat"), "man")

	for i := 0; i < 100; i++ {
		_, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.False(ok)
	}
	val, ok := snapshot.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)

	for i := 0; i < 100; i++ {
		val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}
	_, ok = ctrie.Lookup([]byte("bat"))
	assert.False(ok)

	snapshot2 := snapshot.Snapshot()
	for i := 0; i < 100; i++ {
		_, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
		assert.False(ok)
	}
	val, ok = snapshot2.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)

	snapshot2.Remove([]byte("bat"))
	_, ok = snapshot2.Lookup([]byte("bat"))
	assert.False(ok)
	val, ok = snapshot.Lookup([]byte("bat"))
	assert.True(ok)
	assert.Equal("man", val)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot := ctrie.Snapshot() for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } for i := 0; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } ctrie = New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot = ctrie.Snapshot() for i := 0; i < 100; i++ { snapshot.Remove([]byte(strconv.Itoa(i))) } snapshot.Insert([]byte("bat"), "man") for i := 0; i < 100; i++ { _, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.False(ok) } val, ok := snapshot.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) for i := 0; i < 100; i++ { val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } _, ok = ctrie.Lookup([]byte("bat")) assert.False(ok) snapshot2 := snapshot.Snapshot() for i := 0; i < 100; i++ { _, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))) assert.False(ok) } val, ok = snapshot2.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) snapshot2.Remove([]byte("bat")) _, ok = snapshot2.Lookup([]byte("bat")) assert.False(ok) val, ok = snapshot.Lookup([]byte("bat")) assert.True(ok) assert.Equal("man", val) }]} {Id:10 FileId:147 StartLine:289 StartColumn:1 EndLine:342 EndColumn:2 Name:TestReadOnlySnapshot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	snapshot := ctrie.ReadOnlySnapshot()

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	for i := 0; i < 50; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 100; i++ {
		val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	func() {
		defer func() {
			assert.NotNil(recover())
		}()
		snapshot.Remove([]byte("blah"))
	}()

	snapshot2 := snapshot.Snapshot()
	for i := 50; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
	for i := 0; i < 100; i++ {
		val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
		assert.True(ok)
		assert.Equal(i, val)
	}

	func() {
		defer func() {
			assert.NotNil(recover())
		}()
		snapshot2.Remove([]byte("blah"))
	}()
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 100; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } snapshot := ctrie.ReadOnlySnapshot() for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } for i := 0; i < 50; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } func() { defer func() { assert.NotNil(recover()) }() snapshot.Remove([]byte("blah")) }() snapshot2 := snapshot.Snapshot() for i := 50; i < 100; i++ { ctrie.Remove([]byte(strconv.Itoa(i))) } for i := 0; i < 100; i++ { val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))) assert.True(ok) assert.Equal(i, val) } func() { defer func() { assert.NotNil(recover()) }() snapshot2.Remove([]byte("blah")) }() }]} {Id:11 FileId:147 StartLine:344 StartColumn:1 EndLine:389 EndColumn:2 Name:TestIterator Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	expected := map[string]int{
		"0":	0,
		"1":	1,
		"2":	2,
		"3":	3,
		"4":	4,
		"5":	5,
		"6":	6,
		"7":	7,
		"8":	8,
		"9":	9,
	}

	count := 0
	for entry := range ctrie.Iterator(nil) {
		exp, ok := expected[string(entry.Key)]
		if assert.True(ok) {
			assert.Equal(exp, entry.Value)
		}
		count++
	}
	assert.Equal(len(expected), count)

	cancel := make(chan struct{})
	iter := ctrie.Iterator(cancel)
	entry := <-iter
	exp, ok := expected[string(entry.Key)]
	if assert.True(ok) {
		assert.Equal(exp, entry.Value)
	}
	close(cancel)

	for _ = range expected {
		<-iter
	}
	_, ok = <-iter
	assert.False(ok)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } expected := map[string]int{ "0":	0, "1":	1, "2":	2, "3":	3, "4":	4, "5":	5, "6":	6, "7":	7, "8":	8, "9":	9, } count := 0 for entry := range ctrie.Iterator(nil) { exp, ok := expected[string(entry.Key)] if assert.True(ok) { assert.Equal(exp, entry.Value) } count++ } assert.Equal(len(expected), count) cancel := make(chan struct{}) iter := ctrie.Iterator(cancel) entry := <-iter exp, ok := expected[string(entry.Key)] if assert.True(ok) { assert.Equal(exp, entry.Value) } close(cancel) for _ = range expected { <-iter } _, ok = <-iter assert.False(ok) }]} {Id:12 FileId:147 StartLine:392 StartColumn:1 EndLine:407 EndColumn:2 Name:TestIteratorCoversTNodes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(mockHashFactory)

	ctrie.Insert([]byte("a"), true)
	ctrie.Insert([]byte("b"), true)

	ctrie.Remove([]byte("b"))
	seenKeys := map[string]bool{}
	for entry := range ctrie.Iterator(nil) {
		seenKeys[string(entry.Key)] = true
	}
	assert.Contains(seenKeys, "a", "Iterator did not return 'a'.")
	assert.Len(seenKeys, 1)
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(mockHashFactory) ctrie.Insert([]byte("a"), true) ctrie.Insert([]byte("b"), true) ctrie.Remove([]byte("b")) seenKeys := map[string]bool{} for entry := range ctrie.Iterator(nil) { seenKeys[string(entry.Key)] = true } assert.Contains(seenKeys, "a", "Iterator did not return 'a'.") assert.Len(seenKeys, 1) }]} {Id:13 FileId:147 StartLine:409 StartColumn:1 EndLine:415 EndColumn:2 Name:TestSize Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	assert.Equal(t, uint(10), ctrie.Size())
} PrettyPrintBody:[{ ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } assert.Equal(t, uint(10), ctrie.Size()) }]} {Id:14 FileId:147 StartLine:417 StartColumn:1 EndLine:430 EndColumn:2 Name:TestClear Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert := assert.New(t)
	ctrie := New(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	assert.Equal(uint(10), ctrie.Size())
	snapshot := ctrie.Snapshot()

	ctrie.Clear()

	assert.Equal(uint(0), ctrie.Size())
	assert.Equal(uint(10), snapshot.Size())
} PrettyPrintBody:[{ assert := assert.New(t) ctrie := New(nil) for i := 0; i < 10; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } assert.Equal(uint(10), ctrie.Size()) snapshot := ctrie.Snapshot() ctrie.Clear() assert.Equal(uint(0), ctrie.Size()) assert.Equal(uint(10), snapshot.Size()) }]} {Id:16 FileId:147 StartLine:434 StartColumn:1 EndLine:436 EndColumn:2 Name:Sum32 Params:[] Results:[{Name: Type:uint32}] Receiver:0xc00019f0e0 Body:{
	return 42
} PrettyPrintBody:[{ return 42 }]} {Id:17 FileId:147 StartLine:438 StartColumn:1 EndLine:440 EndColumn:2 Name:Sum Params:[{Name:b Type:[]byte}] Results:[{Name: Type:[]byte}] Receiver:0xc00095bc60 Body:{
	return nil
} PrettyPrintBody:[{ return nil }]} {Id:18 FileId:147 StartLine:442 StartColumn:1 EndLine:444 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:int}] Receiver:0xc00095bca0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:19 FileId:147 StartLine:446 StartColumn:1 EndLine:448 EndColumn:2 Name:BlockSize Params:[] Results:[{Name: Type:int}] Receiver:0xc00095bce0 Body:{
	return 0
} PrettyPrintBody:[{ return 0 }]} {Id:20 FileId:147 StartLine:450 StartColumn:1 EndLine:452 EndColumn:2 Name:Reset Params:[] Results:[] Receiver:0xc0006b8020 Body:{

} PrettyPrintBody:[{ }]} {Id:21 FileId:147 StartLine:454 StartColumn:1 EndLine:456 EndColumn:2 Name:Write Params:[{Name:b Type:[]byte}] Results:[{Name: Type:int} {Name: Type:error}] Receiver:0xc0006b8140 Body:{
	return 0, nil
} PrettyPrintBody:[{ return 0, nil }]} {Id:22 FileId:147 StartLine:458 StartColumn:1 EndLine:460 EndColumn:2 Name:factory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return &fakehash{}
} PrettyPrintBody:[{ return &fakehash{} }]} {Id:23 FileId:147 StartLine:462 StartColumn:1 EndLine:475 EndColumn:2 Name:TestHashCollision Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	trie := New(factory)
	trie.Insert([]byte("foobar"), 1)
	trie.Insert([]byte("zogzog"), 2)
	trie.Insert([]byte("foobar"), 3)
	val, exists := trie.Lookup([]byte("foobar"))
	assert.True(t, exists)
	assert.Equal(t, 3, val)

	trie.Remove([]byte("foobar"))

	_, exists = trie.Lookup([]byte("foobar"))
	assert.False(t, exists)
} PrettyPrintBody:[{ trie := New(factory) trie.Insert([]byte("foobar"), 1) trie.Insert([]byte("zogzog"), 2) trie.Insert([]byte("foobar"), 3) val, exists := trie.Lookup([]byte("foobar")) assert.True(t, exists) assert.Equal(t, 3, val) trie.Remove([]byte("foobar")) _, exists = trie.Lookup([]byte("foobar")) assert.False(t, exists) }]} {Id:24 FileId:147 StartLine:477 StartColumn:1 EndLine:483 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ctrie := New(nil)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctrie.Insert([]byte("foo"), 0)
	}
} PrettyPrintBody:[{ ctrie := New(nil) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Insert([]byte("foo"), 0) } }]} {Id:25 FileId:147 StartLine:485 StartColumn:1 EndLine:497 EndColumn:2 Name:BenchmarkLookup Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Lookup(key)
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } key := []byte(strconv.Itoa(numItems / 2)) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Lookup(key) } }]} {Id:26 FileId:147 StartLine:499 StartColumn:1 EndLine:511 EndColumn:2 Name:BenchmarkRemove Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Remove(key)
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } key := []byte(strconv.Itoa(numItems / 2)) b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Remove(key) } }]} {Id:27 FileId:147 StartLine:513 StartColumn:1 EndLine:524 EndColumn:2 Name:BenchmarkSnapshot Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Snapshot()
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.Snapshot() } }]} {Id:28 FileId:147 StartLine:526 StartColumn:1 EndLine:537 EndColumn:2 Name:BenchmarkReadOnlySnapshot Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000
	ctrie := New(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.ReadOnlySnapshot()
	}
} PrettyPrintBody:[{ numItems := 1000 ctrie := New(nil) for i := 0; i < numItems; i++ { ctrie.Insert([]byte(strconv.Itoa(i)), i) } b.ResetTimer() for i := 0; i < b.N; i++ { ctrie.ReadOnlySnapshot() } }]} {Id:1 FileId:133 StartLine:28 StartColumn:1 EndLine:35 EndColumn:2 Name:generateMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	entries := make(common.Comparators, 0, num)
	for i := uint64(0); i < uint64(num); i++ {
		entries = append(entries, newMockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, num) for i := uint64(0); i < uint64(num); i++ { entries = append(entries, newMockEntry(i)) } return entries }]} {Id:2 FileId:133 StartLine:37 StartColumn:1 EndLine:44 EndColumn:2 Name:generateRandomMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:common.Comparators}] Receiver:<nil> Body:{
	entries := make(common.Comparators, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, newMockEntry(uint64(rand.Int())))
	}

	return entries
} PrettyPrintBody:[{ entries := make(common.Comparators, 0, num) for i := 0; i < num; i++ { entries = append(entries, newMockEntry(uint64(rand.Int()))) } return entries }]} {Id:3 FileId:133 StartLine:46 StartColumn:1 EndLine:59 EndColumn:2 Name:TestInsertByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	m3 := newMockEntry(2)
	sl := New(uint8(0))
	sl.InsertAtPosition(2, m1)
	sl.InsertAtPosition(0, m2)
	sl.InsertAtPosition(0, m3)

	assert.Equal(t, m3, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
	assert.Equal(t, m1, sl.ByPosition(2))
	assert.Nil(t, sl.ByPosition(3))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) m3 := newMockEntry(2) sl := New(uint8(0)) sl.InsertAtPosition(2, m1) sl.InsertAtPosition(0, m2) sl.InsertAtPosition(0, m3) assert.Equal(t, m3, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) assert.Equal(t, m1, sl.ByPosition(2)) assert.Nil(t, sl.ByPosition(3)) }]} {Id:4 FileId:133 StartLine:61 StartColumn:1 EndLine:70 EndColumn:2 Name:TestGetByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	assert.Equal(t, m1, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
	assert.Nil(t, sl.ByPosition(2))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) assert.Equal(t, m1, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) assert.Nil(t, sl.ByPosition(2)) }]} {Id:5 FileId:133 StartLine:72 StartColumn:1 EndLine:89 EndColumn:2 Name:TestSplitAt Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(3)
	m2 := newMockEntry(5)
	m3 := newMockEntry(7)
	sl := New(uint8(0))
	sl.Insert(m1, m2, m3)

	left, right := sl.SplitAt(1)
	assert.Equal(t, uint64(2), left.Len())
	assert.Equal(t, uint64(1), right.Len())
	assert.Equal(t, common.Comparators{m1, m2, nil}, left.Get(m1, m2, m3))
	assert.Equal(t, common.Comparators{nil, nil, m3}, right.Get(m1, m2, m3))
	assert.Equal(t, m1, left.ByPosition(0))
	assert.Equal(t, m2, left.ByPosition(1))
	assert.Equal(t, m3, right.ByPosition(0))
	assert.Equal(t, nil, left.ByPosition(2))
	assert.Equal(t, nil, right.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(3) m2 := newMockEntry(5) m3 := newMockEntry(7) sl := New(uint8(0)) sl.Insert(m1, m2, m3) left, right := sl.SplitAt(1) assert.Equal(t, uint64(2), left.Len()) assert.Equal(t, uint64(1), right.Len()) assert.Equal(t, common.Comparators{m1, m2, nil}, left.Get(m1, m2, m3)) assert.Equal(t, common.Comparators{nil, nil, m3}, right.Get(m1, m2, m3)) assert.Equal(t, m1, left.ByPosition(0)) assert.Equal(t, m2, left.ByPosition(1)) assert.Equal(t, m3, right.ByPosition(0)) assert.Equal(t, nil, left.ByPosition(2)) assert.Equal(t, nil, right.ByPosition(1)) }]} {Id:6 FileId:133 StartLine:91 StartColumn:1 EndLine:112 EndColumn:2 Name:TestSplitLargeSkipList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(100)
	leftEntries := entries[:50]
	rightEntries := entries[50:]
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(49)
	assert.Equal(t, uint64(50), left.Len())
	for _, le := range leftEntries {
		result, index := left.GetWithPosition(le)
		assert.Equal(t, le, result)
		assert.Equal(t, le, left.ByPosition(index))
	}

	assert.Equal(t, uint64(50), right.Len())
	for _, re := range rightEntries {
		result, index := right.GetWithPosition(re)
		assert.Equal(t, re, result)
		assert.Equal(t, re, right.ByPosition(index))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(100) leftEntries := entries[:50] rightEntries := entries[50:] sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(49) assert.Equal(t, uint64(50), left.Len()) for _, le := range leftEntries { result, index := left.GetWithPosition(le) assert.Equal(t, le, result) assert.Equal(t, le, left.ByPosition(index)) } assert.Equal(t, uint64(50), right.Len()) for _, re := range rightEntries { result, index := right.GetWithPosition(re) assert.Equal(t, re, result) assert.Equal(t, re, right.ByPosition(index)) } }]} {Id:7 FileId:133 StartLine:114 StartColumn:1 EndLine:135 EndColumn:2 Name:TestSplitLargeSkipListOddNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(99)
	leftEntries := entries[:50]
	rightEntries := entries[50:]
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(49)
	assert.Equal(t, uint64(50), left.Len())
	for _, le := range leftEntries {
		result, index := left.GetWithPosition(le)
		assert.Equal(t, le, result)
		assert.Equal(t, le, left.ByPosition(index))
	}

	assert.Equal(t, uint64(49), right.Len())
	for _, re := range rightEntries {
		result, index := right.GetWithPosition(re)
		assert.Equal(t, re, result)
		assert.Equal(t, re, right.ByPosition(index))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(99) leftEntries := entries[:50] rightEntries := entries[50:] sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(49) assert.Equal(t, uint64(50), left.Len()) for _, le := range leftEntries { result, index := left.GetWithPosition(le) assert.Equal(t, le, result) assert.Equal(t, le, left.ByPosition(index)) } assert.Equal(t, uint64(49), right.Len()) for _, re := range rightEntries { result, index := right.GetWithPosition(re) assert.Equal(t, re, result) assert.Equal(t, re, right.ByPosition(index)) } }]} {Id:8 FileId:133 StartLine:137 StartColumn:1 EndLine:145 EndColumn:2 Name:TestSplitAtSkipListLength Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(5)
	sl := New(uint64(0))
	sl.Insert(entries...)

	left, right := sl.SplitAt(4)
	assert.Equal(t, sl, left)
	assert.Nil(t, right)
} PrettyPrintBody:[{ entries := generateMockEntries(5) sl := New(uint64(0)) sl.Insert(entries...) left, right := sl.SplitAt(4) assert.Equal(t, sl, left) assert.Nil(t, right) }]} {Id:9 FileId:133 StartLine:147 StartColumn:1 EndLine:160 EndColumn:2 Name:TestGetWithPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	e, pos := sl.GetWithPosition(m1)
	assert.Equal(t, m1, e)
	assert.Equal(t, uint64(0), pos)

	e, pos = sl.GetWithPosition(m2)
	assert.Equal(t, m2, e)
	assert.Equal(t, uint64(1), pos)
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) e, pos := sl.GetWithPosition(m1) assert.Equal(t, m1, e) assert.Equal(t, uint64(0), pos) e, pos = sl.GetWithPosition(m2) assert.Equal(t, m2, e) assert.Equal(t, uint64(1), pos) }]} {Id:10 FileId:133 StartLine:162 StartColumn:1 EndLine:172 EndColumn:2 Name:TestReplaceAtPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))

	sl.Insert(m1, m2)
	m3 := newMockEntry(9)
	sl.ReplaceAtPosition(0, m3)
	assert.Equal(t, m3, sl.ByPosition(0))
	assert.Equal(t, m2, sl.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) m3 := newMockEntry(9) sl.ReplaceAtPosition(0, m3) assert.Equal(t, m3, sl.ByPosition(0)) assert.Equal(t, m2, sl.ByPosition(1)) }]} {Id:11 FileId:133 StartLine:174 StartColumn:1 EndLine:183 EndColumn:2 Name:TestInsertRandomGetByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateRandomMockEntries(100)
	sl := New(uint64(0))
	sl.Insert(entries...)

	for _, e := range entries {
		_, pos := sl.GetWithPosition(e)
		assert.Equal(t, e, sl.ByPosition(pos))
	}
} PrettyPrintBody:[{ entries := generateRandomMockEntries(100) sl := New(uint64(0)) sl.Insert(entries...) for _, e := range entries { _, pos := sl.GetWithPosition(e) assert.Equal(t, e, sl.ByPosition(pos)) } }]} {Id:12 FileId:133 StartLine:185 StartColumn:1 EndLine:193 EndColumn:2 Name:TestGetManyByPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	entries := generateMockEntries(10)
	sl := New(uint64(0))
	sl.Insert(entries...)

	for i, e := range entries {
		assert.Equal(t, e, sl.ByPosition(uint64(i)))
	}
} PrettyPrintBody:[{ entries := generateMockEntries(10) sl := New(uint64(0)) sl.Insert(entries...) for i, e := range entries { assert.Equal(t, e, sl.ByPosition(uint64(i))) } }]} {Id:13 FileId:133 StartLine:195 StartColumn:1 EndLine:208 EndColumn:2 Name:TestGetPositionAfterDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	sl.Delete(m1)
	assert.Equal(t, m2, sl.ByPosition(0))
	assert.Nil(t, sl.ByPosition(1))

	sl.Delete(m2)
	assert.Nil(t, sl.ByPosition(0))
	assert.Nil(t, sl.ByPosition(1))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) sl.Delete(m1) assert.Equal(t, m2, sl.ByPosition(0)) assert.Nil(t, sl.ByPosition(1)) sl.Delete(m2) assert.Nil(t, sl.ByPosition(0)) assert.Nil(t, sl.ByPosition(1)) }]} {Id:14 FileId:133 StartLine:210 StartColumn:1 EndLine:224 EndColumn:2 Name:TestGetPositionBulkDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	es := generateMockEntries(20)
	e1 := es[:10]
	e2 := es[10:]
	sl := New(uint64(0))
	sl.Insert(e1...)
	sl.Insert(e2...)

	for _, e := range e1 {
		sl.Delete(e)
	}
	for i, e := range e2 {
		assert.Equal(t, e, sl.ByPosition(uint64(i)))
	}
} PrettyPrintBody:[{ es := generateMockEntries(20) e1 := es[:10] e2 := es[10:] sl := New(uint64(0)) sl.Insert(e1...) sl.Insert(e2...) for _, e := range e1 { sl.Delete(e) } for i, e := range e2 { assert.Equal(t, e, sl.ByPosition(uint64(i))) } }]} {Id:15 FileId:133 StartLine:226 StartColumn:1 EndLine:243 EndColumn:2 Name:TestSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1)
	assert.Equal(t, common.Comparators{m1}, sl.Get(m1))
	assert.Equal(t, uint64(1), sl.Len())
	assert.Equal(t, common.Comparators{nil}, overwritten)
	assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(1)))

	overwritten = sl.Insert(m2)
	assert.Equal(t, common.Comparators{m2}, sl.Get(m2))
	assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(7)))
	assert.Equal(t, uint64(2), sl.Len())
	assert.Equal(t, common.Comparators{nil}, overwritten)
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) overwritten := sl.Insert(m1) assert.Equal(t, common.Comparators{m1}, sl.Get(m1)) assert.Equal(t, uint64(1), sl.Len()) assert.Equal(t, common.Comparators{nil}, overwritten) assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(1))) overwritten = sl.Insert(m2) assert.Equal(t, common.Comparators{m2}, sl.Get(m2)) assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(7))) assert.Equal(t, uint64(2), sl.Len()) assert.Equal(t, common.Comparators{nil}, overwritten) }]} {Id:16 FileId:133 StartLine:245 StartColumn:1 EndLine:258 EndColumn:2 Name:TestSimpleOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(5)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1)
	assert.Equal(t, common.Comparators{nil}, overwritten)
	assert.Equal(t, uint64(1), sl.Len())

	overwritten = sl.Insert(m2)
	assert.Equal(t, common.Comparators{m1}, overwritten)
	assert.Equal(t, uint64(1), sl.Len())
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(5) sl := New(uint8(0)) overwritten := sl.Insert(m1) assert.Equal(t, common.Comparators{nil}, overwritten) assert.Equal(t, uint64(1), sl.Len()) overwritten = sl.Insert(m2) assert.Equal(t, common.Comparators{m1}, overwritten) assert.Equal(t, uint64(1), sl.Len()) }]} {Id:17 FileId:133 StartLine:260 StartColumn:1 EndLine:270 EndColumn:2 Name:TestInsertOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(6)
	m2 := newMockEntry(5)

	sl := New(uint8(0))

	overwritten := sl.Insert(m1, m2)
	assert.Equal(t, common.Comparators{nil, nil}, overwritten)

	assert.Equal(t, common.Comparators{m1, m2}, sl.Get(m1, m2))
} PrettyPrintBody:[{ m1 := newMockEntry(6) m2 := newMockEntry(5) sl := New(uint8(0)) overwritten := sl.Insert(m1, m2) assert.Equal(t, common.Comparators{nil, nil}, overwritten) assert.Equal(t, common.Comparators{m1, m2}, sl.Get(m1, m2)) }]} {Id:18 FileId:133 StartLine:272 StartColumn:1 EndLine:284 EndColumn:2 Name:TestSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	sl := New(uint8(0))
	sl.Insert(m1)

	deleted := sl.Delete(m1)
	assert.Equal(t, common.Comparators{m1}, deleted)
	assert.Equal(t, uint64(0), sl.Len())
	assert.Equal(t, common.Comparators{nil}, sl.Get(m1))

	deleted = sl.Delete(m1)
	assert.Equal(t, common.Comparators{nil}, deleted)
} PrettyPrintBody:[{ m1 := newMockEntry(5) sl := New(uint8(0)) sl.Insert(m1) deleted := sl.Delete(m1) assert.Equal(t, common.Comparators{m1}, deleted) assert.Equal(t, uint64(0), sl.Len()) assert.Equal(t, common.Comparators{nil}, sl.Get(m1)) deleted = sl.Delete(m1) assert.Equal(t, common.Comparators{nil}, deleted) }]} {Id:19 FileId:133 StartLine:286 StartColumn:1 EndLine:296 EndColumn:2 Name:TestDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	m1 := newMockEntry(5)
	m2 := newMockEntry(6)
	sl := New(uint8(0))
	sl.Insert(m1, m2)

	deleted := sl.Delete(m1, m2)
	assert.Equal(t, common.Comparators{m1, m2}, deleted)
	assert.Equal(t, uint64(0), sl.Len())
	assert.Equal(t, common.Comparators{nil, nil}, sl.Get(m1, m2))
} PrettyPrintBody:[{ m1 := newMockEntry(5) m2 := newMockEntry(6) sl := New(uint8(0)) sl.Insert(m1, m2) deleted := sl.Delete(m1, m2) assert.Equal(t, common.Comparators{m1, m2}, deleted) assert.Equal(t, uint64(0), sl.Len()) assert.Equal(t, common.Comparators{nil, nil}, sl.Get(m1, m2)) }]} {Id:20 FileId:133 StartLine:298 StartColumn:1 EndLine:319 EndColumn:2 Name:TestIter Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sl := New(uint8(0))
	m1 := newMockEntry(5)
	m2 := newMockEntry(10)

	sl.Insert(m1, m2)

	iter := sl.Iter(mockEntry(0))
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(5))
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(6))
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(10))
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.Iter(mockEntry(11))
	assert.Equal(t, common.Comparators{}, iter.exhaust())
} PrettyPrintBody:[{ sl := New(uint8(0)) m1 := newMockEntry(5) m2 := newMockEntry(10) sl.Insert(m1, m2) iter := sl.Iter(mockEntry(0)) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.Iter(mockEntry(5)) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.Iter(mockEntry(6)) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.Iter(mockEntry(10)) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.Iter(mockEntry(11)) assert.Equal(t, common.Comparators{}, iter.exhaust()) }]} {Id:21 FileId:133 StartLine:321 StartColumn:1 EndLine:336 EndColumn:2 Name:TestIterAtPosition Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	sl := New(uint8(0))
	m1 := newMockEntry(5)
	m2 := newMockEntry(10)

	sl.Insert(m1, m2)

	iter := sl.IterAtPosition(0)
	assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust())

	iter = sl.IterAtPosition(1)
	assert.Equal(t, common.Comparators{m2}, iter.exhaust())

	iter = sl.IterAtPosition(2)
	assert.Equal(t, common.Comparators{}, iter.exhaust())
} PrettyPrintBody:[{ sl := New(uint8(0)) m1 := newMockEntry(5) m2 := newMockEntry(10) sl.Insert(m1, m2) iter := sl.IterAtPosition(0) assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()) iter = sl.IterAtPosition(1) assert.Equal(t, common.Comparators{m2}, iter.exhaust()) iter = sl.IterAtPosition(2) assert.Equal(t, common.Comparators{}, iter.exhaust()) }]} {Id:22 FileId:133 StartLine:338 StartColumn:1 EndLine:349 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(entries[i%numItems]) } }]} {Id:23 FileId:133 StartLine:351 StartColumn:1 EndLine:363 EndColumn:2 Name:BenchmarkGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Get(entries[i%numItems]) } }]} {Id:24 FileId:133 StartLine:365 StartColumn:1 EndLine:377 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Delete(entries[i])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Delete(entries[i]) } }]} {Id:25 FileId:133 StartLine:379 StartColumn:1 EndLine:395 EndColumn:2 Name:BenchmarkPrepend Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))

	entries := make(common.Comparators, 0, numItems)
	for i := b.N; i < b.N+numItems; i++ {
		entries = append(entries, newMockEntry(uint64(i)))
	}

	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(newMockEntry(uint64(i)))
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := make(common.Comparators, 0, numItems) for i := b.N; i < b.N+numItems; i++ { entries = append(entries, newMockEntry(uint64(i))) } sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(newMockEntry(uint64(i))) } }]} {Id:26 FileId:133 StartLine:397 StartColumn:1 EndLine:408 EndColumn:2 Name:BenchmarkByPosition Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))
	entries := generateMockEntries(numItems)
	sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.ByPosition(uint64(i % numItems))
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateMockEntries(numItems) sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.ByPosition(uint64(i % numItems)) } }]} {Id:27 FileId:133 StartLine:410 StartColumn:1 EndLine:420 EndColumn:2 Name:BenchmarkInsertAtPosition Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := New(uint64(0))
	entries := generateRandomMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.InsertAtPosition(0, entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := New(uint64(0)) entries := generateRandomMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.InsertAtPosition(0, entries[i%numItems]) } }]} {Id:1 FileId:142 StartLine:25 StartColumn:1 EndLine:32 EndColumn:2 Name:generateMockEntries Params:[{Name:num Type:int}] Results:[{Name: Type:Entries}] Receiver:<nil> Body:{
	entries := make(Entries, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, mockEntry(i))
	}

	return entries
} PrettyPrintBody:[{ entries := make(Entries, 0, num) for i := 0; i < num; i++ { entries = append(entries, mockEntry(i)) } return entries }]} {Id:2 FileId:142 StartLine:34 StartColumn:1 EndLine:54 EndColumn:2 Name:TestAVLSimpleInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(5)
	m2 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), i2.Len())
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, Entries{nil, nil}, i1.Get(m1, m2))
	assert.Equal(t, Entries{m1, m2}, i2.Get(m1, m2))

	m3 := mockEntry(1)

	i3, overwritten := i2.Insert(m3)
	assert.Equal(t, Entries{nil}, overwritten)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, uint64(2), i2.Len())
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(5) m2 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), i2.Len()) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, Entries{nil, nil}, i1.Get(m1, m2)) assert.Equal(t, Entries{m1, m2}, i2.Get(m1, m2)) m3 := mockEntry(1) i3, overwritten := i2.Insert(m3) assert.Equal(t, Entries{nil}, overwritten) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, uint64(2), i2.Len()) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3)) }]} {Id:3 FileId:142 StartLine:56 StartColumn:1 EndLine:78 EndColumn:2 Name:TestAVLInsertRightLeaning Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))

	m4 := mockEntry(15)
	m5 := mockEntry(20)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) m4 := mockEntry(15) m5 := mockEntry(20) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]} {Id:4 FileId:142 StartLine:80 StartColumn:1 EndLine:101 EndColumn:2 Name:TestAVLInsertRightLeaningDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(10)
	m3 := mockEntry(5)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(20)
	m5 := mockEntry(15)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(10) m3 := mockEntry(5) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(20) m5 := mockEntry(15) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]} {Id:5 FileId:142 StartLine:103 StartColumn:1 EndLine:125 EndColumn:2 Name:TestAVLInsertLeftLeaning Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(15)
	m3 := mockEntry(10)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(5)
	m5 := mockEntry(1)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(15) m3 := mockEntry(10) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(5) m5 := mockEntry(1) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) }]} {Id:6 FileId:142 StartLine:127 StartColumn:1 EndLine:150 EndColumn:2 Name:TestAVLInsertLeftLeaningDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(10)
	m3 := mockEntry(15)

	i2, overwritten := i1.Insert(m1, m2, m3)
	assert.Equal(t, Entries{nil, nil, nil}, overwritten)
	assert.Equal(t, uint64(0), i1.Len())
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))

	m4 := mockEntry(1)
	m5 := mockEntry(5)

	i3, overwritten := i2.Insert(m4, m5)
	assert.Equal(t, Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(5), i3.Len())
	assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5))
	assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5))
	assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(10) m3 := mockEntry(15) i2, overwritten := i1.Insert(m1, m2, m3) assert.Equal(t, Entries{nil, nil, nil}, overwritten) assert.Equal(t, uint64(0), i1.Len()) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) m4 := mockEntry(1) m5 := mockEntry(5) i3, overwritten := i2.Insert(m4, m5) assert.Equal(t, Entries{nil, nil}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(5), i3.Len()) assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)) assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)) assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3)) }]} {Id:7 FileId:142 StartLine:152 StartColumn:1 EndLine:167 EndColumn:2 Name:TestAVLInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(20)
	m2 := mockEntry(10)
	m3 := mockEntry(15)

	i2, _ := i1.Insert(m1, m2, m3)
	m4 := mockEntry(15)

	i3, overwritten := i2.Insert(m4)
	assert.Equal(t, Entries{m3}, overwritten)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m4}, i3.Get(m4))
	assert.Equal(t, Entries{m3}, i2.Get(m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(20) m2 := mockEntry(10) m3 := mockEntry(15) i2, _ := i1.Insert(m1, m2, m3) m4 := mockEntry(15) i3, overwritten := i2.Insert(m4) assert.Equal(t, Entries{m3}, overwritten) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m4}, i3.Get(m4)) assert.Equal(t, Entries{m3}, i2.Get(m3)) }]} {Id:8 FileId:142 StartLine:169 StartColumn:1 EndLine:197 EndColumn:2 Name:TestAVLSimpleDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(10)
	m2 := mockEntry(15)
	m3 := mockEntry(20)

	i2, _ := i1.Insert(m1, m2, m3)

	i3, deleted := i2.Delete(m3)
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(3), i2.Len())
	assert.Equal(t, uint64(2), i3.Len())
	assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3))

	i4, deleted := i3.Delete(m2)
	assert.Equal(t, Entries{m2}, deleted)
	assert.Equal(t, uint64(2), i3.Len())
	assert.Equal(t, uint64(1), i4.Len())
	assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3))
	assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3))

	i5, deleted := i4.Delete(m1)
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, uint64(0), i5.Len())
	assert.Equal(t, uint64(1), i4.Len())
	assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3))
	assert.Equal(t, Entries{nil, nil, nil}, i5.Get(m1, m2, m3))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(10) m2 := mockEntry(15) m3 := mockEntry(20) i2, _ := i1.Insert(m1, m2, m3) i3, deleted := i2.Delete(m3) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(3), i2.Len()) assert.Equal(t, uint64(2), i3.Len()) assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3)) i4, deleted := i3.Delete(m2) assert.Equal(t, Entries{m2}, deleted) assert.Equal(t, uint64(2), i3.Len()) assert.Equal(t, uint64(1), i4.Len()) assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3)) assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3)) i5, deleted := i4.Delete(m1) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, uint64(0), i5.Len()) assert.Equal(t, uint64(1), i4.Len()) assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3)) assert.Equal(t, Entries{nil, nil, nil}, i5.Get(m1, m2, m3)) }]} {Id:9 FileId:142 StartLine:199 StartColumn:1 EndLine:215 EndColumn:2 Name:TestAVLDeleteWithRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)
	m5 := mockEntry(20)

	i2, _ := i1.Insert(m1, m2, m3, m4, m5)
	assert.Equal(t, uint64(5), i2.Len())

	i3, deleted := i2.Delete(m1)
	assert.Equal(t, uint64(4), i3.Len())
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, Entries{m1, m2, m3, m4, m5}, i2.Get(m1, m2, m3, m4, m5))
	assert.Equal(t, Entries{nil, m2, m3, m4, m5}, i3.Get(m1, m2, m3, m4, m5))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) m5 := mockEntry(20) i2, _ := i1.Insert(m1, m2, m3, m4, m5) assert.Equal(t, uint64(5), i2.Len()) i3, deleted := i2.Delete(m1) assert.Equal(t, uint64(4), i3.Len()) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, Entries{m1, m2, m3, m4, m5}, i2.Get(m1, m2, m3, m4, m5)) assert.Equal(t, Entries{nil, m2, m3, m4, m5}, i3.Get(m1, m2, m3, m4, m5)) }]} {Id:10 FileId:142 StartLine:217 StartColumn:1 EndLine:232 EndColumn:2 Name:TestAVLDeleteWithDoubleRotation Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted := i2.Delete(m1)
	assert.Equal(t, Entries{m1}, deleted)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4))
	assert.Equal(t, Entries{nil, m2, m3, m4}, i3.Get(m1, m2, m3, m4))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) assert.Equal(t, uint64(4), i2.Len()) i3, deleted := i2.Delete(m1) assert.Equal(t, Entries{m1}, deleted) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4)) assert.Equal(t, Entries{nil, m2, m3, m4}, i3.Get(m1, m2, m3, m4)) }]} {Id:11 FileId:142 StartLine:234 StartColumn:1 EndLine:249 EndColumn:2 Name:TestAVLDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted := i2.Delete(m1, m2, m3, m4)
	assert.Equal(t, Entries{m1, m2, m3, m4}, deleted)
	assert.Equal(t, uint64(0), i3.Len())
	assert.Equal(t, Entries{nil, nil, nil, nil}, i3.Get(m1, m2, m3, m4))
	assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4))
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) assert.Equal(t, uint64(4), i2.Len()) i3, deleted := i2.Delete(m1, m2, m3, m4) assert.Equal(t, Entries{m1, m2, m3, m4}, deleted) assert.Equal(t, uint64(0), i3.Len()) assert.Equal(t, Entries{nil, nil, nil, nil}, i3.Get(m1, m2, m3, m4)) assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4)) }]} {Id:12 FileId:142 StartLine:251 StartColumn:1 EndLine:262 EndColumn:2 Name:TestAVLDeleteNotLeaf Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)
	i3, deleted := i2.Delete(m3)
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(3), i3.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) i3, deleted := i2.Delete(m3) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(3), i3.Len()) }]} {Id:13 FileId:142 StartLine:264 StartColumn:1 EndLine:276 EndColumn:2 Name:TestAVLBulkDeleteAll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	entries := generateMockEntries(5)
	i2, _ := i1.Insert(entries...)

	i3, deleted := i2.Delete(entries...)
	assert.Equal(t, entries, deleted)
	assert.Equal(t, uint64(0), i3.Len())

	i3, deleted = i2.Delete(entries...)
	assert.Equal(t, entries, deleted)
	assert.Equal(t, uint64(0), i3.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() entries := generateMockEntries(5) i2, _ := i1.Insert(entries...) i3, deleted := i2.Delete(entries...) assert.Equal(t, entries, deleted) assert.Equal(t, uint64(0), i3.Len()) i3, deleted = i2.Delete(entries...) assert.Equal(t, entries, deleted) assert.Equal(t, uint64(0), i3.Len()) }]} {Id:14 FileId:142 StartLine:278 StartColumn:1 EndLine:296 EndColumn:2 Name:TestAVLDeleteReplay Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	i1 := NewImmutable()
	m1 := mockEntry(1)
	m2 := mockEntry(5)
	m3 := mockEntry(10)
	m4 := mockEntry(15)

	i2, _ := i1.Insert(m2, m1, m3, m4)

	i3, deleted := i2.Delete(m3)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(4), i2.Len())

	i3, deleted = i2.Delete(m3)
	assert.Equal(t, uint64(3), i3.Len())
	assert.Equal(t, Entries{m3}, deleted)
	assert.Equal(t, uint64(4), i2.Len())
} PrettyPrintBody:[{ i1 := NewImmutable() m1 := mockEntry(1) m2 := mockEntry(5) m3 := mockEntry(10) m4 := mockEntry(15) i2, _ := i1.Insert(m2, m1, m3, m4) i3, deleted := i2.Delete(m3) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(4), i2.Len()) i3, deleted = i2.Delete(m3) assert.Equal(t, uint64(3), i3.Len()) assert.Equal(t, Entries{m3}, deleted) assert.Equal(t, uint64(4), i2.Len()) }]} {Id:15 FileId:142 StartLine:298 StartColumn:1 EndLine:319 EndColumn:2 Name:TestAVLFails Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	keys := []mockEntry{
		mockEntry(0),
		mockEntry(1),
		mockEntry(3),
		mockEntry(4),
		mockEntry(5),
		mockEntry(6),
		mockEntry(7),
		mockEntry(2),
	}
	i1 := NewImmutable()
	for _, k := range keys {
		i1, _ = i1.Insert(k)
	}

	for _, k := range keys {
		var deleted Entries
		i1, deleted = i1.Delete(k)
		assert.Equal(t, Entries{k}, deleted)
	}
} PrettyPrintBody:[{ keys := []mockEntry{ mockEntry(0), mockEntry(1), mockEntry(3), mockEntry(4), mockEntry(5), mockEntry(6), mockEntry(7), mockEntry(2), } i1 := NewImmutable() for _, k := range keys { i1, _ = i1.Insert(k) } for _, k := range keys { var deleted Entries i1, deleted = i1.Delete(k) assert.Equal(t, Entries{k}, deleted) } }]} {Id:16 FileId:142 StartLine:321 StartColumn:1 EndLine:333 EndColumn:2 Name:BenchmarkImmutableInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl, _ = sl.Insert(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl, _ = sl.Insert(entries[i%numItems]) } }]} {Id:17 FileId:142 StartLine:335 StartColumn:1 EndLine:347 EndColumn:2 Name:BenchmarkImmutableGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Get(entries[i%numItems]) } }]} {Id:18 FileId:142 StartLine:349 StartColumn:1 EndLine:360 EndColumn:2 Name:BenchmarkImmutableBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Insert(entries...)
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Insert(entries...) } }]} {Id:19 FileId:142 StartLine:362 StartColumn:1 EndLine:374 EndColumn:2 Name:BenchmarkImmutableDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl, _ = sl.Delete(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl, _ = sl.Delete(entries[i%numItems]) } }]} {Id:20 FileId:142 StartLine:376 StartColumn:1 EndLine:388 EndColumn:2 Name:BenchmarkImmutableBulkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	sl := NewImmutable()

	entries := generateMockEntries(numItems)
	sl, _ = sl.Insert(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		sl.Delete(entries...)
	}
} PrettyPrintBody:[{ numItems := b.N sl := NewImmutable() entries := generateMockEntries(numItems) sl, _ = sl.Insert(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { sl.Delete(entries...) } }]} {Id:1 FileId:114 StartLine:29 StartColumn:1 EndLine:36 EndColumn:2 Name:generateMultiDimensionalEntries Params:[{Name:num Type:int}] Results:[{Name: Type:rangetree.Entries}] Receiver:<nil> Body:{
	entries := make(rangetree.Entries, 0, num)
	for i := 0; i < num; i++ {
		entries = append(entries, newMockEntry(int64(i), int64(i)))
	}

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, num) for i := 0; i < num; i++ { entries = append(entries, newMockEntry(int64(i), int64(i))) } return entries }]} {Id:2 FileId:114 StartLine:38 StartColumn:1 EndLine:46 EndColumn:2 Name:generateRandomMultiDimensionalEntries Params:[{Name:num Type:int}] Results:[{Name: Type:rangetree.Entries}] Receiver:<nil> Body:{
	entries := make(rangetree.Entries, 0, num)
	for i := 0; i < num; i++ {
		value := rand.Int63()
		entries = append(entries, newMockEntry(value, value))
	}

	return entries
} PrettyPrintBody:[{ entries := make(rangetree.Entries, 0, num) for i := 0; i < num; i++ { value := rand.Int63() entries = append(entries, newMockEntry(value, value)) } return entries }]} {Id:3 FileId:114 StartLine:48 StartColumn:1 EndLine:57 EndColumn:2 Name:TestRTSingleDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(5)

	overwritten := rt.Add(m1, m2)
	assert.Equal(t, rangetree.Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(5) overwritten := rt.Add(m1, m2) assert.Equal(t, rangetree.Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2)) }]} {Id:4 FileId:114 StartLine:59 StartColumn:1 EndLine:68 EndColumn:2 Name:TestRTMultiDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 5)
	m2 := newMockEntry(4, 6)

	overwritten := rt.Add(m1, m2)
	assert.Equal(t, rangetree.Entries{nil, nil}, overwritten)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 5) m2 := newMockEntry(4, 6) overwritten := rt.Add(m1, m2) assert.Equal(t, rangetree.Entries{nil, nil}, overwritten) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2)) }]} {Id:5 FileId:114 StartLine:70 StartColumn:1 EndLine:83 EndColumn:2 Name:TestRTSingleDimensionOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(5)
	m2 := newMockEntry(5)

	overwritten := rt.Add(m1)
	assert.Equal(t, rangetree.Entries{nil}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())

	overwritten = rt.Add(m2)
	assert.Equal(t, rangetree.Entries{m1}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())
	assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(5) m2 := newMockEntry(5) overwritten := rt.Add(m1) assert.Equal(t, rangetree.Entries{nil}, overwritten) assert.Equal(t, uint64(1), rt.Len()) overwritten = rt.Add(m2) assert.Equal(t, rangetree.Entries{m1}, overwritten) assert.Equal(t, uint64(1), rt.Len()) assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2)) }]} {Id:6 FileId:114 StartLine:85 StartColumn:1 EndLine:98 EndColumn:2 Name:TestRTMultiDimensionOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(5, 6)
	m2 := newMockEntry(5, 6)

	overwritten := rt.Add(m1)
	assert.Equal(t, rangetree.Entries{nil}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())

	overwritten = rt.Add(m2)
	assert.Equal(t, rangetree.Entries{m1}, overwritten)
	assert.Equal(t, uint64(1), rt.Len())
	assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(5, 6) m2 := newMockEntry(5, 6) overwritten := rt.Add(m1) assert.Equal(t, rangetree.Entries{nil}, overwritten) assert.Equal(t, uint64(1), rt.Len()) overwritten = rt.Add(m2) assert.Equal(t, rangetree.Entries{m1}, overwritten) assert.Equal(t, uint64(1), rt.Len()) assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2)) }]} {Id:7 FileId:114 StartLine:100 StartColumn:1 EndLine:110 EndColumn:2 Name:TestRTSingleDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(5)
	m2 := newMockEntry(2)
	rt.Add(m1, m2)

	deleted := rt.Delete(m1, newMockEntry(10), m2)
	assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted)
	assert.Equal(t, uint64(0), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(5) m2 := newMockEntry(2) rt.Add(m1, m2) deleted := rt.Delete(m1, newMockEntry(10), m2) assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted) assert.Equal(t, uint64(0), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2)) }]} {Id:8 FileId:114 StartLine:112 StartColumn:1 EndLine:122 EndColumn:2 Name:TestRTMultiDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 5)
	m2 := newMockEntry(4, 6)
	rt.Add(m1, m2)

	deleted := rt.Delete(m1, newMockEntry(10, 10), m2)
	assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted)
	assert.Equal(t, uint64(0), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 5) m2 := newMockEntry(4, 6) rt.Add(m1, m2) deleted := rt.Delete(m1, newMockEntry(10, 10), m2) assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted) assert.Equal(t, uint64(0), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2)) }]} {Id:9 FileId:114 StartLine:124 StartColumn:1 EndLine:145 EndColumn:2 Name:TestRTSingleDimensionQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	result := rt.Query(newMockInterval([]int64{1}, []int64{7}))
	assert.Equal(t, rangetree.Entries{m1, m2}, result)

	result = rt.Query(newMockInterval([]int64{6}, []int64{10}))
	assert.Equal(t, rangetree.Entries{m2, m3}, result)

	result = rt.Query(newMockInterval([]int64{9}, []int64{11}))
	assert.Equal(t, rangetree.Entries{m3}, result)

	result = rt.Query(newMockInterval([]int64{0}, []int64{3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{10}, []int64{13}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) result := rt.Query(newMockInterval([]int64{1}, []int64{7})) assert.Equal(t, rangetree.Entries{m1, m2}, result) result = rt.Query(newMockInterval([]int64{6}, []int64{10})) assert.Equal(t, rangetree.Entries{m2, m3}, result) result = rt.Query(newMockInterval([]int64{9}, []int64{11})) assert.Equal(t, rangetree.Entries{m3}, result) result = rt.Query(newMockInterval([]int64{0}, []int64{3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{10}, []int64{13})) assert.Len(t, result, 0) }]} {Id:10 FileId:114 StartLine:147 StartColumn:1 EndLine:177 EndColumn:2 Name:TestRTMultiDimensionQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	result := rt.Query(newMockInterval([]int64{1, 1}, []int64{7, 7}))
	assert.Equal(t, rangetree.Entries{m1, m2}, result)

	result = rt.Query(newMockInterval([]int64{6, 6}, []int64{10, 10}))
	assert.Equal(t, rangetree.Entries{m2, m3}, result)

	result = rt.Query(newMockInterval([]int64{9, 9}, []int64{11, 11}))
	assert.Equal(t, rangetree.Entries{m3}, result)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{10, 10}, []int64{13, 13}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{6, 1}, []int64{7, 6}))
	assert.Len(t, result, 0)

	result = rt.Query(newMockInterval([]int64{0, 0}, []int64{7, 4}))
	assert.Equal(t, rangetree.Entries{m1}, result)
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) result := rt.Query(newMockInterval([]int64{1, 1}, []int64{7, 7})) assert.Equal(t, rangetree.Entries{m1, m2}, result) result = rt.Query(newMockInterval([]int64{6, 6}, []int64{10, 10})) assert.Equal(t, rangetree.Entries{m2, m3}, result) result = rt.Query(newMockInterval([]int64{9, 9}, []int64{11, 11})) assert.Equal(t, rangetree.Entries{m3}, result) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{10, 10}, []int64{13, 13})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{6, 1}, []int64{7, 6})) assert.Len(t, result, 0) result = rt.Query(newMockInterval([]int64{0, 0}, []int64{7, 4})) assert.Equal(t, rangetree.Entries{m1}, result) }]} {Id:11 FileId:114 StartLine:179 StartColumn:1 EndLine:195 EndColumn:2 Name:TestRTSingleDimensionInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 0, 1)
	assert.Equal(t, rangetree.Entries{m1, m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())
	assert.Equal(t, rangetree.Entries{nil, nil, nil}, rt.Get(m1, m2, m3))
	e1 := newMockEntry(4)
	e2 := newMockEntry(7)
	e3 := newMockEntry(10)
	assert.Equal(t, rangetree.Entries{m1, m2, m3}, rt.Get(e1, e2, e3))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 0, 1) assert.Equal(t, rangetree.Entries{m1, m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) assert.Equal(t, rangetree.Entries{nil, nil, nil}, rt.Get(m1, m2, m3)) e1 := newMockEntry(4) e2 := newMockEntry(7) e3 := newMockEntry(10) assert.Equal(t, rangetree.Entries{m1, m2, m3}, rt.Get(e1, e2, e3)) }]} {Id:12 FileId:114 StartLine:197 StartColumn:1 EndLine:213 EndColumn:2 Name:TestRTSingleDimensionInsertNegative Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(1)
	m1 := newMockEntry(3)
	m2 := newMockEntry(6)
	m3 := newMockEntry(9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil}, rt.Get(m1, m2))

	e2 := newMockEntry(4)
	e3 := newMockEntry(7)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(1) m1 := newMockEntry(3) m2 := newMockEntry(6) m3 := newMockEntry(9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil}, rt.Get(m1, m2)) e2 := newMockEntry(4) e3 := newMockEntry(7) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]} {Id:13 FileId:114 StartLine:215 StartColumn:1 EndLine:231 EndColumn:2 Name:TestRTMultiDimensionInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(1, 4, 2)
	assert.Equal(t, rangetree.Entries{m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())

	e2 := newMockEntry(6, 8)
	e3 := newMockEntry(9, 11)
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))
	assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(1, 4, 2) assert.Equal(t, rangetree.Entries{m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) e2 := newMockEntry(6, 8) e3 := newMockEntry(9, 11) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3)) }]} {Id:14 FileId:114 StartLine:233 StartColumn:1 EndLine:249 EndColumn:2 Name:TestRTMultiDimensionInsertNegative Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(1, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(6, 4)
	e3 := newMockEntry(9, 7)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(1, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(6, 4) e3 := newMockEntry(9, 7) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]} {Id:15 FileId:114 StartLine:251 StartColumn:1 EndLine:267 EndColumn:2 Name:TestRTInsertInZeroDimensionMultiDimensionList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 4, 2)
	assert.Equal(t, rangetree.Entries{m2, m3}, affected)
	assert.Len(t, deleted, 0)
	assert.Equal(t, uint64(3), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(8, 6)
	e3 := newMockEntry(11, 9)
	assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 4, 2) assert.Equal(t, rangetree.Entries{m2, m3}, affected) assert.Len(t, deleted, 0) assert.Equal(t, uint64(3), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(8, 6) e3 := newMockEntry(11, 9) assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3)) }]} {Id:16 FileId:114 StartLine:269 StartColumn:1 EndLine:285 EndColumn:2 Name:TestRTInsertNegativeInZeroDimensionMultiDimensionList Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	m2 := newMockEntry(6, 6)
	m3 := newMockEntry(9, 9)
	rt.Add(m1, m2, m3)

	affected, deleted := rt.InsertAtDimension(0, 6, -2)
	assert.Equal(t, rangetree.Entries{m3}, affected)
	assert.Equal(t, rangetree.Entries{m2}, deleted)
	assert.Equal(t, uint64(2), rt.Len())
	assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3))

	e2 := newMockEntry(4, 6)
	e3 := newMockEntry(7, 9)
	assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) m2 := newMockEntry(6, 6) m3 := newMockEntry(9, 9) rt.Add(m1, m2, m3) affected, deleted := rt.InsertAtDimension(0, 6, -2) assert.Equal(t, rangetree.Entries{m3}, affected) assert.Equal(t, rangetree.Entries{m2}, deleted) assert.Equal(t, uint64(2), rt.Len()) assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)) e2 := newMockEntry(4, 6) e3 := newMockEntry(7, 9) assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)) }]} {Id:17 FileId:114 StartLine:287 StartColumn:1 EndLine:296 EndColumn:2 Name:TestRTInsertBeyondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	rt.Add(m1)

	affected, deleted := rt.InsertAtDimension(4, 0, 1)
	assert.Len(t, affected, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) rt.Add(m1) affected, deleted := rt.InsertAtDimension(4, 0, 1) assert.Len(t, affected, 0) assert.Len(t, deleted, 0) assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1)) }]} {Id:18 FileId:114 StartLine:298 StartColumn:1 EndLine:307 EndColumn:2 Name:TestRTInsertZero Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	rt := new(2)
	m1 := newMockEntry(3, 3)
	rt.Add(m1)

	affected, deleted := rt.InsertAtDimension(1, 0, 0)
	assert.Len(t, affected, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1))
} PrettyPrintBody:[{ rt := new(2) m1 := newMockEntry(3, 3) rt.Add(m1) affected, deleted := rt.InsertAtDimension(1, 0, 0) assert.Len(t, affected, 0) assert.Len(t, deleted, 0) assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1)) }]} {Id:19 FileId:114 StartLine:309 StartColumn:1 EndLine:319 EndColumn:2 Name:BenchmarkMultiDimensionInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]} {Id:20 FileId:114 StartLine:321 StartColumn:1 EndLine:332 EndColumn:2 Name:BenchmarkMultiDimensionInsertReverse Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		index := numItems - (i % numItems) - 1
		rt.Add(entries[index])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { index := numItems - (i % numItems) - 1 rt.Add(entries[index]) } }]} {Id:21 FileId:114 StartLine:334 StartColumn:1 EndLine:344 EndColumn:2 Name:BenchmarkMultiDimensionRandomInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]} {Id:22 FileId:114 StartLine:346 StartColumn:1 EndLine:357 EndColumn:2 Name:BenchmarkMultiDimensionalGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Get(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Get(entries[i%numItems]) } }]} {Id:23 FileId:114 StartLine:359 StartColumn:1 EndLine:370 EndColumn:2 Name:BenchmarkMultiDimensionDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Delete(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Delete(entries[i%numItems]) } }]} {Id:24 FileId:114 StartLine:372 StartColumn:1 EndLine:387 EndColumn:2 Name:BenchmarkMultiDimensionQuery Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)
	iv := newMockInterval([]int64{0, 0}, []int64{math.MaxInt64, math.MaxInt64})
	var result rangetree.Entries

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		result = rt.Query(iv)
	}

	assert.Len(b, result, numItems)
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) iv := newMockInterval([]int64{0, 0}, []int64{math.MaxInt64, math.MaxInt64}) var result rangetree.Entries b.ResetTimer() for i := 0; i < b.N; i++ { result = rt.Query(iv) } assert.Len(b, result, numItems) }]} {Id:25 FileId:114 StartLine:389 StartColumn:1 EndLine:400 EndColumn:2 Name:BenchmarkMultiDimensionInsertAtZeroDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.InsertAtDimension(0, 0, 1)
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.InsertAtDimension(0, 0, 1) } }]} {Id:26 FileId:114 StartLine:402 StartColumn:1 EndLine:413 EndColumn:2 Name:BenchmarkMultiDimensionInsertNegativeAtZeroDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	rt := new(2)
	entries := generateRandomMultiDimensionalEntries(numItems)
	rt.Add(entries...)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.InsertAtDimension(0, 0, -1)
	}
} PrettyPrintBody:[{ numItems := b.N rt := new(2) entries := generateRandomMultiDimensionalEntries(numItems) rt.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { rt.InsertAtDimension(0, 0, -1) } }]} {Id:1 FileId:2 StartLine:25 StartColumn:1 EndLine:39 EndColumn:2 Name:min Params:[{Name:one Type:int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	if one == -1 {
		return two
	}

	if two == -1 {
		return one
	}

	if one > two {
		return two
	}

	return one
} PrettyPrintBody:[{ if one == -1 { return two } if two == -1 { return one } if one > two { return two } return one }]} {Id:2 FileId:2 StartLine:41 StartColumn:1 EndLine:55 EndColumn:2 Name:max Params:[{Name:one Type:int64}] Results:[{Name: Type:int64}] Receiver:<nil> Body:{
	if one == -1 {
		return two
	}

	if two == -1 {
		return one
	}

	if one > two {
		return one
	}

	return two
} PrettyPrintBody:[{ if one == -1 { return two } if two == -1 { return one } if one > two { return one } return two }]} {Id:3 FileId:2 StartLine:57 StartColumn:1 EndLine:113 EndColumn:2 Name:checkRedBlack Params:[{Name:tb Type:testing.TB} {Name:node Type:*node} {Name:dimension Type:int}] Results:[{Name: Type:int64} {Name: Type:int64} {Name: Type:int64}] Receiver:<nil> Body:{
	lh, rh := 0, 0
	if node == nil {
		return 1, -1, -1
	}

	if isRed(node) {
		if isRed(node.children[0]) || isRed(node.children[1]) {
			tb.Errorf(`Node is red and has red children: %+v`, node)
		}
	}

	fn := func(min, max int64) {
		if min != -1 && min < node.min {
			tb.Errorf(`Min not set correctly: %+v, node: %+v`, min, node)
		}

		if max != -1 && max > node.max {
			tb.Errorf(`Max not set correctly: %+v, node: %+v`, max, node)
		}
	}

	left, minL, maxL := checkRedBlack(tb, node.children[0], dimension)
	fn(minL, maxL)
	right, minR, maxR := checkRedBlack(tb, node.children[1], dimension)
	fn(minR, maxR)

	min := min(minL, minR)
	if min == -1 && node.min != node.interval.LowAtDimension(1) {
		tb.Errorf(`Min not set correctly, node: %+v`, node)
	} else if min != -1 && node.children[0] != nil && node.children[0].min != node.min {
		tb.Errorf(`Min not set correctly: node: %+v, child: %+v`, node, node.children[0])
	} else if min != -1 && node.children[0] == nil && node.min != node.interval.LowAtDimension(1) {
		tb.Errorf(`Min not set correctly: %+v`, node)
	}

	max := max(maxL, maxR)
	if max == -1 && node.max != node.interval.HighAtDimension(1) {
		tb.Errorf(`Max not set correctly, node: %+v`, node)
	} else if max > node.interval.HighAtDimension(1) && max != node.max {
		tb.Errorf(`Max not set correctly, max: %+v, node: %+v`, max, node)
	}

	if left != 0 && right != 0 && lh != rh {
		tb.Errorf(`Black violation: left: %d, right: %d`, left, right)
	}

	if left != 0 && right != 0 {
		if isRed(node) {
			return left, node.min, node.max
		}

		return left + 1, node.min, node.max
	}

	return 0, node.min, node.max
} PrettyPrintBody:[{ lh, rh := 0, 0 if node == nil { return 1, -1, -1 } if isRed(node) { if isRed(node.children[0]) || isRed(node.children[1]) { tb.Errorf(`Node is red and has red children: %+v`, node) } } fn := func(min, max int64) { if min != -1 && min < node.min { tb.Errorf(`Min not set correctly: %+v, node: %+v`, min, node) } if max != -1 && max > node.max { tb.Errorf(`Max not set correctly: %+v, node: %+v`, max, node) } } left, minL, maxL := checkRedBlack(tb, node.children[0], dimension) fn(minL, maxL) right, minR, maxR := checkRedBlack(tb, node.children[1], dimension) fn(minR, maxR) min := min(minL, minR) if min == -1 && node.min != node.interval.LowAtDimension(1) { tb.Errorf(`Min not set correctly, node: %+v`, node) } else if min != -1 && node.children[0] != nil && node.children[0].min != node.min { tb.Errorf(`Min not set correctly: node: %+v, child: %+v`, node, node.children[0]) } else if min != -1 && node.children[0] == nil && node.min != node.interval.LowAtDimension(1) { tb.Errorf(`Min not set correctly: %+v`, node) } max := max(maxL, maxR) if max == -1 && node.max != node.interval.HighAtDimension(1) { tb.Errorf(`Max not set correctly, node: %+v`, node) } else if max > node.interval.HighAtDimension(1) && max != node.max { tb.Errorf(`Max not set correctly, max: %+v, node: %+v`, max, node) } if left != 0 && right != 0 && lh != rh { tb.Errorf(`Black violation: left: %d, right: %d`, left, right) } if left != 0 && right != 0 { if isRed(node) { return left, node.min, node.max } return left + 1, node.min, node.max } return 0, node.min, node.max }]} {Id:4 FileId:2 StartLine:115 StartColumn:1 EndLine:126 EndColumn:2 Name:constructSingleDimensionTestTree Params:[{Name:number Type:int}] Results:[{Name: Type:*tree} {Name: Type:Intervals}] Receiver:<nil> Body:{
	tree := newTree(1)

	ivs := make(Intervals, 0, number)
	for i := 0; i < number; i++ {
		iv := constructSingleDimensionInterval(int64(i), int64(i)+10, uint64(i))
		ivs = append(ivs, iv)
	}

	tree.Add(ivs...)
	return tree, ivs
} PrettyPrintBody:[{ tree := newTree(1) ivs := make(Intervals, 0, number) for i := 0; i < number; i++ { iv := constructSingleDimensionInterval(int64(i), int64(i)+10, uint64(i)) ivs = append(ivs, iv) } tree.Add(ivs...) return tree, ivs }]} {Id:5 FileId:2 StartLine:128 StartColumn:1 EndLine:141 EndColumn:2 Name:TestSimpleAddNilRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)

	it.Add(iv)

	expected := newNode(iv, 5, 10, 1)
	expected.red = false

	assert.Equal(t, expected, it.root)
	assert.Equal(t, uint64(1), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expected := newNode(iv, 5, 10, 1) expected.red = false assert.Equal(t, expected, it.root) assert.Equal(t, uint64(1), it.Len()) checkRedBlack(t, it.root, 1) }]} {Id:6 FileId:2 StartLine:143 StartColumn:1 EndLine:161 EndColumn:2 Name:TestSimpleAddRootLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 4, 11, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(4, 11, 1)
	it.Add(iv)

	expectedChild := newNode(iv, 4, 11, 1)
	expectedRoot.children[0] = expectedChild

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(2), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 4, 11, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(4, 11, 1) it.Add(iv) expectedChild := newNode(iv, 4, 11, 1) expectedRoot.children[0] = expectedChild assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(2), it.Len()) checkRedBlack(t, it.root, 1) }]} {Id:7 FileId:2 StartLine:163 StartColumn:1 EndLine:181 EndColumn:2 Name:TestSimpleAddRootRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 5, 11, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(7, 11, 1)
	it.Add(iv)

	expectedChild := newNode(iv, 7, 11, 1)
	expectedRoot.children[1] = expectedChild

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(2), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 5, 11, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(7, 11, 1) it.Add(iv) expectedChild := newNode(iv, 7, 11, 1) expectedRoot.children[1] = expectedChild assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(2), it.Len()) checkRedBlack(t, it.root, 1) }]} {Id:8 FileId:2 StartLine:183 StartColumn:1 EndLine:207 EndColumn:2 Name:TestAddRootLeftAndRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	iv := constructSingleDimensionInterval(5, 10, 0)
	it.Add(iv)

	expectedRoot := newNode(iv, 4, 12, 1)
	expectedRoot.red = false

	iv = constructSingleDimensionInterval(4, 11, 1)
	it.Add(iv)

	expectedLeft := newNode(iv, 4, 11, 1)
	expectedRoot.children[0] = expectedLeft

	iv = constructSingleDimensionInterval(7, 12, 1)
	it.Add(iv)

	expectedRight := newNode(iv, 7, 12, 1)
	expectedRoot.children[1] = expectedRight

	assert.Equal(t, expectedRoot, it.root)
	assert.Equal(t, uint64(3), it.Len())
	checkRedBlack(t, it.root, 1)
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(5, 10, 0) it.Add(iv) expectedRoot := newNode(iv, 4, 12, 1) expectedRoot.red = false iv = constructSingleDimensionInterval(4, 11, 1) it.Add(iv) expectedLeft := newNode(iv, 4, 11, 1) expectedRoot.children[0] = expectedLeft iv = constructSingleDimensionInterval(7, 12, 1) it.Add(iv) expectedRight := newNode(iv, 7, 12, 1) expectedRoot.children[1] = expectedRight assert.Equal(t, expectedRoot, it.root) assert.Equal(t, uint64(3), it.Len()) checkRedBlack(t, it.root, 1) }]} {Id:9 FileId:2 StartLine:209 StartColumn:1 EndLine:221 EndColumn:2 Name:TestAddRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	for i := int64(0); i < 10; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(1) for i := int64(0); i < 10; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]} {Id:10 FileId:2 StartLine:223 StartColumn:1 EndLine:235 EndColumn:2 Name:TestAddRebalanceOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	for i := int64(9); i >= 0; i-- {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(1) for i := int64(9); i >= 0; i-- { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]} {Id:11 FileId:2 StartLine:237 StartColumn:1 EndLine:251 EndColumn:2 Name:TestAddRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int64{0, 4, 2, 1, 3}

	for _, start := range starts {
		iv := constructSingleDimensionInterval(start, start+1, uint64(start))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int64{0, 4, 2, 1, 3} for _, start := range starts { iv := constructSingleDimensionInterval(start, start+1, uint64(start)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 5) assert.Equal(t, uint64(5), it.Len()) }]} {Id:12 FileId:2 StartLine:253 StartColumn:1 EndLine:266 EndColumn:2 Name:TestAddLargeNumberOfItems Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	it := newTree(1)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, numItems, 0))
	assert.Len(t, result, int(numItems))
	assert.Equal(t, uint64(numItems), it.Len())
} PrettyPrintBody:[{ numItems := int64(1000) it := newTree(1) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) } checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, numItems, 0)) assert.Len(t, result, int(numItems)) assert.Equal(t, uint64(numItems), it.Len()) }]} {Id:13 FileId:2 StartLine:268 StartColumn:1 EndLine:283 EndColumn:2 Name:BenchmarkAddItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		it := newTree(1)
		it.Add(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } b.ResetTimer() for i := 0; i < b.N; i++ { it := newTree(1) it.Add(intervals...) } }]} {Id:14 FileId:2 StartLine:285 StartColumn:1 EndLine:301 EndColumn:2 Name:BenchmarkQueryItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	it := newTree(1)
	it.Add(intervals...)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		it.Query(constructSingleDimensionInterval(0, numItems, 0))
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } it := newTree(1) it.Add(intervals...) b.ResetTimer() for i := 0; i < b.N; i++ { it.Query(constructSingleDimensionInterval(0, numItems, 0)) } }]} {Id:15 FileId:2 StartLine:303 StartColumn:1 EndLine:318 EndColumn:2 Name:constructSingleDimensionQueryTestTree Params:[] Results:[{Name: Type:*tree} {Name: Type:Interval} {Name: Type:Interval} {Name: Type:Interval}] Receiver:<nil> Body:{

	it := newTree(1)

	iv1 := constructSingleDimensionInterval(6, 10, 0)
	it.Add(iv1)

	iv2 := constructSingleDimensionInterval(4, 5, 1)
	it.Add(iv2)

	iv3 := constructSingleDimensionInterval(7, 12, 2)
	it.Add(iv3)

	return it, iv1, iv2, iv3
} PrettyPrintBody:[{ it := newTree(1) iv1 := constructSingleDimensionInterval(6, 10, 0) it.Add(iv1) iv2 := constructSingleDimensionInterval(4, 5, 1) it.Add(iv2) iv3 := constructSingleDimensionInterval(7, 12, 2) it.Add(iv3) return it, iv1, iv2, iv3 }]} {Id:16 FileId:2 StartLine:320 StartColumn:1 EndLine:327 EndColumn:2 Name:TestSimpleQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(3, 6, 0))

	expected := Intervals{iv2, iv1}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(3, 6, 0)) expected := Intervals{iv2, iv1} assert.Equal(t, expected, result) }]} {Id:17 FileId:2 StartLine:329 StartColumn:1 EndLine:336 EndColumn:2 Name:TestRightQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, _, iv3 := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(6, 8, 0))

	expected := Intervals{iv1, iv3}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, _, iv3 := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(6, 8, 0)) expected := Intervals{iv1, iv3} assert.Equal(t, expected, result) }]} {Id:18 FileId:2 StartLine:338 StartColumn:1 EndLine:345 EndColumn:2 Name:TestLeftQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(3, 5, 0))

	expected := Intervals{iv2}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(3, 5, 0)) expected := Intervals{iv2} assert.Equal(t, expected, result) }]} {Id:19 FileId:2 StartLine:347 StartColumn:1 EndLine:354 EndColumn:2 Name:TestMatchingQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(4, 5, 0))

	expected := Intervals{iv2}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(4, 5, 0)) expected := Intervals{iv2} assert.Equal(t, expected, result) }]} {Id:20 FileId:2 StartLine:356 StartColumn:1 EndLine:363 EndColumn:2 Name:TestNoMatchLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, _, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(1, 3, 0))

	expected := Intervals{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, _, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(1, 3, 0)) expected := Intervals{} assert.Equal(t, expected, result) }]} {Id:21 FileId:2 StartLine:365 StartColumn:1 EndLine:372 EndColumn:2 Name:TestNoMatchRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, _, _ := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(13, 13, 0))

	expected := Intervals{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, _, _ := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(13, 13, 0)) expected := Intervals{} assert.Equal(t, expected, result) }]} {Id:22 FileId:2 StartLine:374 StartColumn:1 EndLine:381 EndColumn:2 Name:TestAllQuery Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	result := it.Query(constructSingleDimensionInterval(1, 14, 0))

	expected := Intervals{iv2, iv1, iv3}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() result := it.Query(constructSingleDimensionInterval(1, 14, 0)) expected := Intervals{iv2, iv1, iv3} assert.Equal(t, expected, result) }]} {Id:23 FileId:2 StartLine:383 StartColumn:1 EndLine:392 EndColumn:2 Name:TestQueryDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, _, iv2, _ := constructSingleDimensionQueryTestTree()
	iv4 := constructSingleDimensionInterval(4, 5, 3)
	it.Add(iv4)

	result := it.Query(constructSingleDimensionInterval(4, 5, 0))

	expected := Intervals{iv2, iv4}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ it, _, iv2, _ := constructSingleDimensionQueryTestTree() iv4 := constructSingleDimensionInterval(4, 5, 3) it.Add(iv4) result := it.Query(constructSingleDimensionInterval(4, 5, 0)) expected := Intervals{iv2, iv4} assert.Equal(t, expected, result) }]} {Id:24 FileId:2 StartLine:394 StartColumn:1 EndLine:405 EndColumn:2 Name:TestRootDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)
	iv := constructSingleDimensionInterval(1, 5, 1)
	it.add(iv)

	it.Delete(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(1, 10, 0))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) iv := constructSingleDimensionInterval(1, 5, 1) it.add(iv) it.Delete(iv) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(1, 10, 0)) assert.Len(t, result, 0) assert.Equal(t, uint64(0), it.Len()) }]} {Id:25 FileId:2 StartLine:407 StartColumn:1 EndLine:418 EndColumn:2 Name:TestDeleteLeft Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv2)

	expected := Intervals{iv1, iv3}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv2) expected := Intervals{iv1, iv3} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]} {Id:26 FileId:2 StartLine:420 StartColumn:1 EndLine:431 EndColumn:2 Name:TestDeleteRight Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv3)

	expected := Intervals{iv2, iv1}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv3) expected := Intervals{iv2, iv1} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]} {Id:27 FileId:2 StartLine:433 StartColumn:1 EndLine:444 EndColumn:2 Name:TestDeleteCenter Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree()

	it.Delete(iv1)

	expected := Intervals{iv2, iv3}

	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	checkRedBlack(t, it.root, 1)
	assert.Equal(t, expected, result)
	assert.Equal(t, uint64(2), it.Len())
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree() it.Delete(iv1) expected := Intervals{iv2, iv3} result := it.Query(constructSingleDimensionInterval(0, 10, 0)) checkRedBlack(t, it.root, 1) assert.Equal(t, expected, result) assert.Equal(t, uint64(2), it.Len()) }]} {Id:28 FileId:2 StartLine:446 StartColumn:1 EndLine:465 EndColumn:2 Name:TestDeleteRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	var toDelete *mockInterval

	for i := int64(0); i < 10; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(1) var toDelete *mockInterval for i := int64(0); i < 10; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]} {Id:29 FileId:2 StartLine:467 StartColumn:1 EndLine:485 EndColumn:2 Name:TestDeleteRebalanceOutOfOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	var toDelete *mockInterval
	for i := int64(9); i >= 0; i-- {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		it.add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(1) var toDelete *mockInterval for i := int64(9); i >= 0; i-- { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) it.add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]} {Id:30 FileId:2 StartLine:487 StartColumn:1 EndLine:507 EndColumn:2 Name:TestDeleteRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int64{0, 4, 2, 1, 3}

	var toDelete *mockInterval
	for _, start := range starts {
		iv := constructSingleDimensionInterval(start, start+1, uint64(start))
		it.add(iv)
		if start == 1 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int64{0, 4, 2, 1, 3} var toDelete *mockInterval for _, start := range starts { iv := constructSingleDimensionInterval(start, start+1, uint64(start)) it.add(iv) if start == 1 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Len(t, result, 4) assert.Equal(t, uint64(4), it.Len()) }]} {Id:31 FileId:2 StartLine:509 StartColumn:1 EndLine:515 EndColumn:2 Name:TestDeleteEmptyTree Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	it.Delete(constructSingleDimensionInterval(0, 1, 1))

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) it.Delete(constructSingleDimensionInterval(0, 1, 1)) assert.Equal(t, uint64(0), it.Len()) }]} {Id:32 FileId:2 StartLine:517 StartColumn:1 EndLine:538 EndColumn:2 Name:BenchmarkDeleteItems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	intervals := make(Intervals, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		iv := constructSingleDimensionInterval(i, i+1, uint64(i))
		intervals = append(intervals, iv)
	}

	trees := make([]*tree, 0, b.N)
	for i := 0; i < b.N; i++ {
		it := newTree(1)
		it.Add(intervals...)
		trees = append(trees, it)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructSingleDimensionInterval(i, i+1, uint64(i)) intervals = append(intervals, iv) } trees := make([]*tree, 0, b.N) for i := 0; i < b.N; i++ { it := newTree(1) it.Add(intervals...) trees = append(trees, it) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(intervals...) } }]} {Id:33 FileId:2 StartLine:540 StartColumn:1 EndLine:550 EndColumn:2 Name:TestAddDuplicateRanges Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)
	iv1 := constructSingleDimensionInterval(0, 10, 1)
	iv2 := constructSingleDimensionInterval(0, 10, 2)
	iv3 := constructSingleDimensionInterval(0, 10, 3)

	it.Add(iv1, iv2, iv3)
	it.Delete(iv1, iv2, iv3)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) iv1 := constructSingleDimensionInterval(0, 10, 1) iv2 := constructSingleDimensionInterval(0, 10, 2) iv3 := constructSingleDimensionInterval(0, 10, 3) it.Add(iv1, iv2, iv3) it.Delete(iv1, iv2, iv3) assert.Equal(t, uint64(0), it.Len()) }]} {Id:34 FileId:2 StartLine:552 StartColumn:1 EndLine:566 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceInOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	intervals := make(Intervals, 0, 10)

	for i := 0; i < 10; i++ {
		iv := constructSingleDimensionInterval(0, 10, uint64(i))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) intervals := make(Intervals, 0, 10) for i := 0; i < 10; i++ { iv := constructSingleDimensionInterval(0, 10, uint64(i)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:35 FileId:2 StartLine:568 StartColumn:1 EndLine:582 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceReverseOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	intervals := make(Intervals, 0, 10)

	for i := 9; i >= 0; i-- {
		iv := constructSingleDimensionInterval(0, 10, uint64(i))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) intervals := make(Intervals, 0, 10) for i := 9; i >= 0; i-- { iv := constructSingleDimensionInterval(0, 10, uint64(i)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:36 FileId:2 StartLine:584 StartColumn:1 EndLine:599 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceRandomOrder Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(1)

	starts := []int{0, 4, 2, 1, 3}
	intervals := make(Intervals, 0, 5)

	for _, start := range starts {
		iv := constructSingleDimensionInterval(0, 10, uint64(start))
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)

	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(1) starts := []int{0, 4, 2, 1, 3} intervals := make(Intervals, 0, 5) for _, start := range starts { iv := constructSingleDimensionInterval(0, 10, uint64(start)) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:37 FileId:2 StartLine:601 StartColumn:1 EndLine:610 EndColumn:2 Name:TestInsertDuplicateIntervalsToRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1)
	iv1 := constructSingleDimensionInterval(0, 10, 1)
	iv2 := constructSingleDimensionInterval(0, 10, 1)
	iv3 := constructSingleDimensionInterval(0, 10, 1)

	tree.Add(iv1, iv2, iv3)

	checkRedBlack(t, tree.root, 1)
} PrettyPrintBody:[{ tree := newTree(1) iv1 := constructSingleDimensionInterval(0, 10, 1) iv2 := constructSingleDimensionInterval(0, 10, 1) iv3 := constructSingleDimensionInterval(0, 10, 1) tree.Add(iv1, iv2, iv3) checkRedBlack(t, tree.root, 1) }]} {Id:38 FileId:2 StartLine:612 StartColumn:1 EndLine:624 EndColumn:2 Name:TestInsertDuplicateIntervalChildren Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructSingleDimensionTestTree(20)

	iv1 := constructSingleDimensionInterval(0, 10, 21)
	iv2 := constructSingleDimensionInterval(0, 10, 21)

	tree.Add(iv1, iv2)

	checkRedBlack(t, tree.root, 1)

	result := tree.Query(constructSingleDimensionInterval(0, 10, 0))
	assert.Contains(t, result, iv1)
} PrettyPrintBody:[{ tree, _ := constructSingleDimensionTestTree(20) iv1 := constructSingleDimensionInterval(0, 10, 21) iv2 := constructSingleDimensionInterval(0, 10, 21) tree.Add(iv1, iv2) checkRedBlack(t, tree.root, 1) result := tree.Query(constructSingleDimensionInterval(0, 10, 0)) assert.Contains(t, result, iv1) }]} {Id:39 FileId:2 StartLine:626 StartColumn:1 EndLine:646 EndColumn:2 Name:TestTraverse Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newTree(1)

	tree.Traverse(func(i Interval) {
		assert.Fail(t, `traverse should not be called for empty tree`)
	})

	top := 30
	for i := 0; i <= top; i++ {
		tree.Add(constructSingleDimensionInterval(int64(i*10), int64((i+1)*10), uint64(i)))
	}
	found := map[uint64]bool{}
	tree.Traverse(func(id Interval) {
		found[id.ID()] = true
	})
	for i := 0; i <= top; i++ {
		if found, _ := found[uint64(i)]; !found {
			t.Errorf("could not find expected interval %d", i)
		}
	}
} PrettyPrintBody:[{ tree := newTree(1) tree.Traverse(func(i Interval) { assert.Fail(t, `traverse should not be called for empty tree`) }) top := 30 for i := 0; i <= top; i++ { tree.Add(constructSingleDimensionInterval(int64(i*10), int64((i+1)*10), uint64(i))) } found := map[uint64]bool{} tree.Traverse(func(id Interval) { found[id.ID()] = true }) for i := 0; i <= top; i++ { if found, _ := found[uint64(i)]; !found { t.Errorf("could not find expected interval %d", i) } } }]} {Id:1 FileId:156 StartLine:29 StartColumn:1 EndLine:33 EndColumn:2 Name:checkTrie Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	checkSuccessor(t, xft)
	checkPredecessor(t, xft)
	checkNodes(t, xft)
} PrettyPrintBody:[{ checkSuccessor(t, xft) checkPredecessor(t, xft) checkNodes(t, xft) }]} {Id:2 FileId:156 StartLine:35 StartColumn:1 EndLine:66 EndColumn:2 Name:checkSuccessor Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	n := xft.min
	var side int
	var successor *node
	for n != nil {
		successor = n.children[1]
		hasSuccesor := successor != nil
		immediateSuccessor := false
		if hasSuccesor {
			assert.Equal(t, n, successor.children[0])
			if n.parent == successor.parent {
				immediateSuccessor = true
			}
		}

		for n.parent != nil {
			side = whichSide(n, n.parent)
			if isInternal(n.parent.children[1]) && isInternal(n.parent.children[0]) {
				break
			}
			if immediateSuccessor && n.parent == successor.parent {
				assert.Equal(t, successor, n.parent.children[1])
				break
			}
			if side == 0 && !isInternal(n.parent.children[1]) && hasSuccesor {
				assert.Equal(t, successor, n.parent.children[1])
			}
			n = n.parent
		}
		n = successor
	}
} PrettyPrintBody:[{ n := xft.min var side int var successor *node for n != nil { successor = n.children[1] hasSuccesor := successor != nil immediateSuccessor := false if hasSuccesor { assert.Equal(t, n, successor.children[0]) if n.parent == successor.parent { immediateSuccessor = true } } for n.parent != nil { side = whichSide(n, n.parent) if isInternal(n.parent.children[1]) && isInternal(n.parent.children[0]) { break } if immediateSuccessor && n.parent == successor.parent { assert.Equal(t, successor, n.parent.children[1]) break } if side == 0 && !isInternal(n.parent.children[1]) && hasSuccesor { assert.Equal(t, successor, n.parent.children[1]) } n = n.parent } n = successor } }]} {Id:3 FileId:156 StartLine:68 StartColumn:1 EndLine:98 EndColumn:2 Name:checkPredecessor Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	n := xft.max
	var side int
	var predecessor *node
	for n != nil {
		predecessor = n.children[0]
		hasPredecessor := predecessor != nil
		immediatePredecessor := false
		if hasPredecessor {
			assert.Equal(t, n, predecessor.children[1])
			if n.parent == predecessor.parent {
				immediatePredecessor = true
			}
		}
		for n.parent != nil {
			side = whichSide(n, n.parent)
			if isInternal(n.parent.children[0]) && isInternal(n.parent.children[1]) {
				break
			}
			if immediatePredecessor && n.parent == predecessor.parent {
				assert.Equal(t, predecessor, n.parent.children[0])
				break
			}
			if side == 1 && !isInternal(n.parent.children[0]) && hasPredecessor {
				assert.Equal(t, predecessor, n.parent.children[0])
			}
			n = n.parent
		}
		n = predecessor
	}
} PrettyPrintBody:[{ n := xft.max var side int var predecessor *node for n != nil { predecessor = n.children[0] hasPredecessor := predecessor != nil immediatePredecessor := false if hasPredecessor { assert.Equal(t, n, predecessor.children[1]) if n.parent == predecessor.parent { immediatePredecessor = true } } for n.parent != nil { side = whichSide(n, n.parent) if isInternal(n.parent.children[0]) && isInternal(n.parent.children[1]) { break } if immediatePredecessor && n.parent == predecessor.parent { assert.Equal(t, predecessor, n.parent.children[0]) break } if side == 1 && !isInternal(n.parent.children[0]) && hasPredecessor { assert.Equal(t, predecessor, n.parent.children[0]) } n = n.parent } n = predecessor } }]} {Id:4 FileId:156 StartLine:100 StartColumn:1 EndLine:110 EndColumn:2 Name:checkNodes Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie}] Results:[] Receiver:<nil> Body:{
	count := uint64(0)
	n := xft.min
	for n != nil {
		count++
		checkNode(t, xft, n)
		n = n.children[1]
	}

	assert.Equal(t, count, xft.Len())
} PrettyPrintBody:[{ count := uint64(0) n := xft.min for n != nil { count++ checkNode(t, xft, n) n = n.children[1] } assert.Equal(t, count, xft.Len()) }]} {Id:5 FileId:156 StartLine:112 StartColumn:1 EndLine:125 EndColumn:2 Name:checkNode Params:[{Name:t Type:*testing.T} {Name:xft Type:*XFastTrie} {Name:n Type:*node}] Results:[] Receiver:<nil> Body:{
	if n.entry == nil {
		assert.Fail(t, `Expected non-nil entry`)
		return
	}
	key := n.entry.Key()
	bits := make([]int, 0, xft.bits)
	for i := uint8(0); i < xft.bits; i++ {
		leftOrRight := (key & positions[xft.diff+i]) >> (xft.bits - 1 - i)
		bits = append(bits, int(leftOrRight))
	}

	checkPattern(t, n, bits)
} PrettyPrintBody:[{ if n.entry == nil { assert.Fail(t, `Expected non-nil entry`) return } key := n.entry.Key() bits := make([]int, 0, xft.bits) for i := uint8(0); i < xft.bits; i++ { leftOrRight := (key & positions[xft.diff+i]) >> (xft.bits - 1 - i) bits = append(bits, int(leftOrRight)) } checkPattern(t, n, bits) }]} {Id:6 FileId:156 StartLine:127 StartColumn:1 EndLine:132 EndColumn:2 Name:dumpNode Params:[{Name:t Type:*testing.T} {Name:n Type:*node}] Results:[] Receiver:<nil> Body:{
	for n != nil {
		t.Logf(`NODE: %+v, %p`, n, n)
		n = n.parent
	}
} PrettyPrintBody:[{ for n != nil { t.Logf(`NODE: %+v, %p`, n, n) n = n.parent } }]} {Id:7 FileId:156 StartLine:134 StartColumn:1 EndLine:148 EndColumn:2 Name:checkPattern Params:[{Name:t Type:*testing.T} {Name:n Type:*node} {Name:pattern Type:[]int}] Results:[] Receiver:<nil> Body:{
	i := len(pattern) - 1
	bottomNode := n
	for n.parent != nil {
		if !assert.False(t, i < 0, fmt.Sprintf(`Too many parents. NODE: %+v, PATTERN: %+v`, bottomNode, pattern)) {
			dumpNode(t, bottomNode)
			break
		}
		assert.Equal(t, pattern[i], whichSide(n, n.parent))
		i--
		n = n.parent
	}

	assert.Equal(t, -1, i)
} PrettyPrintBody:[{ i := len(pattern) - 1 bottomNode := n for n.parent != nil { if !assert.False(t, i < 0, fmt.Sprintf(`Too many parents. NODE: %+v, PATTERN: %+v`, bottomNode, pattern)) { dumpNode(t, bottomNode) break } assert.Equal(t, pattern[i], whichSide(n, n.parent)) i-- n = n.parent } assert.Equal(t, -1, i) }]} {Id:8 FileId:156 StartLine:150 StartColumn:1 EndLine:155 EndColumn:2 Name:TestEmptyMinMax Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))

	assert.Nil(t, xft.Min())
	assert.Nil(t, xft.Max())
} PrettyPrintBody:[{ xft := New(uint8(0)) assert.Nil(t, xft.Min()) assert.Nil(t, xft.Max()) }]} {Id:9 FileId:156 StartLine:157 StartColumn:1 EndLine:159 EndColumn:2 Name:TestMask Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	assert.Equal(t, uint64(math.MaxUint64), masks[63])
} PrettyPrintBody:[{ assert.Equal(t, uint64(math.MaxUint64), masks[63]) }]} {Id:10 FileId:156 StartLine:161 StartColumn:1 EndLine:179 EndColumn:2 Name:TestInsert Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	assert.True(t, xft.Exists(5))
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	assert.True(t, xft.Exists(20))
	assert.Equal(t, uint64(2), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) assert.True(t, xft.Exists(5)) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) e2 := newMockEntry(20) xft.Insert(e2) assert.True(t, xft.Exists(20)) assert.Equal(t, uint64(2), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) }]} {Id:11 FileId:156 StartLine:181 StartColumn:1 EndLine:188 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	assert.Equal(t, e1, xft.Get(5))
	assert.Nil(t, xft.Get(6))
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) assert.Equal(t, e1, xft.Get(5)) assert.Nil(t, xft.Get(6)) }]} {Id:12 FileId:156 StartLine:190 StartColumn:1 EndLine:201 EndColumn:2 Name:TestInsertOverwrite Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	e2 := newMockEntry(5)
	xft.Insert(e2)
	checkTrie(t, xft)

	iter := xft.Iter(5)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) e2 := newMockEntry(5) xft.Insert(e2) checkTrie(t, xft) iter := xft.Iter(5) assert.Equal(t, Entries{e2}, iter.exhaust()) }]} {Id:13 FileId:156 StartLine:203 StartColumn:1 EndLine:244 EndColumn:2 Name:TestInsertBetween Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	assert.True(t, xft.Exists(10))
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	e2 := newMockEntry(20)
	xft.Insert(e2)
	checkTrie(t, xft)

	assert.True(t, xft.Exists(20))
	assert.Equal(t, uint64(2), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())

	assert.Equal(t, e2, xft.Successor(15))

	e3 := newMockEntry(15)
	xft.Insert(e3)

	assert.True(t, xft.Exists(15))
	assert.Equal(t, uint64(3), xft.Len())
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	entries := iter.exhaust()
	assert.Equal(t, Entries{e1, e3, e2}, entries)

	iter = xft.Iter(11)
	entries = iter.exhaust()
	assert.Equal(t, Entries{e3, e2}, entries)

	iter = xft.Iter(16)
	entries = iter.exhaust()
	assert.Equal(t, Entries{e2}, entries)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) assert.True(t, xft.Exists(10)) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) e2 := newMockEntry(20) xft.Insert(e2) checkTrie(t, xft) assert.True(t, xft.Exists(20)) assert.Equal(t, uint64(2), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) assert.Equal(t, e2, xft.Successor(15)) e3 := newMockEntry(15) xft.Insert(e3) assert.True(t, xft.Exists(15)) assert.Equal(t, uint64(3), xft.Len()) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) entries := iter.exhaust() assert.Equal(t, Entries{e1, e3, e2}, entries) iter = xft.Iter(11) entries = iter.exhaust() assert.Equal(t, Entries{e3, e2}, entries) iter = xft.Iter(16) entries = iter.exhaust() assert.Equal(t, Entries{e2}, entries) }]} {Id:14 FileId:156 StartLine:246 StartColumn:1 EndLine:253 EndColumn:2 Name:TestSuccessorDoesNotExist Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Successor(6)
	assert.Nil(t, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Successor(6) assert.Nil(t, result) }]} {Id:15 FileId:156 StartLine:255 StartColumn:1 EndLine:262 EndColumn:2 Name:TestSuccessorIsExactValue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]} {Id:16 FileId:156 StartLine:264 StartColumn:1 EndLine:271 EndColumn:2 Name:TestSuccessorGreaterThanKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(math.MaxUint8)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(math.MaxUint8) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]} {Id:17 FileId:156 StartLine:273 StartColumn:1 EndLine:280 EndColumn:2 Name:TestSuccessorCloseToKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	result := xft.Successor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) result := xft.Successor(5) assert.Equal(t, e1, result) }]} {Id:18 FileId:156 StartLine:282 StartColumn:1 EndLine:299 EndColumn:2 Name:TestSuccessorBetweenTwoKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	for i := uint64(11); i < 20; i++ {
		result := xft.Successor(i)
		assert.Equal(t, e2, result)
	}

	for i := uint64(21); i < 100; i++ {
		result := xft.Successor(i)
		assert.Nil(t, result)
	}
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(20) xft.Insert(e2) for i := uint64(11); i < 20; i++ { result := xft.Successor(i) assert.Equal(t, e2, result) } for i := uint64(21); i < 100; i++ { result := xft.Successor(i) assert.Nil(t, result) } }]} {Id:19 FileId:156 StartLine:301 StartColumn:1 EndLine:308 EndColumn:2 Name:TestPredecessorDoesNotExist Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(4)
	assert.Nil(t, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(4) assert.Nil(t, result) }]} {Id:20 FileId:156 StartLine:310 StartColumn:1 EndLine:317 EndColumn:2 Name:TestPredecessorIsExactValue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(5)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(5) assert.Equal(t, e1, result) }]} {Id:21 FileId:156 StartLine:319 StartColumn:1 EndLine:326 EndColumn:2 Name:TestPredecessorLessThanKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	xft.Insert(e1)

	result := xft.Predecessor(math.MaxUint64)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) xft.Insert(e1) result := xft.Predecessor(math.MaxUint64) assert.Equal(t, e1, result) }]} {Id:22 FileId:156 StartLine:328 StartColumn:1 EndLine:335 EndColumn:2 Name:TestPredecessorCloseToKey Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(5)
	xft.Insert(e1)

	result := xft.Predecessor(10)
	assert.Equal(t, e1, result)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(5) xft.Insert(e1) result := xft.Predecessor(10) assert.Equal(t, e1, result) }]} {Id:23 FileId:156 StartLine:337 StartColumn:1 EndLine:354 EndColumn:2 Name:TestPredecessorBetweenTwoKeys Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(20)
	xft.Insert(e2)

	for i := uint64(11); i < 20; i++ {
		result := xft.Predecessor(i)
		assert.Equal(t, e1, result)
	}

	for i := uint64(0); i < 10; i++ {
		result := xft.Predecessor(i)
		assert.Nil(t, result)
	}
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(20) xft.Insert(e2) for i := uint64(11); i < 20; i++ { result := xft.Predecessor(i) assert.Equal(t, e1, result) } for i := uint64(0); i < 10; i++ { result := xft.Predecessor(i) assert.Nil(t, result) } }]} {Id:24 FileId:156 StartLine:356 StartColumn:1 EndLine:379 EndColumn:2 Name:TestInsertPredecessor Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	e2 := newMockEntry(5)
	xft.Insert(e2)
	checkTrie(t, xft)

	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e1, xft.Max())

	iter := xft.Iter(2)
	assert.Equal(t, Entries{e2, e1}, iter.exhaust())

	iter = xft.Iter(5)
	assert.Equal(t, Entries{e2, e1}, iter.exhaust())

	iter = xft.Iter(6)
	assert.Equal(t, Entries{e1}, iter.exhaust())

	iter = xft.Iter(11)
	assert.Equal(t, Entries{}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) e2 := newMockEntry(5) xft.Insert(e2) checkTrie(t, xft) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e1, xft.Max()) iter := xft.Iter(2) assert.Equal(t, Entries{e2, e1}, iter.exhaust()) iter = xft.Iter(5) assert.Equal(t, Entries{e2, e1}, iter.exhaust()) iter = xft.Iter(6) assert.Equal(t, Entries{e1}, iter.exhaust()) iter = xft.Iter(11) assert.Equal(t, Entries{}, iter.exhaust()) }]} {Id:25 FileId:156 StartLine:381 StartColumn:1 EndLine:401 EndColumn:2 Name:TestDeleteOnlyBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(10)
	xft.Insert(e1)

	xft.Delete(10)
	checkTrie(t, xft)
	assert.Equal(t, uint64(0), xft.Len())
	assert.Nil(t, xft.Min())
	assert.Nil(t, xft.Max())
	for _, hm := range xft.layers {
		assert.Len(t, hm, 0)
	}

	assert.NotNil(t, xft.root)
	assert.Nil(t, xft.root.children[0])
	assert.Nil(t, xft.root.children[1])

	iter := xft.Iter(0)
	assert.False(t, iter.Next())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(10) xft.Insert(e1) xft.Delete(10) checkTrie(t, xft) assert.Equal(t, uint64(0), xft.Len()) assert.Nil(t, xft.Min()) assert.Nil(t, xft.Max()) for _, hm := range xft.layers { assert.Len(t, hm, 0) } assert.NotNil(t, xft.root) assert.Nil(t, xft.root.children[0]) assert.Nil(t, xft.root.children[1]) iter := xft.Iter(0) assert.False(t, iter.Next()) }]} {Id:26 FileId:156 StartLine:403 StartColumn:1 EndLine:426 EndColumn:2 Name:TestDeleteLargeBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(0)
	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	assert.Nil(t, xft.root.children[0])

	n := xft.max
	for n != nil {
		assert.Nil(t, n.children[0])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(0) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) assert.Nil(t, xft.root.children[0]) n := xft.max for n != nil { assert.Nil(t, n.children[0]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e2}, iter.exhaust()) }]} {Id:27 FileId:156 StartLine:428 StartColumn:1 EndLine:449 EndColumn:2 Name:TestDeleteLateBranching Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(1)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(1)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e1, xft.Max())
	checkTrie(t, xft)

	n := xft.min
	for n != nil {
		assert.Nil(t, n.children[1])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(1) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(1) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e1, xft.Max()) checkTrie(t, xft) n := xft.min for n != nil { assert.Nil(t, n.children[1]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e1}, iter.exhaust()) }]} {Id:28 FileId:156 StartLine:451 StartColumn:1 EndLine:475 EndColumn:2 Name:TestDeleteLateBranchingMin Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(1)

	xft.Insert(e1, e2)
	checkTrie(t, xft)

	xft.Delete(0)
	assert.Equal(t, e2, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	assert.Nil(t, xft.min.children[0])
	n := xft.min.parent
	assert.Nil(t, n.children[0])
	n = n.parent
	for n != nil {
		assert.Nil(t, n.children[1])
		n = n.parent
	}

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(1) xft.Insert(e1, e2) checkTrie(t, xft) xft.Delete(0) assert.Equal(t, e2, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) assert.Nil(t, xft.min.children[0]) n := xft.min.parent assert.Nil(t, n.children[0]) n = n.parent for n != nil { assert.Nil(t, n.children[1]) n = n.parent } iter := xft.Iter(0) assert.Equal(t, Entries{e2}, iter.exhaust()) }]} {Id:29 FileId:156 StartLine:477 StartColumn:1 EndLine:493 EndColumn:2 Name:TestDeleteMiddleBranch Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)
	e3 := newMockEntry(64)

	xft.Insert(e1, e2, e3)
	checkTrie(t, xft)

	xft.Delete(64)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) e3 := newMockEntry(64) xft.Insert(e1, e2, e3) checkTrie(t, xft) xft.Delete(64) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) }]} {Id:30 FileId:156 StartLine:495 StartColumn:1 EndLine:511 EndColumn:2 Name:TestDeleteMiddleBranchOtherSide Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(0)
	e2 := newMockEntry(math.MaxUint8)
	e3 := newMockEntry(128)

	xft.Insert(e1, e2, e3)
	checkTrie(t, xft)

	xft.Delete(128)
	assert.Equal(t, e1, xft.Min())
	assert.Equal(t, e2, xft.Max())
	checkTrie(t, xft)

	iter := xft.Iter(0)
	assert.Equal(t, Entries{e1, e2}, iter.exhaust())
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(0) e2 := newMockEntry(math.MaxUint8) e3 := newMockEntry(128) xft.Insert(e1, e2, e3) checkTrie(t, xft) xft.Delete(128) assert.Equal(t, e1, xft.Min()) assert.Equal(t, e2, xft.Max()) checkTrie(t, xft) iter := xft.Iter(0) assert.Equal(t, Entries{e1, e2}, iter.exhaust()) }]} {Id:31 FileId:156 StartLine:513 StartColumn:1 EndLine:523 EndColumn:2 Name:TestDeleteNotFound Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	xft := New(uint8(0))
	e1 := newMockEntry(64)
	xft.Insert(e1)
	checkTrie(t, xft)

	xft.Delete(128)
	assert.Equal(t, e1, xft.Max())
	assert.Equal(t, e1, xft.Min())
	checkTrie(t, xft)
} PrettyPrintBody:[{ xft := New(uint8(0)) e1 := newMockEntry(64) xft.Insert(e1) checkTrie(t, xft) xft.Delete(128) assert.Equal(t, e1, xft.Max()) assert.Equal(t, e1, xft.Min()) checkTrie(t, xft) }]} {Id:32 FileId:156 StartLine:525 StartColumn:1 EndLine:538 EndColumn:2 Name:BenchmarkSuccessor Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 10000
	xft := New(uint64(0))

	for i := uint64(0); i < uint64(numItems); i++ {
		xft.Insert(newMockEntry(i))
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		xft.Successor(uint64(i))
	}
} PrettyPrintBody:[{ numItems := 10000 xft := New(uint64(0)) for i := uint64(0); i < uint64(numItems); i++ { xft.Insert(newMockEntry(i)) } b.ResetTimer() for i := 0; i < b.N; i++ { xft.Successor(uint64(i)) } }]} {Id:33 FileId:156 StartLine:540 StartColumn:1 EndLine:556 EndColumn:2 Name:BenchmarkDelete Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	xs := make([]*XFastTrie, 0, b.N)

	for i := 0; i < b.N; i++ {
		x := New(uint8(0))
		x.Insert(newMockEntry(0))
		xs = append(xs, x)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		xs[i].Delete(0)
	}
} PrettyPrintBody:[{ xs := make([]*XFastTrie, 0, b.N) for i := 0; i < b.N; i++ { x := New(uint8(0)) x.Insert(newMockEntry(0)) xs = append(xs, x) } b.ResetTimer() for i := 0; i < b.N; i++ { xs[i].Delete(0) } }]} {Id:34 FileId:156 StartLine:558 StartColumn:1 EndLine:564 EndColumn:2 Name:BenchmarkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	for i := 0; i < b.N; i++ {
		xft := New(uint64(0))
		e := newMockEntry(uint64(i))
		xft.Insert(e)
	}
} PrettyPrintBody:[{ for i := 0; i < b.N; i++ { xft := New(uint64(0)) e := newMockEntry(uint64(i)) xft.Insert(e) } }]} {Id:35 FileId:156 StartLine:567 StartColumn:1 EndLine:580 EndColumn:2 Name:BenchmarkListInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 100000

	s := make(slice.Int64Slice, 0, numItems)
	for j := int64(0); j < int64(numItems); j++ {
		s = append(s, j)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		s.Insert(int64(i))
	}
} PrettyPrintBody:[{ numItems := 100000 s := make(slice.Int64Slice, 0, numItems) for j := int64(0); j < int64(numItems); j++ { s = append(s, j) } b.ResetTimer() for i := 0; i < b.N; i++ { s.Insert(int64(i)) } }]} {Id:36 FileId:156 StartLine:582 StartColumn:1 EndLine:595 EndColumn:2 Name:BenchmarkListSearch Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000000

	s := make(slice.Int64Slice, 0, numItems)
	for j := int64(0); j < int64(numItems); j++ {
		s = append(s, j)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		s.Search(int64(i))
	}
} PrettyPrintBody:[{ numItems := 1000000 s := make(slice.Int64Slice, 0, numItems) for j := int64(0); j < int64(numItems); j++ { s = append(s, j) } b.ResetTimer() for i := 0; i < b.N; i++ { s.Search(int64(i)) } }]} {Id:1 FileId:97 StartLine:28 StartColumn:1 EndLine:50 EndColumn:2 Name:TestPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	assert.Equal(t, int64(1), q.Len())

	results, err := q.Get(1)
	assert.Nil(t, err)

	result := results[0]
	assert.Equal(t, `test`, result)
	assert.True(t, q.Empty())

	q.Put(`test2`)
	assert.Equal(t, int64(1), q.Len())

	results, err = q.Get(1)
	assert.Nil(t, err)

	result = results[0]
	assert.Equal(t, `test2`, result)
	assert.True(t, q.Empty())
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) assert.Equal(t, int64(1), q.Len()) results, err := q.Get(1) assert.Nil(t, err) result := results[0] assert.Equal(t, `test`, result) assert.True(t, q.Empty()) q.Put(`test2`) assert.Equal(t, int64(1), q.Len()) results, err = q.Get(1) assert.Nil(t, err) result = results[0] assert.Equal(t, `test2`, result) assert.True(t, q.Empty()) }]} {Id:2 FileId:97 StartLine:52 StartColumn:1 EndLine:83 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `test`, result[0])
	assert.Equal(t, int64(0), q.Len())

	q.Put(`1`)
	q.Put(`2`)

	result, err = q.Get(1)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `1`, result[0])
	assert.Equal(t, int64(1), q.Len())

	result, err = q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result[0])
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) result, err := q.Get(2) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `test`, result[0]) assert.Equal(t, int64(0), q.Len()) q.Put(`1`) q.Put(`2`) result, err = q.Get(1) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `1`, result[0]) assert.Equal(t, int64(1), q.Len()) result, err = q.Get(2) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result[0]) }]} {Id:3 FileId:97 StartLine:85 StartColumn:1 EndLine:126 EndColumn:2 Name:TestPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Poll(1, time.Millisecond)

	q.Put(`test`)
	result, err := q.Poll(2, 0)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `test`, result[0])
	assert.Equal(t, int64(0), q.Len())

	q.Put(`1`)
	q.Put(`2`)

	result, err = q.Poll(1, time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `1`, result[0])
	assert.Equal(t, int64(1), q.Len())

	result, err = q.Poll(2, time.Millisecond)
	if !assert.Nil(t, err) {
		return
	}

	assert.Equal(t, `2`, result[0])

	before := time.Now()
	_, err = q.Poll(1, 5*time.Millisecond)

	assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10)
	assert.Equal(t, ErrTimeout, err)
} PrettyPrintBody:[{ q := New(10) q.Poll(1, time.Millisecond) q.Put(`test`) result, err := q.Poll(2, 0) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `test`, result[0]) assert.Equal(t, int64(0), q.Len()) q.Put(`1`) q.Put(`2`) result, err = q.Poll(1, time.Millisecond) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `1`, result[0]) assert.Equal(t, int64(1), q.Len()) result, err = q.Poll(2, time.Millisecond) if !assert.Nil(t, err) { return } assert.Equal(t, `2`, result[0]) before := time.Now() _, err = q.Poll(1, 5*time.Millisecond) assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10) assert.Equal(t, ErrTimeout, err) }]} {Id:4 FileId:97 StartLine:128 StartColumn:1 EndLine:138 EndColumn:2 Name:TestPollNoMemoryLeak Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(0)

	assert.Len(t, q.waiters, 0)

	for i := 0; i < 10; i++ {

		q.Poll(1, time.Nanosecond)
		assert.Len(t, q.waiters, 0)
	}
} PrettyPrintBody:[{ q := New(0) assert.Len(t, q.waiters, 0) for i := 0; i < 10; i++ { q.Poll(1, time.Nanosecond) assert.Len(t, q.waiters, 0) } }]} {Id:5 FileId:97 StartLine:140 StartColumn:1 EndLine:148 EndColumn:2 Name:TestAddEmptyPut Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put()

	if q.Len() != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, q.Len())
	}
} PrettyPrintBody:[{ q := New(10) q.Put() if q.Len() != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, q.Len()) } }]} {Id:6 FileId:97 StartLine:150 StartColumn:1 EndLine:162 EndColumn:2 Name:TestGetNonPositiveNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Put(`test`)
	result, err := q.Get(0)
	if !assert.Nil(t, err) {
		return
	}

	if len(result) != 0 {
		t.Errorf(`Expected len: %d, received: %d`, 0, len(result))
	}
} PrettyPrintBody:[{ q := New(10) q.Put(`test`) result, err := q.Get(0) if !assert.Nil(t, err) { return } if len(result) != 0 { t.Errorf(`Expected len: %d, received: %d`, 0, len(result)) } }]} {Id:7 FileId:97 StartLine:164 StartColumn:1 EndLine:175 EndColumn:2 Name:TestEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	if !q.Empty() {
		t.Errorf(`Expected empty queue.`)
	}

	q.Put(`test`)
	if q.Empty() {
		t.Errorf(`Expected non-empty queue.`)
	}
} PrettyPrintBody:[{ q := New(10) if !q.Empty() { t.Errorf(`Expected empty queue.`) } q.Put(`test`) if q.Empty() { t.Errorf(`Expected non-empty queue.`) } }]} {Id:8 FileId:97 StartLine:177 StartColumn:1 EndLine:191 EndColumn:2 Name:TestGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	go func() {
		q.Put(`a`)
	}()

	result, err := q.Get(2)
	if !assert.Nil(t, err) {
		return
	}

	assert.Len(t, result, 1)
	assert.Equal(t, `a`, result[0])
} PrettyPrintBody:[{ q := New(10) go func() { q.Put(`a`) }() result, err := q.Get(2) if !assert.Nil(t, err) { return } assert.Len(t, result, 1) assert.Equal(t, `a`, result[0]) }]} {Id:9 FileId:97 StartLine:193 StartColumn:1 EndLine:226 EndColumn:2 Name:TestMultipleGetEmpty Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	var wg sync.WaitGroup
	wg.Add(2)
	results := make([][]interface{}, 2)

	go func() {
		wg.Done()
		local, err := q.Get(1)
		assert.Nil(t, err)
		results[0] = local
		wg.Done()
	}()

	go func() {
		wg.Done()
		local, err := q.Get(1)
		assert.Nil(t, err)
		results[1] = local
		wg.Done()
	}()

	wg.Wait()
	wg.Add(2)

	q.Put(`a`, `b`, `c`)
	wg.Wait()

	if assert.Len(t, results[0], 1) && assert.Len(t, results[1], 1) {
		assert.True(t, (results[0][0] == `a` && results[1][0] == `b`) ||
			(results[0][0] == `b` && results[1][0] == `a`),
			`The array should be a, b or b, a`)
	}
} PrettyPrintBody:[{ q := New(10) var wg sync.WaitGroup wg.Add(2) results := make([][]interface{}, 2) go func() { wg.Done() local, err := q.Get(1) assert.Nil(t, err) results[0] = local wg.Done() }() go func() { wg.Done() local, err := q.Get(1) assert.Nil(t, err) results[1] = local wg.Done() }() wg.Wait() wg.Add(2) q.Put(`a`, `b`, `c`) wg.Wait() if assert.Len(t, results[0], 1) && assert.Len(t, results[1], 1) { assert.True(t, (results[0][0] == `a` && results[1][0] == `b`) || (results[0][0] == `b` && results[1][0] == `a`), `The array should be a, b or b, a`) } }]} {Id:10 FileId:97 StartLine:228 StartColumn:1 EndLine:246 EndColumn:2 Name:TestDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{

	q := New(10)
	itemsDisposed := q.Dispose()

	assert.Empty(t, itemsDisposed)

	q = New(10)
	q.Put(`1`)
	itemsDisposed = q.Dispose()

	expected := []interface{}{`1`}
	assert.Equal(t, expected, itemsDisposed)

	itemsDisposed = q.Dispose()
	assert.Nil(t, itemsDisposed)
} PrettyPrintBody:[{ q := New(10) itemsDisposed := q.Dispose() assert.Empty(t, itemsDisposed) q = New(10) q.Put(`1`) itemsDisposed = q.Dispose() expected := []interface{}{`1`} assert.Equal(t, expected, itemsDisposed) itemsDisposed = q.Dispose() assert.Nil(t, itemsDisposed) }]} {Id:11 FileId:97 StartLine:248 StartColumn:1 EndLine:269 EndColumn:2 Name:TestEmptyGetWithDispose Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	var wg sync.WaitGroup
	wg.Add(1)

	var err error

	go func() {
		wg.Done()
		_, err = q.Get(1)
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)

	q.Dispose()

	wg.Wait()

	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) var wg sync.WaitGroup wg.Add(1) var err error go func() { wg.Done() _, err = q.Get(1) wg.Done() }() wg.Wait() wg.Add(1) q.Dispose() wg.Wait() assert.IsType(t, ErrDisposed, err) }]} {Id:12 FileId:97 StartLine:271 StartColumn:1 EndLine:282 EndColumn:2 Name:TestDisposeAfterEmptyPoll Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	_, err := q.Poll(1, time.Millisecond)
	assert.IsType(t, ErrTimeout, err)

	q.Dispose()

	_, err = q.Poll(1, time.Millisecond)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) _, err := q.Poll(1, time.Millisecond) assert.IsType(t, ErrTimeout, err) q.Dispose() _, err = q.Poll(1, time.Millisecond) assert.IsType(t, ErrDisposed, err) }]} {Id:13 FileId:97 StartLine:284 StartColumn:1 EndLine:294 EndColumn:2 Name:TestGetPutDisposed Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)

	q.Dispose()

	_, err := q.Get(1)
	assert.IsType(t, ErrDisposed, err)

	err = q.Put(`a`)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() _, err := q.Get(1) assert.IsType(t, ErrDisposed, err) err = q.Put(`a`) assert.IsType(t, ErrDisposed, err) }]} {Id:14 FileId:97 StartLine:296 StartColumn:1 EndLine:318 EndColumn:2 Name:BenchmarkQueue Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	q := New(int64(b.N))
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			q.Get(1)
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		q.Put(`a`)
	}

	wg.Wait()
} PrettyPrintBody:[{ q := New(int64(b.N)) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { q.Get(1) i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { q.Put(`a`) } wg.Wait() }]} {Id:15 FileId:97 StartLine:320 StartColumn:1 EndLine:342 EndColumn:2 Name:BenchmarkChannel Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	ch := make(chan interface{}, 1)
	var wg sync.WaitGroup
	wg.Add(1)
	i := 0

	go func() {
		for {
			<-ch
			i++
			if i == b.N {
				wg.Done()
				break
			}
		}
	}()

	for i := 0; i < b.N; i++ {
		ch <- `a`
	}

	wg.Wait()
} PrettyPrintBody:[{ ch := make(chan interface{}, 1) var wg sync.WaitGroup wg.Add(1) i := 0 go func() { for { <-ch i++ if i == b.N { wg.Done() break } } }() for i := 0; i < b.N; i++ { ch <- `a` } wg.Wait() }]} {Id:16 FileId:97 StartLine:344 StartColumn:1 EndLine:359 EndColumn:2 Name:TestPeek Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`)
	q.Put(`b`)
	q.Put(`c`)
	peekResult, err := q.Peek()
	peekExpected := `a`
	assert.Nil(t, err)
	assert.Equal(t, q.Len(), int64(3))
	assert.Equal(t, peekExpected, peekResult)

	popResult, err := q.Get(1)
	assert.Nil(t, err)
	assert.Equal(t, peekResult, popResult[0])
	assert.Equal(t, q.Len(), int64(2))
} PrettyPrintBody:[{ q := New(10) q.Put(`a`) q.Put(`b`) q.Put(`c`) peekResult, err := q.Peek() peekExpected := `a` assert.Nil(t, err) assert.Equal(t, q.Len(), int64(3)) assert.Equal(t, peekExpected, peekResult) popResult, err := q.Get(1) assert.Nil(t, err) assert.Equal(t, peekResult, popResult[0]) assert.Equal(t, q.Len(), int64(2)) }]} {Id:17 FileId:97 StartLine:361 StartColumn:1 EndLine:368 EndColumn:2 Name:TestPeekOnDisposedQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Dispose()
	result, err := q.Peek()

	assert.Nil(t, result)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() result, err := q.Peek() assert.Nil(t, result) assert.IsType(t, ErrDisposed, err) }]} {Id:18 FileId:97 StartLine:370 StartColumn:1 EndLine:383 EndColumn:2 Name:TestTakeUntil Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	result, err := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	if !assert.Nil(t, err) {
		return
	}

	expected := []interface{}{`a`, `b`}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) result, err := q.TakeUntil(func(item interface{}) bool { return item != `c` }) if !assert.Nil(t, err) { return } expected := []interface{}{`a`, `b`} assert.Equal(t, expected, result) }]} {Id:19 FileId:97 StartLine:385 StartColumn:1 EndLine:397 EndColumn:2 Name:TestTakeUntilEmptyQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	result, err := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	if !assert.Nil(t, err) {
		return
	}

	expected := []interface{}{}
	assert.Equal(t, expected, result)
} PrettyPrintBody:[{ q := New(10) result, err := q.TakeUntil(func(item interface{}) bool { return item != `c` }) if !assert.Nil(t, err) { return } expected := []interface{}{} assert.Equal(t, expected, result) }]} {Id:20 FileId:97 StartLine:399 StartColumn:1 EndLine:409 EndColumn:2 Name:TestTakeUntilThenGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	takeItems, _ := q.TakeUntil(func(item interface{}) bool {
		return item != `c`
	})

	restItems, _ := q.Get(3)
	assert.Equal(t, []interface{}{`a`, `b`}, takeItems)
	assert.Equal(t, []interface{}{`c`}, restItems)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) takeItems, _ := q.TakeUntil(func(item interface{}) bool { return item != `c` }) restItems, _ := q.Get(3) assert.Equal(t, []interface{}{`a`, `b`}, takeItems) assert.Equal(t, []interface{}{`c`}, restItems) }]} {Id:21 FileId:97 StartLine:411 StartColumn:1 EndLine:421 EndColumn:2 Name:TestTakeUntilNoMatches Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Put(`a`, `b`, `c`)
	takeItems, _ := q.TakeUntil(func(item interface{}) bool {
		return item != `a`
	})

	restItems, _ := q.Get(3)
	assert.Equal(t, []interface{}{}, takeItems)
	assert.Equal(t, []interface{}{`a`, `b`, `c`}, restItems)
} PrettyPrintBody:[{ q := New(10) q.Put(`a`, `b`, `c`) takeItems, _ := q.TakeUntil(func(item interface{}) bool { return item != `a` }) restItems, _ := q.Get(3) assert.Equal(t, []interface{}{}, takeItems) assert.Equal(t, []interface{}{`a`, `b`, `c`}, restItems) }]} {Id:22 FileId:97 StartLine:423 StartColumn:1 EndLine:432 EndColumn:2 Name:TestTakeUntilOnDisposedQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	q.Dispose()
	result, err := q.TakeUntil(func(item interface{}) bool {
		return true
	})

	assert.Nil(t, result)
	assert.IsType(t, ErrDisposed, err)
} PrettyPrintBody:[{ q := New(10) q.Dispose() result, err := q.TakeUntil(func(item interface{}) bool { return true }) assert.Nil(t, result) assert.IsType(t, ErrDisposed, err) }]} {Id:23 FileId:97 StartLine:434 StartColumn:1 EndLine:494 EndColumn:2 Name:TestWaiters Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	s1, s2, s3, s4 := newSema(), newSema(), newSema(), newSema()

	w := waiters{}
	assert.Len(t, w, 0)

	w.put(s1)
	assert.Equal(t, waiters{s1}, w)

	w.put(s2)
	w.put(s3)
	w.put(s4)
	assert.Equal(t, waiters{s1, s2, s3, s4}, w)

	w.remove(s2)
	assert.Equal(t, waiters{s1, s3, s4}, w)

	w.remove(s2)
	assert.Equal(t, waiters{s1, s3, s4}, w)

	w.remove(s1)
	assert.Equal(t, waiters{s3, s4}, w)

	w.remove(s4)
	assert.Equal(t, waiters{s3}, w)

	w.remove(s3)
	assert.Empty(t, w)

	w.remove(s3)
	assert.Empty(t, w)

	w.put(s1)
	w.put(s2)
	w.put(s3)
	assert.Equal(t, waiters{s1, s2, s3}, w)

	assert.Equal(t, s1, w.get())
	assert.Equal(t, s2, w.get())
	w.put(s4)
	assert.Equal(t, s3, w.get())
	assert.Equal(t, s4, w.get())
	assert.Empty(t, w)
	assert.Nil(t, w.get())
} PrettyPrintBody:[{ s1, s2, s3, s4 := newSema(), newSema(), newSema(), newSema() w := waiters{} assert.Len(t, w, 0) w.put(s1) assert.Equal(t, waiters{s1}, w) w.put(s2) w.put(s3) w.put(s4) assert.Equal(t, waiters{s1, s2, s3, s4}, w) w.remove(s2) assert.Equal(t, waiters{s1, s3, s4}, w) w.remove(s2) assert.Equal(t, waiters{s1, s3, s4}, w) w.remove(s1) assert.Equal(t, waiters{s3, s4}, w) w.remove(s4) assert.Equal(t, waiters{s3}, w) w.remove(s3) assert.Empty(t, w) w.remove(s3) assert.Empty(t, w) w.put(s1) w.put(s2) w.put(s3) assert.Equal(t, waiters{s1, s2, s3}, w) assert.Equal(t, s1, w.get()) assert.Equal(t, s2, w.get()) w.put(s4) assert.Equal(t, s3, w.get()) assert.Equal(t, s4, w.get()) assert.Empty(t, w) assert.Nil(t, w.get()) }]} {Id:24 FileId:97 StartLine:496 StartColumn:1 EndLine:511 EndColumn:2 Name:TestExecuteInParallel Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(10)
	for i := 0; i < 10; i++ {
		q.Put(i)
	}

	numCalls := uint64(0)

	ExecuteInParallel(q, func(item interface{}) {
		t.Logf("ExecuteInParallel called us with %+v", item)
		atomic.AddUint64(&numCalls, 1)
	})

	assert.Equal(t, uint64(10), numCalls)
	assert.True(t, q.Disposed())
} PrettyPrintBody:[{ q := New(10) for i := 0; i < 10; i++ { q.Put(i) } numCalls := uint64(0) ExecuteInParallel(q, func(item interface{}) { t.Logf("ExecuteInParallel called us with %+v", item) atomic.AddUint64(&numCalls, 1) }) assert.Equal(t, uint64(10), numCalls) assert.True(t, q.Disposed()) }]} {Id:25 FileId:97 StartLine:513 StartColumn:1 EndLine:520 EndColumn:2 Name:TestExecuteInParallelEmptyQueue Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	q := New(1)

	ExecuteInParallel(q, func(interface{}) {
		t.Fail()
	})
} PrettyPrintBody:[{ q := New(1) ExecuteInParallel(q, func(interface{}) { t.Fail() }) }]} {Id:26 FileId:97 StartLine:522 StartColumn:1 EndLine:539 EndColumn:2 Name:BenchmarkQueuePut Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(10)
		qs = append(qs, q)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		q := qs[i]
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(10) qs = append(qs, q) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] for j := int64(0); j < numItems; j++ { q.Put(j) } } }]} {Id:27 FileId:97 StartLine:541 StartColumn:1 EndLine:562 EndColumn:2 Name:BenchmarkQueueGet Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		q := qs[i]
		for j := int64(0); j < numItems; j++ {
			q.Get(1)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] for j := int64(0); j < numItems; j++ { q.Get(1) } } }]} {Id:28 FileId:97 StartLine:564 StartColumn:1 EndLine:584 EndColumn:2 Name:BenchmarkQueuePoll Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	b.ResetTimer()

	for _, q := range qs {
		for j := int64(0); j < numItems; j++ {
			q.Poll(1, time.Millisecond)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } b.ResetTimer() for _, q := range qs { for j := int64(0); j < numItems; j++ { q.Poll(1, time.Millisecond) } } }]} {Id:29 FileId:97 StartLine:586 StartColumn:1 EndLine:611 EndColumn:2 Name:BenchmarkExecuteInParallel Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	qs := make([]*Queue, 0, b.N)

	for i := 0; i < b.N; i++ {
		q := New(numItems)
		for j := int64(0); j < numItems; j++ {
			q.Put(j)
		}
		qs = append(qs, q)
	}

	var counter int64
	fn := func(ifc interface{}) {
		c := ifc.(int64)
		atomic.AddInt64(&counter, c)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		q := qs[i]
		ExecuteInParallel(q, fn)
	}
} PrettyPrintBody:[{ numItems := int64(1000) qs := make([]*Queue, 0, b.N) for i := 0; i < b.N; i++ { q := New(numItems) for j := int64(0); j < numItems; j++ { q.Put(j) } qs = append(qs, q) } var counter int64 fn := func(ifc interface{}) { c := ifc.(int64) atomic.AddInt64(&counter, c) } b.ResetTimer() for i := 0; i < b.N; i++ { q := qs[i] ExecuteInParallel(q, fn) } }]} {Id:1 FileId:7 StartLine:25 StartColumn:1 EndLine:46 EndColumn:2 Name:constructMultiDimensionQueryTestTree Params:[] Results:[{Name: Type:*tree} {Name: Type:Interval} {Name: Type:Interval} {Name: Type:Interval}] Receiver:<nil> Body:{

	it := newTree(2)

	iv1 := constructMultiDimensionInterval(
		0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10},
	)
	it.Add(iv1)

	iv2 := constructMultiDimensionInterval(
		1, &dimension{low: 4, high: 5}, &dimension{low: 4, high: 5},
	)
	it.Add(iv2)

	iv3 := constructMultiDimensionInterval(
		2, &dimension{low: 7, high: 12}, &dimension{low: 7, high: 12},
	)
	it.Add(iv3)

	return it, iv1, iv2, iv3
} PrettyPrintBody:[{ it := newTree(2) iv1 := constructMultiDimensionInterval( 0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10}, ) it.Add(iv1) iv2 := constructMultiDimensionInterval( 1, &dimension{low: 4, high: 5}, &dimension{low: 4, high: 5}, ) it.Add(iv2) iv3 := constructMultiDimensionInterval( 2, &dimension{low: 7, high: 12}, &dimension{low: 7, high: 12}, ) it.Add(iv3) return it, iv1, iv2, iv3 }]} {Id:2 FileId:7 StartLine:48 StartColumn:1 EndLine:70 EndColumn:2 Name:TestRootAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)
	iv := constructMultiDimensionInterval(
		1, &dimension{low: 0, high: 5}, &dimension{low: 1, high: 6},
	)

	it.Add(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Equal(t, Intervals{iv}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{100, 200}, &dimension{100, 200},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it := newTree(2) iv := constructMultiDimensionInterval( 1, &dimension{low: 0, high: 5}, &dimension{low: 1, high: 6}, ) it.Add(iv) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Equal(t, Intervals{iv}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{100, 200}, &dimension{100, 200}, ), ) assert.Len(t, result, 0) }]} {Id:3 FileId:7 StartLine:72 StartColumn:1 EndLine:111 EndColumn:2 Name:TestMultipleAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree()

	checkRedBlack(t, it.root, 1)

	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Equal(t, Intervals{iv2, iv1, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{3, 5}, &dimension{3, 5},
		),
	)
	assert.Equal(t, Intervals{iv2}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{5, 8}, &dimension{5, 8},
		),
	)
	assert.Equal(t, Intervals{iv1, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{11, 15}, &dimension{11, 15},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{15, 20}, &dimension{15, 20},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree() checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Equal(t, Intervals{iv2, iv1, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{3, 5}, &dimension{3, 5}, ), ) assert.Equal(t, Intervals{iv2}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{5, 8}, &dimension{5, 8}, ), ) assert.Equal(t, Intervals{iv1, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{11, 15}, &dimension{11, 15}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{15, 20}, &dimension{15, 20}, ), ) assert.Len(t, result, 0) }]} {Id:4 FileId:7 StartLine:113 StartColumn:1 EndLine:131 EndColumn:2 Name:TestAddRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	for i := int64(0); i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(2) for i := int64(0); i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]} {Id:5 FileId:7 StartLine:133 StartColumn:1 EndLine:151 EndColumn:2 Name:TestAddRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	for i := int64(9); i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), it.Len())
} PrettyPrintBody:[{ it := newTree(2) for i := int64(9); i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 10) assert.Equal(t, uint64(10), it.Len()) }]} {Id:6 FileId:7 StartLine:153 StartColumn:1 EndLine:173 EndColumn:2 Name:TestAddRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	starts := []int64{0, 4, 2, 1, 3}

	for i, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), it.Len())
} PrettyPrintBody:[{ it := newTree(2) starts := []int64{0, 4, 2, 1, 3} for i, start := range starts { iv := constructMultiDimensionInterval( uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 5) assert.Equal(t, uint64(5), it.Len()) }]} {Id:7 FileId:7 StartLine:175 StartColumn:1 EndLine:194 EndColumn:2 Name:TestAddLargeNumbersMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	it := newTree(2)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
	}

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, numItems}, &dimension{0, numItems},
		),
	)
	assert.Len(t, result, int(numItems))
	assert.Equal(t, uint64(numItems), it.Len())
} PrettyPrintBody:[{ numItems := int64(1000) it := newTree(2) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) } checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, numItems}, &dimension{0, numItems}, ), ) assert.Len(t, result, int(numItems)) assert.Equal(t, uint64(numItems), it.Len()) }]} {Id:8 FileId:7 StartLine:196 StartColumn:1 EndLine:213 EndColumn:2 Name:BenchmarkAddItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(b.N)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	it := newTree(2)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		it.Add(intervals[int64(i)%numItems])
	}
} PrettyPrintBody:[{ numItems := int64(b.N) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } it := newTree(2) b.ResetTimer() for i := 0; i < b.N; i++ { it.Add(intervals[int64(i)%numItems]) } }]} {Id:9 FileId:7 StartLine:215 StartColumn:1 EndLine:237 EndColumn:2 Name:BenchmarkQueryItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	it := newTree(2)
	it.Add(intervals...)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		it.Query(
			constructMultiDimensionInterval(
				0, &dimension{0, numItems}, &dimension{0, numItems},
			),
		)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } it := newTree(2) it.Add(intervals...) b.ResetTimer() for i := 0; i < b.N; i++ { it.Query( constructMultiDimensionInterval( 0, &dimension{0, numItems}, &dimension{0, numItems}, ), ) } }]} {Id:10 FileId:7 StartLine:239 StartColumn:1 EndLine:256 EndColumn:2 Name:TestRootDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)
	iv := constructMultiDimensionInterval(
		0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10},
	)
	it.Add(iv)

	it.Delete(iv)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) iv := constructMultiDimensionInterval( 0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10}, ) it.Add(iv) it.Delete(iv) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Len(t, result, 0) assert.Equal(t, uint64(0), it.Len()) }]} {Id:11 FileId:7 StartLine:258 StartColumn:1 EndLine:299 EndColumn:2 Name:TestDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree()

	checkRedBlack(t, it.root, 1)

	it.Delete(iv1)

	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 100}, &dimension{0, 100},
		),
	)
	assert.Equal(t, Intervals{iv2, iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{3, 5}, &dimension{3, 5},
		),
	)
	assert.Equal(t, Intervals{iv2}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{5, 8}, &dimension{5, 8},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{11, 15}, &dimension{11, 15},
		),
	)
	assert.Equal(t, Intervals{iv3}, result)

	result = it.Query(
		constructMultiDimensionInterval(
			0, &dimension{15, 20}, &dimension{15, 20},
		),
	)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree() checkRedBlack(t, it.root, 1) it.Delete(iv1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 100}, &dimension{0, 100}, ), ) assert.Equal(t, Intervals{iv2, iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{3, 5}, &dimension{3, 5}, ), ) assert.Equal(t, Intervals{iv2}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{5, 8}, &dimension{5, 8}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{11, 15}, &dimension{11, 15}, ), ) assert.Equal(t, Intervals{iv3}, result) result = it.Query( constructMultiDimensionInterval( 0, &dimension{15, 20}, &dimension{15, 20}, ), ) assert.Len(t, result, 0) }]} {Id:12 FileId:7 StartLine:301 StartColumn:1 EndLine:326 EndColumn:2 Name:TestDeleteRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	var toDelete *mockInterval

	for i := int64(0); i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(2) var toDelete *mockInterval for i := int64(0); i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]} {Id:13 FileId:7 StartLine:328 StartColumn:1 EndLine:353 EndColumn:2 Name:TestDeleteRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	var toDelete *mockInterval

	for i := int64(9); i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		it.Add(iv)
		if i == 5 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), it.Len())
} PrettyPrintBody:[{ it := newTree(2) var toDelete *mockInterval for i := int64(9); i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) it.Add(iv) if i == 5 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 9) assert.Equal(t, uint64(9), it.Len()) }]} {Id:14 FileId:7 StartLine:355 StartColumn:1 EndLine:382 EndColumn:2 Name:TestDeleteRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	starts := []int64{0, 4, 2, 1, 3}

	var toDelete *mockInterval

	for i, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1},
		)
		it.Add(iv)
		if start == 1 {
			toDelete = iv
		}
	}

	it.Delete(toDelete)

	checkRedBlack(t, it.root, 1)
	result := it.Query(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), it.Len())
} PrettyPrintBody:[{ it := newTree(2) starts := []int64{0, 4, 2, 1, 3} var toDelete *mockInterval for i, start := range starts { iv := constructMultiDimensionInterval( uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1}, ) it.Add(iv) if start == 1 { toDelete = iv } } it.Delete(toDelete) checkRedBlack(t, it.root, 1) result := it.Query( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Len(t, result, 4) assert.Equal(t, uint64(4), it.Len()) }]} {Id:15 FileId:7 StartLine:384 StartColumn:1 EndLine:393 EndColumn:2 Name:TestDeleteEmptyTreeMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	it.Delete(
		constructMultiDimensionInterval(
			0, &dimension{0, 10}, &dimension{0, 10},
		),
	)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) it.Delete( constructMultiDimensionInterval( 0, &dimension{0, 10}, &dimension{0, 10}, ), ) assert.Equal(t, uint64(0), it.Len()) }]} {Id:16 FileId:7 StartLine:395 StartColumn:1 EndLine:418 EndColumn:2 Name:BenchmarkDeleteItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)
	intervals := make(Intervals, 0, numItems)

	for i := int64(0); i < numItems; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},
		)
		intervals = append(intervals, iv)
	}

	trees := make([]*tree, 0, b.N)
	for i := 0; i < b.N; i++ {
		it := newTree(2)
		it.Add(intervals...)
		trees = append(trees, it)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(intervals...)
	}
} PrettyPrintBody:[{ numItems := int64(1000) intervals := make(Intervals, 0, numItems) for i := int64(0); i < numItems; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1}, ) intervals = append(intervals, iv) } trees := make([]*tree, 0, b.N) for i := 0; i < b.N; i++ { it := newTree(2) it.Add(intervals...) trees = append(trees, it) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(intervals...) } }]} {Id:17 FileId:7 StartLine:420 StartColumn:1 EndLine:435 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 10)

	for i := 0; i < 10; i++ {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 10) for i := 0; i < 10; i++ { iv := constructMultiDimensionInterval( uint64(i), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:18 FileId:7 StartLine:437 StartColumn:1 EndLine:452 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 10)

	for i := 9; i >= 0; i-- {
		iv := constructMultiDimensionInterval(
			uint64(i), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 10) for i := 9; i >= 0; i-- { iv := constructMultiDimensionInterval( uint64(i), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:19 FileId:7 StartLine:454 StartColumn:1 EndLine:470 EndColumn:2 Name:TestAddDeleteDuplicatesRebalanceRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	it := newTree(2)

	intervals := make(Intervals, 0, 5)
	starts := []int{0, 4, 2, 1, 3}

	for _, start := range starts {
		iv := constructMultiDimensionInterval(
			uint64(start), &dimension{0, 10}, &dimension{0, 10},
		)
		intervals = append(intervals, iv)
	}

	it.Add(intervals...)
	it.Delete(intervals...)
	assert.Equal(t, uint64(0), it.Len())
} PrettyPrintBody:[{ it := newTree(2) intervals := make(Intervals, 0, 5) starts := []int{0, 4, 2, 1, 3} for _, start := range starts { iv := constructMultiDimensionInterval( uint64(start), &dimension{0, 10}, &dimension{0, 10}, ) intervals = append(intervals, iv) } it.Add(intervals...) it.Delete(intervals...) assert.Equal(t, uint64(0), it.Len()) }]} {Id:1 FileId:111 StartLine:26 StartColumn:1 EndLine:39 EndColumn:2 Name:constructMultiDimensionalOrderedTree Params:[{Name:number Type:uint64}] Results:[{Name: Type:*orderedTree} {Name: Type:Entries}] Receiver:<nil> Body:{

	tree := newOrderedTree(2)

	entries := make(Entries, 0, number)
	for i := uint64(0); i < number; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree.Add(entries...)

	return tree, entries
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := make(Entries, 0, number) for i := uint64(0); i < number; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree.Add(entries...) return tree, entries }]} {Id:2 FileId:111 StartLine:41 StartColumn:1 EndLine:48 EndColumn:2 Name:TestOTRootAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(1)

	assert.Equal(t, uint64(1), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(1) assert.Equal(t, uint64(1), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) }]} {Id:3 FileId:111 StartLine:50 StartColumn:1 EndLine:78 EndColumn:2 Name:TestOTMultipleAddMultipleDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(4)

	assert.Equal(t, uint64(4), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)

	result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4}))
	assert.Equal(t, Entries{entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4}))
	assert.Equal(t, entries, result)

	result = tree.Query(constructMockInterval(dimension{1, 2}, dimension{1, 2}))
	assert.Equal(t, Entries{entries[1], entries[2]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{10, 20}))
	assert.Len(t, result, 0)

	result = tree.Query(constructMockInterval(dimension{10, 20}, dimension{0, 2}))
	assert.Len(t, result, 0)

	result = tree.Query(constructMockInterval(dimension{0, 1}, dimension{0, 0}))
	assert.Equal(t, Entries{entries[0]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 1}))
	assert.Equal(t, Entries{entries[0]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(4) assert.Equal(t, uint64(4), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4})) assert.Equal(t, Entries{entries[3]}, result) result = tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})) assert.Equal(t, entries, result) result = tree.Query(constructMockInterval(dimension{1, 2}, dimension{1, 2})) assert.Equal(t, Entries{entries[1], entries[2]}, result) result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{10, 20})) assert.Len(t, result, 0) result = tree.Query(constructMockInterval(dimension{10, 20}, dimension{0, 2})) assert.Len(t, result, 0) result = tree.Query(constructMockInterval(dimension{0, 1}, dimension{0, 0})) assert.Equal(t, Entries{entries[0]}, result) result = tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 1})) assert.Equal(t, Entries{entries[0]}, result) }]} {Id:4 FileId:111 StartLine:80 StartColumn:1 EndLine:87 EndColumn:2 Name:TestOTAddInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(10)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, uint64(10), tree.Len())
	assert.Len(t, result, 10)
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(10) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, uint64(10), tree.Len()) assert.Len(t, result, 10) assert.Equal(t, entries, result) }]} {Id:5 FileId:111 StartLine:89 StartColumn:1 EndLine:99 EndColumn:2 Name:TestOTAddReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	for i := uint64(10); i > 0; i-- {
		tree.Add(constructMockEntry(i, int64(i), int64(i)))
	}

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))
	assert.Len(t, result, 10)
	assert.Equal(t, uint64(10), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) for i := uint64(10); i > 0; i-- { tree.Add(constructMockEntry(i, int64(i), int64(i))) } result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 10) assert.Equal(t, uint64(10), tree.Len()) }]} {Id:6 FileId:111 StartLine:101 StartColumn:1 EndLine:113 EndColumn:2 Name:TestOTAddRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	starts := []uint64{0, 4, 2, 1, 3}

	for _, start := range starts {
		tree.Add(constructMockEntry(start, int64(start), int64(start)))
	}

	result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5}))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { tree.Add(constructMockEntry(start, int64(start), int64(start))) } result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5})) assert.Len(t, result, 5) assert.Equal(t, uint64(5), tree.Len()) }]} {Id:7 FileId:111 StartLine:115 StartColumn:1 EndLine:131 EndColumn:2 Name:TestOTAddLargeNumbersMultiDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	tree := newOrderedTree(2)

	for i := uint64(0); i < numItems; i++ {
		tree.Add(constructMockEntry(i, int64(i), int64(i)))
	}

	result := tree.Query(
		constructMockInterval(
			dimension{0, int64(numItems)},
			dimension{0, int64(numItems)},
		),
	)
	assert.Equal(t, numItems, tree.Len())
	assert.Len(t, result, int(numItems))
} PrettyPrintBody:[{ numItems := uint64(1000) tree := newOrderedTree(2) for i := uint64(0); i < numItems; i++ { tree.Add(constructMockEntry(i, int64(i), int64(i))) } result := tree.Query( constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ), ) assert.Equal(t, numItems, tree.Len()) assert.Len(t, result, int(numItems)) }]} {Id:8 FileId:111 StartLine:133 StartColumn:1 EndLine:157 EndColumn:2 Name:TestOTAddReturnsOverwritten Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	starts := []uint64{0, 4, 2, 1, 3}

	entries := make(Entries, 0, len(starts))
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	overwritten := tree.Add(entries...)

	assert.Equal(t, Entries{nil, nil, nil, nil, nil}, overwritten)

	oldEntry := entries[2]
	newEntry := constructMockEntry(10, oldEntry.ValueAtDimension(1),
		oldEntry.ValueAtDimension(2))
	overwritten = tree.Add(newEntry)

	assert.Equal(t, Entries{oldEntry}, overwritten)

	result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5}))
	assert.Len(t, result, 5)
	assert.Equal(t, uint64(5), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) starts := []uint64{0, 4, 2, 1, 3} entries := make(Entries, 0, len(starts)) for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } overwritten := tree.Add(entries...) assert.Equal(t, Entries{nil, nil, nil, nil, nil}, overwritten) oldEntry := entries[2] newEntry := constructMockEntry(10, oldEntry.ValueAtDimension(1), oldEntry.ValueAtDimension(2)) overwritten = tree.Add(newEntry) assert.Equal(t, Entries{oldEntry}, overwritten) result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5})) assert.Len(t, result, 5) assert.Equal(t, uint64(5), tree.Len()) }]} {Id:9 FileId:111 StartLine:159 StartColumn:1 EndLine:174 EndColumn:2 Name:BenchmarkOTAddItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := b.N
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < uint64(numItems); i++ {
		value := rand.Int63()
		entries = append(entries, constructMockEntry(i, value, value))
	}

	rt := newOrderedTree(2)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt.Add(entries[i%numItems])
	}
} PrettyPrintBody:[{ numItems := b.N entries := make(Entries, 0, numItems) for i := uint64(0); i < uint64(numItems); i++ { value := rand.Int63() entries = append(entries, constructMockEntry(i, value, value)) } rt := newOrderedTree(2) b.ResetTimer() for i := 0; i < b.N; i++ { rt.Add(entries[i%numItems]) } }]} {Id:10 FileId:111 StartLine:176 StartColumn:1 EndLine:196 EndColumn:2 Name:BenchmarkOTQueryItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < numItems; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree := newOrderedTree(2)
	tree.Add(entries...)
	iv := constructMockInterval(
		dimension{0, int64(numItems)},
		dimension{0, int64(numItems)},
	)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Query(iv)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) entries := make(Entries, 0, numItems) for i := uint64(0); i < numItems; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree := newOrderedTree(2) tree.Add(entries...) iv := constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Query(iv) } }]} {Id:11 FileId:111 StartLine:198 StartColumn:1 EndLine:206 EndColumn:2 Name:TestOTRootDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(1)
	tree.Delete(entries...)

	assert.Equal(t, uint64(0), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 100}, dimension{0, 100}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(1) tree.Delete(entries...) assert.Equal(t, uint64(0), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 100}, dimension{0, 100})) assert.Len(t, result, 0) }]} {Id:12 FileId:111 StartLine:208 StartColumn:1 EndLine:223 EndColumn:2 Name:TestOTDeleteMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(4)

	tree.Delete(entries[2])

	assert.Equal(t, uint64(3), tree.Len())

	result := tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4}))
	assert.Equal(t, Entries{entries[0], entries[1], entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4}))
	assert.Equal(t, Entries{entries[3]}, result)

	result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{0, 2}))
	assert.Equal(t, Entries{entries[0], entries[1]}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(4) tree.Delete(entries[2]) assert.Equal(t, uint64(3), tree.Len()) result := tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})) assert.Equal(t, Entries{entries[0], entries[1], entries[3]}, result) result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4})) assert.Equal(t, Entries{entries[3]}, result) result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{0, 2})) assert.Equal(t, Entries{entries[0], entries[1]}, result) }]} {Id:13 FileId:111 StartLine:225 StartColumn:1 EndLine:235 EndColumn:2 Name:TestOTDeleteInOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(10)

	tree.Delete(entries[5])

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), tree.Len())

	assert.NotContains(t, result, entries[5])
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(10) tree.Delete(entries[5]) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Len(t, result, 9) assert.Equal(t, uint64(9), tree.Len()) assert.NotContains(t, result, entries[5]) }]} {Id:14 FileId:111 StartLine:237 StartColumn:1 EndLine:254 EndColumn:2 Name:TestOTDeleteReverseOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	for i := uint64(10); i > 0; i-- {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	tree.Add(entries...)

	tree.Delete(entries[5])

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))
	assert.Len(t, result, 9)
	assert.Equal(t, uint64(9), tree.Len())

	assert.NotContains(t, result, entries[5])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() for i := uint64(10); i > 0; i-- { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } tree.Add(entries...) tree.Delete(entries[5]) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 9) assert.Equal(t, uint64(9), tree.Len()) assert.NotContains(t, result, entries[5]) }]} {Id:15 FileId:111 StartLine:256 StartColumn:1 EndLine:275 EndColumn:2 Name:TestOTDeleteRandomOrderMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	starts := []uint64{0, 4, 2, 1, 3}
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	tree.Add(entries...)

	tree.Delete(entries[2])

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))

	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), tree.Len())

	assert.NotContains(t, result, entries[2])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } tree.Add(entries...) tree.Delete(entries[2]) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 4) assert.Equal(t, uint64(4), tree.Len()) assert.NotContains(t, result, entries[2]) }]} {Id:16 FileId:111 StartLine:277 StartColumn:1 EndLine:283 EndColumn:2 Name:TestOTDeleteEmptyTreeMultiDimensions Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	tree.Delete(constructMockEntry(0, 0, 0))

	assert.Equal(t, uint64(0), tree.Len())
} PrettyPrintBody:[{ tree := newOrderedTree(2) tree.Delete(constructMockEntry(0, 0, 0)) assert.Equal(t, uint64(0), tree.Len()) }]} {Id:17 FileId:111 StartLine:285 StartColumn:1 EndLine:306 EndColumn:2 Name:TestOTDeleteReturnsDeleted Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newOrderedTree(2)

	entries := NewEntries()
	starts := []uint64{0, 4, 2, 1, 3}
	for _, start := range starts {
		entries = append(entries, constructMockEntry(start, int64(start), int64(start)))
	}

	tree.Add(entries...)

	deleted := tree.Delete(entries[2], constructMockEntry(10, 10, 10))

	assert.Equal(t, Entries{entries[2], nil}, deleted)

	result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11}))

	assert.Len(t, result, 4)
	assert.Equal(t, uint64(4), tree.Len())

	assert.NotContains(t, result, entries[2])
} PrettyPrintBody:[{ tree := newOrderedTree(2) entries := NewEntries() starts := []uint64{0, 4, 2, 1, 3} for _, start := range starts { entries = append(entries, constructMockEntry(start, int64(start), int64(start))) } tree.Add(entries...) deleted := tree.Delete(entries[2], constructMockEntry(10, 10, 10)) assert.Equal(t, Entries{entries[2], nil}, deleted) result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})) assert.Len(t, result, 4) assert.Equal(t, uint64(4), tree.Len()) assert.NotContains(t, result, entries[2]) }]} {Id:18 FileId:111 StartLine:308 StartColumn:1 EndLine:328 EndColumn:2 Name:BenchmarkOTDeleteItemsMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(1000)
	entries := make(Entries, 0, numItems)

	for i := uint64(0); i < numItems; i++ {
		entries = append(entries, constructMockEntry(i, int64(i), int64(i)))
	}

	trees := make([]*orderedTree, 0, b.N)
	for i := 0; i < b.N; i++ {
		tree := newOrderedTree(2)
		tree.Add(entries...)
		trees = append(trees, tree)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		trees[i].Delete(entries...)
	}
} PrettyPrintBody:[{ numItems := uint64(1000) entries := make(Entries, 0, numItems) for i := uint64(0); i < numItems; i++ { entries = append(entries, constructMockEntry(i, int64(i), int64(i))) } trees := make([]*orderedTree, 0, b.N) for i := 0; i < b.N; i++ { tree := newOrderedTree(2) tree.Add(entries...) trees = append(trees, tree) } b.ResetTimer() for i := 0; i < b.N; i++ { trees[i].Delete(entries...) } }]} {Id:19 FileId:111 StartLine:330 StartColumn:1 EndLine:347 EndColumn:2 Name:TestOverwrites Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalOrderedTree(1)

	entry := constructMockEntry(10, 10, 10)

	overwritten := tree.Add(entry)
	assert.Equal(t, Entries{nil}, overwritten)

	results := tree.Query(constructMockInterval(dimension{10, 11}, dimension{10, 11}))

	assert.Equal(t, Entries{entry}, results)
	assert.Equal(t, uint64(2), tree.Len())

	newEntry := constructMockEntry(10, 10, 10)

	overwritten = tree.Add(newEntry)
	assert.Equal(t, Entries{entry}, overwritten)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalOrderedTree(1) entry := constructMockEntry(10, 10, 10) overwritten := tree.Add(entry) assert.Equal(t, Entries{nil}, overwritten) results := tree.Query(constructMockInterval(dimension{10, 11}, dimension{10, 11})) assert.Equal(t, Entries{entry}, results) assert.Equal(t, uint64(2), tree.Len()) newEntry := constructMockEntry(10, 10, 10) overwritten = tree.Add(newEntry) assert.Equal(t, Entries{entry}, overwritten) }]} {Id:20 FileId:111 StartLine:349 StartColumn:1 EndLine:357 EndColumn:2 Name:TestGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := tree.Get(entries...)
	assert.Equal(t, entries, result)

	result = tree.Get(constructMockEntry(10000, 5000, 5000))
	assert.Equal(t, Entries{nil}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := tree.Get(entries...) assert.Equal(t, entries, result) result = tree.Get(constructMockEntry(10000, 5000, 5000)) assert.Equal(t, Entries{nil}, result) }]} {Id:21 FileId:111 StartLine:359 StartColumn:1 EndLine:372 EndColumn:2 Name:TestTreeApply Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := make(Entries, 0, len(entries))

	tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}),
		func(e Entry) bool {
			result = append(result, e)
			return true
		},
	)

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := make(Entries, 0, len(entries)) tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}), func(e Entry) bool { result = append(result, e) return true }, ) assert.Equal(t, entries, result) }]} {Id:22 FileId:111 StartLine:374 StartColumn:1 EndLine:387 EndColumn:2 Name:TestApplyWithBail Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	result := make(Entries, 0, 1)

	tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}),
		func(e Entry) bool {
			result = append(result, e)
			return false
		},
	)

	assert.Equal(t, entries[:1], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) result := make(Entries, 0, 1) tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}), func(e Entry) bool { result = append(result, e) return false }, ) assert.Equal(t, entries[:1], result) }]} {Id:23 FileId:111 StartLine:389 StartColumn:1 EndLine:404 EndColumn:2 Name:BenchmarkApply Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := 1000

	tree, _ := constructMultiDimensionalOrderedTree(uint64(numItems))

	iv := constructMockInterval(
		dimension{0, int64(numItems)}, dimension{0, int64(numItems)},
	)
	fn := func(Entry) bool { return true }

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Apply(iv, fn)
	}
} PrettyPrintBody:[{ numItems := 1000 tree, _ := constructMultiDimensionalOrderedTree(uint64(numItems)) iv := constructMockInterval( dimension{0, int64(numItems)}, dimension{0, int64(numItems)}, ) fn := func(Entry) bool { return true } b.ResetTimer() for i := 0; i < b.N; i++ { tree.Apply(iv, fn) } }]} {Id:24 FileId:111 StartLine:406 StartColumn:1 EndLine:415 EndColumn:2 Name:TestInsertPositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(2)

	modified, deleted := tree.InsertAtDimension(1, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(2) modified, deleted := tree.InsertAtDimension(1, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]} {Id:25 FileId:111 StartLine:417 StartColumn:1 EndLine:426 EndColumn:2 Name:TestInsertPositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[1:], result) }]} {Id:26 FileId:111 StartLine:428 StartColumn:1 EndLine:438 EndColumn:2 Name:TestInsertPositiveIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]} {Id:27 FileId:111 StartLine:440 StartColumn:1 EndLine:450 EndColumn:2 Name:TestInsertPositiveIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]} {Id:28 FileId:111 StartLine:452 StartColumn:1 EndLine:461 EndColumn:2 Name:TestInsertMultiplePositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]} {Id:29 FileId:111 StartLine:463 StartColumn:1 EndLine:472 EndColumn:2 Name:TestInsertMultiplePositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Equal(t, entries[1:], result) }]} {Id:30 FileId:111 StartLine:474 StartColumn:1 EndLine:487 EndColumn:2 Name:TestInsertNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree.Len()) }]} {Id:31 FileId:111 StartLine:489 StartColumn:1 EndLine:502 EndColumn:2 Name:TestInsertNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree.Len()) }]} {Id:32 FileId:111 StartLine:504 StartColumn:1 EndLine:515 EndColumn:2 Name:TestInsertNegativeIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree.Len()) }]} {Id:33 FileId:111 StartLine:517 StartColumn:1 EndLine:528 EndColumn:2 Name:TestInsertNegativeIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))

	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree.Len()) }]} {Id:34 FileId:111 StartLine:530 StartColumn:1 EndLine:540 EndColumn:2 Name:TestInsertMultipleNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree.Len()) }]} {Id:35 FileId:111 StartLine:542 StartColumn:1 EndLine:552 EndColumn:2 Name:TestInsertMultipleNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(2, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(2, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree.Len()) }]} {Id:36 FileId:111 StartLine:554 StartColumn:1 EndLine:563 EndColumn:2 Name:TestInsertInvalidDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(3, 1, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(3, 1, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]} {Id:37 FileId:111 StartLine:565 StartColumn:1 EndLine:574 EndColumn:2 Name:TestInsertInvalidNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalOrderedTree(3)

	modified, deleted := tree.InsertAtDimension(1, 1, 0)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)

	result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalOrderedTree(3) modified, deleted := tree.InsertAtDimension(1, 1, 0) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) }]} {Id:38 FileId:111 StartLine:576 StartColumn:1 EndLine:586 EndColumn:2 Name:BenchmarkInsertFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, 1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, 1) } }]} {Id:39 FileId:111 StartLine:588 StartColumn:1 EndLine:598 EndColumn:2 Name:BenchmarkInsertSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, 1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, 1) } }]} {Id:40 FileId:111 StartLine:600 StartColumn:1 EndLine:610 EndColumn:2 Name:BenchmarkDeleteFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, -1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, -1) } }]} {Id:41 FileId:111 StartLine:612 StartColumn:1 EndLine:622 EndColumn:2 Name:BenchmarkDeleteSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := uint64(100000)

	tree, _ := constructMultiDimensionalOrderedTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, -1)
	}
} PrettyPrintBody:[{ numItems := uint64(100000) tree, _ := constructMultiDimensionalOrderedTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, -1) } }]} {Id:42 FileId:111 StartLine:624 StartColumn:1 EndLine:644 EndColumn:2 Name:BenchmarkGetMultiDimensions Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItemsX := 10000
	numItemsY := 100

	tree := newOrderedTree(2)
	entries := make(Entries, 0, numItemsY*numItemsX)

	for i := 0; i < numItemsX; i++ {
		for j := 0; j < numItemsY; j++ {
			e := constructMockEntry(uint64(j*numItemsY+i), int64(i), int64(j))
			entries = append(entries, e)
		}
	}

	tree.Add(entries...)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.Get(entries[i%len(entries)])
	}
} PrettyPrintBody:[{ numItemsX := 10000 numItemsY := 100 tree := newOrderedTree(2) entries := make(Entries, 0, numItemsY*numItemsX) for i := 0; i < numItemsX; i++ { for j := 0; j < numItemsY; j++ { e := constructMockEntry(uint64(j*numItemsY+i), int64(i), int64(j)) entries = append(entries, e) } } tree.Add(entries...) b.ResetTimer() for i := 0; i < b.N; i++ { tree.Get(entries[i%len(entries)]) } }]} {Id:1 FileId:104 StartLine:25 StartColumn:1 EndLine:39 EndColumn:2 Name:TestImmutableSingleDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)

	result := tree.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Len(t, result, 0)

	result = tree2.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Equal(t, Entries{entry}, result)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) result := tree.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Len(t, result, 0) result = tree2.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Equal(t, Entries{entry}, result) }]} {Id:2 FileId:104 StartLine:41 StartColumn:1 EndLine:64 EndColumn:2 Name:TestImmutableSingleDimensionMultipleAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree1.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree2.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree2.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree1.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree1.Len()) result = tree2.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree2.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) }]} {Id:3 FileId:104 StartLine:66 StartColumn:1 EndLine:79 EndColumn:2 Name:TestImmutableSingleDimensionBulkAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	entries := Entries{e1, e2, e3}

	tree1 := tree.Add(entries...)

	result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree1.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) entries := Entries{e1, e2, e3} tree1 := tree.Add(entries...) result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree1.Len()) }]} {Id:4 FileId:104 StartLine:81 StartColumn:1 EndLine:95 EndColumn:2 Name:TestImmutableMultiDimensionAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)

	result := tree.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Len(t, result, 0)

	result = tree2.Query(
		constructMockInterval(dimension{0, 10}, dimension{0, 10}),
	)
	assert.Equal(t, Entries{entry}, result)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) result := tree.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Len(t, result, 0) result = tree2.Query( constructMockInterval(dimension{0, 10}, dimension{0, 10}), ) assert.Equal(t, Entries{entry}, result) }]} {Id:5 FileId:104 StartLine:97 StartColumn:1 EndLine:120 EndColumn:2 Name:TestImmutableMultiDimensionMultipleAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree1.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree2.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree2.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree1.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree1.Len()) result = tree2.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree2.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) }]} {Id:6 FileId:104 StartLine:122 StartColumn:1 EndLine:135 EndColumn:2 Name:TestImmutableMultiDimensionBulkAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	entries := Entries{e1, e2, e3}

	tree1 := tree.Add(entries...)

	result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10}))
	assert.Equal(t, entries, result)
	assert.Equal(t, uint64(3), tree1.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) entries := Entries{e1, e2, e3} tree1 := tree.Add(entries...) result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})) assert.Equal(t, entries, result) assert.Equal(t, uint64(3), tree1.Len()) }]} {Id:7 FileId:104 StartLine:137 StartColumn:1 EndLine:154 EndColumn:2 Name:BenchmarkImmutableMultiDimensionInserts Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(1000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newImmutableRangeTree(2)
		for _, e := range entries {
			tree = tree.Add(e)
		}
	}
} PrettyPrintBody:[{ numItems := int64(1000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newImmutableRangeTree(2) for _, e := range entries { tree = tree.Add(e) } } }]} {Id:8 FileId:104 StartLine:156 StartColumn:1 EndLine:171 EndColumn:2 Name:BenchmarkImmutableMultiDimensionBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newImmutableRangeTree(2)
		tree.Add(entries...)
	}
} PrettyPrintBody:[{ numItems := int64(100000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newImmutableRangeTree(2) tree.Add(entries...) } }]} {Id:9 FileId:104 StartLine:173 StartColumn:1 EndLine:188 EndColumn:2 Name:BenchmarkMultiDimensionBulkInsert Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	entries := make(Entries, 0, numItems)
	for i := int64(0); i < numItems; i++ {
		e := constructMockEntry(uint64(i), i, i)
		entries = append(entries, e)
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree := newOrderedTree(2)
		tree.Add(entries...)
	}
} PrettyPrintBody:[{ numItems := int64(100000) entries := make(Entries, 0, numItems) for i := int64(0); i < numItems; i++ { e := constructMockEntry(uint64(i), i, i) entries = append(entries, e) } b.ResetTimer() for i := 0; i < b.N; i++ { tree := newOrderedTree(2) tree.Add(entries...) } }]} {Id:10 FileId:104 StartLine:190 StartColumn:1 EndLine:200 EndColumn:2 Name:TestImmutableSingleDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)
	tree3 := tree2.Delete(entry)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree3.Query(iv)
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) tree3 := tree2.Delete(entry) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree3.Query(iv) assert.Len(t, result, 0) }]} {Id:11 FileId:104 StartLine:202 StartColumn:1 EndLine:235 EndColumn:2 Name:TestImmutableSingleDimensionMultipleDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	tree4 := tree3.Delete(e3)
	result := tree4.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree4.Len())

	tree5 := tree4.Delete(e2)
	result = tree5.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree5.Len())

	tree6 := tree5.Delete(e1)
	result = tree6.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree6.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())

	tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3)))
	assert.Equal(t, tree3, tree7)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) tree4 := tree3.Delete(e3) result := tree4.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree4.Len()) tree5 := tree4.Delete(e2) result = tree5.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree5.Len()) tree6 := tree5.Delete(e1) result = tree6.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree6.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3))) assert.Equal(t, tree3, tree7) }]} {Id:12 FileId:104 StartLine:237 StartColumn:1 EndLine:257 EndColumn:2 Name:TestImmutableSingleDimensionBulkDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(1)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1, e2, e3)
	tree2 := tree1.Delete(e2, e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree2.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree2.Len())

	tree3 := tree2.Delete(e1)

	result = tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(1) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1, e2, e3) tree2 := tree1.Delete(e2, e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree2.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree2.Len()) tree3 := tree2.Delete(e1) result = tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]} {Id:13 FileId:104 StartLine:259 StartColumn:1 EndLine:270 EndColumn:2 Name:TestImmutableMultiDimensionDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entry := constructMockEntry(0, int64(0), int64(0))
	tree2 := tree.Add(entry)
	tree3 := tree2.Delete(entry)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entry := constructMockEntry(0, int64(0), int64(0)) tree2 := tree.Add(entry) tree3 := tree2.Delete(entry) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]} {Id:14 FileId:104 StartLine:272 StartColumn:1 EndLine:305 EndColumn:2 Name:TestImmutableMultiDimensionMultipleDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1)
	tree2 := tree1.Add(e2)
	tree3 := tree2.Add(e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})
	tree4 := tree3.Delete(e3)

	result := tree4.Query(iv)
	assert.Equal(t, Entries{e1, e2}, result)
	assert.Equal(t, uint64(2), tree4.Len())

	tree5 := tree4.Delete(e2)
	result = tree5.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree5.Len())

	tree6 := tree5.Delete(e1)
	result = tree6.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree6.Len())

	result = tree3.Query(iv)
	assert.Equal(t, Entries{e1, e2, e3}, result)
	assert.Equal(t, uint64(3), tree3.Len())

	tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3)))
	assert.Equal(t, tree3, tree7)
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1) tree2 := tree1.Add(e2) tree3 := tree2.Add(e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) tree4 := tree3.Delete(e3) result := tree4.Query(iv) assert.Equal(t, Entries{e1, e2}, result) assert.Equal(t, uint64(2), tree4.Len()) tree5 := tree4.Delete(e2) result = tree5.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree5.Len()) tree6 := tree5.Delete(e1) result = tree6.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree6.Len()) result = tree3.Query(iv) assert.Equal(t, Entries{e1, e2, e3}, result) assert.Equal(t, uint64(3), tree3.Len()) tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3))) assert.Equal(t, tree3, tree7) }]} {Id:15 FileId:104 StartLine:307 StartColumn:1 EndLine:327 EndColumn:2 Name:TestImmutableMultiDimensionBulkDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	e1 := constructMockEntry(0, int64(0), int64(0))
	e2 := constructMockEntry(0, int64(1), int64(1))
	e3 := constructMockEntry(0, int64(2), int64(2))

	tree1 := tree.Add(e1, e2, e3)
	tree2 := tree1.Delete(e2, e3)

	iv := constructMockInterval(dimension{0, 10}, dimension{0, 10})

	result := tree2.Query(iv)
	assert.Equal(t, Entries{e1}, result)
	assert.Equal(t, uint64(1), tree2.Len())

	tree3 := tree2.Delete(e1)

	result = tree3.Query(iv)
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(0), tree3.Len())
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) e1 := constructMockEntry(0, int64(0), int64(0)) e2 := constructMockEntry(0, int64(1), int64(1)) e3 := constructMockEntry(0, int64(2), int64(2)) tree1 := tree.Add(e1, e2, e3) tree2 := tree1.Delete(e2, e3) iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}) result := tree2.Query(iv) assert.Equal(t, Entries{e1}, result) assert.Equal(t, uint64(1), tree2.Len()) tree3 := tree2.Delete(e1) result = tree3.Query(iv) assert.Len(t, result, 0) assert.Equal(t, uint64(0), tree3.Len()) }]} {Id:16 FileId:104 StartLine:329 StartColumn:1 EndLine:337 EndColumn:2 Name:constructMultiDimensionalImmutableTree Params:[{Name:number Type:int64}] Results:[{Name: Type:*immutableRangeTree} {Name: Type:Entries}] Receiver:<nil> Body:{
	tree := newImmutableRangeTree(2)
	entries := make(Entries, 0, number)
	for i := int64(0); i < number; i++ {
		entries = append(entries, constructMockEntry(uint64(i), i, i))
	}

	return tree.Add(entries...), entries
} PrettyPrintBody:[{ tree := newImmutableRangeTree(2) entries := make(Entries, 0, number) for i := int64(0); i < number; i++ { entries = append(entries, constructMockEntry(uint64(i), i, i)) } return tree.Add(entries...), entries }]} {Id:17 FileId:104 StartLine:339 StartColumn:1 EndLine:351 EndColumn:2 Name:TestImmutableInsertPositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(2)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{0, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(2) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{0, 10})) assert.Len(t, result, 0) }]} {Id:18 FileId:104 StartLine:353 StartColumn:1 EndLine:365 EndColumn:2 Name:TestImmutableInsertPositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, 1)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[2:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, 1) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[2:], result) }]} {Id:19 FileId:104 StartLine:367 StartColumn:1 EndLine:374 EndColumn:2 Name:TestImmutableInsertPositiveIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:20 FileId:104 StartLine:376 StartColumn:1 EndLine:383 EndColumn:2 Name:TestImmutableInsertPositiveIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 4, 1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 4, 1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:21 FileId:104 StartLine:385 StartColumn:1 EndLine:397 EndColumn:2 Name:TestImmutableInsertMultiplePositiveIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})) assert.Len(t, result, 0) }]} {Id:22 FileId:104 StartLine:399 StartColumn:1 EndLine:411 EndColumn:2 Name:TestImmutableInsertMultiplePositiveIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, 2)
	assert.Len(t, deleted, 0)
	assert.Equal(t, entries[1:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Equal(t, entries[1:], result)

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10}))
	assert.Len(t, result, 0)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, 2) assert.Len(t, deleted, 0) assert.Equal(t, entries[1:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Equal(t, entries[1:], result) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})) assert.Len(t, result, 0) }]} {Id:23 FileId:104 StartLine:413 StartColumn:1 EndLine:430 EndColumn:2 Name:TestImmutableInsertNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree1.Len()) result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) assert.Equal(t, uint64(3), tree.Len()) }]} {Id:24 FileId:104 StartLine:432 StartColumn:1 EndLine:449 EndColumn:2 Name:TestImmutableInsertNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, -1)
	assert.Equal(t, entries[1:2], deleted)
	assert.Equal(t, entries[2:], modified)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[2:], result)

	result = tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(2), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10}))
	assert.Equal(t, entries[2:], result)
	assert.Equal(t, uint64(3), tree.Len())
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, -1) assert.Equal(t, entries[1:2], deleted) assert.Equal(t, entries[2:], modified) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[2:], result) result = tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(2), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})) assert.Equal(t, entries[2:], result) assert.Equal(t, uint64(3), tree.Len()) }]} {Id:25 FileId:104 StartLine:451 StartColumn:1 EndLine:458 EndColumn:2 Name:TestImmutableInsertNegativeIndexOutOfBoundsFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:26 FileId:104 StartLine:460 StartColumn:1 EndLine:467 EndColumn:2 Name:TestImmutableInsertNegativeIndexOutOfBoundsSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 4, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 4, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:27 FileId:104 StartLine:469 StartColumn:1 EndLine:482 EndColumn:2 Name:TestImmutableInsertMultipleNegativeIndexFirstDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]} {Id:28 FileId:104 StartLine:484 StartColumn:1 EndLine:497 EndColumn:2 Name:TestImmutableInsertMultipleNegativeIndexSecondDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(2, 1, -2)
	assert.Equal(t, entries[1:], deleted)
	assert.Len(t, modified, 0)

	result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Len(t, result, 0)
	assert.Equal(t, uint64(1), tree1.Len())

	result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10}))
	assert.Equal(t, entries[1:], result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(2, 1, -2) assert.Equal(t, entries[1:], deleted) assert.Len(t, modified, 0) result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Len(t, result, 0) assert.Equal(t, uint64(1), tree1.Len()) result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})) assert.Equal(t, entries[1:], result) }]} {Id:29 FileId:104 StartLine:499 StartColumn:1 EndLine:506 EndColumn:2 Name:TestImmutableInsertInvalidDimension Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(3, 1, -1)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(3, 1, -1) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:30 FileId:104 StartLine:508 StartColumn:1 EndLine:515 EndColumn:2 Name:TestImmutableInsertInvalidNumber Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, _ := constructMultiDimensionalImmutableTree(3)

	tree1, modified, deleted := tree.InsertAtDimension(1, 1, 0)
	assert.Len(t, modified, 0)
	assert.Len(t, deleted, 0)
	assert.Equal(t, tree, tree1)
} PrettyPrintBody:[{ tree, _ := constructMultiDimensionalImmutableTree(3) tree1, modified, deleted := tree.InsertAtDimension(1, 1, 0) assert.Len(t, modified, 0) assert.Len(t, deleted, 0) assert.Equal(t, tree, tree1) }]} {Id:31 FileId:104 StartLine:517 StartColumn:1 EndLine:525 EndColumn:2 Name:TestImmutableGet Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	tree, entries := constructMultiDimensionalImmutableTree(2)

	result := tree.Get(entries...)
	assert.Equal(t, entries, result)

	result = tree.Get(constructMockEntry(10000, 5000, 5000))
	assert.Equal(t, Entries{nil}, result)
} PrettyPrintBody:[{ tree, entries := constructMultiDimensionalImmutableTree(2) result := tree.Get(entries...) assert.Equal(t, entries, result) result = tree.Get(constructMockEntry(10000, 5000, 5000)) assert.Equal(t, Entries{nil}, result) }]} {Id:32 FileId:104 StartLine:527 StartColumn:1 EndLine:537 EndColumn:2 Name:BenchmarkImmutableInsertFirstDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	tree, _ := constructMultiDimensionalImmutableTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(1, 0, 1)
	}
} PrettyPrintBody:[{ numItems := int64(100000) tree, _ := constructMultiDimensionalImmutableTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(1, 0, 1) } }]} {Id:33 FileId:104 StartLine:539 StartColumn:1 EndLine:549 EndColumn:2 Name:BenchmarkImmutableInsertSecondDimension Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	numItems := int64(100000)

	tree, _ := constructMultiDimensionalImmutableTree(numItems)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		tree.InsertAtDimension(2, 0, 1)
	}
} PrettyPrintBody:[{ numItems := int64(100000) tree, _ := constructMultiDimensionalImmutableTree(numItems) b.ResetTimer() for i := 0; i < b.N; i++ { tree.InsertAtDimension(2, 0, 1) } }]} {Id:3 FileId:146 StartLine:48 StartColumn:1 EndLine:50 EndColumn:2 Name:defaultHashFactory Params:[] Results:[{Name: Type:hash.Hash32}] Receiver:<nil> Body:{
	return fnv.New32a()
} PrettyPrintBody:[{ return fnv.New32a() }]} {Id:7 FileId:146 StartLine:80 StartColumn:1 EndLine:86 EndColumn:2 Name:copyToGen Params:[{Name:gen Type:*generation} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*iNode}] Receiver:0xc0012901c0 Body:{
	nin := &iNode{gen: gen}
	main := gcasRead(i, ctrie)
	atomic.StorePointer(
		(*unsafe.Pointer)(unsafe.Pointer(&nin.main)), unsafe.Pointer(main))
	return nin
} PrettyPrintBody:[{ nin := &iNode{gen: gen} main := gcasRead(i, ctrie) atomic.StorePointer( (*unsafe.Pointer)(unsafe.Pointer(&nin.main)), unsafe.Pointer(main)) return nin }]} {Id:10 FileId:146 StartLine:116 StartColumn:1 EndLine:135 EndColumn:2 Name:newMainNode Params:[{Name:x Type:*sNode} {Name:xhc Type:uint32} {Name:y Type:*sNode} {Name:yhc Type:uint32} {Name:lev Type:uint} {Name:gen Type:*generation}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := newMainNode(x, xhc, y, yhc, lev+w, gen)
			iNode := &iNode{main: main, gen: gen}
			return &mainNode{cNode: &cNode{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &mainNode{cNode: &cNode{bmp, []branch{x, y}, gen}}
		}
		return &mainNode{cNode: &cNode{bmp, []branch{y, x}, gen}}
	}
	l := list.Empty.Add(x).Add(y)
	return &mainNode{lNode: &lNode{l}}
} PrettyPrintBody:[{ if lev < exp2 { xidx := (xhc >> lev) & 0x1f yidx := (yhc >> lev) & 0x1f bmp := uint32((1 << xidx) | (1 << yidx)) if xidx == yidx { main := newMainNode(x, xhc, y, yhc, lev+w, gen) iNode := &iNode{main: main, gen: gen} return &mainNode{cNode: &cNode{bmp, []branch{iNode}, gen}} } if xidx < yidx { return &mainNode{cNode: &cNode{bmp, []branch{x, y}, gen}} } return &mainNode{cNode: &cNode{bmp, []branch{y, x}, gen}} } l := list.Empty.Add(x).Add(y) return &mainNode{lNode: &lNode{l}} }]} {Id:11 FileId:146 StartLine:139 StartColumn:1 EndLine:151 EndColumn:2 Name:inserted Params:[{Name:pos Type:uint32} {Name:br Type:branch} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc00095a600 Body:{
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &cNode{bmp: bmp | flag, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ length := uint32(len(c.array)) bmp := c.bmp array := make([]branch, length+1) copy(array, c.array) array[pos] = br for i, x := pos, uint32(0); x < length-pos; i++ { array[i+1] = c.array[i] x++ } ncn := &cNode{bmp: bmp | flag, array: array, gen: gen} return ncn }]} {Id:12 FileId:146 StartLine:155 StartColumn:1 EndLine:161 EndColumn:2 Name:updated Params:[{Name:pos Type:uint32} {Name:br Type:branch} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc0009922a0 Body:{
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &cNode{bmp: c.bmp, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ array := make([]branch, len(c.array)) copy(array, c.array) array[pos] = br ncn := &cNode{bmp: c.bmp, array: array, gen: gen} return ncn }]} {Id:13 FileId:146 StartLine:165 StartColumn:1 EndLine:178 EndColumn:2 Name:removed Params:[{Name:pos Type:uint32} {Name:gen Type:*generation}] Results:[{Name: Type:*cNode}] Receiver:0xc0001e61e0 Body:{
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &cNode{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
} PrettyPrintBody:[{ length := uint32(len(c.array)) bmp := c.bmp array := make([]branch, length-1) for i := uint32(0); i < pos; i++ { array[i] = c.array[i] } for i, x := pos, uint32(0); x < length-pos-1; i++ { array[i] = c.array[i+1] x++ } ncn := &cNode{bmp: bmp ^ flag, array: array, gen: gen} return ncn }]} {Id:14 FileId:146 StartLine:182 StartColumn:1 EndLine:193 EndColumn:2 Name:renewed Params:[{Name:gen Type:*generation} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*cNode}] Receiver:0xc0003e5220 Body:{
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *iNode:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &cNode{bmp: c.bmp, array: array, gen: gen}
} PrettyPrintBody:[{ array := make([]branch, len(c.array)) for i, br := range c.array { switch t := br.(type) { case *iNode: array[i] = t.copyToGen(gen, ctrie) default: array[i] = br } } return &cNode{bmp: c.bmp, array: array, gen: gen} }]} {Id:16 FileId:146 StartLine:202 StartColumn:1 EndLine:204 EndColumn:2 Name:untombed Params:[] Results:[{Name: Type:*sNode}] Receiver:0xc001603060 Body:{
	return &sNode{&Entry{Key: t.Key, hash: t.hash, Value: t.Value}}
} PrettyPrintBody:[{ return &sNode{&Entry{Key: t.Key, hash: t.hash, Value: t.Value}} }]} {Id:18 FileId:146 StartLine:213 StartColumn:1 EndLine:216 EndColumn:2 Name:entry Params:[] Results:[{Name: Type:*sNode}] Receiver:0xc0016032e0 Body:{
	head, _ := l.Head()
	return head.(*sNode)
} PrettyPrintBody:[{ head, _ := l.Head() return head.(*sNode) }]} {Id:19 FileId:146 StartLine:220 StartColumn:1 EndLine:228 EndColumn:2 Name:lookup Params:[{Name:e Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc00095af40 Body:{
	found, ok := l.Find(func(sn interface{}) bool {
		return bytes.Equal(e.Key, sn.(*sNode).Key)
	})
	if !ok {
		return nil, false
	}
	return found.(*sNode).Value, true
} PrettyPrintBody:[{ found, ok := l.Find(func(sn interface{}) bool { return bytes.Equal(e.Key, sn.(*sNode).Key) }) if !ok { return nil, false } return found.(*sNode).Value, true }]} {Id:20 FileId:146 StartLine:231 StartColumn:1 EndLine:233 EndColumn:2 Name:inserted Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:*lNode}] Receiver:0xc0001e66a0 Body:{
	return &lNode{l.removed(entry).Add(&sNode{entry})}
} PrettyPrintBody:[{ return &lNode{l.removed(entry).Add(&sNode{entry})} }]} {Id:21 FileId:146 StartLine:236 StartColumn:1 EndLine:245 EndColumn:2 Name:removed Params:[{Name:e Type:*Entry}] Results:[{Name: Type:*lNode}] Receiver:0xc00095b0a0 Body:{
	idx := l.FindIndex(func(sn interface{}) bool {
		return bytes.Equal(e.Key, sn.(*sNode).Key)
	})
	if idx < 0 {
		return l
	}
	nl, _ := l.Remove(uint(idx))
	return &lNode{nl}
} PrettyPrintBody:[{ idx := l.FindIndex(func(sn interface{}) bool { return bytes.Equal(e.Key, sn.(*sNode).Key) }) if idx < 0 { return l } nl, _ := l.Remove(uint(idx)) return &lNode{nl} }]} {Id:22 FileId:146 StartLine:248 StartColumn:1 EndLine:250 EndColumn:2 Name:length Params:[] Results:[{Name: Type:uint}] Receiver:0xc001603600 Body:{
	return l.Length()
} PrettyPrintBody:[{ return l.Length() }]} {Id:26 FileId:146 StartLine:269 StartColumn:1 EndLine:275 EndColumn:2 Name:New Params:[{Name:hashFactory Type:HashFactory}] Results:[{Name: Type:*Ctrie}] Receiver:<nil> Body:{
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &iNode{main: &mainNode{cNode: &cNode{}}}
	return newCtrie(root, hashFactory, false)
} PrettyPrintBody:[{ if hashFactory == nil { hashFactory = defaultHashFactory } root := &iNode{main: &mainNode{cNode: &cNode{}}} return newCtrie(root, hashFactory, false) }]} {Id:27 FileId:146 StartLine:277 StartColumn:1 EndLine:283 EndColumn:2 Name:newCtrie Params:[{Name:root Type:*iNode} {Name:hashFactory Type:HashFactory} {Name:readOnly Type:bool}] Results:[{Name: Type:*Ctrie}] Receiver:<nil> Body:{
	return &Ctrie{
		root:		root,
		hashFactory:	hashFactory,
		readOnly:	readOnly,
	}
} PrettyPrintBody:[{ return &Ctrie{ root:		root, hashFactory:	hashFactory, readOnly:	readOnly, } }]} {Id:28 FileId:146 StartLine:287 StartColumn:1 EndLine:294 EndColumn:2 Name:Insert Params:[{Name:key Type:[]byte} {Name:value Type:interface{}}] Results:[] Receiver:0xc001603740 Body:{
	c.assertReadWrite()
	c.insert(&Entry{
		Key:	key,
		Value:	value,
		hash:	c.hash(key),
	})
} PrettyPrintBody:[{ c.assertReadWrite() c.insert(&Entry{ Key:	key, Value:	value, hash:	c.hash(key), }) }]} {Id:29 FileId:146 StartLine:298 StartColumn:1 EndLine:300 EndColumn:2 Name:Lookup Params:[{Name:key Type:[]byte}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000a8b9a0 Body:{
	return c.lookup(&Entry{Key: key, hash: c.hash(key)})
} PrettyPrintBody:[{ return c.lookup(&Entry{Key: key, hash: c.hash(key)}) }]} {Id:30 FileId:146 StartLine:304 StartColumn:1 EndLine:307 EndColumn:2 Name:Remove Params:[{Name:key Type:[]byte}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc000a8bb40 Body:{
	c.assertReadWrite()
	return c.remove(&Entry{Key: key, hash: c.hash(key)})
} PrettyPrintBody:[{ c.assertReadWrite() return c.remove(&Entry{Key: key, hash: c.hash(key)}) }]} {Id:31 FileId:146 StartLine:311 StartColumn:1 EndLine:313 EndColumn:2 Name:Snapshot Params:[] Results:[{Name: Type:*Ctrie}] Receiver:0xc00095b440 Body:{
	return c.snapshot(c.readOnly)
} PrettyPrintBody:[{ return c.snapshot(c.readOnly) }]} {Id:32 FileId:146 StartLine:317 StartColumn:1 EndLine:319 EndColumn:2 Name:ReadOnlySnapshot Params:[] Results:[{Name: Type:*Ctrie}] Receiver:0xc000992480 Body:{
	return c.snapshot(true)
} PrettyPrintBody:[{ return c.snapshot(true) }]} {Id:33 FileId:146 StartLine:322 StartColumn:1 EndLine:340 EndColumn:2 Name:snapshot Params:[{Name:readOnly Type:bool}] Results:[{Name: Type:*Ctrie}] Receiver:0xc0001e6ce0 Body:{
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := gcasRead(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return newCtrie(root, c.hashFactory, readOnly)
			}

			return newCtrie(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
} PrettyPrintBody:[{ if readOnly && c.readOnly { return c } for { root := c.readRoot() main := gcasRead(root, c) if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) { if readOnly { return newCtrie(root, c.hashFactory, readOnly) } return newCtrie(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly) } } }]} {Id:34 FileId:146 StartLine:343 StartColumn:1 EndLine:355 EndColumn:2 Name:Clear Params:[] Results:[] Receiver:0xc000258280 Body:{
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &iNode{
			main:	&mainNode{cNode: &cNode{array: make([]branch, 0), gen: gen}},
			gen:	gen,
		}
		if c.rdcssRoot(root, gcasRead(root, c), newRoot) {
			return
		}
	}
} PrettyPrintBody:[{ for { root := c.readRoot() gen := &generation{} newRoot := &iNode{ main:	&mainNode{cNode: &cNode{array: make([]branch, 0), gen: gen}}, gen:	gen, } if c.rdcssRoot(root, gcasRead(root, c), newRoot) { return } } }]} {Id:35 FileId:146 StartLine:361 StartColumn:1 EndLine:369 EndColumn:2 Name:Iterator Params:[{Name:cancel Type:<-chan struct{}}] Results:[{Name: Type:<-chan *Entry}] Receiver:0xc0000edaa0 Body:{
	ch := make(chan *Entry)
	snapshot := c.ReadOnlySnapshot()
	go func() {
		snapshot.traverse(snapshot.readRoot(), ch, cancel)
		close(ch)
	}()
	return ch
} PrettyPrintBody:[{ ch := make(chan *Entry) snapshot := c.ReadOnlySnapshot() go func() { snapshot.traverse(snapshot.readRoot(), ch, cancel) close(ch) }() return ch }]} {Id:36 FileId:146 StartLine:372 StartColumn:1 EndLine:383 EndColumn:2 Name:Size Params:[] Results:[{Name: Type:uint}] Receiver:0xc000259380 Body:{

	size := uint(0)
	for _ = range c.Iterator(nil) {
		size++
	}
	return size
} PrettyPrintBody:[{ size := uint(0) for _ = range c.Iterator(nil) { size++ } return size }]} {Id:38 FileId:146 StartLine:387 StartColumn:1 EndLine:423 EndColumn:2 Name:traverse Params:[{Name:i Type:*iNode} {Name:ch Type:chan<- *Entry} {Name:cancel Type:<-chan struct{}}] Results:[{Name: Type:error}] Receiver:0xc000259720 Body:{
	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		for _, br := range main.cNode.array {
			switch b := br.(type) {
			case *iNode:
				if err := c.traverse(b, ch, cancel); err != nil {
					return err
				}
			case *sNode:
				select {
				case ch <- b.Entry:
				case <-cancel:
					return errCanceled
				}
			}
		}
	case main.lNode != nil:
		for _, e := range main.lNode.Map(func(sn interface{}) interface{} {
			return sn.(*sNode).Entry
		}) {
			select {
			case ch <- e.(*Entry):
			case <-cancel:
				return errCanceled
			}
		}
	case main.tNode != nil:
		select {
		case ch <- main.tNode.Entry:
		case <-cancel:
			return errCanceled
		}
	}
	return nil
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: for _, br := range main.cNode.array { switch b := br.(type) { case *iNode: if err := c.traverse(b, ch, cancel); err != nil { return err } case *sNode: select { case ch <- b.Entry: case <-cancel: return errCanceled } } } case main.lNode != nil: for _, e := range main.lNode.Map(func(sn interface{}) interface{} { return sn.(*sNode).Entry }) { select { case ch <- e.(*Entry): case <-cancel: return errCanceled } } case main.tNode != nil: select { case ch <- main.tNode.Entry: case <-cancel: return errCanceled } } return nil }]} {Id:39 FileId:146 StartLine:425 StartColumn:1 EndLine:429 EndColumn:2 Name:assertReadWrite Params:[] Results:[] Receiver:0xc000259d40 Body:{
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
} PrettyPrintBody:[{ if c.readOnly { panic("Cannot modify read-only snapshot") } }]} {Id:40 FileId:146 StartLine:431 StartColumn:1 EndLine:436 EndColumn:2 Name:insert Params:[{Name:entry Type:*Entry}] Results:[] Receiver:0xc00095bac0 Body:{
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
} PrettyPrintBody:[{ root := c.readRoot() if !c.iinsert(root, entry, 0, nil, root.gen) { c.insert(entry) } }]} {Id:41 FileId:146 StartLine:438 StartColumn:1 EndLine:445 EndColumn:2 Name:lookup Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc00019ec80 Body:{
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
} PrettyPrintBody:[{ root := c.readRoot() result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen) for !ok { return c.lookup(entry) } return result, exists }]} {Id:42 FileId:146 StartLine:447 StartColumn:1 EndLine:454 EndColumn:2 Name:remove Params:[{Name:entry Type:*Entry}] Results:[{Name: Type:interface{}} {Name: Type:bool}] Receiver:0xc0000edf40 Body:{
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
} PrettyPrintBody:[{ root := c.readRoot() result, exists, ok := c.iremove(root, entry, 0, nil, root.gen) for !ok { return c.remove(entry) } return result, exists }]} {Id:43 FileId:146 StartLine:456 StartColumn:1 EndLine:460 EndColumn:2 Name:hash Params:[{Name:k Type:[]byte}] Results:[{Name: Type:uint32}] Receiver:0xc0000edfa0 Body:{
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
} PrettyPrintBody:[{ hasher := c.hashFactory() hasher.Write(k) return hasher.Sum32() }]} {Id:44 FileId:146 StartLine:464 StartColumn:1 EndLine:532 EndColumn:2 Name:iinsert Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:bool}] Receiver:0xc001603f60 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &mainNode{cNode: rn.inserted(pos, flag, &sNode{entry}, i.gen)}
			return gcas(i, main, ncn, c)
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if startGen == in.gen {
				return c.iinsert(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *sNode:
			sn := branch.(*sNode)
			if !bytes.Equal(sn.Key, entry.Key) {

				rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &sNode{entry}
				nin := &iNode{main: newMainNode(sn, sn.hash, nsn, nsn.hash, lev+w, i.gen), gen: i.gen}
				ncn := &mainNode{cNode: rn.updated(pos, nin, i.gen)}
				return gcas(i, main, ncn, c)
			}

			ncn := &mainNode{cNode: cn.updated(pos, &sNode{entry}, i.gen)}
			return gcas(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		clean(parent, lev-w, c)
		return false
	case main.lNode != nil:
		nln := &mainNode{lNode: main.lNode.inserted(entry)}
		return gcas(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { rn := cn if cn.gen != i.gen { rn = cn.renewed(i.gen, c) } ncn := &mainNode{cNode: rn.inserted(pos, flag, &sNode{entry}, i.gen)} return gcas(i, main, ncn, c) } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if startGen == in.gen { return c.iinsert(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.iinsert(i, entry, lev, parent, startGen) } return false case *sNode: sn := branch.(*sNode) if !bytes.Equal(sn.Key, entry.Key) { rn := cn if cn.gen != i.gen { rn = cn.renewed(i.gen, c) } nsn := &sNode{entry} nin := &iNode{main: newMainNode(sn, sn.hash, nsn, nsn.hash, lev+w, i.gen), gen: i.gen} ncn := &mainNode{cNode: rn.updated(pos, nin, i.gen)} return gcas(i, main, ncn, c) } ncn := &mainNode{cNode: cn.updated(pos, &sNode{entry}, i.gen)} return gcas(i, main, ncn, c) default: panic("Ctrie is in an invalid state") } case main.tNode != nil: clean(parent, lev-w, c) return false case main.lNode != nil: nln := &mainNode{lNode: main.lNode.inserted(entry)} return gcas(i, main, nln, c) default: panic("Ctrie is in an invalid state") } }]} {Id:45 FileId:146 StartLine:538 StartColumn:1 EndLine:588 EndColumn:2 Name:ilookup Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:interface{}} {Name: Type:bool} {Name: Type:bool}] Receiver:0xc000a8ac20 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			return nil, false, true
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return nil, false, false
		case *sNode:

			sn := branch.(*sNode)
			if bytes.Equal(sn.Key, entry.Key) {
				return sn.Value, true, true
			}
			return nil, false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return cleanReadOnly(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

		val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { return nil, false, true } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if c.readOnly || startGen == in.gen { return c.ilookup(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.ilookup(i, entry, lev, parent, startGen) } return nil, false, false case *sNode: sn := branch.(*sNode) if bytes.Equal(sn.Key, entry.Key) { return sn.Value, true, true } return nil, false, true default: panic("Ctrie is in an invalid state") } case main.tNode != nil: return cleanReadOnly(main.tNode, lev, parent, c, entry) case main.lNode != nil: val, ok := main.lNode.lookup(entry) return val, ok, true default: panic("Ctrie is in an invalid state") } }]} {Id:46 FileId:146 StartLine:594 StartColumn:1 EndLine:665 EndColumn:2 Name:iremove Params:[{Name:i Type:*iNode} {Name:entry Type:*Entry} {Name:lev Type:uint} {Name:parent Type:*iNode} {Name:startGen Type:*generation}] Results:[{Name: Type:interface{}} {Name: Type:bool} {Name: Type:bool}] Receiver:0xc0006b8280 Body:{

	main := gcasRead(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

			return nil, false, true
		}

		branch := cn.array[pos]
		switch branch.(type) {
		case *iNode:

			in := branch.(*iNode)
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return nil, false, false
		case *sNode:

			sn := branch.(*sNode)
			if !bytes.Equal(sn.Key, entry.Key) {

				return nil, false, true
			}

			ncn := cn.removed(pos, flag, i.gen)
			cntr := toContracted(ncn, lev)
			if gcas(i, main, cntr, c) {
				if parent != nil {
					main = gcasRead(i, c)
					if main.tNode != nil {
						cleanParent(parent, i, entry.hash, lev-w, c, startGen)
					}
				}
				return sn.Value, true, true
			}
			return nil, false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		clean(parent, lev-w, c)
		return nil, false, false
	case main.lNode != nil:
		nln := &mainNode{lNode: main.lNode.removed(entry)}
		if nln.lNode.length() == 1 {
			nln = entomb(nln.lNode.entry())
		}
		if gcas(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return nil, false, true
	default:
		panic("Ctrie is in an invalid state")
	}
} PrettyPrintBody:[{ main := gcasRead(i, c) switch { case main.cNode != nil: cn := main.cNode flag, pos := flagPos(entry.hash, lev, cn.bmp) if cn.bmp&flag == 0 { return nil, false, true } branch := cn.array[pos] switch branch.(type) { case *iNode: in := branch.(*iNode) if startGen == in.gen { return c.iremove(in, entry, lev+w, i, startGen) } if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) { return c.iremove(i, entry, lev, parent, startGen) } return nil, false, false case *sNode: sn := branch.(*sNode) if !bytes.Equal(sn.Key, entry.Key) { return nil, false, true } ncn := cn.removed(pos, flag, i.gen) cntr := toContracted(ncn, lev) if gcas(i, main, cntr, c) { if parent != nil { main = gcasRead(i, c) if main.tNode != nil { cleanParent(parent, i, entry.hash, lev-w, c, startGen) } } return sn.Value, true, true } return nil, false, false default: panic("Ctrie is in an invalid state") } case main.tNode != nil: clean(parent, lev-w, c) return nil, false, false case main.lNode != nil: nln := &mainNode{lNode: main.lNode.removed(entry)} if nln.lNode.length() == 1 { nln = entomb(nln.lNode.entry()) } if gcas(i, main, nln, c) { val, ok := main.lNode.lookup(entry) return val, ok, true } return nil, false, true default: panic("Ctrie is in an invalid state") } }]} {Id:47 FileId:146 StartLine:671 StartColumn:1 EndLine:682 EndColumn:2 Name:toContracted Params:[{Name:cn Type:*cNode} {Name:lev Type:uint}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	if lev > 0 && len(cn.array) == 1 {
		branch := cn.array[0]
		switch branch.(type) {
		case *sNode:
			return entomb(branch.(*sNode))
		default:
			return &mainNode{cNode: cn}
		}
	}
	return &mainNode{cNode: cn}
} PrettyPrintBody:[{ if lev > 0 && len(cn.array) == 1 { branch := cn.array[0] switch branch.(type) { case *sNode: return entomb(branch.(*sNode)) default: return &mainNode{cNode: cn} } } return &mainNode{cNode: cn} }]} {Id:48 FileId:146 StartLine:685 StartColumn:1 EndLine:702 EndColumn:2 Name:toCompressed Params:[{Name:cn Type:*cNode} {Name:lev Type:uint}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub.(type) {
		case *iNode:
			inode := sub.(*iNode)
			mainPtr := (*unsafe.Pointer)(unsafe.Pointer(&inode.main))
			main := (*mainNode)(atomic.LoadPointer(mainPtr))
			tmpArray[i] = resurrect(inode, main)
		case *sNode:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return toContracted(&cNode{bmp: cn.bmp, array: tmpArray}, lev)
} PrettyPrintBody:[{ tmpArray := make([]branch, len(cn.array)) for i, sub := range cn.array { switch sub.(type) { case *iNode: inode := sub.(*iNode) mainPtr := (*unsafe.Pointer)(unsafe.Pointer(&inode.main)) main := (*mainNode)(atomic.LoadPointer(mainPtr)) tmpArray[i] = resurrect(inode, main) case *sNode: tmpArray[i] = sub default: panic("Ctrie is in an invalid state") } } return toContracted(&cNode{bmp: cn.bmp, array: tmpArray}, lev) }]} {Id:49 FileId:146 StartLine:704 StartColumn:1 EndLine:706 EndColumn:2 Name:entomb Params:[{Name:m Type:*sNode}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	return &mainNode{tNode: &tNode{m}}
} PrettyPrintBody:[{ return &mainNode{tNode: &tNode{m}} }]} {Id:50 FileId:146 StartLine:708 StartColumn:1 EndLine:713 EndColumn:2 Name:resurrect Params:[{Name:iNode Type:*iNode} {Name:main Type:*mainNode}] Results:[{Name: Type:branch}] Receiver:<nil> Body:{
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
} PrettyPrintBody:[{ if main.tNode != nil { return main.tNode.untombed() } return iNode }]} {Id:51 FileId:146 StartLine:715 StartColumn:1 EndLine:721 EndColumn:2 Name:clean Params:[{Name:i Type:*iNode} {Name:lev Type:uint} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	main := gcasRead(i, ctrie)
	if main.cNode != nil {
		return gcas(i, main, toCompressed(main.cNode, lev), ctrie)
	}
	return true
} PrettyPrintBody:[{ main := gcasRead(i, ctrie) if main.cNode != nil { return gcas(i, main, toCompressed(main.cNode, lev), ctrie) } return true }]} {Id:52 FileId:146 StartLine:723 StartColumn:1 EndLine:732 EndColumn:2 Name:cleanReadOnly Params:[{Name:tn Type:*tNode} {Name:lev Type:uint} {Name:p Type:*iNode} {Name:ctrie Type:*Ctrie} {Name:entry Type:*Entry}] Results:[{Name:val Type:interface{}} {Name:exists Type:bool} {Name:ok Type:bool}] Receiver:<nil> Body:{
	if !ctrie.readOnly {
		clean(p, lev-5, ctrie)
		return nil, false, false
	}
	if tn.hash == entry.hash && bytes.Equal(tn.Key, entry.Key) {
		return tn.Value, true, true
	}
	return nil, false, true
} PrettyPrintBody:[{ if !ctrie.readOnly { clean(p, lev-5, ctrie) return nil, false, false } if tn.hash == entry.hash && bytes.Equal(tn.Key, entry.Key) { return tn.Value, true, true } return nil, false, true }]} {Id:53 FileId:146 StartLine:734 StartColumn:1 EndLine:753 EndColumn:2 Name:cleanParent Params:[{Name:p Type:*iNode} {Name:hc Type:uint32} {Name:lev Type:uint} {Name:ctrie Type:*Ctrie} {Name:startGen Type:*generation}] Results:[] Receiver:<nil> Body:{
	var (
		mainPtr		= (*unsafe.Pointer)(unsafe.Pointer(&i.main))
		main		= (*mainNode)(atomic.LoadPointer(mainPtr))
		pMainPtr	= (*unsafe.Pointer)(unsafe.Pointer(&p.main))
		pMain		= (*mainNode)(atomic.LoadPointer(pMainPtr))
	)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, resurrect(i, main), i.gen)
				if !gcas(p, pMain, toContracted(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
					cleanParent(p, i, hc, lev, ctrie, startGen)
				}
			}
		}
	}
} PrettyPrintBody:[{ var ( mainPtr		= (*unsafe.Pointer)(unsafe.Pointer(&i.main)) main		= (*mainNode)(atomic.LoadPointer(mainPtr)) pMainPtr	= (*unsafe.Pointer)(unsafe.Pointer(&p.main)) pMain		= (*mainNode)(atomic.LoadPointer(pMainPtr)) ) if pMain.cNode != nil { flag, pos := flagPos(hc, lev, pMain.cNode.bmp) if pMain.cNode.bmp&flag != 0 { sub := pMain.cNode.array[pos] if sub == i && main.tNode != nil { ncn := pMain.cNode.updated(pos, resurrect(i, main), i.gen) if !gcas(p, pMain, toContracted(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen { cleanParent(p, i, hc, lev, ctrie, startGen) } } } } }]} {Id:54 FileId:146 StartLine:755 StartColumn:1 EndLine:761 EndColumn:2 Name:flagPos Params:[{Name:hashcode Type:uint32} {Name:lev Type:uint} {Name:bmp Type:uint32}] Results:[{Name: Type:uint32} {Name: Type:uint32}] Receiver:<nil> Body:{
	idx := (hashcode >> lev) & 0x1f
	flag := uint32(1) << uint32(idx)
	mask := uint32(flag - 1)
	pos := bitCount(bmp & mask)
	return flag, pos
} PrettyPrintBody:[{ idx := (hashcode >> lev) & 0x1f flag := uint32(1) << uint32(idx) mask := uint32(flag - 1) pos := bitCount(bmp & mask) return flag, pos }]} {Id:55 FileId:146 StartLine:763 StartColumn:1 EndLine:769 EndColumn:2 Name:bitCount Params:[{Name:x Type:uint32}] Results:[{Name: Type:uint32}] Receiver:<nil> Body:{
	x -= (x >> 1) & 0x55555555
	x = ((x >> 2) & 0x33333333) + (x & 0x33333333)
	x = ((x >> 4) + x) & 0x0f0f0f0f
	x *= 0x01010101
	return x >> 24
} PrettyPrintBody:[{ x -= (x >> 1) & 0x55555555 x = ((x >> 2) & 0x33333333) + (x & 0x33333333) x = ((x >> 4) + x) & 0x0f0f0f0f x *= 0x01010101 return x >> 24 }]} {Id:56 FileId:146 StartLine:776 StartColumn:1 EndLine:786 EndColumn:2 Name:gcas Params:[{Name:in Type:*iNode} {Name:old Type:*mainNode} {Name:ct Type:*Ctrie}] Results:[{Name: Type:bool}] Receiver:<nil> Body:{
	prevPtr := (*unsafe.Pointer)(unsafe.Pointer(&n.prev))
	atomic.StorePointer(prevPtr, unsafe.Pointer(old))
	if atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&in.main)),
		unsafe.Pointer(old), unsafe.Pointer(n)) {
		gcasComplete(in, n, ct)
		return atomic.LoadPointer(prevPtr) == nil
	}
	return false
} PrettyPrintBody:[{ prevPtr := (*unsafe.Pointer)(unsafe.Pointer(&n.prev)) atomic.StorePointer(prevPtr, unsafe.Pointer(old)) if atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&in.main)), unsafe.Pointer(old), unsafe.Pointer(n)) { gcasComplete(in, n, ct) return atomic.LoadPointer(prevPtr) == nil } return false }]} {Id:57 FileId:146 StartLine:789 StartColumn:1 EndLine:796 EndColumn:2 Name:gcasRead Params:[{Name:in Type:*iNode} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	m := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&in.main))))
	prev := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&m.prev))))
	if prev == nil {
		return m
	}
	return gcasComplete(in, m, ctrie)
} PrettyPrintBody:[{ m := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&in.main)))) prev := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&m.prev)))) if prev == nil { return m } return gcasComplete(in, m, ctrie) }]} {Id:58 FileId:146 StartLine:799 StartColumn:1 EndLine:841 EndColumn:2 Name:gcasComplete Params:[{Name:i Type:*iNode} {Name:m Type:*mainNode} {Name:ctrie Type:*Ctrie}] Results:[{Name: Type:*mainNode}] Receiver:<nil> Body:{
	for {
		if m == nil {
			return nil
		}
		prev := (*mainNode)(atomic.LoadPointer(
			(*unsafe.Pointer)(unsafe.Pointer(&m.prev))))
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)),
				unsafe.Pointer(m), unsafe.Pointer(fn)) {
				return fn
			}
			m = (*mainNode)(atomic.LoadPointer(
				(*unsafe.Pointer)(unsafe.Pointer(&i.main))))
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if atomic.CompareAndSwapPointer(
				(*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), nil) {
				return m
			}
			continue
		}

		atomic.CompareAndSwapPointer(
			(*unsafe.Pointer)(unsafe.Pointer(&m.prev)),
			unsafe.Pointer(prev),
			unsafe.Pointer(&mainNode{failed: prev}))
		m = (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main))))
		return gcasComplete(i, m, ctrie)
	}
} PrettyPrintBody:[{ for { if m == nil { return nil } prev := (*mainNode)(atomic.LoadPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)))) root := ctrie.rdcssReadRoot(true) if prev == nil { return m } if prev.failed != nil { fn := prev.failed if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)), unsafe.Pointer(m), unsafe.Pointer(fn)) { return fn } m = (*mainNode)(atomic.LoadPointer( (*unsafe.Pointer)(unsafe.Pointer(&i.main)))) continue } if root.gen == i.gen && !ctrie.readOnly { if atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), nil) { return m } continue } atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), unsafe.Pointer(&mainNode{failed: prev})) m = (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)))) return gcasComplete(i, m, ctrie) } }]} {Id:60 FileId:146 StartLine:856 StartColumn:1 EndLine:858 EndColumn:2 Name:readRoot Params:[] Results:[{Name: Type:*iNode}] Receiver:0xc00019f540 Body:{
	return c.rdcssReadRoot(false)
} PrettyPrintBody:[{ return c.rdcssReadRoot(false) }]} {Id:61 FileId:146 StartLine:862 StartColumn:1 EndLine:868 EndColumn:2 Name:rdcssReadRoot Params:[{Name:abort Type:bool}] Results:[{Name: Type:*iNode}] Receiver:0xc00019f5a0 Body:{
	r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root))))
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
} PrettyPrintBody:[{ r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root)))) if r.rdcss != nil { return c.rdcssComplete(abort) } return r }]} {Id:62 FileId:146 StartLine:873 StartColumn:1 EndLine:886 EndColumn:2 Name:rdcssRoot Params:[{Name:old Type:*iNode} {Name:expected Type:*mainNode} {Name:nv Type:*iNode}] Results:[{Name: Type:bool}] Receiver:0xc00019f5e0 Body:{
	desc := &iNode{
		rdcss: &rdcssDescriptor{
			old:		old,
			expected:	expected,
			nv:		nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return atomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
} PrettyPrintBody:[{ desc := &iNode{ rdcss: &rdcssDescriptor{ old:		old, expected:	expected, nv:		nv, }, } if c.casRoot(old, desc) { c.rdcssComplete(false) return atomic.LoadInt32(&desc.rdcss.committed) == 1 } return false }]} {Id:63 FileId:146 StartLine:889 StartColumn:1 EndLine:924 EndColumn:2 Name:rdcssComplete Params:[{Name:abort Type:bool}] Results:[{Name: Type:*iNode}] Receiver:0xc0003e4100 Body:{
	for {
		r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root))))
		if r.rdcss == nil {
			return r
		}

		var (
			desc	= r.rdcss
			ov	= desc.old
			exp	= desc.expected
			nv	= desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := gcasRead(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				atomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
} PrettyPrintBody:[{ for { r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root)))) if r.rdcss == nil { return r } var ( desc	= r.rdcss ov	= desc.old exp	= desc.expected nv	= desc.nv ) if abort { if c.casRoot(r, ov) { return ov } continue } oldeMain := gcasRead(ov, c) if oldeMain == exp { if c.casRoot(r, nv) { atomic.StoreInt32(&desc.committed, 1) return nv } continue } if c.casRoot(r, ov) { return ov } continue } }]} {Id:64 FileId:146 StartLine:927 StartColumn:1 EndLine:931 EndColumn:2 Name:casRoot Params:[{Name:ov Type:*iNode}] Results:[{Name: Type:bool}] Receiver:0xc000a8b060 Body:{
	c.assertReadWrite()
	return atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&c.root)), unsafe.Pointer(ov), unsafe.Pointer(nv))
} PrettyPrintBody:[{ c.assertReadWrite() return atomic.CompareAndSwapPointer( (*unsafe.Pointer)(unsafe.Pointer(&c.root)), unsafe.Pointer(ov), unsafe.Pointer(nv)) }]} {Id:2 FileId:50 StartLine:36 StartColumn:1 EndLine:49 EndColumn:2 Name:Save Params:[{Name:items Type:...*Payload}] Results:[{Name: Type:error}] Receiver:0xc00129bb20 Body:{
	e.lock.Lock()
	defer e.lock.Unlock()

	if len(items) == 0 {
		return nil
	}

	for _, item := range items {
		e.mp[string(item.Key)] = item
	}

	return nil
} PrettyPrintBody:[{ e.lock.Lock() defer e.lock.Unlock() if len(items) == 0 { return nil } for _, item := range items { e.mp[string(item.Key)] = item } return nil }]} {Id:3 FileId:50 StartLine:51 StartColumn:1 EndLine:65 EndColumn:2 Name:Load Params:[{Name:keys Type:...[]byte}] Results:[{Name: Type:[]*Payload} {Name: Type:error}] Receiver:0xc001308c40 Body:{
	e.lock.RLock()
	defer e.lock.RUnlock()

	if len(keys) == 0 {
		return nil, nil
	}

	items := make([]*Payload, 0, len(keys))
	for _, k := range keys {
		items = append(items, e.mp[string(k)])
	}

	return items, nil
} PrettyPrintBody:[{ e.lock.RLock() defer e.lock.RUnlock() if len(keys) == 0 { return nil, nil } items := make([]*Payload, 0, len(keys)) for _, k := range keys { items = append(items, e.mp[string(k)]) } return items, nil }]} {Id:5 FileId:50 StartLine:71 StartColumn:1 EndLine:73 EndColumn:2 Name:init Params:[] Results:[] Receiver:<nil> Body:{
	rand.Seed(time.Now().Unix())
} PrettyPrintBody:[{ rand.Seed(time.Now().Unix()) }]} {Id:7 FileId:50 StartLine:80 StartColumn:1 EndLine:82 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001308c80 Body:{
	return len(v.values)
} PrettyPrintBody:[{ return len(v.values) }]} {Id:8 FileId:50 StartLine:84 StartColumn:1 EndLine:86 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc001308cc0 Body:{
	v.values[i], v.values[j] = v.values[j], v.values[i]
} PrettyPrintBody:[{ v.values[i], v.values[j] = v.values[j], v.values[i] }]} {Id:9 FileId:50 StartLine:88 StartColumn:1 EndLine:90 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc001602240 Body:{
	return v.comparator(v.values[i], v.values[j]) < 0
} PrettyPrintBody:[{ return v.comparator(v.values[i], v.values[j]) < 0 }]} {Id:10 FileId:50 StartLine:92 StartColumn:1 EndLine:94 EndColumn:2 Name:sort Params:[] Results:[] Receiver:0xc0012401a0 Body:{
	sort.Sort(v)
} PrettyPrintBody:[{ sort.Sort(v) }]} {Id:11 FileId:50 StartLine:96 StartColumn:1 EndLine:102 EndColumn:2 Name:reverse Params:[{Name:items Type:items}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	for i := 0; i < len(items)/2; i++ {
		items[i], items[len(items)-1-i] = items[len(items)-1-i], items[i]
	}

	return items
} PrettyPrintBody:[{ for i := 0; i < len(items)/2; i++ { items[i], items[len(items)-1-i] = items[len(items)-1-i], items[i] } return items }]} {Id:14 FileId:50 StartLine:123 StartColumn:1 EndLine:125 EndColumn:2 Name:Len Params:[] Results:[{Name: Type:int}] Receiver:0xc001309580 Body:{
	return len(o)
} PrettyPrintBody:[{ return len(o) }]} {Id:15 FileId:50 StartLine:127 StartColumn:1 EndLine:129 EndColumn:2 Name:Swap Params:[{Name:i Type:int}] Results:[] Receiver:0xc000a237c0 Body:{
	o[i], o[j] = o[j], o[i]
} PrettyPrintBody:[{ o[i], o[j] = o[j], o[i] }]} {Id:16 FileId:50 StartLine:131 StartColumn:1 EndLine:133 EndColumn:2 Name:Less Params:[{Name:i Type:int}] Results:[{Name: Type:bool}] Receiver:0xc0010337a0 Body:{
	return comparator(o[i].Value, o[j].Value) < 0
} PrettyPrintBody:[{ return comparator(o[i].Value, o[j].Value) < 0 }]} {Id:17 FileId:50 StartLine:135 StartColumn:1 EndLine:137 EndColumn:2 Name:equal Params:[{Name:item1 Type:*Item}] Results:[{Name: Type:bool}] Receiver:0xc000a8b880 Body:{
	return comparator(item1.Value, item2.Value) == 0
} PrettyPrintBody:[{ return comparator(item1.Value, item2.Value) == 0 }]} {Id:18 FileId:50 StartLine:139 StartColumn:1 EndLine:143 EndColumn:2 Name:copy Params:[] Results:[{Name: Type:orderedItems}] Receiver:0xc000a8a300 Body:{
	cp := make(orderedItems, len(o))
	copy(cp, o)
	return cp
} PrettyPrintBody:[{ cp := make(orderedItems, len(o)) copy(cp, o) return cp }]} {Id:19 FileId:50 StartLine:145 StartColumn:1 EndLine:149 EndColumn:2 Name:search Params:[{Name:value Type:interface{}}] Results:[{Name: Type:int}] Receiver:0xc0010338e0 Body:{
	return sort.Search(len(o), func(i int) bool {
		return comparator(o[i].Value, value) >= 0
	})
} PrettyPrintBody:[{ return sort.Search(len(o), func(i int) bool { return comparator(o[i].Value, value) >= 0 }) }]} {Id:20 FileId:50 StartLine:151 StartColumn:1 EndLine:169 EndColumn:2 Name:add Params:[{Name:item Type:*Item}] Results:[{Name: Type:orderedItems}] Receiver:0xc000a8a5e0 Body:{
	cp := make(orderedItems, len(o))
	copy(cp, o)
	i := cp.search(item.Value)
	if i < len(o) && o.equal(o[i], item) {
		cp[i] = item
		return cp
	}

	if i == len(cp) {
		cp = append(cp, item)
		return cp
	}

	cp = append(cp, nil)
	copy(cp[i+1:], cp[i:])
	cp[i] = item
	return cp
} PrettyPrintBody:[{ cp := make(orderedItems, len(o)) copy(cp, o) i := cp.search(item.Value) if i < len(o) && o.equal(o[i], item) { cp[i] = item return cp } if i == len(cp) { cp = append(cp, item) return cp } cp = append(cp, nil) copy(cp[i+1:], cp[i:]) cp[i] = item return cp }]} {Id:21 FileId:50 StartLine:171 StartColumn:1 EndLine:188 EndColumn:2 Name:delete Params:[{Name:item Type:*Item}] Results:[{Name: Type:orderedItems}] Receiver:0xc001602980 Body:{
	i := o.search(item.Value)
	if i == len(o) {
		return o
	}

	if !o.equal(o[i], item) {
		return o
	}

	cp := make(orderedItems, len(o))
	copy(cp, o)

	copy(cp[i:], cp[i+1:])
	cp[len(cp)-1] = nil
	cp = cp[:len(cp)-1]
	return cp
} PrettyPrintBody:[{ i := o.search(item.Value) if i == len(o) { return o } if !o.equal(o[i], item) { return o } cp := make(orderedItems, len(o)) copy(cp, o) copy(cp[i:], cp[i+1:]) cp[len(cp)-1] = nil cp = cp[:len(cp)-1] return cp }]} {Id:22 FileId:50 StartLine:190 StartColumn:1 EndLine:197 EndColumn:2 Name:toItems Params:[] Results:[{Name: Type:items}] Receiver:0xc00019e060 Body:{
	cp := make(items, 0, len(o))
	for _, item := range o {
		cp = append(cp, item)
	}

	return cp
} PrettyPrintBody:[{ cp := make(items, 0, len(o)) for _, item := range o { cp = append(cp, item) } return cp }]} {Id:23 FileId:50 StartLine:199 StartColumn:1 EndLine:211 EndColumn:2 Name:query Params:[{Name:start Type:interface{}}] Results:[{Name: Type:items}] Receiver:0xc0003e5180 Body:{
	items := make(items, 0, len(o))

	for i := o.search(start); i < len(o); i++ {
		if comparator(o[i], stop) > 0 {
			break
		}

		items = append(items, o[i])
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, len(o)) for i := o.search(start); i < len(o); i++ { if comparator(o[i], stop) > 0 { break } items = append(items, o[i]) } return items }]} {Id:24 FileId:50 StartLine:213 StartColumn:1 EndLine:217 EndColumn:2 Name:generateRandomQuery Params:[] Results:[{Name: Type:interface{}} {Name: Type:interface{}}] Receiver:<nil> Body:{
	start := int64(rand.Intn(int(maxValue)))
	offset := int64(rand.Intn(100))
	return start, start + offset
} PrettyPrintBody:[{ start := int64(rand.Intn(int(maxValue))) offset := int64(rand.Intn(100)) return start, start + offset }]} {Id:25 FileId:50 StartLine:219 StartColumn:1 EndLine:224 EndColumn:2 Name:newItem Params:[{Name:value Type:interface{}}] Results:[{Name: Type:*Item}] Receiver:<nil> Body:{
	return &Item{
		Value:		value,
		Payload:	newID(),
	}
} PrettyPrintBody:[{ return &Item{ Value:		value, Payload:	newID(), } }]} {Id:26 FileId:50 StartLine:226 StartColumn:1 EndLine:230 EndColumn:2 Name:newEphemeral Params:[] Results:[{Name: Type:Persister}] Receiver:<nil> Body:{
	return &ephemeral{
		mp: make(map[string]*Payload),
	}
} PrettyPrintBody:[{ return &ephemeral{ mp: make(map[string]*Payload), } }]} {Id:28 FileId:50 StartLine:236 StartColumn:1 EndLine:239 EndColumn:2 Name:Load Params:[{Name:keys Type:...[]byte}] Results:[{Name: Type:[]*Payload} {Name: Type:error}] Receiver:0xc000993c00 Body:{
	time.Sleep(5 * time.Millisecond)
	return d.Persister.Load(keys...)
} PrettyPrintBody:[{ time.Sleep(5 * time.Millisecond) return d.Persister.Load(keys...) }]} {Id:29 FileId:50 StartLine:241 StartColumn:1 EndLine:243 EndColumn:2 Name:newDelayed Params:[] Results:[{Name: Type:Persister}] Receiver:<nil> Body:{
	return &delayedPersister{newEphemeral()}
} PrettyPrintBody:[{ return &delayedPersister{newEphemeral()} }]} {Id:30 FileId:50 StartLine:245 StartColumn:1 EndLine:251 EndColumn:2 Name:defaultConfig Params:[] Results:[{Name: Type:Config}] Receiver:<nil> Body:{
	return Config{
		NodeWidth:	10,
		Persister:	newEphemeral(),
		Comparator:	comparator,
	}
} PrettyPrintBody:[{ return Config{ NodeWidth:	10, Persister:	newEphemeral(), Comparator:	comparator, } }]} {Id:31 FileId:50 StartLine:253 StartColumn:1 EndLine:255 EndColumn:2 Name:generateRandomItem Params:[] Results:[{Name: Type:*Item}] Receiver:<nil> Body:{
	return newItem(int64(rand.Intn(int(maxValue))))
} PrettyPrintBody:[{ return newItem(int64(rand.Intn(int(maxValue)))) }]} {Id:32 FileId:50 StartLine:259 StartColumn:1 EndLine:272 EndColumn:2 Name:generateRandomItems Params:[{Name:num Type:int}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	items := make(items, 0, num)
	mp := make(map[interface{}]struct{}, num)
	for len(items) < num {
		c := generateRandomItem()
		if _, ok := mp[c.Value]; ok {
			continue
		}
		mp[c.Value] = struct{}{}
		items = append(items, c)
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, num) mp := make(map[interface{}]struct{}, num) for len(items) < num { c := generateRandomItem() if _, ok := mp[c.Value]; ok { continue } mp[c.Value] = struct{}{} items = append(items, c) } return items }]} {Id:33 FileId:50 StartLine:276 StartColumn:1 EndLine:284 EndColumn:2 Name:generateLinearItems Params:[{Name:num Type:int}] Results:[{Name: Type:items}] Receiver:<nil> Body:{
	items := make(items, 0, num)
	for i := 0; i < num; i++ {
		c := newItem(int64(i))
		items = append(items, c)
	}

	return items
} PrettyPrintBody:[{ items := make(items, 0, num) for i := 0; i < num; i++ { c := newItem(int64(i)) items = append(items, c) } return items }]} {Id:34 FileId:50 StartLine:286 StartColumn:1 EndLine:293 EndColumn:2 Name:toOrdered Params:[{Name:items Type:items}] Results:[{Name: Type:orderedItems}] Receiver:<nil> Body:{
	oc := make(orderedItems, 0, len(items))
	for _, item := range items {
		oc = oc.add(item)
	}

	return oc
} PrettyPrintBody:[{ oc := make(orderedItems, 0, len(items)) for _, item := range items { oc = oc.add(item) } return oc }]} {Id:35 FileId:50 StartLine:297 StartColumn:1 EndLine:304 EndColumn:2 Name:toList Params:[{Name:values Type:...interface{}}] Results:[{Name: Type:items} {Name: Type:error}] Receiver:0xc0001e65a0 Body:{
	items := make(items, 0, t.Count)
	err := t.Apply(func(item *Item) {
		items = append(items, item)
	}, values...)

	return items, err
} PrettyPrintBody:[{ items := make(items, 0, t.Count) err := t.Apply(func(item *Item) { items = append(items, item) }, values...) return items, err }]} {Id:36 FileId:50 StartLine:306 StartColumn:1 EndLine:328 EndColumn:2 Name:pprint Params:[{Name:id Type:ID}] Results:[] Receiver:0xc000a8b960 Body:{
	n, _ := t.contextOrCachedNode(id, true)
	if n == nil {
		log.Printf(`NODE: %+v`, n)
		return
	}
	log.Printf(`NODE: %+v, LEN(ids): %+v, LEN(values): %+v`, n, n.lenKeys(), n.lenValues())
	for i, key := range n.ChildKeys {
		child, _ := t.contextOrCachedNode(key.ID(), true)
		if child == nil {
			continue
		}
		log.Printf(`CHILD %d: %+v`, i, child)
	}

	for _, key := range n.ChildKeys {
		child, _ := t.contextOrCachedNode(key.ID(), true)
		if child == nil {
			continue
		}
		t.pprint(key.ID())
	}
} PrettyPrintBody:[{ n, _ := t.contextOrCachedNode(id, true) if n == nil { log.Printf(`NODE: %+v`, n) return } log.Printf(`NODE: %+v, LEN(ids): %+v, LEN(values): %+v`, n, n.lenKeys(), n.lenValues()) for i, key := range n.ChildKeys { child, _ := t.contextOrCachedNode(key.ID(), true) if child == nil { continue } log.Printf(`CHILD %d: %+v`, i, child) } for _, key := range n.ChildKeys { child, _ := t.contextOrCachedNode(key.ID(), true) if child == nil { continue } t.pprint(key.ID()) } }]} {Id:37 FileId:50 StartLine:330 StartColumn:1 EndLine:369 EndColumn:2 Name:verify Params:[{Name:id Type:ID} {Name:tb Type:testing.TB}] Results:[{Name: Type:interface{}} {Name: Type:interface{}}] Receiver:0xc0001e67e0 Body:{
	n, err := t.contextOrCachedNode(id, true)
	require.NoError(tb, err)

	cp := n.copy()
	cpValues := cp.ChildValues

	(&valueSortWrapper{comparator: comparator, values: cpValues}).sort()
	assert.Equal(tb, cpValues, n.ChildValues)

	if !assert.False(tb, n.needsSplit(t.config.NodeWidth)) {
		tb.Logf(`NODE NEEDS SPLIT: NODE: %+v`, n)
	}
	if string(t.Root) != string(n.ID) {
		assert.True(tb, n.lenValues() >= t.config.NodeWidth/2)
	}

	if n.IsLeaf {
		assert.Equal(tb, n.lenValues(), n.lenKeys())
		return n.firstValue(), n.lastValue()
	} else {
		for _, key := range n.ChildKeys {
			assert.Empty(tb, key.Payload)
		}
	}

	for i, key := range n.ChildKeys {
		min, max := t.verify(key.ID(), tb)
		if i == 0 {
			assert.True(tb, comparator(max, n.valueAt(i)) <= 0)
		} else if i == n.lenValues() {
			assert.True(tb, comparator(min, n.lastValue()) > 0)
		} else {
			assert.True(tb, comparator(max, n.valueAt(i)) <= 0)
			assert.True(tb, comparator(min, n.valueAt(i-1)) > 0)
		}
	}

	return n.firstValue(), n.lastValue()
} PrettyPrintBody:[{ n, err := t.contextOrCachedNode(id, true) require.NoError(tb, err) cp := n.copy() cpValues := cp.ChildValues (&valueSortWrapper{comparator: comparator, values: cpValues}).sort() assert.Equal(tb, cpValues, n.ChildValues) if !assert.False(tb, n.needsSplit(t.config.NodeWidth)) { tb.Logf(`NODE NEEDS SPLIT: NODE: %+v`, n) } if string(t.Root) != string(n.ID) { assert.True(tb, n.lenValues() >= t.config.NodeWidth/2) } if n.IsLeaf { assert.Equal(tb, n.lenValues(), n.lenKeys()) return n.firstValue(), n.lastValue() } else { for _, key := range n.ChildKeys { assert.Empty(tb, key.Payload) } } for i, key := range n.ChildKeys { min, max := t.verify(key.ID(), tb) if i == 0 { assert.True(tb, comparator(max, n.valueAt(i)) <= 0) } else if i == n.lenValues() { assert.True(tb, comparator(min, n.lastValue()) > 0) } else { assert.True(tb, comparator(max, n.valueAt(i)) <= 0) assert.True(tb, comparator(min, n.valueAt(i-1)) > 0) } } return n.firstValue(), n.lastValue() }]} {Id:38 FileId:50 StartLine:371 StartColumn:1 EndLine:378 EndColumn:2 Name:itemsToValues Params:[{Name:items Type:...*Item}] Results:[{Name: Type:[]interface{}}] Receiver:<nil> Body:{
	values := make([]interface{}, 0, len(items))
	for _, item := range items {
		values = append(values, item.Value)
	}

	return values
} PrettyPrintBody:[{ values := make([]interface{}, 0, len(items)) for _, item := range items { values = append(values, item.Value) } return values }]} {Id:39 FileId:50 StartLine:380 StartColumn:1 EndLine:421 EndColumn:2 Name:TestNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 100
	items := generateLinearItems(number)
	cfg := defaultConfig()

	rt := New(cfg)
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)
	assert.Equal(t, number, mutable.Len())
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err := mutable.(*Tr).toList(itemsToValues(items[5:10]...)...)
	require.NoError(t, err)
	if !assert.Equal(t, items[5:10], result) {
		mutable.(*Tr).pprint(mutable.(*Tr).Root)
		for i, c := range items[5:10] {
			t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i])
		}
		t.FailNow()
	}

	mutable = rt.AsMutable()
	for _, c := range items {
		_, err := mutable.AddItems(c)
		require.NoError(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	rt, err = mutable.Commit()
	require.NoError(t, err)
	rt, err = Load(cfg.Persister, rt.ID(), comparator)

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 100 items := generateLinearItems(number) cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) assert.Equal(t, number, mutable.Len()) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(items[5:10]...)...) require.NoError(t, err) if !assert.Equal(t, items[5:10], result) { mutable.(*Tr).pprint(mutable.(*Tr).Root) for i, c := range items[5:10] { t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i]) } t.FailNow() } mutable = rt.AsMutable() for _, c := range items { _, err := mutable.AddItems(c) require.NoError(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, rt.ID(), comparator) result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]} {Id:40 FileId:50 StartLine:423 StartColumn:1 EndLine:453 EndColumn:2 Name:TestReverseNodeSplit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 400
	items := generateLinearItems(number)

	reversed := make([]*Item, len(items))
	copy(reversed, items)
	reversed = reverse(reversed)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(reversed...)
	require.NoError(t, err)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	if !assert.Equal(t, items, result) {
		for _, c := range result {
			t.Logf(`RESULT: %+v`, c)
		}
	}

	mutable = rt.AsMutable()
	for _, c := range reversed {
		_, err := mutable.AddItems(c)
		require.NoError(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 400 items := generateLinearItems(number) reversed := make([]*Item, len(items)) copy(reversed, items) reversed = reverse(reversed) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(reversed...) require.NoError(t, err) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) if !assert.Equal(t, items, result) { for _, c := range result { t.Logf(`RESULT: %+v`, c) } } mutable = rt.AsMutable() for _, c := range reversed { _, err := mutable.AddItems(c) require.NoError(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]} {Id:41 FileId:50 StartLine:455 StartColumn:1 EndLine:472 EndColumn:2 Name:TestDuplicate Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	item1 := newItem(int64(1))
	item2 := newItem(int64(1))

	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(item1)
	require.NoError(t, err)
	_, err = mutable.AddItems(item2)
	require.NoError(t, err)

	assert.Equal(t, 1, mutable.Len())
	result, err := mutable.(*Tr).toList(int64(1))
	require.NoError(t, err)

	assert.Equal(t, items{item2}, result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ item1 := newItem(int64(1)) item2 := newItem(int64(1)) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(item1) require.NoError(t, err) _, err = mutable.AddItems(item2) require.NoError(t, err) assert.Equal(t, 1, mutable.Len()) result, err := mutable.(*Tr).toList(int64(1)) require.NoError(t, err) assert.Equal(t, items{item2}, result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]} {Id:42 FileId:50 StartLine:474 StartColumn:1 EndLine:496 EndColumn:2 Name:TestCommit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	items := generateRandomItems(5)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.Nil(t, err)

	rt, err = mutable.Commit()
	require.NoError(t, err)
	expected := toOrdered(items).toItems()
	result, err := rt.(*Tr).toList(itemsToValues(expected...)...)
	require.NoError(t, err)
	if !assert.Equal(t, expected, result) {
		require.Equal(t, len(expected), len(result))
		for i, c := range expected {
			if !assert.Equal(t, c, result[i]) {
				t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i])
			}
		}
	}

	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ items := generateRandomItems(5) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) rt, err = mutable.Commit() require.NoError(t, err) expected := toOrdered(items).toItems() result, err := rt.(*Tr).toList(itemsToValues(expected...)...) require.NoError(t, err) if !assert.Equal(t, expected, result) { require.Equal(t, len(expected), len(result)) for i, c := range expected { if !assert.Equal(t, c, result[i]) { t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i]) } } } rt.(*Tr).verify(rt.(*Tr).Root, t) }]} {Id:43 FileId:50 StartLine:498 StartColumn:1 EndLine:515 EndColumn:2 Name:TestRandom Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	items := generateRandomItems(1000)
	rt := New(defaultConfig())
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.Nil(t, err)

	require.NoError(t, err)
	expected := toOrdered(items).toItems()
	result, err := mutable.(*Tr).toList(itemsToValues(expected...)...)
	if !assert.Equal(t, expected, result) {
		assert.Equal(t, len(expected), len(result))
		for i, c := range expected {
			assert.Equal(t, c, result[i])
		}
	}
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ items := generateRandomItems(1000) rt := New(defaultConfig()) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) require.NoError(t, err) expected := toOrdered(items).toItems() result, err := mutable.(*Tr).toList(itemsToValues(expected...)...) if !assert.Equal(t, expected, result) { assert.Equal(t, len(expected), len(result)) for i, c := range expected { assert.Equal(t, c, result[i]) } } mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]} {Id:44 FileId:50 StartLine:517 StartColumn:1 EndLine:536 EndColumn:2 Name:TestLoad Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(1000)
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	id := mutable.ID()
	_, err = mutable.Commit()
	require.NoError(t, err)

	rt, err = Load(cfg.Persister, id, comparator)
	require.NoError(t, err)
	sort.Sort(orderedItems(items))
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(1000) _, err := mutable.AddItems(items...) require.NoError(t, err) id := mutable.ID() _, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, id, comparator) require.NoError(t, err) sort.Sort(orderedItems(items)) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]} {Id:45 FileId:50 StartLine:538 StartColumn:1 EndLine:554 EndColumn:2 Name:TestDeleteFromRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 5
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(number)

	mutable.AddItems(items...)
	mutable.DeleteItems(items[0].Value, items[1].Value, items[2].Value)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[3:], result)
	assert.Equal(t, 2, mutable.Len())

	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
} PrettyPrintBody:[{ number := 5 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(number) mutable.AddItems(items...) mutable.DeleteItems(items[0].Value, items[1].Value, items[2].Value) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[3:], result) assert.Equal(t, 2, mutable.Len()) mutable.(*Tr).verify(mutable.(*Tr).Root, t) }]} {Id:46 FileId:50 StartLine:556 StartColumn:1 EndLine:570 EndColumn:2 Name:TestDeleteAllFromRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 5
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	mutable.DeleteItems(itemsToValues(items...)...)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Empty(t, result)
	assert.Equal(t, 0, mutable.Len())
} PrettyPrintBody:[{ num := 5 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) mutable.DeleteItems(itemsToValues(items...)...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Empty(t, result) assert.Equal(t, 0, mutable.Len()) }]} {Id:47 FileId:50 StartLine:572 StartColumn:1 EndLine:587 EndColumn:2 Name:TestDeleteAfterSplitIncreasing Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 11
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	for i := 0; i < num-1; i++ {
		mutable.DeleteItems(itemsToValues(items[i])...)
		result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
		require.Nil(t, err)
		assert.Equal(t, items[i+1:], result)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	}
} PrettyPrintBody:[{ num := 11 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) for i := 0; i < num-1; i++ { mutable.DeleteItems(itemsToValues(items[i])...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[i+1:], result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) } }]} {Id:48 FileId:50 StartLine:589 StartColumn:1 EndLine:599 EndColumn:2 Name:TestDeleteMultipleLevelsRandomlyBulk Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 200
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	mutable.DeleteItems(itemsToValues(items[:100]...)...)
	result, _ := mutable.(*Tr).toList(itemsToValues(items...)...)
	assert.Len(t, result, 100)
} PrettyPrintBody:[{ num := 200 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) mutable.DeleteItems(itemsToValues(items[:100]...)...) result, _ := mutable.(*Tr).toList(itemsToValues(items...)...) assert.Len(t, result, 100) }]} {Id:49 FileId:50 StartLine:601 StartColumn:1 EndLine:618 EndColumn:2 Name:TestDeleteAfterSplitDecreasing Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 11
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateLinearItems(num)

	mutable.AddItems(items...)
	for i := num - 1; i >= 0; i-- {
		mutable.DeleteItems(itemsToValues(items[i])...)
		result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
		require.Nil(t, err)
		assert.Equal(t, items[:i], result)
		if i > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}
} PrettyPrintBody:[{ num := 11 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateLinearItems(num) mutable.AddItems(items...) for i := num - 1; i >= 0; i-- { mutable.DeleteItems(itemsToValues(items[i])...) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[:i], result) if i > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } }]} {Id:50 FileId:50 StartLine:620 StartColumn:1 EndLine:652 EndColumn:2 Name:TestDeleteMultipleLevels Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 20
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	ordered := toOrdered(items)

	for i, c := range ordered {
		_, err := mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...)
		require.NoError(t, err)
		if !assert.Equal(t, ordered[i+1:].toItems(), result) {
			log.Printf(`LEN EXPECTED: %+v, RESULT: %+v`, len(ordered[i+1:]), len(result))
			mutable.(*Tr).pprint(mutable.(*Tr).Root)
			assert.Equal(t, len(ordered[i+1:]), len(result))
			for i, c := range ordered[i+1:] {
				log.Printf(`EXPECTED: %+v`, c)
				if i < len(result) {
					log.Printf(`RECEIVED: %+v`, result[i])
				}
			}
			break
		}
		if len(ordered[i+1:]) > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}

	assert.Nil(t, mutable.(*Tr).Root)
} PrettyPrintBody:[{ num := 20 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) ordered := toOrdered(items) for i, c := range ordered { _, err := mutable.DeleteItems(c.Value) require.NoError(t, err) result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...) require.NoError(t, err) if !assert.Equal(t, ordered[i+1:].toItems(), result) { log.Printf(`LEN EXPECTED: %+v, RESULT: %+v`, len(ordered[i+1:]), len(result)) mutable.(*Tr).pprint(mutable.(*Tr).Root) assert.Equal(t, len(ordered[i+1:]), len(result)) for i, c := range ordered[i+1:] { log.Printf(`EXPECTED: %+v`, c) if i < len(result) { log.Printf(`RECEIVED: %+v`, result[i]) } } break } if len(ordered[i+1:]) > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } assert.Nil(t, mutable.(*Tr).Root) }]} {Id:51 FileId:50 StartLine:654 StartColumn:1 EndLine:677 EndColumn:2 Name:TestDeleteMultipleLevelsRandomly Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 200
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	ordered := toOrdered(items)

	for _, c := range items {
		_, err := mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		ordered = ordered.delete(c)

		result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...)
		require.NoError(t, err)
		assert.Equal(t, ordered.toItems(), result)
		if len(ordered) > 0 {
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		}
	}

	assert.Nil(t, mutable.(*Tr).Root)
} PrettyPrintBody:[{ num := 200 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) ordered := toOrdered(items) for _, c := range items { _, err := mutable.DeleteItems(c.Value) require.NoError(t, err) ordered = ordered.delete(c) result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...) require.NoError(t, err) assert.Equal(t, ordered.toItems(), result) if len(ordered) > 0 { mutable.(*Tr).verify(mutable.(*Tr).Root, t) } } assert.Nil(t, mutable.(*Tr).Root) }]} {Id:52 FileId:50 StartLine:679 StartColumn:1 EndLine:708 EndColumn:2 Name:TestDeleteMultipleLevelsWithCommit Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 20
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	rt, _ = mutable.Commit()

	rt, _ = Load(cfg.Persister, rt.ID(), comparator)
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	mutable = rt.AsMutable()

	for _, c := range items[:10] {
		_, err := mutable.DeleteItems(c.Value)
		require.Nil(t, err)
	}

	result, err = mutable.(*Tr).toList(itemsToValues(items[10:]...)...)
	require.Nil(t, err)
	assert.Equal(t, items[10:], result)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err = rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)
} PrettyPrintBody:[{ num := 20 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) rt, _ = mutable.Commit() rt, _ = Load(cfg.Persister, rt.ID(), comparator) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) mutable = rt.AsMutable() for _, c := range items[:10] { _, err := mutable.DeleteItems(c.Value) require.Nil(t, err) } result, err = mutable.(*Tr).toList(itemsToValues(items[10:]...)...) require.Nil(t, err) assert.Equal(t, items[10:], result) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]} {Id:53 FileId:50 StartLine:710 StartColumn:1 EndLine:729 EndColumn:2 Name:TestCommitAfterDelete Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 15
	cfg := defaultConfig()
	rt := New(cfg)
	mutable := rt.AsMutable()
	items := generateRandomItems(num)
	mutable.AddItems(items...)
	for _, c := range items[:5] {
		mutable.DeleteItems(c.Value)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	}

	rt, err := mutable.Commit()
	require.Nil(t, err)
	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[5:], result)
	rt.(*Tr).verify(rt.(*Tr).Root, t)

} PrettyPrintBody:[{ num := 15 cfg := defaultConfig() rt := New(cfg) mutable := rt.AsMutable() items := generateRandomItems(num) mutable.AddItems(items...) for _, c := range items[:5] { mutable.DeleteItems(c.Value) mutable.(*Tr).verify(mutable.(*Tr).Root, t) } rt, err := mutable.Commit() require.Nil(t, err) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[5:], result) rt.(*Tr).verify(rt.(*Tr).Root, t) }]} {Id:54 FileId:50 StartLine:731 StartColumn:1 EndLine:754 EndColumn:2 Name:TestSecondCommitSplitsRoot Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	number := 15
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateLinearItems(number)

	mutable := rt.AsMutable()
	mutable.AddItems(items[:10]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, _ = mutable.Commit()
	rt.(*Tr).verify(rt.(*Tr).Root, t)
	mutable = rt.AsMutable()
	mutable.AddItems(items[10:]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)

	if !assert.Equal(t, items, result) {
		for i, c := range items {
			log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i])
		}
	}
} PrettyPrintBody:[{ number := 15 cfg := defaultConfig() rt := New(cfg) items := generateLinearItems(number) mutable := rt.AsMutable() mutable.AddItems(items[:10]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, _ = mutable.Commit() rt.(*Tr).verify(rt.(*Tr).Root, t) mutable = rt.AsMutable() mutable.AddItems(items[10:]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) if !assert.Equal(t, items, result) { for i, c := range items { log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i]) } } }]} {Id:55 FileId:50 StartLine:756 StartColumn:1 EndLine:782 EndColumn:2 Name:TestSecondCommitMultipleSplits Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	num := 50
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateRandomItems(num)

	mutable := rt.AsMutable()
	mutable.AddItems(items[:25]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, err := mutable.Commit()
	rt.(*Tr).verify(rt.(*Tr).Root, t)

	result, err := rt.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	assert.Equal(t, items[:25], result)

	mutable = rt.AsMutable()
	mutable.AddItems(items[25:]...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)

	sort.Sort(orderedItems(items))
	result, err = mutable.(*Tr).toList(itemsToValues(items...)...)
	require.Nil(t, err)
	if !assert.Equal(t, items, result) {
		mutable.(*Tr).pprint(mutable.(*Tr).Root)
	}
} PrettyPrintBody:[{ num := 50 cfg := defaultConfig() rt := New(cfg) items := generateRandomItems(num) mutable := rt.AsMutable() mutable.AddItems(items[:25]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err := mutable.Commit() rt.(*Tr).verify(rt.(*Tr).Root, t) result, err := rt.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) assert.Equal(t, items[:25], result) mutable = rt.AsMutable() mutable.AddItems(items[25:]...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) sort.Sort(orderedItems(items)) result, err = mutable.(*Tr).toList(itemsToValues(items...)...) require.Nil(t, err) if !assert.Equal(t, items, result) { mutable.(*Tr).pprint(mutable.(*Tr).Root) } }]} {Id:56 FileId:50 StartLine:784 StartColumn:1 EndLine:807 EndColumn:2 Name:TestLargeAdd Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	number := cfg.NodeWidth * 5
	rt := New(cfg)
	items := generateLinearItems(number)

	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	id := mutable.ID()
	result, err := mutable.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)

	_, err = mutable.Commit()
	require.NoError(t, err)

	rt, err = Load(cfg.Persister, id, comparator)
	require.NoError(t, err)
	result, err = rt.(*Tr).toList(itemsToValues(items...)...)
	require.NoError(t, err)
	assert.Equal(t, items, result)
} PrettyPrintBody:[{ cfg := defaultConfig() number := cfg.NodeWidth * 5 rt := New(cfg) items := generateLinearItems(number) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) id := mutable.ID() result, err := mutable.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) _, err = mutable.Commit() require.NoError(t, err) rt, err = Load(cfg.Persister, id, comparator) require.NoError(t, err) result, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(t, err) assert.Equal(t, items, result) }]} {Id:57 FileId:50 StartLine:809 StartColumn:1 EndLine:821 EndColumn:2 Name:TestNodeInfiniteLoop Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	cfg := defaultConfig()
	rt := New(cfg)
	items := generateLinearItems(3)

	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(t, err)

	result, err := mutable.DeleteItems(items[1].Value, items[2].Value)
	require.NoError(t, err)
	assert.Len(t, result, 2)
} PrettyPrintBody:[{ cfg := defaultConfig() rt := New(cfg) items := generateLinearItems(3) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(t, err) result, err := mutable.DeleteItems(items[1].Value, items[2].Value) require.NoError(t, err) assert.Len(t, result, 2) }]} {Id:58 FileId:50 StartLine:826 StartColumn:1 EndLine:876 EndColumn:2 Name:TestGenerativeAdds Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative add`)
		return
	}

	number := 100
	cfg := defaultConfig()
	rt := New(cfg)
	oc := make(orderedItems, 0)
	for i := 0; i < number; i++ {
		num := int(rand.Int31n(100))
		if num == 0 {
			num++
		}

		items := generateRandomItems(num)
		mutated := oc.copy()
		for _, c := range items {
			mutated = mutated.add(c)
		}

		mutable := rt.AsMutable()
		_, err := mutable.AddItems(items...)
		require.Nil(t, err)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)

		rtMutated, err := mutable.Commit()
		require.Nil(t, err)
		rtMutated.(*Tr).verify(rtMutated.(*Tr).Root, t)

		result, err := rtMutated.(*Tr).toList(itemsToValues(mutated.toItems()...)...)
		require.Nil(t, err)
		if !assert.Equal(t, mutated.toItems(), result) {
			rtMutated.(*Tr).pprint(rtMutated.(*Tr).Root)
			if len(mutated) == len(result) {
				for i, c := range mutated.toItems() {
					log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i])
				}
			}
		}
		assert.Equal(t, len(mutated), rtMutated.Len())

		result, err = rt.(*Tr).toList(itemsToValues(oc.toItems()...)...)
		require.Nil(t, err)
		assert.Equal(t, oc.toItems(), result)

		oc = mutated
		rt = rtMutated
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative add`) return } number := 100 cfg := defaultConfig() rt := New(cfg) oc := make(orderedItems, 0) for i := 0; i < number; i++ { num := int(rand.Int31n(100)) if num == 0 { num++ } items := generateRandomItems(num) mutated := oc.copy() for _, c := range items { mutated = mutated.add(c) } mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.Nil(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rtMutated, err := mutable.Commit() require.Nil(t, err) rtMutated.(*Tr).verify(rtMutated.(*Tr).Root, t) result, err := rtMutated.(*Tr).toList(itemsToValues(mutated.toItems()...)...) require.Nil(t, err) if !assert.Equal(t, mutated.toItems(), result) { rtMutated.(*Tr).pprint(rtMutated.(*Tr).Root) if len(mutated) == len(result) { for i, c := range mutated.toItems() { log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i]) } } } assert.Equal(t, len(mutated), rtMutated.Len()) result, err = rt.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.Nil(t, err) assert.Equal(t, oc.toItems(), result) oc = mutated rt = rtMutated } }]} {Id:59 FileId:50 StartLine:878 StartColumn:1 EndLine:916 EndColumn:2 Name:TestGenerativeDeletes Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative delete`)
		return
	}

	number := 100
	var err error
	cfg := defaultConfig()
	rt := New(cfg)
	oc := toOrdered(generateRandomItems(1000))
	mutable := rt.AsMutable()
	mutable.AddItems(oc.toItems()...)
	mutable.(*Tr).verify(mutable.(*Tr).Root, t)
	rt, err = mutable.Commit()
	require.NoError(t, err)
	for i := 0; i < number; i++ {
		mutable = rt.AsMutable()
		index := rand.Intn(len(oc))
		c := oc[index]
		mutated := oc.delete(c)

		result, err := rt.(*Tr).toList(itemsToValues(oc.toItems()...)...)
		require.NoError(t, err)
		assert.Equal(t, oc.toItems(), result)
		assert.Equal(t, len(oc), rt.Len())

		_, err = mutable.DeleteItems(c.Value)
		require.NoError(t, err)
		mutable.(*Tr).verify(mutable.(*Tr).Root, t)
		result, err = mutable.(*Tr).toList(itemsToValues(mutated.toItems()...)...)
		require.NoError(t, err)
		assert.Equal(t, len(mutated), len(result))
		require.Equal(t, mutated.toItems(), result)
		oc = mutated
		rt, err = mutable.Commit()
		require.NoError(t, err)
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative delete`) return } number := 100 var err error cfg := defaultConfig() rt := New(cfg) oc := toOrdered(generateRandomItems(1000)) mutable := rt.AsMutable() mutable.AddItems(oc.toItems()...) mutable.(*Tr).verify(mutable.(*Tr).Root, t) rt, err = mutable.Commit() require.NoError(t, err) for i := 0; i < number; i++ { mutable = rt.AsMutable() index := rand.Intn(len(oc)) c := oc[index] mutated := oc.delete(c) result, err := rt.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) assert.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), rt.Len()) _, err = mutable.DeleteItems(c.Value) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = mutable.(*Tr).toList(itemsToValues(mutated.toItems()...)...) require.NoError(t, err) assert.Equal(t, len(mutated), len(result)) require.Equal(t, mutated.toItems(), result) oc = mutated rt, err = mutable.Commit() require.NoError(t, err) } }]} {Id:60 FileId:50 StartLine:918 StartColumn:1 EndLine:969 EndColumn:2 Name:TestGenerativeOperations Params:[{Name:t Type:*testing.T}] Results:[] Receiver:<nil> Body:{
	if testing.Short() {
		t.Skipf(`skipping generative operations`)
		return
	}

	number := 100
	cfg := defaultConfig()
	rt := New(cfg)

	items := generateRandomItems(1000)
	oc := toOrdered(items)

	mutable := rt.AsMutable()
	mutable.AddItems(items...)

	result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
	require.NoError(t, err)
	require.Equal(t, oc.toItems(), result)

	rt, err = mutable.Commit()
	require.NoError(t, err)

	for i := 0; i < number; i++ {
		mutable = rt.AsMutable()
		if rand.Float64() < .5 && len(oc) > 0 {
			c := oc[rand.Intn(len(oc))]
			oc = oc.delete(c)
			_, err = mutable.DeleteItems(c.Value)
			require.NoError(t, err)
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
			result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
			require.NoError(t, err)
			require.Equal(t, oc.toItems(), result)
			assert.Equal(t, len(oc), mutable.Len())
		} else {
			c := generateRandomItem()
			oc = oc.add(c)
			_, err = mutable.AddItems(c)
			require.NoError(t, err)
			mutable.(*Tr).verify(mutable.(*Tr).Root, t)
			result, err = mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...)
			require.NoError(t, err)
			require.Equal(t, oc.toItems(), result)
			assert.Equal(t, len(oc), mutable.Len())
		}

		rt, err = mutable.Commit()
		require.NoError(t, err)
	}
} PrettyPrintBody:[{ if testing.Short() { t.Skipf(`skipping generative operations`) return } number := 100 cfg := defaultConfig() rt := New(cfg) items := generateRandomItems(1000) oc := toOrdered(items) mutable := rt.AsMutable() mutable.AddItems(items...) result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) rt, err = mutable.Commit() require.NoError(t, err) for i := 0; i < number; i++ { mutable = rt.AsMutable() if rand.Float64() < .5 && len(oc) > 0 { c := oc[rand.Intn(len(oc))] oc = oc.delete(c) _, err = mutable.DeleteItems(c.Value) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), mutable.Len()) } else { c := generateRandomItem() oc = oc.add(c) _, err = mutable.AddItems(c) require.NoError(t, err) mutable.(*Tr).verify(mutable.(*Tr).Root, t) result, err = mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...) require.NoError(t, err) require.Equal(t, oc.toItems(), result) assert.Equal(t, len(oc), mutable.Len()) } rt, err = mutable.Commit() require.NoError(t, err) } }]} {Id:61 FileId:50 StartLine:971 StartColumn:1 EndLine:994 EndColumn:2 Name:BenchmarkGetitems Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	number := 100
	cfg := defaultConfig()
	cfg.Persister = newDelayed()
	rt := New(cfg)

	items := generateRandomItems(number)
	mutable := rt.AsMutable()
	_, err := mutable.AddItems(items...)
	require.NoError(b, err)

	rt, err = mutable.Commit()
	require.NoError(b, err)
	id := rt.ID()

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		rt, err = Load(cfg.Persister, id, comparator)
		require.NoError(b, err)
		_, err = rt.(*Tr).toList(itemsToValues(items...)...)
		require.NoError(b, err)
	}
} PrettyPrintBody:[{ number := 100 cfg := defaultConfig() cfg.Persister = newDelayed() rt := New(cfg) items := generateRandomItems(number) mutable := rt.AsMutable() _, err := mutable.AddItems(items...) require.NoError(b, err) rt, err = mutable.Commit() require.NoError(b, err) id := rt.ID() b.ResetTimer() for i := 0; i < b.N; i++ { rt, err = Load(cfg.Persister, id, comparator) require.NoError(b, err) _, err = rt.(*Tr).toList(itemsToValues(items...)...) require.NoError(b, err) } }]} {Id:62 FileId:50 StartLine:996 StartColumn:1 EndLine:1006 EndColumn:2 Name:BenchmarkBulkAdd Params:[{Name:b Type:*testing.B}] Results:[] Receiver:<nil> Body:{
	number := 1000000
	items := generateLinearItems(number)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		tr := New(defaultConfig())
		mutable := tr.AsMutable()
		mutable.AddItems(items...)
	}
} PrettyPrintBody:[{ number := 1000000 items := generateLinearItems(number) b.ResetTimer() for i := 0; i < b.N; i++ { tr := New(defaultConfig()) mutable := tr.AsMutable() mutable.AddItems(items...) } }]}] Strings:{mu:{state:0 sema:0} read:{v:{m:map[if dimension > uint64(len(mi.dimensions)) {:0xc000190140 panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension)):0xc000190148 return mi.dimensions[dimension-1].low:0xc000190158 sort.Sort(comparators):0xc0004a4000 {:0xc000190138 }:0xc000190150] amended:true}} dirty:map[!isLastDimension(irt.dimensions, uint64(i)+1),:0xc000827630 !vertices[0].less(nm.config, reflection) {:0xc00028d538 "0":	0,:0xc00028d398 "1":	1,:0xc00028d3a0 "2":	2,:0xc00028d3a8 "3":	3,:0xc00028d3b0 "4":	4,:0xc00028d3b8 "5":	5,:0xc00028d3c0 "6":	6,:0xc00028d3c8 "7":	7,:0xc00028d3d0 "8":	8,:0xc00028d3d8 "9":	9,:0xc00028d3e0 &modified, &deleted,:0xc000a131c0 (&valueSortWrapper{comparator: comparator, values: cpValues}).sort():0xc000a13d68 (*b)[index] = block(0):0xc0001bf2b0 (*b)[len(*b)-1] = block(0):0xc0001bf390 (*entries) = append(*entries, nil):0xc00039cec8 (*entries)[i] = entry:0xc00039ceb8 (*entries)[i] = nil:0xc00000e270 (*entries)[len(*entries)-1] = nil:0xc0009133c0 (*items)[i] = nil:0xc00000e9a8 (*items)[i], (*items)[j] = (*items)[j], (*items)[i]:0xc000191768 (*items)[size-1], *items = nil, (*items)[:size-1]:0xc00039c3c8 (*ivs)[i] = nil:0xc0006aab90 (*keys)[i] = key:0xc0001be668 (*keys)[j] = nil:0xc0001bea10 (*nb.list)[nb.index] = nb.newNode:0xc000827658 (*nodes)[i] = node:0xc000913038 (*nodes)[j].orderedNodes.flatten(deleted):0xc0004a57e0 (*nodes)[j].orderedNodes.flatten(modified):0xc0004a57f0 (*nodes)[j].value += number:0xc0004a57b8 (*nodes)[len(*nodes)-1] = nil:0xc00000e320 (*ns)[i] = n:0xc0004a4eb0 (*ns)[i] = nil:0xc0004a40a8 (*ns)[j] = nil:0xc000c24c08 (*ns)[len(*ns)-1] = nil:0xc0001bed60 (*u)[i] = x:0xc000912be0 (*u)[len(*u)-1] = 0:0xc0006aa0f8 (*unsafe.Pointer)(unsafe.Pointer(&c.root)), unsafe.Pointer(ov), unsafe.Pointer(nv)):0xc000224b30 (*unsafe.Pointer)(unsafe.Pointer(&i.main)))):0xc0000a44d0 (*unsafe.Pointer)(unsafe.Pointer(&in.main)),:0xc0006aa038 (*unsafe.Pointer)(unsafe.Pointer(&m.prev)))):0xc0000a4490 (*unsafe.Pointer)(unsafe.Pointer(&m.prev)),:0xc0000a44f0 (*unsafe.Pointer)(unsafe.Pointer(&m.prev)), unsafe.Pointer(prev), nil) {:0xc0000a44e0 (*unsafe.Pointer)(unsafe.Pointer(&nin.main)), unsafe.Pointer(main)):0xc0004a5380 (*w)[len(*w)-1] = nil:0xc00000eff8 (*z) = (*z)[:xsz]:0xc000a13710 (*z) = ID(tmp):0xc00028c600 (*z) = make(Keys, xsz):0xc000a13718 (*z)[bzg] = new(Key):0xc000a13748 (*z)[bzg] = nil:0xc000a13738 (results[0][0] == `b` && results[1][0] == `a`),:0xc000224528 ):0xc00028c2a0 ),:0xc000913268 *added++:0xc000826e68 *affected = append(*affected, e.(*lastBundle).entry):0xc000225a00 *b = (*b)[:len(*b)-1]:0xc0001bf398 *b = append(*b, block(0)):0xc0001bf2a0 *deleted = append(*deleted, (*nodes)[j].entry):0xc0004a57d8 *deleted = append(*deleted, cp[j].entry):0xc000827808 *deleted = append(*deleted, e.(*lastBundle).entry):0xc000225a28 *deleted++:0xc0008275d8 *done = 1:0xc000225d48 *entries = (*entries)[:0]:0xc00000e278 *entries = (*entries)[:len(*entries)-1]:0xc0009133c8 *entries = append(*entries, entry):0xc00039cea0 *entries = append(*entries, iter.Value().(*lastBundle).entry):0xc0002258e8 *entries = append(*entries, node.entry):0xc00028ca20 *items = (*items)[index+1:]:0xc0004a5648 *items = (*items)[index:]:0xc00000e9b8 *items = append(*items, item):0xc000c24ba0 *ivs = (*ivs)[:0]:0xc0006aab98 *keys = (*keys)[:i+1]:0xc0001bea78 *keys = append(*keys, k):0xc0004a5828 *keys = append(*keys, key):0xc0001be4c0 *keys = append(*keys, nil):0xc0001be6f0 *modified = append(*modified, (*nodes)[j].entry):0xc0004a57e8 *modified = append(*modified, cp[j].entry):0xc000827818 *nodes = (*nodes)[:len(*nodes)-1]:0xc00000e468 *nodes = append(*nodes, left, right):0xc0004a5830 *nodes = append(*nodes, nil):0xc000913028 *nodes = append(*nodes, node):0xc000913020 *ns = (*ns)[:0]:0xc0004a4100 *ns = (*ns)[:i+1]:0xc000c24c10 *ns = (*ns)[:len(*ns)-1]:0xc0001bedf8 *ns = append(*ns, n):0xc0004a4108 *ns = append(*ns, nil):0xc0004a4ea0 *nums = append(*nums, i+offset):0xc000191a18 *u = (*u)[:len(*u)-1]:0xc0006aa108 *u = append(*u, 0):0xc000912ac0 *u = append(*u, x):0xc000912a20 *w = (*w)[:len(*w)-1]:0xc00000f000 *w = append(*w, sema):0xc00000f020 *w = newWs:0xc000826f70 *x = *y:0xc000913120 *x = n - 1 - *x:0xc000913108 *y = n - 1 - *y:0xc000913110 *y = t:0xc000913128 0, &dimension{0, 100}, &dimension{0, 100},:0xc0004a4208 0, &dimension{0, 10}, &dimension{0, 10},:0xc000913260 0, &dimension{0, numItems}, &dimension{0, numItems},:0xc00000e0a0 0, &dimension{100, 200}, &dimension{100, 200},:0xc000913280 0, &dimension{11, 15}, &dimension{11, 15},:0xc0004a42f8 0, &dimension{15, 20}, &dimension{15, 20},:0xc0004a4350 0, &dimension{3, 5}, &dimension{3, 5},:0xc0004a42a8 0, &dimension{5, 8}, &dimension{5, 8},:0xc0004a42e0 0, &dimension{low: 5, high: 10}, &dimension{low: 5, high: 10},:0xc000912f98 1,:0xc0001bfb30 1, &dimension{low: 0, high: 5}, &dimension{low: 1, high: 6},:0xc000913238 1, &dimension{low: 4, high: 5}, &dimension{low: 4, high: 5},:0xc000912fb0 2, &dimension{low: 7, high: 12}, &dimension{low: 7, high: 12},:0xc000912fc8 <-ch:0xc0000a55e0 <-f.wchan():0xc0009131c8 <-iter:0xc0000a5790 <-m.lock:0xc00039d0f0 <-sema.ready:0xc000c25018 <-wait:0xc000827288 ChildKeys:	cpKeys,:0xc0001bf570 ChildValues:	cpValues,:0xc0001bf568 Comparator:	comparator,:0xc00039cf38 Count:		t.Count,:0xc000c24ea8 Decode(int64(i)):0xc0002252d8 Encode(int32(i), int32(i)):0xc0009135d8 EvictionPolicy(LeastRecentlyAdded)(c):0xc000191c78 EvictionPolicy(LeastRecentlyUsed)(c):0xc000191c50 ExecuteInParallel(q, fn):0xc0000a4388 ExecuteInParallel(q, func(interface{}) {:0xc0000a4178 ExecuteInParallel(q, func(item interface{}) {:0xc000224638 Fn:	fn,:0xc000191b58 Guess::0xc0006aae68 ID:		newID(),:0xc0001bf558 ID: newID(),:0xc0000a5668 Intervals	= intervalsPool.Get().(Intervals):0xc000c24220 Intervals = append(Intervals, node.interval):0xc000c24240 IsLeaf:		n.IsLeaf,:0xc0001bf560 Key:	key,:0xc0002259e0 L::0xc000a12448 MultithreadedSortComparators(comparators):0xc0006ab110 N := 1000000:0xc000a13be8 N := 10000000:0xc00028ce98 NewRingBuffer(1024):0xc00000f870 NodeWidth:	10,:0xc000827480 NodeWidth:	10000,:0xc00039cf28 NodeWidth:	t.NodeWidth,:0xc000c24ed8 Payload:	k.Payload,:0xc0000a5088 Payload:	newID(),:0xc000c24fe0 Persister:	newEphemeral(),:0xc000827488 Persister:	persister,:0xc00039cf30 Root:		t.Root,:0xc000c24eb8 Target:	float64(-100),:0xc00000f190 Target:	float64(14),:0xc00028cd38 Target:	float64(9),:0xc000191b50 Target:	math.Inf(-1),:0xc000225360 Target:	math.Inf(1),:0xc000225960 UUID:		newID(),:0xc000c24eb0 UUID:	newID(),:0xc000a13af0 Value:		k.Value,:0xc0000a5080 Value:		value,:0xc000c24fd8 Value:	value,:0xc0002259e8 Vars:	[]float64{-10, 10},:0xc00000f198 Vars:	[]float64{-5, 5},:0xc000225968 Vars:	[]float64{0, 3},:0xc0000a55c0 Vars:	[]float64{2, 4},:0xc000191b60 Vars:	[]float64{6, .5},:0xc00028cd80 Vars:	[]float64{6, 3},:0xc00028cd40 _ = field:0xc0002247b8 _, err := Empty.Insert(1, 5):0xc000826050 _, err := New(0, 0, 100, 5, nil):0xc000191b78 _, err := ba.GetBit(1500):0xc0001bf650 _, err := ba.GetBit(s * 2):0xc0006ab470 _, err := heap.DecreaseKey(e1, Seq2DecreaseKey1Trgt):0xc0006ab068 _, err := heap1.Merge(&heap2):0xc000c253b8 _, err := io.ReadFull(rand.Reader, id):0xc0000a5060 _, err := mutable.AddItems(c):0xc00028ce68 _, err := mutable.AddItems(item1):0xc00028d270 _, err := mutable.AddItems(items...):0xc00028ce10 _, err := mutable.AddItems(reversed...):0xc0004a5d90 _, err := mutable.DeleteItems(c.Value):0xc000c240f0 _, err := n.UnmarshalMsg(data):0xc0000a55b0 _, err := q.Get(1):0xc0002259b8 _, err := q.Poll(1, time.Millisecond):0xc000225ba0 _, err := rb.Get():0xc000c24200 _, err := rb.Poll(1):0xc000225590 _, err := rb.put(item, false):0xc000191d78 _, err := t.UnmarshalMsg(data):0xc00000eb18 _, err = b.Get():0xc000c24190 _, err = ba.GetBit(1501):0xc0001bf660 _, err = ba.GetBit(s + 1):0xc00039cf60 _, err = heap.DecreaseKey(e2, Seq2DecreaseKey2Trgt):0xc0006ab070 _, err = heap.DecreaseKey(e3, Seq2DecreaseKey3Trgt):0xc0006ab078 _, err = mutable.AddItems(c):0xc0006aa200 _, err = mutable.AddItems(item2):0xc00028d278 _, err = mutable.Commit():0xc000c25528 _, err = mutable.DeleteItems(c.Value):0xc0006aa198 _, err = q.Get(1):0xc000827908 _, err = q.Poll(1, 5*time.Millisecond):0xc0004a4508 _, err = q.Poll(1, time.Millisecond):0xc000225bb0 _, err = rb.Poll(5 * time.Millisecond):0xc000225858 _, err = rt.(*Tr).toList(itemsToValues(items...)...):0xc0006aa230 _, exists = trie.Lookup([]byte("foobar")):0xc0008264b0 _, i := parent.searchKey(t.config.Comparator, key.Value):0xc0000a47e0 _, ok := c.seenNodes[string(id)]:0xc0004a49e0 _, ok := ctrie.Lookup([]byte("11")):0xc00000f340 _, ok := ctrie.Lookup([]byte("foo")):0xc000913490 _, ok := set.items[item]:0xc0004a52a8 _, ok := snapshot.Lookup([]byte(strconv.Itoa(i))):0xc000a13ec0 _, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))):0xc000a13ee8 _, ok := xft.layers[xft.bits-1][key]:0xc0004a4eb8 _, ok = <-iter:0xc0000a5798 _, ok = ctrie.Lookup([]byte("bat")):0xc000a13ed8 _, ok = ctrie.Remove([]byte("foo")):0xc000913508 _, ok = hm[key]:0xc0004a46f0 _, ok = l.Get(2):0xc0008261e0 _, ok = snapshot2.Lookup([]byte("bat")):0xc000a13f00 _, pos := sl.GetWithPosition(e):0xc00028cbd8 _, rightKeys := n.keys.splitAt(i):0xc000225248 _, rightKeys := n.keys.splitAt(i, capacity):0xc000c241c0 _, rightKeys := n.keys.splitAt(i-1, capacity):0xc000a13de0 _, rightNodes := n.nodes.splitAt(i, capacity):0xc000a13de8 `The array should be a, b or b, a`):0xc000224540 a, err = ptree.actions.Get():0xc00039d050 a, err = tree.actions.Get():0xc000826ee0 a.complete():0xc0001be270 aa := &applyAction{:0xc0001bf3a8 aa := newApplyAction(func(cmp common.Comparator) bool {:0xc000225c80 aa.completer.Add(1):0xc0001bf3c8 aa.completer.Done():0xc0001bf2c0 aa.completer.Wait():0xc000225ca0 accessed, added := c.recordAccess("foo"), c.recordAdd("foo"):0xc000191c58 accessed, added = c.recordAccess("foo"), c.recordAdd("foo"):0xc000191c80 action := ifc.(action):0xc000827000 action := xns[index].(action):0xc0001bf718 action.addNode(int64(i), n):0xc000c24b28 action.addNode(j, n):0xc0001bf750 action.complete():0xc00039d090 action.keys()[i] = k:0xc000a136b0 action.keys()[i] = key:0xc000a13150 action.keys()[i] = nil:0xc000a13138 action.keys()[j] = k:0xc0006ab3f8 action.keys()[j] = nil:0xc0006ab3e8 added := uint64(0):0xc0006aaf60 adds := adds[n]:0xc0004a5ba0 adj := make([]interface{}, deg):0xc00028c640 adj[i] = key:0xc00028c658 adjacencyList:	make(map[interface{}]map[interface{}]struct{}),:0xc00028c9a8 adjustBalance(root, dir, int(bal)):0xc000c25468 adjustBalance(root, takeOpposite(dir), int(-bal)):0xc000225d28 affected := make(rangetree.Entries, 0, 100):0xc00028cef0 affected, deleted := rt.InsertAtDimension(0, 0, 1):0xc00000f800 affected, deleted := rt.InsertAtDimension(0, 4, 2):0xc0000a4018 affected, deleted := rt.InsertAtDimension(0, 6, -2):0xc000c254e0 affected, deleted := rt.InsertAtDimension(1, 0, 0):0xc000224390 affected, deleted := rt.InsertAtDimension(1, 4, 2):0xc00000fb98 affected, deleted := rt.InsertAtDimension(1, 6, -2):0xc000826290 affected, deleted := rt.InsertAtDimension(4, 0, 1):0xc000224378 affectedDimension := dimension == insertDimension:0xc0002245e0 allowDuplicates:	allowDuplicates,:0xc000225950 alreadyChecked = n:0xc0008273b8 anyset:		ba.anyset,:0xc00028cc10 anyset:	false,:0xc0004a4b50 args := m.Called():0xc00039cd28 args := m.Called(dimension, index, number):0xc0009a0410 args := m.Called(entries):0xc000c24718 args := m.Called(interval):0xc0009a0408 args := m.Called(items):0xc000c240d0 args := me.Called():0xc000224968 args := mi.Called():0xc00039cd50 array := make([]branch, len(c.array)):0xc00000f628 array := make([]branch, length+1):0xc0001bf5a8 array := make([]branch, length-1):0xc000826870 array[i+1] = c.array[i]:0xc0001bf5c8 array[i] = br:0xc000a13898 array[i] = c.array[i+1]:0xc000826898 array[i] = c.array[i]:0xc000826888 array[i] = t.copyToGen(gen, ctrie):0xc000a13890 array[pos] = br:0xc0001bf5b8 ary := uint64(16):0xc0008274c0 assert := assert.New(t):0xc0000a4f88 assert.Contains(seenKeys, "a", "Iterator did not return 'a'."):0xc00028d420 assert.Contains(t, fromTree, key):0xc000a13770 assert.Contains(t, result, iv1):0xc0008269e8 assert.Contains(t, result, r1):0xc0008278e0 assert.Contains(t, result, r2):0xc0008278e8 assert.Contains(t, result, r3):0xc0008278f0 assert.Contains(t, result, r4):0xc0006ab510 assert.Contains(v, "A"):0xc000c25240 assert.Contains(v, "B"):0xc000c25220 assert.Contains(v, "C"):0xc000c25228 assert.Contains(v, "D"):0xc000c25260 assert.Contains(v, "E"):0xc000c25288 assert.Contains(v, "F"):0xc000c25270 assert.Contains(v, "G"):0xc000c25278 assert.Contains(v, "H"):0xc000c25290 assert.Empty(t, itemsDisposed):0xc00028cc68 assert.Empty(t, nodes):0xc0002247a0 assert.Empty(t, result):0xc0000a5720 assert.Empty(t, w):0xc000826620 assert.Empty(tb, key.Payload):0xc000a13da8 assert.Equal("A", v[0]):0xc000c25210 assert.Equal("B", v[0]):0xc000c25200 assert.Equal("a", head):0xc0006aad08 assert.Equal("bar", val):0xc0009134a8 assert.Equal("baz", val):0xc0009134c8 assert.Equal("blah", val):0xc0009134e8 assert.Equal("man", val):0xc000a13ed0 assert.Equal("qux", val):0xc0009134f8 assert.Equal(-1, idx):0xc000a13c70 assert.Equal(0, sgraph.E()):0xc000225068 assert.Equal(0, sgraph.V()):0xc00039cf98 assert.Equal(1, found):0xc000225898 assert.Equal(1, head):0xc0006aaca8 assert.Equal(1, idx):0xc000a13c80 assert.Equal(1, item):0xc000826068 assert.Equal(1, len(v)):0xc000c251f8 assert.Equal(1, sgraph.E()):0xc000225070 assert.Equal(1, v):0xc0004a4f18 assert.Equal(2, head):0xc0006aacd0 assert.Equal(2, item):0xc0008261c8 assert.Equal(2, len(v)):0xc000c25218 assert.Equal(2, sgraph.E()):0xc000225078 assert.Equal(2, sgraph.V()):0xc00039cfa8 assert.Equal(2, v):0xc0004a4f58 assert.Equal(3, head):0xc000a137d8 assert.Equal(3, sgraph.E()):0xc000225080 assert.Equal(3, sgraph.V()):0xc00039cfb8 assert.Equal(Empty, tail):0xc0006aacb8 assert.Equal(ErrDisposed, b.Flush()):0xc000c241a8 assert.Equal(ErrDisposed, b.Put("j")):0xc000c241a0 assert.Equal(ErrDisposed, err):0xc000c24198 assert.Equal([]interface{}{"a", "b"}, batch1):0xc000c24048 assert.Equal([]interface{}{"a"}, batch):0xc00000f4e8 assert.Equal([]interface{}{"c"}, batch2):0xc000c24058 assert.Equal([]interface{}{1, 4, 9, 16}, l.Map(f)):0xc00028cb80 assert.Equal(exp, entry.Value):0xc0000a5758 assert.Equal(i, val):0xc00000f338 assert.Equal(len(expected), count):0xc0000a5760 assert.Equal(t,:0xc0002244e8 assert.Equal(t, "bar", item):0xc000826938 assert.Equal(t, "foo", item):0xc000826928 assert.Equal(t, -1, i):0xc000a13330 assert.Equal(t, 0, i):0xc000a13348 assert.Equal(t, 0, keySearch(keys, testKey)):0xc00028c3f8 assert.Equal(t, 0, keySearch(nil, testKey)):0xc00028c410 assert.Equal(t, 0, mutable.Len()):0xc0000a5728 assert.Equal(t, 0, n.keys[0].Compare(key)):0xc00000f400 assert.Equal(t, 0, result):0xc000826040 assert.Equal(t, 1, i):0xc000a13360 assert.Equal(t, 1, keySearch(keys, testKey)):0xc00028c3e8 assert.Equal(t, 1, mutable.Len()):0xc00028d280 assert.Equal(t, 1, q.Len()):0xc000826418 assert.Equal(t, 1, result):0xc0001be078 assert.Equal(t, 1, s.Search(2)):0xc0006aa2e8 assert.Equal(t, 1, s.Search(3)):0xc0006aa2d8 assert.Equal(t, 1000, c):0xc0001bf4e0 assert.Equal(t, 10000, c):0xc0001bf498 assert.Equal(t, 10000, d.Size()):0xc0001bf4f0 assert.Equal(t, 16, Bitmap32(x).PopCount()):0xc00028c458 assert.Equal(t, 2, keySearch(keys, testKey)):0xc00028c408 assert.Equal(t, 2, mutable.Len()):0xc00028d388 assert.Equal(t, 2, q.Len()):0xc000c242b0 assert.Equal(t, 2, result):0xc0001be048 assert.Equal(t, 3, keySearch(keys, testKey)):0xc00028c3d8 assert.Equal(t, 3, s.Search(7)):0xc0006aa610 assert.Equal(t, 3, val):0xc000826498 assert.Equal(t, 32, Bitmap64(x).PopCount()):0xc0004a5210 assert.Equal(t, 5, result):0xc00039d1e8 assert.Equal(t, Bitmap32(0), m.ClearBit(2)):0xc000c24758 assert.Equal(t, Bitmap32(0x4), m.SetBit(2)):0xc000c24748 assert.Equal(t, Bitmap64(0), m.ClearBit(2)):0xc0004a54e0 assert.Equal(t, Bitmap64(0x4), m.SetBit(2)):0xc000225060 assert.Equal(t, Entries{e1, e2, e3}, result):0xc000a13030 assert.Equal(t, Entries{e1, e2}, iter.exhaust()):0xc0006ab5f8 assert.Equal(t, Entries{e1, e2}, result):0xc000a13018 assert.Equal(t, Entries{e1, e3, e2}, entries):0xc000a13cc0 assert.Equal(t, Entries{e1, e3, e2}, iter.exhaust()):0xc0006ab620 assert.Equal(t, Entries{e1}, iter.exhaust()):0xc0006ab5f0 assert.Equal(t, Entries{e1}, result):0xc000a13000 assert.Equal(t, Entries{e2, e1}, es):0xc000c247b0 assert.Equal(t, Entries{e2, e1}, iter.exhaust()):0xc0000a5848 assert.Equal(t, Entries{e2, e3, e1}, es):0xc000c247c8 assert.Equal(t, Entries{e2}, entries):0xc000a13ce8 assert.Equal(t, Entries{e2}, es):0xc000a13160 assert.Equal(t, Entries{e2}, iter.exhaust()):0xc0004a58e8 assert.Equal(t, Entries{e2}, result):0xc000224860 assert.Equal(t, Entries{e3, e2}, entries):0xc000a13cd8 assert.Equal(t, Entries{e3}, result):0xc000225098 assert.Equal(t, Entries{entries[0], entries[1], entries[3]}, result):0xc000225cc0 assert.Equal(t, Entries{entries[0], entries[1]}, result):0xc000225cd0 assert.Equal(t, Entries{entries[0]}, result):0xc0000a5098 assert.Equal(t, Entries{entries[1], entries[2]}, result):0xc000a13648 assert.Equal(t, Entries{entries[2], nil}, deleted):0xc00028d4a8 assert.Equal(t, Entries{entries[3]}, result):0xc000a13630 assert.Equal(t, Entries{entry}, overwritten):0xc0000a5890 assert.Equal(t, Entries{entry}, result):0xc000a12dc8 assert.Equal(t, Entries{entry}, results):0xc0000a5880 assert.Equal(t, Entries{k}, deleted):0xc000224418 assert.Equal(t, Entries{m1, m2, m3, m4, m5}, i2.Get(m1, m2, m3, m4, m5)):0xc0000a5610 assert.Equal(t, Entries{m1, m2, m3, m4}, deleted):0xc00000faf8 assert.Equal(t, Entries{m1, m2, m3, m4}, i2.Get(m1, m2, m3, m4)):0xc00028d350 assert.Equal(t, Entries{m1, m2, m3}, i2.Get(m1, m2, m3)):0xc0006ab1b8 assert.Equal(t, Entries{m1, m2, m3}, i3.Get(m1, m2, m3)):0xc0004a5748 assert.Equal(t, Entries{m1, m2, nil}, i3.Get(m1, m2, m3)):0xc00000f8a0 assert.Equal(t, Entries{m1, m2}, i2.Get(m1, m2)):0xc0004a5720 assert.Equal(t, Entries{m1, nil, nil}, i4.Get(m1, m2, m3)):0xc00000f8c0 assert.Equal(t, Entries{m1}, deleted):0xc00000f8d0 assert.Equal(t, Entries{m2}, deleted):0xc00000f8b0 assert.Equal(t, Entries{m3}, deleted):0xc00000f890 assert.Equal(t, Entries{m3}, i2.Get(m3)):0xc000a13d48 assert.Equal(t, Entries{m3}, overwritten):0xc000a13d38 assert.Equal(t, Entries{m4, m5}, i3.Get(m4, m5)):0xc0006ab1f0 assert.Equal(t, Entries{m4}, i3.Get(m4)):0xc000a13d40 assert.Equal(t, Entries{n2.entry, n3.entry, n1.entry}, deleted):0xc0002258d0 assert.Equal(t, Entries{nil, m2, m3, m4, m5}, i3.Get(m1, m2, m3, m4, m5)):0xc0000a5618 assert.Equal(t, Entries{nil, m2, m3, m4}, i3.Get(m1, m2, m3, m4)):0xc00028d358 assert.Equal(t, Entries{nil, nil, nil, nil, nil}, overwritten):0xc0004a4bf8 assert.Equal(t, Entries{nil, nil, nil, nil}, i3.Get(m1, m2, m3, m4)):0xc00000fb08 assert.Equal(t, Entries{nil, nil, nil}, i1.Get(m1, m2, m3)):0xc0006ab1c0 assert.Equal(t, Entries{nil, nil, nil}, i5.Get(m1, m2, m3)):0xc00000f8e0 assert.Equal(t, Entries{nil, nil, nil}, overwritten):0xc0006ab1a8 assert.Equal(t, Entries{nil, nil}, i1.Get(m1, m2)):0xc0004a5718 assert.Equal(t, Entries{nil, nil}, i2.Get(m4, m5)):0xc0006ab1e8 assert.Equal(t, Entries{nil, nil}, overwritten):0xc0004a5700 assert.Equal(t, Entries{nil}, overwritten):0xc0004a5738 assert.Equal(t, Entries{nil}, result):0xc0002250b8 assert.Equal(t, Entries{oldEntry}, overwritten):0xc0004a4c20 assert.Equal(t, Entries{}, es):0xc000a13170 assert.Equal(t, Entries{}, iter.exhaust()):0xc0006ab5e0 assert.Equal(t, ErrTimeout, err):0xc0004a4568 assert.Equal(t, Int64Slice{-1, 0, 1, 3, 6}, s):0xc0004a4588 assert.Equal(t, Int64Slice{1, 2, 3, 6, 7}, s):0xc000a12ea0 assert.Equal(t, Int64Slice{1, 2, 3, 6}, s):0xc000a12e90 assert.Equal(t, Intervals{iv1, iv3}, result):0xc0004a42f0 assert.Equal(t, Intervals{iv2, iv1, iv3}, result):0xc0004a4298 assert.Equal(t, Intervals{iv2, iv3}, result):0xc0000a4090 assert.Equal(t, Intervals{iv2}, result):0xc0004a42d8 assert.Equal(t, Intervals{iv3}, result):0xc0004a4318 assert.Equal(t, Intervals{iv}, result):0xc000913270 assert.Equal(t, Keys{k1, k2, k3}, l.keys):0xc000a12fb0 assert.Equal(t, Keys{k1, k2}, l.keys):0xc000f04028 assert.Equal(t, Keys{k1, k2}, tree.Get(k1, k2)):0xc0004a4060 assert.Equal(t, Keys{k3}, r.keys):0xc000f04030 assert.Equal(t, Keys{k4}, r.keys):0xc000a12fb8 assert.Equal(t, Keys{keys[0]}, result):0xc000a13f38 assert.Equal(t, Keys{mockKey(15)}, r.keys):0xc000191e98 assert.Equal(t, Keys{mockKey(20)}, r.keys):0xc00028c710 assert.Equal(t, Keys{mockKey(5), mockKey(10)}, l.keys):0xc00028c708 assert.Equal(t, Keys{mockKey(5)}, l.keys):0xc000191e90 assert.Equal(t, Keys{nil, nil, nil, nil}, result):0xc0006ab378 assert.Equal(t, Keys{nil, nil, nil}, result):0xc00028ca68 assert.Equal(t, Keys{nil, nil}, result):0xc0004a4050 assert.Equal(t, Keys{nil}, result):0xc000826de0 assert.Equal(t, Keys{nil}, tree.Get(newMockKey(20))):0xc0006ab448 assert.Equal(t, Keys{nil}, tree.Get(newMockKey(3))):0xc0001bfd50 assert.Equal(t, NumberSequence2Deleted3ElemSorted[i], min.Priority):0xc0006aa770 assert.Equal(t, NumberSequence2Sorted[i], min.Priority):0xc0006ab088 assert.Equal(t, NumberSequenceMerged3And4Sorted[i], min.Priority):0xc0004a58b8 assert.Equal(t, OutOfRangeError(1500), err):0xc0001bf658 assert.Equal(t, OutOfRangeError(1501), err):0xc0001bf668 assert.Equal(t, Seq1FifthMinimum, min.Priority):0xc000a12f10 assert.Equal(t, Seq1FirstMinimum, min.Priority):0xc000a12b80 assert.Equal(t, Seq1LastMinimum, min.Priority):0xc000a12f20 assert.Equal(t, Seq1ThirdMinimum, min.Priority):0xc000a12c90 assert.Equal(t, []interface{}{`a`, `b`, `c`}, restItems):0xc000826540 assert.Equal(t, []interface{}{`a`, `b`}, takeItems):0xc000826510 assert.Equal(t, []interface{}{`c`}, restItems):0xc000826518 assert.Equal(t, []interface{}{}, takeItems):0xc000826538 assert.Equal(t, []uint64{1, 30, 2680}, nums):0xc000826eb8 assert.Equal(t, []uint64{155, 500, 1200, 1500}, nums):0xc0008268e8 assert.Equal(t, []uint64{155}, nums):0xc000826f90 assert.Equal(t, []uint64{1}, nums):0xc0004a47f0 assert.Equal(t, []uint64{3, 280, 1000}, nums):0xc0004a5470 assert.Equal(t, `1`, result):0xc000225840 assert.Equal(t, `1`, result[0]):0xc000c24a90 assert.Equal(t, `2`, result):0xc000225850 assert.Equal(t, `2`, result[0]):0xc000c24aa0 assert.Equal(t, `a`, result[0]):0xc000c252b8 assert.Equal(t, `test2`, result):0xc00000f138 assert.Equal(t, `test`, result):0xc0004a50e0 assert.Equal(t, `test`, result[0]):0xc000c24a68 assert.Equal(t, ba.anyset, result.anyset):0xc0004a5cb8 assert.Equal(t, ba.blocks, result.blocks):0xc0004a5cd0 assert.Equal(t, ba.highest, result.highest):0xc0004a5cc8 assert.Equal(t, ba.lowest, result.lowest):0xc0004a5cc0 assert.Equal(t, c, result[i]):0xc0004a5e70 assert.Equal(t, common.Comparators{duplicate}, tree.Get(duplicate)):0xc00028c038 assert.Equal(t, common.Comparators{m1, m2, nil}, left.Get(m1, m2, m3)):0xc000827210 assert.Equal(t, common.Comparators{m1, m2}, deleted):0xc0006aa008 assert.Equal(t, common.Comparators{m1, m2}, iter.exhaust()):0xc0004a4160 assert.Equal(t, common.Comparators{m1, m2}, result):0xc00000faa8 assert.Equal(t, common.Comparators{m1, m2}, sl.Get(m1, m2)):0xc00000fb80 assert.Equal(t, common.Comparators{m1}, deleted):0xc00028d468 assert.Equal(t, common.Comparators{m1}, overwritten):0xc000c255c8 assert.Equal(t, common.Comparators{m1}, result):0xc000225d58 assert.Equal(t, common.Comparators{m1}, sl.Get(m1)):0xc0004a5e30 assert.Equal(t, common.Comparators{m1}, tree.Get(m1)):0xc000913220 assert.Equal(t, common.Comparators{m2}, iter.exhaust()):0xc0004a4178 assert.Equal(t, common.Comparators{m2}, result):0xc00000fac8 assert.Equal(t, common.Comparators{m2}, sl.Get(m2)):0xc000a13ff8 assert.Equal(t, common.Comparators{nil, nil, m3}, right.Get(m1, m2, m3)):0xc000827218 assert.Equal(t, common.Comparators{nil, nil}, overwritten):0xc00000fb78 assert.Equal(t, common.Comparators{nil, nil}, sl.Get(m1, m2)):0xc0006aa010 assert.Equal(t, common.Comparators{nil, nil}, tree.Get(m1, m2)):0xc000a133c0 assert.Equal(t, common.Comparators{nil}, deleted):0xc00028d488 assert.Equal(t, common.Comparators{nil}, overwritten):0xc0004a5e40 assert.Equal(t, common.Comparators{nil}, sl.Get(m1)):0xc00028d478 assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(1))):0xc000a13fe8 assert.Equal(t, common.Comparators{nil}, sl.Get(mockEntry(7))):0xc0000a42e0 assert.Equal(t, common.Comparators{nil}, tree.Get(k)):0xc0006ab2e0 assert.Equal(t, common.Comparators{nil}, tree.Get(m1)):0xc0004a5530 assert.Equal(t, common.Comparators{}, iter.exhaust()):0xc0004a41a0 assert.Equal(t, comparators, result):0xc000a12ee0 assert.Equal(t, comparators[1:6], w):0xc0009131b0 assert.Equal(t, comparators[2:5], w):0xc00039cf10 assert.Equal(t, comparators[5:], v2):0xc00039cf18 assert.Equal(t, comparators[6:], v2):0xc0009131b8 assert.Equal(t, comparators[7:], v2):0xc00000f180 assert.Equal(t, comparators[:1], v1):0xc0009131a8 assert.Equal(t, comparators[:2], v1):0xc00039cf08 assert.Equal(t, comparators[:7], w):0xc00000f178 assert.Equal(t, count, xft.Len()):0xc00000f2c0 assert.Equal(t, dba, result):0xc000a13d18 assert.Equal(t, e, sl.ByPosition(pos)):0xc00028cbe0 assert.Equal(t, e, sl.ByPosition(uint64(i))):0xc00028cdb0 assert.Equal(t, e1, iter.Value()):0xc000191bb8 assert.Equal(t, e1, predecessor):0xc000a135c0 assert.Equal(t, e1, result):0xc0004a5050 assert.Equal(t, e1, successor):0xc000a13368 assert.Equal(t, e1, xft.Get(5)):0xc00000e0e0 assert.Equal(t, e1, xft.Max()):0xc00000e060 assert.Equal(t, e1, xft.Min()):0xc00000e058 assert.Equal(t, e2, iter.Value()):0xc000191bf0 assert.Equal(t, e2, predecessor):0xc000a135b0 assert.Equal(t, e2, result):0xc0004a5060 assert.Equal(t, e2, successor):0xc000a13350 assert.Equal(t, e2, xft.Max()):0xc00000e090 assert.Equal(t, e2, xft.Min()):0xc0000a5838 assert.Equal(t, e2, xft.Successor(15)):0xc000a13c88 assert.Equal(t, e2, yfast.Get(3)):0xc000224fb8 assert.Equal(t, e3, result):0xc0004a5070 assert.Equal(t, e3, successor):0xc000225210 assert.Equal(t, entries, deleted):0xc00028d440 assert.Equal(t, entries, result):0xc000a13218 assert.Equal(t, entries[1:2], deleted):0xc0000a4208 assert.Equal(t, entries[1:], deleted):0xc000c25658 assert.Equal(t, entries[1:], modified):0xc000c25588 assert.Equal(t, entries[1:], result):0xc000c25598 assert.Equal(t, entries[2:], modified):0xc0000a4210 assert.Equal(t, entries[2:], result):0xc0008264e0 assert.Equal(t, entries[:1], result):0xc0000a4048 assert.Equal(t, err, e.Get()):0xc0009a06c0 assert.Equal(t, err, nil):0xc00000efa0 assert.Equal(t, expected, it.root):0xc000c248f8 assert.Equal(t, expected, itemsDisposed):0xc00028cc88 assert.Equal(t, expected, outBytes[:10]):0xc00000efc0 assert.Equal(t, expected, result):0xc00039ce00 assert.Equal(t, expected, results):0xc0002245a0 assert.Equal(t, expected, u):0xc00000f4d0 assert.Equal(t, expectedRoot, it.root):0xc0004a4638 assert.Equal(t, float64(0), result[0]):0xc0000a55c8 assert.Equal(t, float64(3), result[1]):0xc0000a55d0 assert.Equal(t, i, value):0xc000c24b00 assert.Equal(t, i, x.Value()):0xc00000f2e8 assert.Equal(t, int32(0), x):0xc0006ab0a8 assert.Equal(t, int32(0), y):0xc0006ab0b0 assert.Equal(t, int32(1), x):0xc0006ab0d0 assert.Equal(t, int32(1), y):0xc0006ab0e8 assert.Equal(t, int64(0), h):0xc0006ab0a0 assert.Equal(t, int64(0), q.Len()):0xc000c24a70 assert.Equal(t, int64(1), h):0xc0006ab0f8 assert.Equal(t, int64(1), q.Len()):0xc00000f100 assert.Equal(t, int64(2), h):0xc0006ab0e0 assert.Equal(t, int64(3), h):0xc0006ab0c8 assert.Equal(t, items, result):0xc00028ce78 assert.Equal(t, items[10:], result):0xc0000a41a8 assert.Equal(t, items[3:], result):0xc00028d380 assert.Equal(t, items[5:], result):0xc0000a4310 assert.Equal(t, items[:25], result):0xc0000a4450 assert.Equal(t, items[:i], result):0xc000826570 assert.Equal(t, items[i+1:], result):0xc0006aa318 assert.Equal(t, items{item2}, result):0xc00028d290 assert.Equal(t, k1, n.keys[0]):0xc000c24da8 assert.Equal(t, k2, key):0xc000f04020 assert.Equal(t, k2, n.keys[1]):0xc000c24db0 assert.Equal(t, k3, key):0xc000a12fa8 assert.Equal(t, keys, result):0xc000191d48 assert.Equal(t, keys2, tree.Get(keys2...)):0xc00000eb70 assert.Equal(t, keys[1], key):0xc0006ab4a0 assert.Equal(t, keys[2:], result):0xc0004a5788 assert.Equal(t, keys[2], key):0xc000a13a80 assert.Equal(t, keys[4:], result):0xc000913550 assert.Equal(t, keys[i], tree.Get(keys[i]...)):0xc0004a5c98 assert.Equal(t, l.right, r):0xc000191eb0 assert.Equal(t, le, left.ByPosition(index)):0xc000225330 assert.Equal(t, le, result):0xc000225328 assert.Equal(t, left.(*lnode).keys, keys[:1]):0xc0006ab4a8 assert.Equal(t, left.(*lnode).keys, keys[:2]):0xc000a13a88 assert.Equal(t, left.(*lnode).pointer, right):0xc000a13a98 assert.Equal(t, len(expected), len(result)):0xc0004a5e68 assert.Equal(t, len(mutated), len(result)):0xc0006aa1a8 assert.Equal(t, len(mutated), rtMutated.Len()):0xc0000a45b0 assert.Equal(t, len(oc), mutable.Len()):0xc0006aa1f0 assert.Equal(t, len(oc), rt.Len()):0xc0006aa190 assert.Equal(t, len(ordered[i+1:]), len(result)):0xc000c24110 assert.Equal(t, len(outBytes), 178):0xc000191ca0 assert.Equal(t, len(outBytes), 337):0xc00000efa8 assert.Equal(t, len(outputBytes), 178):0xc000826638 assert.Equal(t, len(outputBytes), 337):0xc000a13320 assert.Equal(t, m1, e):0xc0002242d8 assert.Equal(t, m1, left.ByPosition(0)):0xc000827220 assert.Equal(t, m1, sl.ByPosition(0)):0xc000c24b78 assert.Equal(t, m1, sl.ByPosition(2)):0xc000c24958 assert.Equal(t, m2, e):0xc0002242f0 assert.Equal(t, m2, left.ByPosition(1)):0xc000827228 assert.Equal(t, m2, sl.ByPosition(0)):0xc00000f7c8 assert.Equal(t, m2, sl.ByPosition(1)):0xc000c24950 assert.Equal(t, m3, right.ByPosition(0)):0xc000827230 assert.Equal(t, m3, sl.ByPosition(0)):0xc000c24948 assert.Equal(t, mockItem(1), q.Peek()):0xc0006ab6c0 assert.Equal(t, mockItem(1), q.items[0]):0xc0004a52e8 assert.Equal(t, mockItem(1), result[0]):0xc000913818 assert.Equal(t, mockItem(2), q.items[0]):0xc0004a52d0 assert.Equal(t, mockItem(2), q.items[1]):0xc0004a52f0 assert.Equal(t, mockItem(2), result[0]):0xc000913808 assert.Equal(t, mockKey(10), key):0xc000191e88 assert.Equal(t, mockKey(15), key):0xc00028c700 assert.Equal(t, n, predecessor.children[1]):0xc0000a5420 assert.Equal(t, n, successor.children[0]):0xc0000a5158 assert.Equal(t, n.keys[0], key):0xc00000f3f8 assert.Equal(t, n1, deleted):0xc0002247a8 assert.Equal(t, n2, deleted):0xc000224768 assert.Equal(t, newHeap, FloatingFibonacciHeap{}):0xc0001bfe38 assert.Equal(t, newMockKey(i), key):0xc00000f5a8 assert.Equal(t, newMockKey(i+4), key):0xc000a12550 assert.Equal(t, nil, left.ByPosition(2)):0xc000827238 assert.Equal(t, nil, right.ByPosition(1)):0xc000827240 assert.Equal(t, nodes[2:], right.(*inode).nodes):0xc00028cbc8 assert.Equal(t, nodes[3:], right.(*inode).nodes):0xc000225b88 assert.Equal(t, nodes[3].(*lnode).keys[0], key):0xc00028cba8 assert.Equal(t, nodes[4].(*lnode).keys[0], key):0xc000225b70 assert.Equal(t, nodes[:2], left.(*inode).nodes):0xc00028cbc0 assert.Equal(t, nodes[:3], left.(*inode).nodes):0xc000225b80 assert.Equal(t, nodes{n1, n2, n3}, l.nodes):0xc00028c718 assert.Equal(t, nodes{n1, n2}, l.nodes):0xc000191ea0 assert.Equal(t, nodes{n1}, results):0xc0008277a8 assert.Equal(t, nodes{n2, n1}, results):0xc0008277b8 assert.Equal(t, nodes{n2}, results):0xc000827778 assert.Equal(t, nodes{n3, n4}, r.nodes):0xc000191ea8 assert.Equal(t, nodes{n4, n5}, r.nodes):0xc00028c720 assert.Equal(t, numItems, tree.Len()):0xc00000f760 assert.Equal(t, number, mutable.Len()):0xc00028ce18 assert.Equal(t, oc.toItems(), result):0xc0000a45c0 assert.Equal(t, oldLength, tree.Len()):0xc000a13f40 assert.Equal(t, ordered.toItems(), result):0xc0004a4288 assert.Equal(t, orderedNodes{n1}, nodes):0xc000224760 assert.Equal(t, orderedNodes{n2, n1}, nodes):0xc0008266a0 assert.Equal(t, orderedNodes{n2, n3}, nodes):0xc0008266c0 assert.Equal(t, other, result):0xc000a13b60 assert.Equal(t, output, nil):0xc000827160 assert.Equal(t, outputBytes[0], byte('B')):0xc000826568 assert.Equal(t, outputBytes[0], byte('S')):0xc000a13318 assert.Equal(t, pattern[i], whichSide(n, n.parent)):0xc000a13588 assert.Equal(t, peekExpected, peekResult):0xc00028d2d0 assert.Equal(t, peekResult, popResult[0]):0xc00028d2e0 assert.Equal(t, predecessor, n.parent.children[0]):0xc0000a5448 assert.Equal(t, q.Len(), int64(2)):0xc00028d2e8 assert.Equal(t, q.Len(), int64(3)):0xc00028d2c8 assert.Equal(t, r, l.right):0xc000f04048 assert.Equal(t, rangetree.Entries{m1, m2, m3}, affected):0xc00000f808 assert.Equal(t, rangetree.Entries{m1, m2, m3}, rt.Get(e1, e2, e3)):0xc00000f838 assert.Equal(t, rangetree.Entries{m1, m2}, result):0xc0008260f8 assert.Equal(t, rangetree.Entries{m1, m2}, rt.Get(m1, m2)):0xc000191f70 assert.Equal(t, rangetree.Entries{m1, nil, m2}, deleted):0xc00039c248 assert.Equal(t, rangetree.Entries{m1, nil, nil}, rt.Get(m1, m2, m3)):0xc00000fbb8 assert.Equal(t, rangetree.Entries{m1, nil}, rt.Get(m1, m2)):0xc000c254f8 assert.Equal(t, rangetree.Entries{m1}, overwritten):0xc0002250e0 assert.Equal(t, rangetree.Entries{m1}, result):0xc000c242a0 assert.Equal(t, rangetree.Entries{m1}, rt.Get(m1)):0xc000224388 assert.Equal(t, rangetree.Entries{m2, m3}, affected):0xc00000fba0 assert.Equal(t, rangetree.Entries{m2, m3}, result):0xc000826108 assert.Equal(t, rangetree.Entries{m2, m3}, rt.Get(e2, e3)):0xc00000fbc0 assert.Equal(t, rangetree.Entries{m2}, deleted):0xc000c254f0 assert.Equal(t, rangetree.Entries{m2}, rt.Get(m2)):0xc0002250e8 assert.Equal(t, rangetree.Entries{m3}, affected):0xc000c254e8 assert.Equal(t, rangetree.Entries{m3}, result):0xc000826118 assert.Equal(t, rangetree.Entries{nil, m3}, rt.Get(e2, e3)):0xc000c25510 assert.Equal(t, rangetree.Entries{nil, nil, nil}, rt.Get(m1, m2, m3)):0xc00000f820 assert.Equal(t, rangetree.Entries{nil, nil}, overwritten):0xc000191f60 assert.Equal(t, rangetree.Entries{nil, nil}, rt.Get(m1, m2)):0xc00039c280 assert.Equal(t, rangetree.Entries{nil}, overwritten):0xc0002250c8 assert.Equal(t, re, result):0xc000225350 assert.Equal(t, re, right.ByPosition(index)):0xc000225358 assert.Equal(t, right.(*lnode).keys, keys[1:]):0xc0006ab4b0 assert.Equal(t, right.(*lnode).keys, keys[2:]):0xc000a13a90 assert.Equal(t, rtree.Rectangles{r1, r2}, result):0xc0001bff60 assert.Equal(t, rtree.Rectangles{r1}, result):0xc000a133f0 assert.Equal(t, rtree.Rectangles{r2}, result):0xc0001bff80 assert.Equal(t, rtree.Rectangles{}, result):0xc0004a4ab0 assert.Equal(t, s-1, ba.highest):0xc00028cf78 assert.Equal(t, s1, w.get()):0xc000826630 assert.Equal(t, s2, w.get()):0xc000826640 assert.Equal(t, s3, w.get()):0xc000826648 assert.Equal(t, s4, w.get()):0xc000826758 assert.Equal(t, sba, result):0xc000a13b58 assert.Equal(t, sl, left):0xc000a13c20 assert.Equal(t, successor, n.parent.children[1]):0xc0000a5190 assert.Equal(t, testCase.expectedItems, testCase.cache.Get(keys...)):0xc0004a5ac0 assert.Equal(t, testCase.expectedSize, testCase.cache.Size()):0xc0004a5ab8 assert.Equal(t, tree, tree1):0xc0002243b0 assert.Equal(t, tree3, tree7):0xc000c243a0 assert.Equal(t, true, m.GetBit(2)):0xc000191e08 assert.Equal(t, u1, u):0xc0004a5770 assert.Equal(t, uint(10), ctrie.Size()):0xc000c25608 assert.Equal(t, uint64(0), ba.highest):0xc0004a48c8 assert.Equal(t, uint64(0), ba.lowest):0xc0004a48c0 assert.Equal(t, uint64(0), c.size):0xc00028c488 assert.Equal(t, uint64(0), hm.Len()):0xc0001bf3f8 assert.Equal(t, uint64(0), i1.Len()):0xc0004a5710 assert.Equal(t, uint64(0), i3.Len()):0xc00000fb00 assert.Equal(t, uint64(0), i5.Len()):0xc00000f8d8 assert.Equal(t, uint64(0), it.Len()):0xc0000a57d8 assert.Equal(t, uint64(0), max):0xc000827118 assert.Equal(t, uint64(0), n.nodes.len()):0xc000826c78 assert.Equal(t, uint64(0), pos):0xc0002242e0 assert.Equal(t, uint64(0), rb.Len()):0xc000225820 assert.Equal(t, uint64(0), rt.Len()):0xc00039c260 assert.Equal(t, uint64(0), sl.Len()):0xc00028d470 assert.Equal(t, uint64(0), tree.Len()):0xc0004a5528 assert.Equal(t, uint64(0), tree3.Len()):0xc000c243d8 assert.Equal(t, uint64(0), tree6.Len()):0xc000c24390 assert.Equal(t, uint64(0), value):0xc0000a51e0 assert.Equal(t, uint64(0), xft.Len()):0xc000c25618 assert.Equal(t, uint64(0), yfast.Len()):0xc0002250a8 assert.Equal(t, uint64(1), hm.Len()):0xc0001bf3e0 assert.Equal(t, uint64(1), i4.Len()):0xc00000f8b8 assert.Equal(t, uint64(1), it.Len()):0xc000c24900 assert.Equal(t, uint64(1), max):0xc000827128 assert.Equal(t, uint64(1), pos):0xc0002242f8 assert.Equal(t, uint64(1), rb.Len()):0xc000225848 assert.Equal(t, uint64(1), right.Len()):0xc000827208 assert.Equal(t, uint64(1), rt.Len()):0xc0002250d0 assert.Equal(t, uint64(1), sl.Len()):0xc0004a5e38 assert.Equal(t, uint64(1), tree.Len()):0xc0000a4f80 assert.Equal(t, uint64(1), tree1.Len()):0xc000a13008 assert.Equal(t, uint64(1), tree2.Len()):0xc000c243c8 assert.Equal(t, uint64(1), tree5.Len()):0xc000c24378 assert.Equal(t, uint64(1), yfast.Len()):0xc000224fc0 assert.Equal(t, uint64(10), it.Len()):0xc000a13690 assert.Equal(t, uint64(10), numCalls):0xc000224650 assert.Equal(t, uint64(10), tree.Len()):0xc00000e130 assert.Equal(t, uint64(10), value):0xc000224aa8 assert.Equal(t, uint64(100), tree.Len()):0xc0006ab2c8 assert.Equal(t, uint64(16), hm.Cap()):0xc0006aad78 assert.Equal(t, uint64(1<<31), result):0xc00028c3b0 assert.Equal(t, uint64(1<<63), result):0xc00028c3c0 assert.Equal(t, uint64(2), i2.Len()):0xc0004a5708 assert.Equal(t, uint64(2), i3.Len()):0xc00000f898 assert.Equal(t, uint64(2), it.Len()):0xc0004a4660 assert.Equal(t, uint64(2), left.Len()):0xc000827200 assert.Equal(t, uint64(2), rt.Len()):0xc000191f68 assert.Equal(t, uint64(2), sl.Len()):0xc0000a42e8 assert.Equal(t, uint64(2), tree.Len()):0xc0004a4058 assert.Equal(t, uint64(2), tree1.Len()):0xc0000a4228 assert.Equal(t, uint64(2), tree2.Len()):0xc000a13020 assert.Equal(t, uint64(2), tree4.Len()):0xc000c24360 assert.Equal(t, uint64(2), xft.Len()):0xc00000e088 assert.Equal(t, uint64(2), yfast.Len()):0xc000224850 assert.Equal(t, uint64(3), ba.lowest):0xc0001bffa0 assert.Equal(t, uint64(3), i2.Len()):0xc0006ab1b0 assert.Equal(t, uint64(3), i3.Len()):0xc0004a5740 assert.Equal(t, uint64(3), it.Len()):0xc000c24d58 assert.Equal(t, uint64(3), rb.Len()):0xc0004a46c0 assert.Equal(t, uint64(3), rt.Len()):0xc00000f818 assert.Equal(t, uint64(3), tree.Len()):0xc000c24cd8 assert.Equal(t, uint64(3), tree1.Len()):0xc000a13220 assert.Equal(t, uint64(3), tree3.Len()):0xc000a13038 assert.Equal(t, uint64(3), xft.Len()):0xc000a13ca8 assert.Equal(t, uint64(3), yfast.Len()):0xc0004a5088 assert.Equal(t, uint64(314159), c.cap):0xc00028c480 assert.Equal(t, uint64(32), result):0xc00028c3a0 assert.Equal(t, uint64(4), i2.Len()):0xc00028d348 assert.Equal(t, uint64(4), i3.Len()):0xc0000a5608 assert.Equal(t, uint64(4), it.Len()):0xc0004a4230 assert.Equal(t, uint64(4), rb.Len()):0xc0004a46b8 assert.Equal(t, uint64(4), tree.Len()):0xc000a13620 assert.Equal(t, uint64(42), value):0xc0006ab278 assert.Equal(t, uint64(49), right.Len()):0xc0002257a0 assert.Equal(t, uint64(5), ba.highest):0xc0004a48e0 assert.Equal(t, uint64(5), ba.lowest):0xc0004a48d8 assert.Equal(t, uint64(5), i2.Len()):0xc0000a55f8 assert.Equal(t, uint64(5), i3.Len()):0xc0006ab1e0 assert.Equal(t, uint64(5), it.Len()):0xc000826158 assert.Equal(t, uint64(5), max):0xc000827130 assert.Equal(t, uint64(5), tree.Len()):0xc000c25128 assert.Equal(t, uint64(5), value):0xc0006aad68 assert.Equal(t, uint64(50), left.Len()):0xc000225310 assert.Equal(t, uint64(50), right.Len()):0xc000225338 assert.Equal(t, uint64(6), value):0xc00000e0d0 assert.Equal(t, uint64(7), ba.highest):0xc0001bffb0 assert.Equal(t, uint64(8), ba.highest):0xc0004a48f0 assert.Equal(t, uint64(8), rb.Cap()):0xc00039d1c8 assert.Equal(t, uint64(9), it.Len()):0xc000826338 assert.Equal(t, uint64(9), tree.Len()):0xc000225d88 assert.Equal(t, uint64(len(keys1)), tree.Len()):0xc00000eb58 assert.Equal(t, uint64(len(keys2)), tree.Len()):0xc00000eb68 assert.Equal(t, uint64(len(points)), tree.Len()):0xc0004a5908 assert.Equal(t, uint64(math.MaxUint64), masks[63]):0xc00000f5b8 assert.Equal(t, uint64(numItems), it.Len()):0xc0004a4bc0 assert.Equal(t, uint64(s-1), ba.highest):0xc0001bffc8 assert.Equal(t, w1, w):0xc0004a5778 assert.Equal(t, waiters{s1, s2, s3, s4}, w):0xc0008265e0 assert.Equal(t, waiters{s1, s2, s3}, w):0xc000826628 assert.Equal(t, waiters{s1, s3, s4}, w):0xc0008265f0 assert.Equal(t, waiters{s1}, w):0xc0008265c0 assert.Equal(t, waiters{s3, s4}, w):0xc000826600 assert.Equal(t, waiters{s3}, w):0xc000826610 assert.Equal(t, x, resultx):0xc00028cac0 assert.Equal(t, y, resulty):0xc00028cac8 assert.Equal(tb, cpValues, n.ChildValues):0xc000a13d70 assert.Equal(tb, n.lenValues(), n.lenKeys()):0xc000a13d98 assert.Equal(uint(0), Empty.Length()):0xc0006ab630 assert.Equal(uint(0), ctrie.Size()):0xc0004a41f8 assert.Equal(uint(1), l.Length()):0xc0006ab640 assert.Equal(uint(10), ctrie.Size()):0xc0004a41e8 assert.Equal(uint(10), snapshot.Size()):0xc0004a4210 assert.Equal(uint(10000), ctrie.Size()):0xc00000e2e0 assert.Equal(uint(3), l.Length()):0xc0006ab650 assert.EqualError(t, err, "Cannot decrease key in an empty heap"):0xc0001bf228 assert.EqualError(t, err, "Cannot decrease key: given node is nil"):0xc000c24ca0 assert.EqualError(t, err, "Cannot delete element from an empty heap"):0xc000a136c0 assert.EqualError(t, err, "Cannot delete node: given node is nil"):0xc0002253c8 assert.EqualError(t, err, "Cannot dequeue minimum of empty heap"):0xc00000f358 assert.EqualError(t, err, "One of the heaps to merge is nil. Cannot merge"):0xc0001bfe30 assert.EqualError(t, err, "The given new priority: 20, is larger than or equal to the old: 1"):0xc0001bf240 assert.EqualError(t, err, "Trying to get minimum element of empty heap"):0xc0000a5578 assert.Error(err):0xc0004a4f08 assert.Error(t, err):0xc000191b80 assert.Fail(t, `Expected non-nil entry`):0xc00000f368 assert.Fail(t, `traverse should not be called for empty tree`):0xc0000a4258 assert.False(b.IsDisposed()):0xc0002245a8 assert.False(l1.IsEmpty()):0xc0006aac90 assert.False(ok):0xc0000a4fa0 assert.False(t, ba.Equals(cba)):0xc000225c18 assert.False(t, ba.Equals(other)):0xc0001bfc80 assert.False(t, ba.Intersects(cba)):0xc000c24008 assert.False(t, ba.Intersects(other)):0xc0006ab398 assert.False(t, ba.IsEmpty()):0xc00028c4d0 assert.False(t, ba.anyset):0xc0000a5298 assert.False(t, cba.Equals(ba)):0xc000827900 assert.False(t, cba.Intersects(ba)):0xc00000f6e0 assert.False(t, exists):0xc0008264b8 assert.False(t, f.HasResult()):0xc00000f290 assert.False(t, hm.Exists(5)):0xc0001bf3e8 assert.False(t, hm.Exists(6)):0xc0001bf400 assert.False(t, hm.Exists(i)):0xc0006ab218 assert.False(t, iter.Next()):0xc000191bc0 assert.False(t, l.isLeaf):0xc000191eb8 assert.False(t, n.insert(tree, k1)):0xc0009136a0 assert.False(t, n.insert(tree, k2)):0xc000913698 assert.False(t, ok):0xc0000a51d8 assert.False(t, ok, "Bitarray at position %d should be unset", position):0xc0000a4ff8 assert.False(t, q.Empty()):0xc0004a5968 assert.False(t, r.isLeaf):0xc000191ec0 assert.False(t, result):0xc0001bf200 assert.False(t, s.Exists(4)):0xc000191a98 assert.InDelta(200, time.Since(before).Seconds()*1000, 100):0xc0001be660 assert.InDelta(t, 5, time.Since(before).Seconds()*1000, 10):0xc0004a4550 assert.IsType(t, &inode{}, tree.root):0xc0004a4fb8 assert.IsType(t, EmptyHeapError(""), err):0xc00000f350 assert.IsType(t, ErrDisposed, err):0xc000827910 assert.IsType(t, ErrTimeout, err):0xc000225ba8 assert.IsType(t, NilError(""), err):0xc000c24c98 assert.Len(b, result, numItems):0xc0004a4270 assert.Len(batch, 100):0xc00028c838 assert.Len(seenKeys, 1):0xc00028d428 assert.Len(t, affected, 0):0xc000224380 assert.Len(t, ba.blocks, 0):0xc000826098 assert.Len(t, ba.indices, 0):0xc0008260a0 assert.Len(t, deleted, 0):0xc00000f810 assert.Len(t, entries, 0):0xc0008267a8 assert.Len(t, hm, 0):0xc000c25628 assert.Len(t, intervals, 0):0xc000a12ec0 assert.Len(t, left.(*inode).keys, 1):0xc00028cbb0 assert.Len(t, left.(*inode).keys, 2):0xc000225b78 assert.Len(t, modified, 0):0xc0002243a8 assert.Len(t, n.keys, 1):0xc00000f3e8 assert.Len(t, n.nodes, 0):0xc0004a5488 assert.Len(t, ns, 0):0xc0002258c8 assert.Len(t, q.items, 0):0xc000913810 assert.Len(t, q.items, 1):0xc0004a52c8 assert.Len(t, q.waiters, 0):0xc0001bfab0 assert.Len(t, result, 0):0xc000a12db8 assert.Len(t, result, 1):0xc000c24a60 assert.Len(t, result, 10):0xc00000f598 assert.Len(t, result, 100):0xc000224360 assert.Len(t, result, 2):0xc0000a4470 assert.Len(t, result, 4):0xc00000f9e8 assert.Len(t, result, 5):0xc000c25120 assert.Len(t, result, 6):0xc000a12548 assert.Len(t, result, 9):0xc000225d80 assert.Len(t, result, int(numItems)):0xc00000f768 assert.Len(t, result, len(keys)):0xc0002259b0 assert.Len(t, results, 0):0xc000827790 assert.Len(t, right.(*inode).keys, 1):0xc00028cbb8 assert.Len(t, tree.root.(*inode).keys, 1):0xc00039cc00 assert.Len(t, tree.root.(*inode).keys, 2):0xc0004a4148 assert.Len(t, tree.root.(*inode).nodes, 2):0xc00039cc08 assert.Len(t, tree.root.(*inode).nodes, 3):0xc0004a4fb0 assert.Len(t, v1, 0):0xc00000f170 assert.Len(t, w, 0):0xc0008265b0 assert.Nil(Empty.Map(f)):0xc00028cb70 assert.Nil(b, err):0xc000a13fa0 assert.Nil(b.Put("foo bar baz")):0xc00028c828 assert.Nil(err):0xc0006aacf0 assert.Nil(found):0xc000225878 assert.Nil(head):0xc0000a4f98 assert.Nil(l):0xc000826200 assert.Nil(l1):0xc000a137c0 assert.Nil(t, accessed):0xc000191c88 assert.Nil(t, added):0xc000191c68 assert.Nil(t, deleted):0xc000224790 assert.Nil(t, e.Get()):0xc0009a06a8 assert.Nil(t, err):0xc0001bf1f8 assert.Nil(t, itemsDisposed):0xc00028cc90 assert.Nil(t, iter.Value()):0xc000191bc8 assert.Nil(t, key):0xc0002242c0 assert.Nil(t, left):0xc0002242c8 assert.Nil(t, min):0xc0000a5580 assert.Nil(t, mutable.(*Tr).Root):0xc000c24148 assert.Nil(t, n.children[0]):0xc0000a4070 assert.Nil(t, n.children[1]):0xc000826778 assert.Nil(t, n.pointer):0xc00000f3f0 assert.Nil(t, overwritten):0xc000826690 assert.Nil(t, predecessor):0xc000a13598 assert.Nil(t, result):0xc0004a5080 assert.Nil(t, right):0xc000a13c28 assert.Nil(t, sl.ByPosition(0)):0xc00000f7e0 assert.Nil(t, sl.ByPosition(1)):0xc00000f7d0 assert.Nil(t, sl.ByPosition(2)):0xc000c24b80 assert.Nil(t, sl.ByPosition(3)):0xc000c24960 assert.Nil(t, successor):0xc000a13338 assert.Nil(t, w.get()):0xc000826760 assert.Nil(t, xft.Get(6)):0xc00000e0f0 assert.Nil(t, xft.Max()):0xc0001bf5f8 assert.Nil(t, xft.Min()):0xc0001bf5f0 assert.Nil(t, xft.min.children[0]):0xc0004a42a0 assert.Nil(t, xft.root.children[0]):0xc000c25638 assert.Nil(t, xft.root.children[1]):0xc000c25640 assert.Nil(t, yfast.Get(3)):0xc000224848 assert.Nil(t, yfast.Get(7)):0xc000225088 assert.Nil(t, yfast.Get(8)):0xc0002250a0 assert.Nil(tail):0xc0000a4fb0 assert.NoError(b, err):0xc00028d1a0 assert.NotContains(t, result, entries[2]):0xc00000fb20 assert.NotContains(t, result, entries[5]):0xc000225d90 assert.NotContains(v, "A"):0xc000c25230 assert.NotContains(v, "B"):0xc000c25248 assert.NotContains(v, "C"):0xc000c25250 assert.NotContains(v, "D"):0xc000c25238 assert.NotEqual(t, defaultHasher("foo"), defaultHasher("bar")):0xc000224568 assert.NotEqual(t, key, h):0xc000a12f00 assert.NotNil(recover()):0xc0000a4308 assert.NotNil(t, accessed):0xc000191c60 assert.NotNil(t, added):0xc000191c90 assert.NotNil(t, c.items):0xc00028c490 assert.NotNil(t, c.keyList):0xc00028c498 assert.NotNil(t, e1):0xc0006aa738 assert.NotNil(t, e2):0xc0006aa740 assert.NotNil(t, e3):0xc0006aa748 assert.NotNil(t, err):0xc00039cc98 assert.NotNil(t, xft.root):0xc000c25630 assert.Panics(t, func() {:0xc0004a5358 assert.True(:0xc000a13b30 assert.True(Empty.IsEmpty()):0xc0000a4fb8 assert.True(b.IsDisposed()):0xc0002245b0 assert.True(len(batch) > 0):0xc0001be670 assert.True(ok):0xc0006aaca0 assert.True(t, (results[0][0] == `a` && results[1][0] == `b`) ||:0xc000224520 assert.True(t, ba.Equals(cba)):0xc000225c10 assert.True(t, ba.Equals(other)):0xc0001bfc78 assert.True(t, ba.Intersects(cba)):0xc000c24000 assert.True(t, ba.Intersects(other)):0xc0006ab390 assert.True(t, ba.IsEmpty()):0xc00028c4c8 assert.True(t, ba.anyset):0xc0004a48d0 assert.True(t, c == 100):0xc0001bf4c8 assert.True(t, cba.Equals(ba)):0xc0008278f8 assert.True(t, cba.Intersects(ba)):0xc00000f6d8 assert.True(t, exists):0xc000826490 assert.True(t, f.HasResult()):0xc00000f2a0 assert.True(t, hm.Exists(5)):0xc0006aad58 assert.True(t, hm.Exists(6)):0xc00000e0c0 assert.True(t, input.Equals(output)):0xc00000efd8 assert.True(t, iter.Next()):0xc000191bb0 assert.True(t, l.isLeaf):0xc000f04038 assert.True(t, math.Abs(14-math.Abs(calced)) <= .01 || math.Abs(8.75-math.Abs(calced)) <= .01):0xc00028cd98 assert.True(t, math.Abs(14-math.Abs(calced)) <= .01):0xc00028cd48 assert.True(t, math.Abs(2-result[1]) <= .01):0xc000225370 assert.True(t, math.Abs(2-result[1]) <= .1):0xc00000f1c0 assert.True(t, math.Abs(3-result[0]) <= .01):0xc000225368 assert.True(t, math.Abs(3-result[0]) <= .1):0xc00000f1b8 assert.True(t, math.Abs(6-math.Abs(calced)) <= .01):0xc000225970 assert.True(t, math.Abs(7-math.Abs(calced)) <= .01):0xc00000f1b0 assert.True(t, math.Abs(result-config.Target) <= .01):0xc000191b70 assert.True(t, n.insert(tree, k1)):0xc000913690 assert.True(t, n1 == overwritten):0xc0008266b8 assert.True(t, ok):0xc0006aad70 assert.True(t, ok, "Bitarray at position %d should be set", position):0xc0000a4ff0 assert.True(t, optionApplied):0xc00028c4a0 assert.True(t, other.Intersects(ba)):0xc0006ab3a0 assert.True(t, outBytes[0] == 'S'):0xc00000efb0 assert.True(t, q.Disposed()):0xc000224658 assert.True(t, q.Empty()):0xc00000f118 assert.True(t, r.isLeaf):0xc000f04040 assert.True(t, rb.IsDisposed()):0xc000c24218 assert.True(t, result):0xc0000a4790 assert.True(t, result[0] >= 1):0xc00028cd50 assert.True(t, result[0] >= 6 && result[0] <= 8):0xc000c24310 assert.True(t, result[1] >= 0 && result[1] <= 2):0xc000c24318 assert.True(t, result[1] >= 1):0xc00028cd58 assert.True(t, s.Exists(3)):0xc000191a90 assert.True(t, xft.Exists(10)):0xc000a12788 assert.True(t, xft.Exists(15)):0xc000a13ca0 assert.True(t, xft.Exists(20)):0xc00000e080 assert.True(t, xft.Exists(5)):0xc00000e050 assert.True(tb, comparator(max, n.valueAt(i)) <= 0):0xc000a13db8 assert.True(tb, comparator(min, n.lastValue()) > 0):0xc000a13dc8 assert.True(tb, comparator(min, n.valueAt(i-1)) > 0):0xc000a13dd0 assert.True(tb, n.lenValues() >= t.config.NodeWidth/2):0xc000a13d90 assert.Zero(v):0xc0004a4f00 atomic.AddInt64(&counter, c):0xc0000a4380 atomic.AddUint64(&blink.number, 1):0xc000913188 atomic.AddUint64(&numCalls, 1):0xc000224648 atomic.AddUint64(&ptree.number, 1):0xc0001bfd88 atomic.AddUint64(&ptree.number, ^uint64(0)):0xc0001bfd68 atomic.AddUint64(&sl.num, -right.num):0xc0004a4880 atomic.AddUint64(&sl.num, 1):0xc0001bfa10 atomic.AddUint64(&sl.num, ^uint64(0)):0xc00000f900 atomic.AddUint64(&tree.number, 1):0xc0004a59c8 atomic.AddUint64(&tree.number, ^uint64(0)):0xc0004a59b0 atomic.CompareAndSwapPointer(:0xc0000a44e8 atomic.CompareAndSwapUint64(&rb.disposed, 0, 1):0xc000827150 atomic.StoreInt32(&desc.committed, 1):0xc000224b10 atomic.StoreInt64(&forCache.i, index+1):0xc0001bf738 atomic.StorePointer(:0xc0004a5378 atomic.StorePointer(prevPtr, unsafe.Pointer(old)):0xc0006aa028 atomic.StoreUint32(&f.filled, 1):0xc0004a5320 atomic.StoreUint64(&n.position, pos+1):0xc000a12f80 atomic.StoreUint64(&n.position, pos+rb.mask+1):0xc0001bf340 atomic.StoreUint64(&ptree.disposed, 1):0xc0004a5cf8 atomic.StoreUint64(&ptree.running, 0):0xc000a136f0 atomic.StoreUint64(&tree.disposed, 1):0xc00028d310 atomic.StoreUint64(&tree.running, 0):0xc000912020 b &= 0x0f0f0f0f:0xc0000a5208 b &= 0x0f0f0f0f0f0f0f0f:0xc000c24a28 b *= 0x01010101:0xc0000a5210 b *= 0x0101010101010101:0xc000c24a30 b += b >> 4:0xc0000a5200 b -= (b >> 1) & 0x55555555:0xc0000a51f0 b -= (b >> 1) & 0x5555555555555555:0xc000c24a18 b := []uint32{:0xc00028c420 b := []uint64{:0xc0004a51e0 b := block(0):0xc00039cdd0 b = (b>>2)&0x33333333 + b&0x33333333:0xc0000a51f8 b = (b>>2)&0x3333333333333333 + b&0x3333333333333333:0xc000c24a20 b = b.insert(s - 2):0xc00039cdd8 b = b.insert(s - 6):0xc00039cde0 b, err := New(0, 10, 10, 10, func(str interface{}) uint {:0xc00000f4d8 b, err := New(0, 100, 100000, 10, func(str interface{}) uint {:0xc00028c810 b, err := New(0, 10000, 100, 10, func(str interface{}) uint {:0xc0001be540 b, err := New(1, 2, 100000, 2, func(str interface{}) uint {:0xc000c24010 b, err := New(time.Millisecond*200, 100000, 100000, 10,:0xc0001be628 b.Dispose():0xc000c24180 b.Fail():0xc00028d230 b.Flush():0xc00000f4f8 b.Log(err):0xc00028d238 b.Put("a"):0xc0001be570 b.Put("b"):0xc000c24030 b.Put("c"):0xc000c24038 b.Put("d"):0xc000c24060 b.Put("e"):0xc000c24068 b.Put("f"):0xc000c24070 b.ReportAllocs():0xc0006ab288 b.ResetTimer():0xc000a12e70 b.StopTimer():0xc0004a46f8 b.availableBytes += b.calculateBytes(item):0xc0001bebd0 b.availableBytes = 0:0xc00000f538 b.batchChan <- b.items:0xc0002252b8 b.disposed = true:0xc0001bf670 b.drainBatchChan():0xc0001bf680 b.flush():0xc0001bebe0 b.items = append(b.items, item):0xc0001bebc0 b.items = make([]interface{}, 0, b.maxItems):0xc00000f530 b.items = nil:0xc0001bf678 b.lock.Lock():0xc0001beb90 b.lock.Unlock():0xc0001bebb0 b.toNums(0, &result):0xc00039cdf8 ba := &bitArray{:0xc0004a4b38 ba := andDenseWithDenseBitArray(dba, other):0xc0001bf630 ba := andSparseWithDenseBitArray(sba, other):0xc0004a4e60 ba := andSparseWithSparseBitArray(sba, other):0xc000826e80 ba := nandDenseWithDenseBitArray(dba, other):0xc0004a47e0 ba := nandDenseWithSparseBitArray(sba, other):0xc000a13610 ba := nandSparseWithDenseBitArray(sba, other):0xc000826828 ba := nandSparseWithSparseBitArray(sba, other):0xc0004a5418 ba := newBitArray(10):0xc000a12d28 ba := newBitArray(160000):0xc000826468 ba := newBitArray(162432):0xc00028ca28 ba := newBitArray(4):0xc00039cf40 ba := newBitArray(5):0xc0001bffc0 ba := newBitArray(8, true):0xc00028cf68 ba := newBitArray(max * s):0xc000a13058 ba := newBitArray(min * s):0xc000224ca8 ba := newBitArray(numBits):0xc00000f940 ba := newBitArray(numItems):0xc00039d270 ba := newBitArray(s * 2):0xc0006ab468 ba := newBitArray(s + 1):0xc00039d2d8 ba := newSparseBitArray():0xc0001bf1e8 ba := sba.copy():0xc0006aa158 ba = andDenseWithDenseBitArray(dba, other):0xc00039c380 ba = andSparseWithDenseBitArray(sba, other):0xc0008263a8 ba = nandDenseWithDenseBitArray(dba, other):0xc0004a5a40 ba = nandSparseWithDenseBitArray(sba, other):0xc000c250d8 ba = newBitArray(24):0xc00028c2f0 ba.ClearBit(3):0xc0001bffa8 ba.ClearBit(5):0xc000826090 ba.ClearBit(7):0xc0001bff98 ba.ClearBit(s * 2):0xc0008260a8 ba.ClearBit(uint64(i)):0xc0004a4968 ba.Equals(other):0xc0008264a0 ba.GetBit(j):0xc00039d288 ba.GetBit(s):0xc000a12e80 ba.Intersects(other):0xc00028ca40 ba.Reset():0xc0000a5290 ba.SetBit(1):0xc00000ea00 ba.SetBit(159999):0xc00028ca30 ba.SetBit(2):0xc00000ea08 ba.SetBit(3):0xc0001bff88 ba.SetBit(5):0xc0000a4788 ba.SetBit(7):0xc0001bff90 ba.SetBit(8):0xc0004a48e8 ba.SetBit(i):0xc00039d278 ba.SetBit(s * 2):0xc0000a47b8 ba.SetBit(s + 1):0xc00039d2f8 ba.SetBit(s - 1):0xc000225cd8 ba.SetBit(uint64(i)):0xc000a12e68 ba.SetBit(uint64(j)):0xc0004a5508 ba.ToNums():0xc0000a45f0 ba.anyset = false:0xc000191c30 ba.anyset = true:0xc000191c28 ba.blocks = ba.blocks[:selfIndex-1]:0xc0006aa678 ba.blocks.deleteAtIndex(int64(i)):0xc0006aaf28 ba.blocks[i] &= block(0):0xc0004a47f8 ba.blocks[i] &^= block(1 << pos):0xc0009136a8 ba.blocks[i] = ^ba.blocks[i]:0xc00028cb88 ba.blocks[i] = ba.blocks[i].insert(pos):0xc00039d2d0 ba.blocks[i] = dba.blocks[i].and(other.blocks[i]):0xc0001bee98 ba.blocks[i] = dba.blocks[i].nand(other.blocks[i]):0xc000224d18 ba.blocks[i] = dba.blocks[i].or(other.blocks[i]):0xc0006ab180 ba.blocks[i] = maximumBlock:0xc0004a4b60 ba.blocks[otherIndex] = other.blocks[otherIndex]:0xc000a13098 ba.blocks[otherIndex] = sba.blocks[selfIndex].or(other.blocks[otherIndex]):0xc000a13090 ba.blocks[selfIndex] = ba.blocks[selfIndex].and(:0xc0006aaf10 ba.blocks[value] = sba.blocks[i+selfIndex]:0xc000a13080 ba.complement():0xc0006ab118 ba.highest = (uint64(i) * s) + pos:0xc00039d018 ba.highest = 0:0xc000191c40 ba.highest = i*s - 1:0xc0004a4b68 ba.highest = k:0xc00039d2b0 ba.indices = ba.indices[:selfIndex-1]:0xc0006aaf08 ba.indices.deleteAtIndex(int64(i)):0xc0006aaf30 ba.intersectsSparseBitArray(other):0xc00000f950 ba.lowest = (i * s) + pos:0xc000191c20 ba.lowest = 0:0xc000191c38 ba.lowest = k:0xc00039d2a8 ba.setHighest():0xc000224d58 ba.setLowest():0xc000224d40 ba:		ba,:0xc0004a55d0 bal = -1:0xc000c25440 bal = 1:0xc000c25448 balance:	n.balance,:0xc000826df8 base := node:0xc0002255f8 batch, err := b.Get():0xc00028c830 batch1, err := b.Get():0xc000c24040 batch2, err := b.Get():0xc000c24050 batchChan:	make(chan []interface{}, queueLen),:0xc0001beb58 before := time.Now():0xc0001be658 best := vertices[0]:0xc00000e120 bestGuess := results.vertices[0]:0xc000c252c8 binary.Write(hasher, binary.LittleEndian, key):0xc00039d230 bits := make([]int, 0, xft.bits):0xc00000f378 bits := uint8(0):0xc000c249b8 bits = 16:0xc000c249c8 bits = 32:0xc000c249d0 bits = 64:0xc000c249d8 bits = 8:0xc000c249c0 bits = append(bits, int(leftOrRight)):0xc00000f390 blink.lock.Lock():0xc000913138 blink.lock.RLock():0xc00039d3c0 blink.lock.RUnlock():0xc00039d3c8 blink.lock.Unlock():0xc000913170 blink.root = newNode(:0xc000913148 blink.root.isLeaf = true:0xc000913160 blink.root.keys = make(Keys, 0, blink.ary):0xc000913158 blink.root.print(output):0xc0001be4c8 block := block(0):0xc000224ab8 block = block.insert(i):0xc000224b00 block.toNums(0, &nums):0xc000224ba8 block.toNums(uint64(i)*s, &nums):0xc0000a52c8 blocks := make(blocks, 0, len(sba.indices)):0xc000913318 blocks := make(blocks, 0, max):0xc00000e298 blocks := make(blocks, len(ba.blocks)):0xc00028cbe8 blocks := make(blocks, len(sba.blocks)):0xc000c251c8 blocks = append(blocks, other.blocks[otherIndex:]...):0xc00028c590 blocks = append(blocks, other.blocks[otherIndex]):0xc00028c5c8 blocks = append(blocks, resultBlock):0xc00000f0a8 blocks = append(blocks, sba.blocks[selfIndex:]...):0xc00028c5a0 blocks = append(blocks, sba.blocks[selfIndex]):0xc00000f048 blocks = append(blocks, sba.blocks[selfIndex].or(other.blocks[otherIndex])):0xc00028c5d0 blocks:		blocks,:0xc00000f0c0 blocks:	make([]block, i),:0xc0004a4b40 blocksLen := uint64(len(ba.blocks)):0xc00039cd78 bmp := c.bmp:0xc0001bf5a0 bmp := uint32((1 << xidx) | (1 << yidx)):0xc000225138 bottomNode := n:0xc000a13570 branch := cn.array[0]:0xc0004a4370 branch := cn.array[pos]:0xc0002241c0 break:0xc0006aab48 break L:0xc000a12f40 bts, err = (*z)[bzg].UnmarshalMsg(bts):0xc000a13750 bts, err = msgp.ReadNilBytes(bts):0xc000a13730 bts, err = msgp.Skip(bts):0xc000224830 bts, err = z.ChildKeys[ajw].UnmarshalMsg(bts):0xc00028cb48 bts, err = z.Root.UnmarshalMsg(bts):0xc000224818 bts, err = z.UUID.UnmarshalMsg(bts):0xc0002247f8 buf, err := n.MarshalMsg(nil):0xc000224890 buf, err := t.MarshalMsg(nil):0xc000a131e8 buffer	[8]uint64:0xc0001bf6d0 bundle := xfastIter.Value():0xc000c24f10 bundle := yfast.xfast.Get(bundleKey):0xc00000ea58 bundle := yfast.xfast.Predecessor(bundleKey):0xc0002248d0 bundle := yfast.xfast.Successor(key):0xc00000f618 bundle = yfast.xfast.Predecessor(bundleKey - 1):0xc0002248e8 bundleChunks := make([][]*hilbertBundle, len(chunks)):0xc00028c7a0 bundleChunks[i] = []*hilbertBundle{}:0xc00028c7b8 bundleChunks[i] = bundles:0xc00028c7e0 bundleKey := yfast.getBucketKey(entry.Key()):0xc00000ea50 bundleKey := yfast.getBucketKey(key):0xc0001be6a0 bundles := make([]*hilbertBundle, 0, len(chunks[i])):0xc00028c7c0 bundles := make([]*hilbertBundle, 0, len(rects)):0xc00028c7e8 bundles := make(pbs, 0, len(vertices)):0xc000912070 bundles = append(bundles, &hilbertBundle{hilbert(h), r}):0xc00028c7d8 bundles = append(bundles, &vertexProbabilityBundle{vertex: v}):0xc000912078 bundles = append(bundles, bc...):0xc00028c7f8 c := &cache{:0xc000191658 c := &cache{keyList: list.New()}:0xc000191c48 c := 0:0xc0001bf480 c := New(314159, option).(*cache):0xc00028c478 c := generateRandomItem():0xc0004a5948 c := ifc.(int64):0xc0000a4378 c := newItem(int64(i)):0xc000827700 c := nodes[len(nodes)-1]:0xc00039ca58 c := oc[index]:0xc0006aa168 c := oc[rand.Intn(len(oc))]:0xc0006aa1e0 c = &cache{keyList: list.New()}:0xc000191c70 c = 0:0xc0001bf4a0 c++:0xc0001bf490 c.Get("foo"):0xc0004a4ce0 c.Lock():0xc0004a50f8 c.Put("bar", testItem(1)):0xc0004a4cd8 c.Put("baz", testItem(1)):0xc0004a4ce8 c.Put("foo", testItem(1)):0xc0004a4c88 c.Put("foo", testItem(10)):0xc0004a4cb0 c.Remove("baz"):0xc0004a4e30 c.Remove("foo"):0xc0004a4e40 c.assertReadWrite():0xc0002259d0 c.cache = make(map[string]*futures.Future, 10):0xc0009130d0 c.cache[string(key)] = future:0xc0008270b0 c.deleteFromCache(key):0xc0008270c0 c.element = element:0xc0008266d0 c.ensureCapacity(item.Size()):0xc0000a5228 c.insert(&Entry{:0xc0002259d8 c.insert(entry):0xc0004a5e88 c.items[key] = cached:0xc0000a5248 c.keyList.MoveToFront(item.element):0xc000826fb0 c.keyList.Remove(cached.element):0xc0001be620 c.lock.Lock():0xc0009130c0 c.lock.RLock():0xc0004a4990 c.lock.Unlock():0xc000827088 c.rdcssComplete(false):0xc0006aa0c0 c.recordAccess = c.noop:0xc000c24698 c.recordAccess = c.record:0xc000c246b0 c.recordAccess(key):0xc0004a5130 c.recordAdd = c.noop:0xc000c246b8 c.recordAdd = c.record:0xc000c246a0 c.remove(key):0xc0000a5220 c.seenNodes[string(n.ID)] = n:0xc0006aabd0 c.size += item.Size():0xc0000a5250 c.size -= cached.item.Size():0xc0001be618 cNode := &collisionNode{entries: make([]Entry, 2)}:0xc000a13488 cNode := n.entries[index].(*collisionNode):0xc00000f5f8 cNode := newNode.entries[index].(*collisionNode):0xc000a134b0 cNode.entries = append(cNode.entries, entry):0xc000a134b8 cNode.entries = append(cNode.entries[:i], cNode.entries[i+1:]...):0xc0004a4768 cNode.entries[0] = newNode.entries[index]:0xc000a13490 cNode.entries[1] = entry:0xc000a13498 c[j], c[i] = c[i], c[j]:0xc0004a40c8 cache				= make(nodes, 64):0xc00028cf80 cache		Cache:0xc0004a4c48 cache := make([]slice.Int64Slice, 0, dimensions-1):0xc0002249e0 cache := newCache(irt.dimensions):0xc0006aaf48 cache = append(cache, slice.Int64Slice{}):0xc0002249f8 cache:		make(map[string]*futures.Future, 10),:0xc0004a5608 cache:	New(10000),:0xc0004a4c78 cache:	New(2, EvictionPolicy(LeastRecentlyAdded)),:0xc0004a4cd0 cache:	New(2, EvictionPolicy(LeastRecentlyUsed)),:0xc0004a4e18 cache[i+1] = q:0xc00028d028 cache[i-1].Insert(node.value):0xc000826e50 cache[i] = sl.head:0xc0001bfa30 cache[i].forward[i] = nn:0xc0001bfa58 cache[i].widths[i] = pos - posCache[i]:0xc0001bfa88 cache[i].widths[i]++:0xc0001bfaa0 cache[oldTop-1].children[dirs[oldTop-1]] = it:0xc00028d0a8 cache[top-1].children[dirs[top-1]] = cache[top]:0xc00028d100 cache[top-1].children[dirs[top-1]] = it.children[dir]:0xc00028d058 cache[top-1].children[intFromBool(cache[top-1] == it)] = heir.children[1]:0xc00028d0b8 cache[top] = heir:0xc00028d088 cache[top] = it:0xc00028cfd0 cache[top] = removeBalance(cache[top], dirs[top], &done):0xc00028d0f8 cache[top].balance++:0xc00028d0e0 cache[top].balance--:0xc00028d0d8 cached := &cached{item: item}:0xc0000a5230 cached := c.items[key]:0xc0004a5118 cached.setElementIfNotNil(c.recordAccess(key)):0xc0000a5240 cached.setElementIfNotNil(c.recordAdd(key)):0xc0000a5238 cacher:		t.cacher,:0xc000c24ec8 cacher:	newCacher(cfg.Persister),:0xc000a13af8 calced, _ := fn(result):0xc00000f1a8 calced, _ = fn(result):0xc00028cd90 calculateBytes:	calculate,:0xc000191ff8 cancel := make(chan struct{}):0xc0000a5768 cap:		capacity,:0xc000191710 case "c"::0xc000224800 case "ck"::0xc00028cb18 case "cv"::0xc00028caf0 case "id"::0xc00028c1f8 case "il"::0xc00028cae0 case "nw"::0xc000224820 case "p"::0xc0006aafc8 case "r"::0xc000224810 case "u"::0xc0002247f0 case "v"::0xc0006aafb8 case *iNode::0xc000a13888 case *sNode::0xc00000fa40 case -1::0xc0004a4f70 case 0, 1::0xc000913448 case 0::0xc0004a4fc0 case 1, 0::0xc0001befd0 case 1::0xc0004a4dd0 case <-b.batchChan::0xc000c24e28 case <-cancel::0xc00000fa50 case <-f.WaitChan()::0xc00039cc18 case <-ptree.disposeChannel::0xc000a13560 case <-sema.ready::0xc000c24e00 case <-stop::0xc00000eb80 case <-t.C::0xc0000a5278 case <-time.After(0)::0xc00039cc20 case <-timeout::0xc0001bec58 case <-timeoutC::0xc000c24e18 case LeastRecentlyAdded::0xc000c24690 case LeastRecentlyUsed::0xc000c246a8 case add, remove::0xc00039d0a0 case add::0xc000827008 case apply::0xc00039d0c0 case ch <- b.Entry::0xc00000fa48 case ch <- e.(*Entry)::0xc00000fa78 case ch <- main.tNode.Entry::0xc00000fa88 case dif < 0::0xc000a12f48 case dif == 0::0xc000a12490 case diff < 0::0xc00028c5b8 case diff > 0::0xc00028c5b0 case float32::0xc0004a5278 case float64::0xc0004a5280 case get, apply::0xc000a13438 case get::0xc00039d080 case int16::0xc0004a5248 case int32::0xc0004a5250 case int64::0xc0004a5258 case int8::0xc0004a5240 case int::0xc0004a5268 case item := <-ch::0xc0000a5260 case items, ok := <-b.batchChan::0xc00000f518 case m.lock <- struct{}{}::0xc00039d0f8 case main.cNode != nil::0xc00000fa20 case main.lNode != nil::0xc00000fa60 case main.tNode != nil::0xc00000fa80 case mp := <-ptree.mpChannel::0xc000a13550 case n.dataMap.GetBit(index)::0xc00000f778 case n.level == 6 && e != nil::0xc00000f798 case n.nodeMap.GetBit(index)::0xc00000f788 case otherValue < selfValue::0xc00000f070 case otherValue > selfValue::0xc00000f080 case remove::0xc000827028 case result < 0::0xc000224f48 case result == 0::0xc000224e60 case result > 0::0xc000224e88 case sema.ready <- true::0xc0001bf520 case uint, uint64::0xc000912730 case uint16::0xc0009123e8 case uint32::0xc000912720 case uint64, uint::0xc000c24fb0 case uint64::0xc0004a5238 case uint8::0xc000912290 case uint::0xc0004a5260 case uintptr::0xc0004a5270 case waiter.ready <- true::0xc000a138d0 cba := newSparseBitArray():0xc00000f6d0 cba.Equals(other):0xc000827930 cba.SetBit(10):0xc00000f6f0 cba.SetBit(5):0xc00000f6e8 cba.SetBit(i):0xc000827928 cba.SetBit(s * 3):0xc00000f700 cba.SetBit(s + 1):0xc00000f6f8 cfg := DefaultConfig(p, comparator):0xc00000eb20 cfg := defaultConfig():0xc00028cdf8 cfg.NodeWidth = t.NodeWidth:0xc00000eb30 cfg.Persister = newDelayed():0xc0006aa210 ch := f.wait:0xc00039ce60 ch := make(chan *Entry):0xc00028d200 ch := make(chan interface{}, 1):0xc0000a55d8 ch <- `a`:0xc0000a55e8 checkBit(t, ba, 0, false):0xc0001bf638 checkBit(t, ba, 1, false):0xc0004a5420 checkBit(t, ba, 1, true):0xc000826e88 checkBit(t, ba, 100, false):0xc0004a5458 checkBit(t, ba, 1000, false):0xc000826eb0 checkBit(t, ba, 1000, true):0xc0004a5448 checkBit(t, ba, 1200, false):0xc00028c9f0 checkBit(t, ba, 1200, true):0xc0008268d8 checkBit(t, ba, 128, false):0xc00028ca00 checkBit(t, ba, 150, false):0xc000826830 checkBit(t, ba, 150, true):0xc0004a4e68 checkBit(t, ba, 1500, false):0xc00028c9f8 checkBit(t, ba, 1500, true):0xc0008268e0 checkBit(t, ba, 155, false):0xc0004a4e78 checkBit(t, ba, 155, true):0xc000826f80 checkBit(t, ba, 156, false):0xc000826f88 checkBit(t, ba, 18, false):0xc0001bf640 checkBit(t, ba, 2, false):0xc0004a5460 checkBit(t, ba, 222, false):0xc0004a47e8 checkBit(t, ba, 222, true):0xc0001bf648 checkBit(t, ba, 2680, false):0xc0004a5430 checkBit(t, ba, 2680, true):0xc000826e98 checkBit(t, ba, 280, false):0xc000826ea8 checkBit(t, ba, 280, true):0xc0004a5440 checkBit(t, ba, 3, false):0xc000826ea0 checkBit(t, ba, 3, true):0xc0004a5438 checkBit(t, ba, 30, false):0xc0004a5428 checkBit(t, ba, 30, true):0xc000826e90 checkBit(t, ba, 300, false):0xc000826f78 checkBit(t, ba, 300, true):0xc0004a4e70 checkBit(t, ba, 5, false):0xc000826010 checkBit(t, ba, 5, true):0xc000c24fe8 checkBit(t, ba, 500, false):0xc00028c9e8 checkBit(t, ba, 500, true):0xc0008268d0 checkBit(t, ba, 9, false):0xc0004a5450 checkNode(t, xft, n):0xc00000f2b8 checkNodes(t, xft):0xc00039cd20 checkPattern(t, n, bits):0xc00000f398 checkPredecessor(t, xft):0xc00039cd18 checkRedBlack(t, it.root, 1):0xc000913248 checkRedBlack(t, tree.root, 1):0xc0004a4400 checkSuccessor(t, xft):0xc00039cd10 checkTree(t, tree):0xc000913228 checkTrie(t, xft):0xc00000e068 child := childL:0xc00039c3e8 child := parent.children[otherDir]:0xc000c25350 child = childR:0xc00039c488 child = n.nodes[i+1]:0xc0001bf008 child = n.nodes[i]:0xc0001bf010 child = n.nodes[len(n.nodes)-1]:0xc0001bef90 child, _ := t.contextOrCachedNode(key.ID(), true):0xc00028c000 child.children[dir] = parent:0xc000c25360 child.max = parent.max:0xc000c25378 child.red = false:0xc000c25370 childDir := intFromBool(node.children[0] == nil):0xc000a12768 childL, childR := 2*index+1, 2*index+2:0xc00039c3d8 childL, childR = 2*index+1, 2*index+2:0xc00039c9d0 children:	[2]*node{n.children[0], n.children[1]},:0xc000826e00 children:	[2]*node{},:0xc000191da8 children: [2]*node{},:0xc00028c5e8 chunk := chunks[i]:0xc0006aade0 chunkPaths := make([]map[interface{}]*nodeBundle, len(chunks)):0xc0004a4068 chunkPaths[i] = mp:0xc0004a4120 chunks := chunk(toBeSorted, numCPU):0xc0006aac08 chunks := chunkKeys(keys, int64(blink.numRoutines)):0xc0008260c8 chunks := chunkKeys(keys, int64(numRoutines)):0xc0004a4ac0 chunks := chunkRectangles(rects, int64(runtime.NumCPU())):0xc00028c798 chunks := splitKeys(keys, runtime.NumCPU()):0xc0004a4028 chunks := splitValues(keys, runtime.NumCPU()):0xc0006aadc0 chunks = copyChunk(todo):0xc0006aac70 clean(p, lev-5, ctrie):0xc0004a4420 clean(parent, lev-w, c):0xc0004a41a8 cleanParent(p, i, hc, lev, ctrie, startGen):0xc0000a43e0 cleanParent(parent, i, entry.hash, lev-w, c, startGen):0xc0000a4138 close(b.batchChan):0xc0001bf688 close(cancel):0xc0000a5780 close(ch):0xc00028d218 close(closed):0xc000224838 close(ptree.disposeChannel):0xc0004a5d00 close(stop):0xc0001bf4c0 close(w):0xc0004a5340 cmps := make(common.Comparators, 0, 32):0xc000225c78 cmps = append(cmps, cmp):0xc000225c88 cn := main.cNode:0xc000224178 cntr := toContracted(ncn, lev):0xc0000a4110 comparator:	comparator,:0xc0001bfcf0 comparators := constructOrderedMockComparators(10):0xc000a12ec8 comparators := constructOrderedMockComparators(7):0xc00039cef8 comparators := constructOrderedMockComparators(8):0xc000913198 comparators := constructOrderedMockComparators(9):0xc000225050 comparators := constructOrderedMockComparators(numCells):0xc0006ab108 comparators := make(Comparators, 0, len(values)):0xc000a12e00 comparators := make(Comparators, 0, upTo):0xc00039ce28 comparators = append(comparators, mockComparator(i)):0xc00039ce38 comparators = append(comparators, mockComparator(v)):0xc000a12e10 comparators = reverseComparators(comparators):0xc000a12ed0 comparators[i], comparators[li] = comparators[li], comparators[i]:0xc0000a4888 completer := make(chan interface{}):0xc00000f150 completer := make(chan interface{}, 1):0xc0008270a0 completer <- ErrNodeNotFound:0xc000826b28 completer <- `test`:0xc00000f160 completer <- err:0xc000826a90 completer <- n:0xc000826b40 completer:	new(sync.WaitGroup),:0xc000224928 config := NelderMeadConfiguration{:0xc000191b48 config = NelderMeadConfiguration{:0xc00028cd78 config:		config,:0xc0001bf908 config:		t.config,:0xc000c24ec0 config:	cfg,:0xc000a13ae8 config:	config,:0xc000912090 constructMockInterval(:0xc00000f750 constructMockInterval(dimension{0, 10}, dimension{0, 10}),:0xc000a12db0 constructMultiDimensionInterval(:0xc000913258 context:	newContext(),:0xc000c24ed0 continue:0xc000191c10 continue Guess:0xc0006aaef8 copy((*b)[i:], (*b)[i+1:]):0xc0001bf388 copy((*b)[index+1:], (*b)[index:]):0xc0001bf2a8 copy((*entries)[i+1:], (*entries)[i:]):0xc00039ced0 copy((*entries)[i:], (*entries)[i+1:]):0xc0009133b8 copy((*keys)[i+1:], (*keys)[i:]):0xc0001be6f8 copy((*nodes)[i+1:], (*nodes)[i:]):0xc000913030 copy((*nodes)[i:], (*nodes)[i+1:]):0xc00000e268 copy((*ns)[i+1:], (*ns)[i:]):0xc0004a4ea8 copy((*u)[i+1:], (*u)[i:]):0xc000912b38 copy((*u)[i:], (*u)[i+1:]):0xc0006aa0f0 copy((*w)[0:], (*w)[1:]):0xc00000eff0 copy(array, c.array):0xc0001bf5b0 copy(ba.blocks[i:], dba.blocks[i:]):0xc0006ab178 copy(ba.blocks[i:], other.blocks[i:]):0xc0006ab168 copy(ba.blocks[otherIndex:], other.blocks[otherIndex:]):0xc000a13068 copy(blocks, ba.blocks):0xc00028cbf0 copy(blocks, sba.blocks):0xc000c251d0 copy(cp, chunk):0xc000a12d80 copy(cp, nodes):0xc0008277d0 copy(cp, o):0xc0004a4890 copy(cpKeys, n.ChildKeys):0xc0001bf548 copy(cpValues, n.ChildValues):0xc0001bf538 copy(cp[i+1:], cp[i:]):0xc0001bf380 copy(cp[i:], cp[i+1:]):0xc0009135c0 copy(indices, sba.indices):0xc000c251e0 copy(ks.list[i+1:], ks.list[i:]):0xc0008276e0 copy(ks.list[i:], ks.list[i+1:]):0xc0001bf268 copy(left, ns[:i]):0xc0006aa8f8 copy(leftKeys, n.ChildKeys[:i+1]):0xc0004a49b8 copy(leftValues, n.ChildValues[:i+1]):0xc0004a49a0 copy(leftValues, n.ChildValues[:i]):0xc00028cc38 copy(n.ChildKeys[1:], n.ChildKeys):0xc0004a5ca0 copy(n.ChildKeys[i+1:], n.ChildKeys[i:]):0xc000827550 copy(n.ChildKeys[i:], n.ChildKeys[i+1:]):0xc0006aa170 copy(n.ChildKeys[index:], n.ChildKeys[index+1:]):0xc000a13990 copy(n.ChildValues[1:], n.ChildValues):0xc000225c00 copy(n.ChildValues[i+1:], n.ChildValues[i:]):0xc000827528 copy(n.ChildValues[i:], n.ChildValues[i+1:]):0xc0008279b0 copy(n.ChildValues[index:], n.ChildValues[index+1:]):0xc000a13988 copy(nodes, *list):0xc000826e40 copy(nodes, *nb.list):0xc000827600 copy(ns.list[i+1:], ns.list[i:]):0xc00028c618 copy(ns.list[i:], ns.list[i+1:]):0xc000a13380 copy(otherKeys, n.keys[:i]):0xc000913618 copy(otherKeys, node.keys[:i]):0xc000826210 copy(ourKeys, n.keys[i+1:]):0xc000913610 copy(ourKeys, node.keys[i:]):0xc000826220 copy(result, keys):0xc000224910 copy(results.pbs, results.pbs[num:]):0xc000c25150 copy(results.vertices[i+1:], results.vertices[i:]):0xc00028ca98 copy(reversed, items):0xc0004a5d78 copy(right, (*keys)[i+1:]):0xc0001be920 copy(right, (*ns)[i+1:]):0xc000c24bf8 copy(right, ks.list[i:]):0xc000a13230 copy(right, ns.list[i:]):0xc0000a48b0 copy(right, ns[i:]):0xc0006aa960 copy(rightKeys, n.keys[i+1:]):0xc0006ab308 copy(rightNodes, n.nodes[i+1:]):0xc0006ab310 copy(s[i+1:], s[i:]):0xc0000a4ce8 copy(toBeSorted, comparators):0xc0006aabe0 copy(top, irt.top):0xc0006aaf58 copy(u1, u[:i]):0xc000c24f68 copy(u2, u[i:]):0xc000c24f80 correctedValue := value:0xc0000a4a68 correctedValue = parent.valueAt(i):0xc0000a4a80 correctedValue, key := node.popValue(), node.popKey():0xc0000a4a20 count := 0:0xc0000a5738 count := uint64(0):0xc00000f2a8 count++:0xc00000f2b0 count:		0,:0xc0001be1c0 counter := uint64(0):0xc000a13f98 cp := &Immutable{:0xc000912770 cp := immutable.copy():0xc000225738 cp := make([]Comparators, len(chunk)):0xc000a12d78 cp := make(items, 0, len(o)):0xc0006aa708 cp := make(orderedItems, len(o)):0xc0004a4878 cp := make(orderedNodes, len(nodes)):0xc0004a59f8 cp := n.copy():0xc0006aa720 cp := node.copy():0xc0002255e0 cp := parent.copy():0xc000225698 cp := t.copyNode(n):0xc0000a4778 cp = append(cp, item):0xc0001bf370 cp = append(cp, nil):0xc0001bf378 cp = cp[:len(cp)-1]:0xc0009135d0 cp.deleteAt(index):0xc000827830 cpKeys := make(Keys, len(n.ChildKeys)):0xc0001bf540 cpValues := cp.ChildValues:0xc000a13d60 cpValues := make([]interface{}, len(n.ChildValues)):0xc0001bf530 cp[i] = item:0xc0001bf360 cp[i] = nn:0xc000827870 cp[j] = nn:0xc0008277f8 cp[j].orderedNodes.flatten(deleted):0xc000827810 cp[j].orderedNodes.flatten(modified):0xc000827820 cp[len(cp)-1] = nil:0xc0009135c8 ctrie := New(mockHashFactory):0xc00000f318 ctrie := New(nil):0xc000913488 ctrie = New(nil):0xc000a13ea0 ctrie.Clear():0xc0004a41f0 ctrie.Insert([]byte("a"), true):0xc00028d3f8 ctrie.Insert([]byte("b"), true):0xc00028d400 ctrie.Insert([]byte("foo"), "bar"):0xc000913498 ctrie.Insert([]byte("foo"), "qux"):0xc0009134f0 ctrie.Insert([]byte("foo"), 0):0xc0000a4050 ctrie.Insert([]byte("fooooo"), "baz"):0xc0009134b0 ctrie.Insert([]byte(strconv.Itoa(i)), "blah"):0xc0009134d8 ctrie.Insert([]byte(strconv.Itoa(i)), i):0xc00000f328 ctrie.Lookup(key):0xc0008264f0 ctrie.ReadOnlySnapshot():0xc00000e2d8 ctrie.Remove([]byte("b")):0xc00028d408 ctrie.Remove([]byte(strconv.Itoa(i))):0xc000913518 ctrie.Remove(key):0xc0008264f8 ctrie.Snapshot():0xc00000e2c8 ctx := false:0xc0000a5358 ctx = !ctx:0xc0000a5380 cur := start:0xc0001bfac8 cur = n.lastValue():0xc0001bfb08 curLoc += intsize:0xc000a98530 curr := l:0xc000c24888 curr := min.child:0xc0009136e8 curr = curr.next:0xc000913700 curr = minT:0xc0009137e8 curr = tail.(*list):0xc000c248b8 curr.parent = nil:0xc0009136f8 cutNode(heap, node):0xc000a13b88 cutNode(heap, node.parent):0xc0006ab578 d += int64(int64(s) * int64(s) * int64(((3 * rx) ^ ry))):0xc000912f30 d := &Dtrie{n, defaultHasher}:0xc0001bf4e8 data := n.data:0xc0001bf330 db	*dimensionalBundle:0xc00000f420 db = &dimensionalBundle{id: uint64(value), sl: skip.New(uint64(0))}:0xc00000f488 db = e.(*dimensionalBundle):0xc00000f498 db, ok := sl.Get(skipEntry(value))[0].(*dimensionalBundle):0xc000827448 dba := newBitArray(1000):0xc0001bf600 dba := newBitArray(numItems):0xc000a13b48 dba.Reset():0xc00039c368 dba.SetBit(1):0xc0001bf608 dba.SetBit(222):0xc0001bf618 dba.SetBit(5):0xc00039c360 dba.SetBit(i):0xc0004a5970 dba.SetBit(s - 1):0xc0004a5978 decomposeForSymMerge(8, comparators):0xc0004a5360 decreaseKeyUnchecked(heap, node, -math.MaxFloat64):0xc000c24e98 decreaseKeyUnchecked(heap, node, newPriority):0xc0002253b0 default::0xc00000f090 defaultHasher(map[int]string{11234: "foo"})):0xc000224530 defaultHasher(map[int]string{11234: "foo"}),:0xc0002244f0 defer c.Unlock():0xc0004a5100 defer c.lock.RUnlock():0xc0004a49c0 defer c.lock.Unlock():0xc0009130c8 defer close(out):0xc000a13d00 defer e.lock.RUnlock():0xc000913048 defer e.lock.Unlock():0xc0004a4f88 defer func() {:0xc0000a4300 defer g.mutex.RUnlock():0xc000191cf8 defer g.mutex.Unlock():0xc00039d168 defer parent.lock.RUnlock():0xc000191450 defer pq.disposeLock.Unlock():0xc000a13aa8 defer pq.lock.Unlock():0xc0001bf410 defer q.lock.Unlock():0xc0008268a8 defer set.lock.RUnlock():0xc0004a54f0 defer set.lock.Unlock():0xc000191d08 defer tree.Dispose():0xc000913208 defer wg.Done():0xc0006aadd8 deg, err := g.Degree(v):0xc00028c630 delete(c.cache, string(id)):0xc000a12dd0 delete(c.items, key):0xc0001be610 delete(hm, j):0xc00028cca8 delete(pq.itemMap, item):0xc000c25008 delete(set.items, item):0xc00039d000 delete(set.items, k):0xc0002884e0 delete(xft.layers[xft.bits-1], key):0xc000224320 delete(xft.layers[xft.bits-i-1], key&masks[len(masks)-1-int(i)]):0xc000224488 deleteItems := func(items []Item) {:0xc000c25000 deleteItems(items):0xc000c25038 deleteOperations := make(map[*node][]*keyBundle):0xc000826fe8 deleteOperations[n] = append(deleteOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}):0xc000827030 deleteOperations[n] = append(deleteOperations[n], ptree.newKeyBundle(action.keys()[i])):0xc000a13430 deleted := (*nodes)[i]:0xc00000e180 deleted := make(Entries, 0, 1):0xc0002258b8 deleted := make(Entries, 0, 100):0xc0004a5a10 deleted := make(Entries, 0, len(entries)):0xc000c243e8 deleted := make(common.Comparators, 0, len(comparators)):0xc0004a5e48 deleted := n.delete(kb):0xc0004a59a8 deleted := n.keys.delete(kb.key):0xc0001bfd60 deleted := nodes.delete(n2.value):0xc000224758 deleted := ot.delete(entry):0xc000a135d8 deleted := rt.Delete(m1, newMockEntry(10), m2):0xc00039c240 deleted := rt.Delete(m1, newMockEntry(10, 10), m2):0xc000c252e8 deleted := sl.Delete(m1):0xc00028d460 deleted := sl.Delete(m1, m2):0xc0006aa000 deleted := tree.Delete(entries[2], constructMockEntry(10, 10, 10)):0xc00028d4a0 deleted := uint64(0):0xc00028c948 deleted = append(deleted, cp.delete(e)):0xc000c243f0 deleted = append(deleted, sl.delete(cmp)):0xc0004a5e50 deleted = make(rangetree.Entries, 0, 100):0xc00028cf00 deleted = nodes.delete(missingValue):0xc000224788 deleted = nodes.delete(n1.value):0xc000224798 deleted = sl.Delete(m1):0xc00028d480 deletedEntries := make(Entries, len(entries)):0xc000a135d0 deletedEntries := make(rangetree.Entries, len(entries)):0xc000c251b8 deletedEntries[i] = deleted.entry:0xc000a135e8 deletedEntries[i] = rt.delete(e):0xc000c251c0 deletes := deletes[n]:0xc0004a5ba8 desc	= r.rdcss:0xc000224ab0 desc := &iNode{:0xc0006aa088 diff := 64 - len(layers):0xc00039d1f8 diff := lenU - lenW:0xc0001bf990 diff := uint64(len(sba.indices)) * s:0xc000c24d60 dimension, 1, irt.dimensions,:0xc000a131b0 dimensions := len(guess.vars):0xc0006aae58 dimensions:	dimensions,:0xc000c25300 dimensions:	values,:0xc00039cd48 dimensions: dimensions,:0xc00028c2b0 dimension{0, int64(numItems)},:0xc00000f758 dimension{0, int64(numItems)}, dimension{0, int64(numItems)},:0xc000826580 dir				= 1:0xc000a12048 dir = compare(node.interval.LowAtDimension(1), ivLow, node.id, id):0xc0001bfc28 dir = intFromBool(it.children[0] == nil):0xc00028d048 dir = it.entry.Compare(entry):0xc00028cfb8 dir = p.entry.Compare(entry):0xc000225430 dir, last		int:0xc0001bfb60 dir, normalized	int:0xc000225410 dirs				= make([]int, 64):0xc00028cf98 dirs[top] = 0:0xc00028d080 dirs[top] = 1:0xc00028d070 dirs[top] = normalized:0xc00028cfc8 disposed := b.disposed:0xc000c24d18 disposedItems := q.items:0xc000a138d8 distance := -guess.euclideanDistance(vertex):0xc0000a50a8 done := int64(-1):0xc000827298 dummy				= tree.dummy:0xc000a12010 dummy			= tree.dummy:0xc0001bfb48 dummy		= immutable.dummy:0xc000225400 dummy:		newDummy(),:0xc000a13f88 dummy:	*newNode(nil),:0xc0009128b8 dummyRoot = &node{:0xc0004a5b48 dumpNode(t, bottomNode):0xc000a13580 duplicate := mockKey(0):0xc00028c030 duplicate := mockKey(uint64(keys[0].(mockKey))):0xc000a13f20 duplicate := newMockKey(0):0xc0004a4ee8 duplicate := newMockKey(2):0xc00039d378 duplicate := newMockKey(4):0xc00028c918 e	common.Comparator:0xc00000f410 e := New():0xc0009a06a0 e := constructMockEntry(uint64(i), i, i):0xc000827738 e := constructMockEntry(uint64(j*numItemsY+i), int64(i), int64(j)):0xc000224a88 e := newMockEntry(uint64(i)):0xc0000a4238 e = iter.Value():0xc000a139d0 e = sl.Get(skipEntry(value))[0]:0xc00000f440 e = subNode.entries[i]:0xc0004a4748 e, pos := sl.GetWithPosition(m1):0xc0002242d0 e, pos = sl.GetWithPosition(m2):0xc0002242e8 e.(*dimensionalBundle).id += uint64(number):0xc000225a08 e.(*lastBundle).id += uint64(number):0xc0002259f8 e.Set(err):0xc0009a06b8 e.err = err:0xc000913090 e.lock.Lock():0xc0004a4f80 e.lock.RLock():0xc000913040 e.mp[string(item.Key)] = item:0xc0004a4fa0 e1 := constructMockEntry(0, int64(0), int64(0)):0xc000a12fc0 e1 := es[:10]:0xc00028d1b8 e1 := newMockEntry(0):0xc00000f960 e1 := newMockEntry(1):0xc000191b88 e1 := newMockEntry(10):0xc000a12780 e1 := newMockEntry(3):0xc0004a5028 e1 := newMockEntry(4):0xc00000f828 e1 := newMockEntry(5):0xc000c24790 e1 := newMockEntry(64):0xc000224660 e1 := newMockEntry(math.MaxUint8):0xc000c242b8 e1 = heap.Enqueue(NumberSequence2[i]):0xc0006ab020 e2 := constructMockEntry(0, int64(1), int64(1)):0xc000a12fc8 e2 := es[10:]:0xc00028d1c0 e2 := newMockEntry(1):0xc000c24798 e2 := newMockEntry(10):0xc00000f3c0 e2 := newMockEntry(12):0xc000a13a48 e2 := newMockEntry(2):0xc000191bd0 e2 := newMockEntry(20):0xc00000e070 e2 := newMockEntry(3):0xc000224fa0 e2 := newMockEntry(4):0xc000c25500 e2 := newMockEntry(4, 6):0xc0000a4030 e2 := newMockEntry(5):0xc0004a58d8 e2 := newMockEntry(6, 4):0xc000826298 e2 := newMockEntry(6, 8):0xc00000fba8 e2 := newMockEntry(7):0xc0004a5030 e2 := newMockEntry(8, 6):0xc0000a4020 e2 := newMockEntry(math.MaxUint8):0xc0000a4058 e2 = heap.Enqueue(NumberSequence2[i]):0xc0006ab030 e3 := constructMockEntry(0, int64(2), int64(2)):0xc000a12fd0 e3 := newMockEntry(10):0xc00000f830 e3 := newMockEntry(11, 9):0xc0000a4028 e3 := newMockEntry(128):0xc0008267b0 e3 := newMockEntry(13):0xc0002251f8 e3 := newMockEntry(15):0xc000a13c90 e3 := newMockEntry(3):0xc000c247b8 e3 := newMockEntry(6):0xc0006ab608 e3 := newMockEntry(64):0xc0000a40e0 e3 := newMockEntry(7):0xc000c25508 e3 := newMockEntry(7, 9):0xc0000a4038 e3 := newMockEntry(8):0xc0004a5038 e3 := newMockEntry(9, 11):0xc00000fbb0 e3 := newMockEntry(9, 7):0xc0008262a0 e3 = heap.Enqueue(NumberSequence2[i]):0xc0006ab040 e:		0,:0xc00028c9b8 echan := iterate(n, nil):0xc0001bf478 echan = iterate(n, nil):0xc0001bf4d8 echan = iterate(n, stop):0xc0001bf4b0 elem := heap.Enqueue(15):0xc0001bf210 encodedanyset = 0:0xc00039c420 encodedanyset = 1:0xc00039c418 end := n - start:0xc0001bf790 entries := Entries{e1, e2, e3}:0xc000a13200 entries := NewEntries():0xc000826730 entries := generateEntries(b.N):0xc0006ab690 entries := generateEntries(numItems):0xc0006ab6a0 entries := generateMockEntries(10):0xc00028cda8 entries := generateMockEntries(100):0xc0002252e0 entries := generateMockEntries(5):0xc000a13c10 entries := generateMockEntries(99):0xc000225798 entries := generateMockEntries(numItems):0xc0000a4000 entries := generateMultiDimensionalEntries(numItems):0xc000826520 entries := generateRandomMockEntries(100):0xc00028cbd0 entries := generateRandomMockEntries(numItems):0xc000c24020 entries := generateRandomMultiDimensionalEntries(numItems):0xc0004a4220 entries := iter.exhaust():0xc000a13cb8 entries := make(Entries, 0, 100):0xc0006aa998 entries := make(Entries, 0, len(keys)):0xc000c24b40 entries := make(Entries, 0, len(starts)):0xc0004a4be0 entries := make(Entries, 0, num):0xc0009130a0 entries := make(Entries, 0, numItems):0xc000827728 entries := make(Entries, 0, numItemsY*numItemsX):0xc000224a70 entries := make(Entries, 0, number):0xc0002246f8 entries := make(Entries, 0, yfast.bits):0xc00000eb90 entries := make(common.Comparators, 0, 10):0xc000913000 entries := make(common.Comparators, 0, num):0xc000191ad0 entries := make(common.Comparators, 0, numItems):0xc000826340 entries := make(rangetree.Entries, 0, 100):0xc000a13a20 entries := make(rangetree.Entries, 0, num):0xc000a12008 entries := sl.Delete(skipEntry(value)):0xc000827428 entries = append(entries, constructMockEntry(0, 0)):0xc000826768 entries = append(entries, constructMockEntry(i, int64(i), int64(i))):0xc000224748 entries = append(entries, constructMockEntry(i, value, value)):0xc000c242f8 entries = append(entries, constructMockEntry(start, int64(start), int64(start))):0xc0004a4be8 entries = append(entries, constructMockEntry(uint64(i), i, i)):0xc0000a56c0 entries = append(entries, e):0xc000a13a30 entries = append(entries, i.Value()):0xc000913010 entries = append(entries, it.Value()):0xc0006aa9d0 entries = append(entries, mockEntry(i)):0xc00039cdc8 entries = append(entries, n.entry):0xc000225728 entries = append(entries, newMockEntry(i)):0xc000191ae0 entries = append(entries, newMockEntry(i+uint64(b.N/2))):0xc0004a5ad8 entries = append(entries, newMockEntry(int64(i), int64(i))):0xc000a12020 entries = append(entries, newMockEntry(uint64(i))):0xc000826348 entries = append(entries, newMockEntry(uint64(rand.Int()))):0xc000912180 entries = append(entries, newMockEntry(value, value)):0xc000a12040 entries = append(entries, yfast.delete(key)):0xc000c24b48 entries = iter.exhaust():0xc000a13cd0 entries.Dispose():0xc000826780 entries.insert(entry):0xc00000eb98 entries:	bundle.(*entriesWrapper),:0xc000c24f30 entries:	entries,:0xc00000ebb0 entriesPool.Put(*entries):0xc00000e280 entry := <-iter:0xc0000a5778 entry := bundle.(*entriesWrapper).entries.get(key):0xc0001bf2b8 entry := constructMockEntry(0, int64(0), int64(0)):0xc000a12d98 entry := constructMockEntry(10, 10, 10):0xc0000a5868 entry := ew.entries.delete(key):0xc0001be6b8 entry := yfast.get(key):0xc0002250f8 entry := yfast.predecessor(key):0xc0004a41e0 entry := yfast.successor(key):0xc0006ab2f8 entry, _ := bundle.(*entriesWrapper).entries.successor(key):0xc00000f620 entry, _ := ew.entries.predecessor(key):0xc0002248d8 entry, _ = ew.entries.predecessor(key):0xc0002248f8 entry:		cmp,:0xc0006aa680 entry:		entry,:0xc000191db0 entry:		n.entry,:0xc000826e08 err := ba.ClearBit(s * 2):0xc000827718 err := ba.SetBit(5):0xc000a12d30 err := ba.SetBit(s * 2):0xc000c252a8 err := ba.SetBit(s + 1):0xc00039cf48 err := binary.Read(r, binary.LittleEndian, &ret.lowest):0xc0001bfe58 err := binary.Write(w, binary.LittleEndian, identifier):0xc00039cd70 err := fmt.Errorf(`test`):0xc0009a06b0 err := heap.Delete(elem):0xc000a136b8 err := heap.Delete(nil):0xc0002253c0 err := heap.Delete(sliceE[i]):0xc00028d198 err := rb.Put(0):0xc0006aa730 err := rb.Put(1):0xc0004a4ec8 err := rb.Put(4):0xc000826038 err := rb.Put(5):0xc00039d1d0 err := rb.Put(i):0xc000826030 err := ret.Deserialize(input):0xc000a12cf0 err := sgraph.AddEdge("A", "B"):0xc0006aafd8 err := t.Apply(func(item *Item) {:0xc0001be5d8 err := t.config.Persister.Save(items...):0xc00000e158 err = ba.ClearBit(5):0xc00028c2d8 err = ba.SetBit(16):0xc00028c2f8 err = ba.SetBit(5):0xc00028c4a8 err = ba.SetBit(9):0xc0000a5288 err = binary.Read(r, binary.LittleEndian, &encodedanyset):0xc0001bfe68 err = binary.Read(r, binary.LittleEndian, &nextblock):0xc0001bfe88 err = binary.Read(r, binary.LittleEndian, &ret.highest):0xc0001bfe60 err = binary.Write(w, binary.LittleEndian, ba.blocks):0xc00039cd90 err = binary.Write(w, binary.LittleEndian, ba.highest):0xc00039c400 err = binary.Write(w, binary.LittleEndian, ba.indices):0xc00039cda0 err = binary.Write(w, binary.LittleEndian, ba.lowest):0xc00039c3f8 err = binary.Write(w, binary.LittleEndian, blocksLen):0xc00039cd88 err = binary.Write(w, binary.LittleEndian, encodedanyset):0xc00039c428 err = binary.Write(w, binary.LittleEndian, indexLen):0xc00039cd98 err = heap.Delete(e1):0xc0006aa750 err = heap.Delete(e2):0xc0006aa758 err = heap.Delete(e3):0xc0006aa760 err = output.Deserialize(outBytes):0xc00000efd0 err = q.Put(`a`):0xc00000f7e8 err = q.Put(mockItem(1)):0xc0002259c0 err = rb.Put(2):0xc0004a4ed0 err = sgraph.AddEdge("A", "A"):0xc0006aaff0 err = sgraph.AddEdge("A", "B"):0xc0006aafe0 err = sgraph.AddEdge("B", "A"):0xc0006aafe8 err = sgraph.AddEdge("B", "C"):0xc0006ab000 err = sgraph.AddEdge("C", "C"):0xc0006aaff8 err = t.delete(keys):0xc0001be5f0 err = t.walkupDelete(key, base, path, mapping):0xc0002256e8 es := Entries{}:0xc000c24788 es := generateMockEntries(20):0xc00028d1b0 es.delete(1):0xc000a13168 es.delete(5):0xc000a13158 es.insert(e1):0xc000c247a0 es.insert(e2):0xc000c247a8 es.insert(e3):0xc000c247c0 ew := &entriesWrapper{:0xc00000eba0 ew := bundle.(*entriesWrapper):0xc0001be6b0 ew = bundle.(*entriesWrapper):0xc0002248f0 exp	= desc.expected:0xc000224ac8 exp, ok := expected[string(entry.Key)]:0xc0000a5748 expanded := nm.expand(vertices, midpoint, reflection):0xc00028d550 expected := Intervals{iv1, iv3}:0xc000a13fc0 expected := Intervals{iv2, iv1, iv3}:0xc00028d338 expected := Intervals{iv2, iv1}:0xc000a13f70 expected := Intervals{iv2, iv3}:0xc000224170 expected := Intervals{iv2, iv4}:0xc0000a57b0 expected := Intervals{iv2}:0xc000c25428 expected := Intervals{}:0xc00000fa10 expected := []byte{66, 0, 0, 0, 0, 0, 0, 0, 0, 254}:0xc000191ca8 expected := []byte{83, 20, 0, 0, 0, 0, 0, 0, 0, 73}:0xc00000efb8 expected := []interface{}{`1`}:0xc00028cc80 expected := []interface{}{`a`, `b`}:0xc0000a57f0 expected := []interface{}{}:0xc000224238 expected := []uint64{s - 1, s + 1}:0xc000224590 expected := []uint64{s - 6, s - 2}:0xc00039cde8 expected := constructMockComparators(0, 1, 3, 5, 7, 9):0xc00028cc50 expected := constructMockComparators(1, 2, 3, 4, 5, 7, 9):0xc0004a4a08 expected := constructMockComparators(1, 2, 3, 4, 7):0xc000c250f0 expected := constructMockComparators(1, 2, 3, 4, 7, 12, 15):0xc00000eaf0 expected := constructMockComparators(1, 2, 5, 8):0xc00000f4c0 expected := constructMockComparators(1, 3, 5):0xc0004a4b98 expected := constructMockComparators(1, 5, 6, 7):0xc000c24e60 expected := constructMockComparators(2, 4, 5, 7, 9, 10, 11, 12):0xc0001bffd8 expected := map[string]int{:0xc00028d390 expected := newNode(iv, 5, 10, 1):0xc000c248e8 expected := toOrdered(items).toItems():0xc00000f980 expected.red = false:0xc000c248f0 expected:	expected,:0xc0006aa0a8 expectedChild := newNode(iv, 4, 11, 1):0xc0004a4600 expectedChild := newNode(iv, 7, 11, 1):0xc000a13540 expectedItems	[]Item:0xc0004a4c60 expectedItems:	[]Item{nil, nil, nil},:0xc0004a4e50 expectedItems:	[]Item{nil, testItem(1), testItem(1)},:0xc0004a4d08 expectedItems:	[]Item{testItem(1), nil, nil},:0xc0004a4c98 expectedItems:	[]Item{testItem(1), nil, testItem(1)},:0xc0004a4e20 expectedItems:	[]Item{testItem(10), nil, nil},:0xc0004a4cc0 expectedLeft := newNode(iv, 4, 11, 1):0xc000c24d30 expectedRight := newNode(iv, 7, 12, 1):0xc000c24d48 expectedRoot := newNode(iv, 4, 11, 1):0xc0004a4328 expectedRoot := newNode(iv, 4, 12, 1):0xc000c24d28 expectedRoot := newNode(iv, 5, 11, 1):0xc000a13530 expectedRoot.children[0] = expectedChild:0xc0004a4620 expectedRoot.children[0] = expectedLeft:0xc000c24d38 expectedRoot.children[1] = expectedChild:0xc000a13548 expectedRoot.children[1] = expectedRight:0xc000c24d50 expectedRoot.red = false:0xc0004a45a0 expectedSize	uint64:0xc0004a4c58 expectedSize:	0,:0xc0004a4e48 expectedSize:	1,:0xc0004a4c90 expectedSize:	10,:0xc0004a4cb8 expectedSize:	2,:0xc0004a4d00 f := &Future{}:0xc00028c750 f := New(completer, time.Duration(0)):0xc000826dc0 f := New(completer, time.Duration(30*time.Minute)):0xc00000f158 f := New(completer, timeout):0xc0000a53e0 f := NewSelectable():0xc0004a50a0 f := func(x interface{}) interface{} {:0xc00028cb60 f.Fill(nil, e):0xc0004a5390 f.GetResult():0xc00000f298 f.SetError(ErrFutureCanceled):0xc000913468 f.SetError(fmt.Errorf("timeout")):0xc00039cc28 f.SetValue(`test`):0xc0004a50d8 f.err = e:0xc0004a5318 f.err = err:0xc0006aad38 f.item = item:0xc0006aad30 f.lock.Lock():0xc000224f50 f.lock.Unlock():0xc000224f60 f.m.Lock():0xc00039ce48 f.m.Unlock():0xc00039ce68 f.setItem(item, nil):0xc0000a5268 f.setItem(nil, fmt.Errorf(`timeout after %f seconds`, timeout.Seconds())):0xc0000a5280 f.triggered = true:0xc0006aad28 f.val = v:0xc0004a5310 f.wait = closed:0xc0004a5330 f.wait = make(chan struct{}):0xc00039ce58 f.wg.Add(1):0xc00028c758 f.wg.Done():0xc0006aad40 f.wg.Wait():0xc000224f70 fi.count++:0xc00028c908 fi.count--:0xc0004a4030 fi.packets = packets:0xc000225048 fi.packets.set(&packet{key: key, value: value}):0xc00028c900 fi.rebuild():0xc00028c8f8 field, bts, err = msgp.ReadMapKeyZC(bts):0xc0002247e0 first:	true,:0xc000191ba8 first: true,:0xc00000f3a8 firstSeen := false:0xc000191a48 firstSeen = true:0xc000191a68 flag := uint32(1) << uint32(idx):0xc000c24160 flag, pos := flagPos(entry.hash, lev, cn.bmp):0xc000224180 flag, pos := flagPos(hc, lev, pMain.cNode.bmp):0xc0000a43a8 flatten1 := set.Flatten():0xc000a133f8 flatten2 := set.Flatten():0xc000a13400 fmt.Printf("Delete from merged heap: %v\n", SomeNumberAround0):0xc00039d138 fmt.Printf("Dequeue minimum of merged heap: %v\n", min.Priority):0xc00039d130 fmt.Printf("Dequeueing minimal element: %v\n", node.Priority):0xc00039cdb8 fmt.Printf("Empty after insert? %v\n", heap.IsEmpty()):0xc000191ce8 fmt.Printf("Empty before insert? %v\n", heap.IsEmpty()):0xc000191ce0 fmt.Printf("Extracting minimum of merged heap: %v\n", min.Priority):0xc00039d150 fmt.Printf("Heap 1 insert: %v\n", nodeh1_1.Priority):0xc00028c4f8 fmt.Printf("Heap 1 is empty? %v\n", heap1.IsEmpty()):0xc00028c548 fmt.Printf("Heap 1 size: %v\n", heap1.Size()):0xc00028c538 fmt.Printf("Heap 2 insert: %v\n", nodeh2_1.Priority):0xc00028c520 fmt.Printf("Heap 2 insert: %v\n", nodeh2_2.Priority):0xc00028c530 fmt.Printf("Heap 2 is empty? %v\n", heap2.IsEmpty()):0xc00028c510 fmt.Printf("Heap 2 size: %v\n", heap2.Size()):0xc00028c540 fmt.Printf("Merged heap is empty? %v\n", mergedHeap.IsEmpty()):0xc00039d158 fmt.Printf("Merged heap size: %v\n", mergedHeap.Size()):0xc00039d110 fmt.Printf("Minimal element after decreasing key: %v\n", min.Priority):0xc000a124b0 fmt.Printf("Minimal element after deletion: %v\n", min.Priority):0xc0004a4018 fmt.Printf("Minimal element before decreasing key: %v\n", min.Priority):0xc000a12460 fmt.Printf("Minimal element before deletion: %v\n", min.Priority):0xc0004a4008 fmt.Printf("Minimal element of heap 1: %v\n", min.Priority):0xc000c24990 fmt.Printf("Minimal element of heap 2: %v\n", min.Priority):0xc000c249a0 fmt.Printf("Minimal element of merged heap: %v\n", min.Priority):0xc000c249b0 fmt.Printf("Set node with priority %v to new priority %v\n", SomeNumberAroundMinus1000, SomeNumberAroundMinus1003):0xc00039d118 fmt.Printf("Size after insert: %v\n", heap.Size()):0xc0000a4fd0 fmt.Printf("Size before insert: %v\n", heap.Size()):0xc0000a4fc8 fmt.Printf("\nMerge Heap 1 and Heap 2.\n"):0xc00039d100 fmt.Println("Created heap 1."):0xc00028c4e8 fmt.Println("Created heap 2."):0xc00028c508 fmt.Println(min.Priority):0xc000191cd8 fmt.Println(node.Priority):0xc0009125d8 fn := func(Entry) bool { return true }:0xc000826588 fn := func(ifc interface{}) {:0xc0000a4368 fn := func(min, max int64) {:0xc0000a5488 fn := func(vars []float64) (float64, bool) {:0xc000191b38 fn := prev.failed:0xc0000a44a8 fn = func(vars []float64) (float64, bool) {:0xc00028cd60 fn(c.interval):0xc00039d328 fn(ifc):0xc0008272f0 fn(ifs[i]):0xc0008272e0 fn(item):0xc0006aae48 fn(items[index]):0xc00000f6a8 fn(minL, maxL):0xc0000a54b8 fn(minR, maxR):0xc0000a54c8 fn(n):0xc00000f1e0 fn:		fn,:0xc0001bf3b0 for !ok {:0xc00000fb30 for ; index < len(nodes); index++ {:0xc0004a4710 for _ = range c.Iterator(nil) {:0xc000c25410 for _ = range echan {:0xc0001bf488 for _ = range expected {:0xc0000a5788 for _ = range iterate(d.root, nil) {:0xc000191dc8 for _, a := range toComplete {:0xc0001be268 for _, bc := range bundleChunks {:0xc00028c7f0 for _, br := range main.cNode.array {:0xc00000fa28 for _, bundle := range bundles {:0xc0001bfca8 for _, bundles := range op {:0xc00000e920 for _, c := range items {:0xc00028ce60 for _, c := range items[:10] {:0xc0000a4198 for _, c := range items[:5] {:0xc0000a42c0 for _, c := range result {:0xc0004a5da8 for _, c := range reversed {:0xc0004a5db8 for _, ce := range n.entries[index].(*collisionNode).entries {:0xc00000f7a0 for _, child := range n.nodes {:0xc0004a54c0 for _, child := range n.nodes.list {:0xc000826da8 for _, chunk := range chunkPaths {:0xc0004a4138 for _, chunk := range chunks {:0xc000826198 for _, chunk := range localOverwrittens {:0xc0004a56a8 for _, cmp := range comparators {:0xc0006ab660 for _, curr := range toVisit {:0xc000913740 for _, e := range cNode.entries {:0xc00000f600 for _, e := range e1 {:0xc00028d1d8 for _, e := range entries {:0xc000913478 for _, e := range main.lNode.Map(func(sn interface{}) interface{} {:0xc00000fa68 for _, e := range n.entries {:0xc0004a4940 for _, e := range toDelete {:0xc000225a20 for _, entry := range entries {:0xc0006aaf68 for _, hm := range xft.layers {:0xc000c25620 for _, i := range indices {:0xc000a13940 for _, id := range ids {:0xc00000f588 for _, ifc := range ifs {:0xc0008272e8 for _, ifc := range xns {:0xc000826ff8 for _, index := range toDelete {:0xc000827828 for _, item := range items {:0xc0004a4f98 for _, item := range its {:0xc000a12138 for _, item := range o {:0xc0006aa710 for _, item := range set.Flatten() {:0xc000191a58 for _, iv := range intervals {:0xc00039c310 for _, k := range keys {:0xc000913068 for _, k := range n.keys.list {:0xc000225bd8 for _, k := range result {:0xc0006aae30 for _, k := range reversed {:0xc0006ab2d8 for _, k := range toDelete {:0xc000225648 for _, kb := range adds {:0xc0001bfd70 for _, kb := range bundles {:0xc00000e928 for _, kb := range deletes {:0xc0001bfd58 for _, key := range k {:0xc0004a4ff0 for _, key := range keys {:0xc000826c00 for _, key := range n.ChildKeys {:0xc00028c018 for _, le := range leftEntries {:0xc000225318 for _, n := range n.nodes {:0xc000a13908 for _, n := range n.nodes.list {:0xc000225be8 for _, n := range rightNodes.list {:0xc000a13df0 for _, n := range t.context.seenNodes {:0xc000224880 for _, nb := range path {:0xc000827648 for _, node := range *nodes {:0xc0004a5808 for _, node := range nodes {:0xc00028ca08 for _, option := range options {:0xc000191830 for _, p := range points {:0xc0004a5d38 for _, packet := range fi.packets {:0xc000225030 for _, pb := range chunk {:0xc0004a4180 for _, q := range qs {:0xc0000a4248 for _, r := range chunks[i] {:0xc00028c7c8 for _, re := range rightEntries {:0xc000225340 for _, start := range starts {:0xc000c25108 for _, testCase := range testCases {:0xc0004a5aa0 for _, v := range pbs {:0xc000c24760 for _, v := range values {:0xc000a12e08 for _, v := range vertices {:0xc000913570 for _, v := range vertices[1:] {:0xc000225108 for _, value := range chunk {:0xc0006aadf0 for _, vertex := range vs {:0xc0006aaee8 for _, waiter := range pq.waiters {:0xc000a13ac0 for _, waiter := range q.waiters {:0xc000a138c0 for _, wh := range n.nodes.list {:0xc000826958 for _, x := range b {:0xc00028c450 for ajw := range z.ChildKeys {:0xc0008276c0 for bai := range z {:0xc000a13848 for bzg := range *z {:0xc000a13720 for cmr := range z.ChildValues {:0xc0008276a0 for curr := heap.min; len(toVisit) == 0 || toVisit[0] != curr; curr = curr.next {:0xc000913730 for curr.degree >= len(treeSlice) {:0xc000913748 for entry := range ctrie.Iterator(nil) {:0xc0000a5740 for err == nil {:0xc0001bfe90 for heap.Size() > 0 {:0xc000a12b10 for heir.children[0] != nil {:0xc00028d078 for i != j {:0xc0002251d8 for i := 0; i < 10000; i++ {:0xc0001be648 for i := 0; i < 1000; i++ {:0xc00028c820 for i := 0; i < 100; i++ {:0xc0009134d0 for i := 0; i < 10; i++ {:0xc00000f320 for i := 0; i < 4; i++ {:0xc000826028 for i := 0; i < 5000; i++ {:0xc0001bf248 for i := 0; i < 500; i++ {:0xc000c25140 for i := 0; i < 50; i++ {:0xc000c250a8 for i := 0; i < 5; i++ {:0xc000c25138 for i := 0; i < N; i++ {:0xc000a13bf8 for i := 0; i < b.N; i++ {:0xc000a12e78 for i := 0; i < count; i++ {:0xc00028c788 for i := 0; i < end; i++ {:0xc0001becc0 for i := 0; i < len(*entries); i++ {:0xc00000e260 for i := 0; i < len(*ivs); i++ {:0xc0006aab88 for i := 0; i < len(NumberSequence1); i++ {:0xc000a12a78 for i := 0; i < len(NumberSequence2); i++ {:0xc0006ab010 for i := 0; i < len(NumberSequence2Deleted3ElemSorted); i++ {:0xc0006aa768 for i := 0; i < len(NumberSequence2Sorted); i++ {:0xc0006ab080 for i := 0; i < len(NumberSequence3); i++ {:0xc0004a5888 for i := 0; i < len(NumberSequence4); i++ {:0xc0004a5898 for i := 0; i < len(NumberSequenceMerged3And4Sorted); i++ {:0xc0004a58b0 for i := 0; i < len(ba.blocks); i++ {:0xc0006aaf20 for i := 0; i < len(chunk); i++ {:0xc0008261b0 for i := 0; i < len(chunks); i += 2 {:0xc0006aac60 for i := 0; i < len(chunks); i++ {:0xc0006aac18 for i := 0; i < len(comparators); i++ {:0xc0000a4838 for i := 0; i < len(cp); i++ {:0xc000827838 for i := 0; i < len(items)/2; i++ {:0xc0004a54c8 for i := 0; i < len(keys)/2; i++ {:0xc00028cdd0 for i := 0; i < len(keys); {:0xc0002255a0 for i := 0; i < len(n.keys); i++ {:0xc0004a5498 for i := 0; i < len(nm.vars); i++ {:0xc000a13c38 for i := 0; i < len(nsw.values); i++ {:0xc0001bfd00 for i := 0; i < len(set.flattened); i++ {:0xc000288568 for i := 0; i < maxIterations; i++ {:0xc00028d4f8 for i := 0; i < num-1; i++ {:0xc0006aa308 for i := 0; i < num; i++ {:0xc000191ab0 for i := 0; i < numCPU; i++ {:0xc00000f690 for i := 0; i < numItems; i++ {:0xc000a12e60 for i := 0; i < numItemsX; i++ {:0xc000224a78 for i := 0; i < numLoops; i++ {:0xc0004a5c70 for i := 0; i < numThreads; i++ {:0xc000c241f0 for i := 0; i < number; i++ {:0xc00000e9d8 for i := 0; i < runtime.NumCPU(); i++ {:0xc00028c7a8 for i := 0; i < top; i++ {:0xc00028cff8 for i := 0; i < upTo; i++ {:0xc00039ce30 for i := 0; i <= 1; i++ {:0xc000913288 for i := 0; i <= top; i++ {:0xc0000a4270 for i := 1; i < len(choices); i++ {:0xc000c24cb8 for i := 1; i < len(ints); i++ {:0xc000c246c8 for i := 1; i < len(nodes); i++ {:0xc000827180 for i := 1; i < len(rects); i++ {:0xc00000f280 for i := 1; i < len(vertices); i++ {:0xc0000a56d8 for i := 50; i < 100; i++ {:0xc0000a4320 for i := 9; i >= 0; i-- {:0xc000826960 for i := b.N; i < b.N+numItems; i++ {:0xc000a13ba8 for i := b.N; i > 0; i-- {:0xc00028c938 for i := index; i < len(u); i++ {:0xc000191fb8 for i := int32(0); i < int32(b.N); i++ {:0xc00028d3e8 for i := int32(0); i < int32(num); i++ {:0xc00028c730 for i := int64(0); i < 10; i++ {:0xc000a13670 for i := int64(0); i < int64(numParts); i++ {:0xc000a12cb0 for i := int64(0); i < numItems; i++ {:0xc000827730 for i := int64(0); i < numParts; i++ {:0xc000912f78 for i := int64(0); i < number; i++ {:0xc00000e988 for i := int64(9); i >= 0; i-- {:0xc000827888 for i := iter; i.Next(); {:0xc000913008 for i := len(ba.blocks) - 1; i >= 0; i-- {:0xc00039d008 for i := len(cmps) - 1; i >= 0; i-- {:0xc000912828 for i := len(keys) - 1; i >= 0; i-- {:0xc0001beb08 for i := len(ot.path) - 1; i >= 0; i-- {:0xc0004a5578 for i := len(path) - 1; i >= 0; i-- {:0xc0008275e0 for i := length; i < len(results.pbs); i++ {:0xc000c25160 for i := nodeLevel; i < sl.level; i++ {:0xc0001bfa90 for i := num - 1; i >= 0; i-- {:0xc000826560 for i := o.search(start); i < len(o); i++ {:0xc00000e028 for i := range *ns {:0xc0004a4098 for i := range chunks {:0xc0004a4090 for i := range ns {:0xc00039cbe0 for i := range ptree.cache {:0xc000a136d8 for i := range tree.cache {:0xc000912008 for i := range ws {:0xc000826f58 for i := s - 1; i < s; i-- {:0xc00039cca0 for i := selfIndex; i < toIndex; i++ {:0xc0001bff20 for i := sl.level; i < nodeLevel; i++ {:0xc0001bfa28 for i := splitAt; i < length; i += splitAt {:0xc0004a4910 for i := uint(0); i < 32; i++ {:0xc0004a4738 for i := uint32(0); i < pos; i++ {:0xc000826880 for i := uint64(0); i < 1000; i += s {:0xc0000a5360 for i := uint64(0); i < 10; i++ {:0xc0000a5700 for i := uint64(0); i < dimensions; i++ {:0xc0002249f0 for i := uint64(0); i < intsToRead; i++ {:0xc000a98588 for i := uint64(0); i < max; i++ {:0xc0006ab158 for i := uint64(0); i < min; i++ {:0xc000224ce8 for i := uint64(0); i < numBits; i++ {:0xc00000f948 for i := uint64(0); i < numCPU; i++ {:0xc0008272c8 for i := uint64(0); i < numItems; i += s {:0xc00000f2f8 for i := uint64(0); i < numItems; i++ {:0xc00000ef80 for i := uint64(0); i < number; i++ {:0xc000224738 for i := uint64(0); i < ptree.kbRing.Cap(); i++ {:0xc0000a5330 for i := uint64(0); i < rt.dimensions; i++ {:0xc00000f430 for i := uint64(0); i < s; i++ {:0xc000191a08 for i := uint64(0); i < size; i++ {:0xc0000a51c0 for i := uint64(0); i < uint64(len(ba.blocks)); i++ {:0xc000191c00 for i := uint64(0); i < uint64(num); i++ {:0xc000191ad8 for i := uint64(0); i < uint64(numItems); i++ {:0xc000c242f0 for i := uint64(1); i <= irt.dimensions; i++ {:0xc000826e20 for i := uint64(1); i <= ot.dimensions; i++ {:0xc0004a5188 for i := uint64(10); i > 0; i-- {:0xc000225708 for i := uint64(11); i < 20; i++ {:0xc0004a5c40 for i := uint64(2); i <= maxDimension; i++ {:0xc00039cf78 for i := uint64(21); i < 100; i++ {:0xc0004a5c50 for i := uint8(0); i < bits; i++ {:0xc000c249f8 for i := uint8(0); i < nodeLevel; i++ {:0xc0001bfa48 for i := uint8(0); i < xft.bits; i++ {:0xc00000f380 for i := uint8(0); i <= sl.level; i++ {:0xc0004a4840 for i := uint8(layer); i < xft.bits; i++ {:0xc0001bf830 for i < n.keys.len() && n.keys.list[i] == kb.key {:0xc000827940 for i < num {:0xc0006aae70 for i, block := range ba.blocks {:0xc0000a52c0 for i, block := range other.blocks {:0xc0004a4a18 for i, br := range c.array {:0xc000a13878 for i, c := range expected {:0xc00000f9a0 for i, c := range items {:0xc0002246f0 for i, c := range items[5:10] {:0xc00028ce40 for i, c := range mutated.toItems() {:0xc0000a45a8 for i, c := range ordered {:0xc000c240e8 for i, c := range ordered[i+1:] {:0xc000c24118 for i, e := range cNode.entries {:0xc0004a4760 for i, e := range e2 {:0xc00028d1e8 for i, e := range entries {:0xc0001bf580 for i, e := range n.entries {:0xc00000eb78 for i, entry := range entries {:0xc000191f88 for i, index := range other.indices {:0xc0002245c0 for i, index := range toDelete {:0xc0004a57f8 for i, item := range *items {:0xc0004a5628 for i, j := range indices {:0xc000a13978 for i, k := range action.keys() {:0xc000a13128 for i, k := range keys {:0xc0004a5bf8 for i, k := range n.keys.list {:0xc000826c98 for i, key := range action.keys() {:0xc000a13698 for i, key := range action.rects() {:0xc000c24b18 for i, key := range keys {:0xc0004a5110 for i, key := range n.ChildKeys {:0xc0001bfff8 for i, key := range result {:0xc00000f5a0 for i, n := range action.nodes() {:0xc000827010 for i, n := range nm.vars {:0xc00028cf40 for i, offset := range sba.indices {:0xc000c24d70 for i, otherPoint := range other.vars {:0xc000a13e08 for i, start := range starts {:0xc000826148 for i, sub := range cn.array {:0xc0000a41c0 for i, v := range vertices {:0xc000225570 for i, value := range n.ChildValues {:0xc0001bfc98 for i, value := range sba.indices[selfIndex:] {:0xc000a13078 for i, wh := range n.nodes.list {:0xc0008268c0 for i, x := pos, uint32(0); x < length-pos-1; i++ {:0xc000826890 for i, x := pos, uint32(0); x < length-pos; i++ {:0xc0001bf5c0 for id, bundles := range nodes {:0xc000a132a8 for id, keys := range splitNodes {:0xc000225b00 for id, path := range nodes {:0xc000225a80 for isz > 0 {:0xc0002247d0 for it := iter; it.Next(); {:0xc0006aa9c8 for item := range set.items {:0xc0009133e8 for iter := iter; iter.Next(); {:0xc000191d58 for iter := n.iter(t.config.Comparator, start, stop); iter.next(); {:0xc0004a55a0 for iter := other.Blocks(); iter.Next(); {:0xc00000e2f8 for iter := sl.Iter(skipEntry(0)); iter.Next(); {:0xc0002258e0 for iter := sl.Iter(skipEntry(lowValue)); iter.Next(); {:0xc000a139c8 for iter := yfast.Iter(0); iter.Next(); {:0xc0004a5cd8 for iter.Next() {:0xc000224728 for j := 0; j < b.N; j++ {:0xc0004a5df8 for j := 0; j < dimensions; j++ {:0xc0006aae88 for j := 0; j < len(xns); j++ {:0xc0001bf6e0 for j := 0; j < maxRuns; j++ {:0xc00028d500 for j := 0; j < num; j++ {:0xc000c24ab0 for j := 0; j < numItems; j++ {:0xc0004a5500 for j := 0; j < numItemsY; j++ {:0xc000224a80 for j := 0; j < numRoutines; j++ {:0xc0004a4ae8 for j := 0; j <= i; j++ {:0xc0004a49c8 for j := i + 1; j < len(*keys); j++ {:0xc0001be9b8 for j := i + 1; j < len(*ns); j++ {:0xc000c24c00 for j := i + 1; j < len(n.nodes); j++ {:0xc0006ab318 for j := i + 1; j <= len(keys); j++ {:0xc000225608 for j := i; j < len(*nodes); j++ {:0xc0004a57b0 for j := i; j < len(cp); j++ {:0xc0008277e0 for j := i; j < n.keys.len(); j++ {:0xc000a13510 for j := i; j < uint64(len(ks.list)); j++ {:0xc000a13238 for j := i; j < uint64(len(ns.list)); j++ {:0xc0000a48b8 for j := int64(0); j < int64(numItems); j++ {:0xc000826978 for j := int64(0); j < numItems; j++ {:0xc000224690 for j := uint64(0); j < numItems; j++ {:0xc00039d280 for k := 0; k < numCPU; k++ {:0xc0001bf700 for k := range set.items {:0xc000288220 for key := range g.adjacencyList[v] {:0xc00028c650 for len(*items) > childL {:0xc00039c3e0 for len(items) < num {:0xc0004a5940 for len(nodes) != 0 {:0xc00039ca38 for len(nodes) > 0 {:0xc000225a68 for len(whs) > 0 {:0xc0000a5638 for level = uint8(1); level < maxLevel-1; level++ {:0xc00028c318 for low <= high {:0xc0004a4cf8 for mustRemove > 0 {:0xc0004a4130 for n != nil && n != root {:0xc000c24e70 for n != nil && n.parent != nil {:0xc000224470 for n != nil {:0xc0000a5130 for n := range adds {:0xc0004a5b08 for n := range deletes {:0xc0004a5b28 for n.forward[offset] != nil && n.forward[offset] != alreadyChecked && n.forward[offset].Compare(cmp) < 0 {:0xc0008273a0 for n.forward[offset] != nil && pos+n.widths[offset] <= position {:0xc000a13a10 for n.needsSplit() {:0xc00028c850 for n.needsSplit(t.config.NodeWidth) {:0xc000c25180 for n.parent != nil {:0xc0000a5170 for node.children[dir] != nil {:0xc000a12110 for node.lenValues() < needsMerged || sibling.lenValues() < needsMerged {:0xc0000a4a10 for ok := true; ok; ok = (curr != min.child) {:0xc0009136f0 for otherIndex, otherValue := range other.indices {:0xc000913378 for p = s; p != q; p = p.children[normalized] {:0xc0002254d8 for packets[i] != nil && packets[i].key != key {:0xc000a12d60 for packets[i] != nil {:0xc00039cee0 for parent != nil && !parent.isLeaf {:0xc0006aa9f0 for parent >= 0 && (*items)[parent].Compare(item) > 0 {:0xc000c24bb8 for parent.keys.byPosition(i) == key {:0xc0006aab08 for pb.prev != nil {:0xc000225670 for ptree.actions.Len() > 0 {:0xc00039d048 for s := int32(n / 2); s > 0; s /= 2 {:0xc000912ec0 for s := int64(1); s < int64(n); s *= 2 {:0xc000191f00 for s, p = helper.children[1], helper.children[1]; ; {:0xc000225428 for selfIndex, selfValue := range ba.indices {:0xc0006aa670 for selfIndex, selfValue := range sba.indices {:0xc000913320 for sl.head.forward[sl.level-1] == nil && sl.level > 1 {:0xc000c250c8 for sl.level > 1 && sl.head.forward[sl.level-1] == nil {:0xc00000f928 for start < stop {:0xc0001914a8 for t.config.Comparator(stop, cur) > 0 {:0xc0001bfad8 for top-1 >= 0 && done == 0 {:0xc00028d0c0 for tree.actions.Len() > 0 {:0xc000826ed8 for xvk := range z {:0xc000826948 for {:0xc00000eed8 forCache.js = append(forCache.js, -1):0xc0001bf6e8 formerWidth := cache[i].widths[i]:0xc0001bfa60 forward:	make(nodes, maxLevels),:0xc0006aa6a8 found := make(Keys, 0, len(keys)):0xc0001be2e8 found := map[uint64]bool{}:0xc0000a4280 found := node.keys[i]:0xc000913438 found = append(found, blink.get(k)):0xc0001be2f0 found = node:0xc000a12130 found, ok := Empty.Find(pred):0xc000225870 found, ok := l.Find(func(sn interface{}) bool {:0xc0001bfee8 found, ok = l.Find(pred):0xc000225888 found, parent, grandParent	*node:0xc000a12018 found.interval, found.max, found.min, found.id = node.interval, node.max, node.min, node.id:0xc000a12758 found[id.ID()] = true:0xc0000a4290 fromTree := tree.Get(keys...):0xc000a13768 func() {:0xc0000a42f8 func(e Entry) bool {:0xc0008262b0 func(i int) bool { return nodes[i].value >= value },:0xc0009a04d8 func(str interface{}) uint {:0xc0001be630 future = futures.New(completer, 30*time.Second):0xc0008270a8 future, ok := c.cache[string(key)]:0xc000827080 g.addVertex(v):0xc00039d180 g.addVertex(w):0xc00039d188 g.adjacencyList[v] = mm:0xc0009132e0 g.adjacencyList[v][w] = struct{}{}:0xc00039d1a0 g.adjacencyList[w][v] = struct{}{}:0xc00039d1a8 g.e++:0xc00039d1b0 g.mutex.Lock():0xc00039d160 g.mutex.RLock():0xc000191cf0 g.v++:0xc0009132e8 ga := &getAction{:0xc000224918 ga := action.(*getAction):0xc000826f00 ga := newGetAction(keys):0xc000c24338 ga := newGetAction(rect):0xc00028d2f0 ga.completer.Add(1):0xc0002249e8 ga.completer.Done():0xc00000ef20 ga.completer.Wait():0xc000c24348 ga.result = rects:0xc000c24b38 ga.result = result:0xc000826f10 gcasComplete(in, n, ct):0xc0006aa048 gen := &generation{}:0xc00000f840 gen:	gen,:0xc00000f858 get(n, defaultHasher(i), i):0xc000913828 getTest(t, collisionHash, 1000):0xc00000f2d0 getTest(t, defaultHasher, 10000):0xc00000f2c8 go c.asyncLoadNode(t, key, completer):0xc0008270b8 go func() {:0xc0004a50c0 go func(chunk Keys, offset uint64) {:0xc0008261a0 go func(i int) {:0xc0006aac20 go func(i int, id string, bundles []*nodeBundle) {:0xc000a132b0 go func(i, j int) {:0xc0004a4af8 go func(id ID, keys Keys) {:0xc000225b08 go listenForResult(f, completer, timeout, &wg):0xc00028c760 go ptree.disposer(&wg):0xc0000a5350 go ptree.operationRunner(ptree.cache, true):0xc00039d068 go tree.operationRunner(tree.cache, true):0xc000826ef8 grandParent, parent, node = parent, node, node.children[dir]:0xc0001bfc40 grandParent.children[localDir] = doubleRotate(:0xc000a12508 grandParent.children[localDir] = rotate(:0xc000a12520 grandParent.children[localDir].children[0].red = false:0xc000a12530 grandParent.children[localDir].children[1].red = false:0xc000a12538 grandParent.children[localDir].red = true:0xc000a12528 greater than max dimension: %d`,:0xc00028c290 guess := &nmVertex{:0xc0006aaeb8 h := Encode(0, 0):0xc0006ab090 h := Encode(x, y):0xc00028cab0 h := h.Encode(getCenter(r)):0xc00028c7d0 h := hash(key):0xc000a12d50 h = Encode(0, 1):0xc0006ab0f0 h = Encode(1, 0):0xc0006ab0b8 h = Encode(1, 1):0xc0006ab0d8 hasImmediateSibling := false:0xc000224340 hasImmediateSibling = true:0xc000224458 hasPredecessor := predecessor != nil:0xc0000a5408 hasResult := f.triggered:0xc00000e128 hasSuccesor := successor != nil:0xc0000a5140 hash(key):0xc000225000 hash:	c.hash(key),:0xc0002259f0 hashFactory = defaultHashFactory:0xc0006ab4d8 hashFactory:	hashFactory,:0xc000a13c58 hasher := c.hashFactory():0xc00000fb58 hasher := fnv.New32a():0xc0004a5288 hasher := fnv.New64():0xc00039d228 hasher = defaultHasher:0xc00028c378 hasher.Sum64():0xc00039d238 hasher.Write([]byte(fmt.Sprintf("%#v", value))):0xc0004a5290 hasher.Write(k):0xc00000fb60 hasher:	hasher,:0xc00028c390 hb := action.rects()[j]:0xc0001bf740 head, _ := l.Head():0xc000827878 head, ok := Empty.Head():0xc0000a4f90 head, ok := l.Head():0xc000a137d0 head, ok := l1.Head():0xc0006aac98 head, ok = l.Head():0xc000a137f0 head, ok = l1.Head():0xc0006aacc8 head, ok = l2.Head():0xc0006aacf8 head, ok = tail.Head():0xc0006aace0 heap := NewFloatFibHeap():0xc0009124f8 heap = NewFloatFibHeap():0xc0001bfe20 heap, _ := heap1.Merge(&heap2):0xc000c249a8 heap, err := heap1.Merge(&heap2):0xc0004a58a8 heap.DecreaseKey(node, SomeSmallerNumber):0xc000a12498 heap.DecreaseKey(sliceE[i%N], sliceFlt[i%N]-offset):0xc00028ced8 heap.Delete(node):0xc0004a4010 heap.DequeueMin():0xc0001bf218 heap.Enqueue(0):0xc0000a5560 heap.Enqueue(1):0xc000c24c88 heap.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)):0xc0001bfeb8 heap.Enqueue(NumberSequence1[i]):0xc000a12a88 heap.Enqueue(NumberSequence2[i]):0xc0006ab048 heap.Enqueue(SomeLargerNumber):0xc000191cc8 heap.Enqueue(SomeNumber):0xc000191cc0 heap.Enqueue(slice[i]):0xc000a13c08 heap.min = curr:0xc0009137f8 heap.min = heap.min.next:0xc0009136d8 heap.min = mergeLists(heap.min, min.child):0xc000913708 heap.min = mergeLists(heap.min, node):0xc0006ab568 heap.min = mergeLists(heap.min, singleton):0xc000a12de8 heap.min = nil:0xc0009136c0 heap.min = node:0xc000a13b98 heap.min.next.prev = heap.min.prev:0xc0009136d0 heap.min.prev.next = heap.min.next:0xc0009136c8 heap.size = 0:0xc000c25078 heap.size++:0xc000a12df0 heap.size--:0xc000c24cf0 heap1 := NewFloatFibHeap():0xc00028c4e0 heap1.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)):0xc000c253a8 heap1.Enqueue(NumberSequence3[i]):0xc0004a5890 heap1.Enqueue(NumberSequence4[i]):0xc0004a58a0 heap1.Enqueue(SomeLargerNumber):0xc000c24978 heap1.Enqueue(SomeNumber):0xc000c24970 heap2 := NewFloatFibHeap():0xc00028c500 heap2.Enqueue(2 * 1E10 * (rand.Float64() - 0.5)):0xc000c253b0 heap2.Enqueue(SomeSmallerNumber):0xc000c24980 heir := it.children[1]:0xc00028d068 heir = heir.children[0]:0xc00028d090 helper			= &dummy:0xc0001bfb88 helper		= &dummy:0xc000225418 helper = grandParent:0xc0001bfc38 helper = p:0xc0002254a8 helper.children[1] = immutable.root:0xc000225420 helper.children[1] = tree.root:0xc0001bfb90 helper.children[intFromBool(helper.children[1] == q)] = s:0xc000225530 helper.children[localDir] = doubleRotate(grandParent, otherLast):0xc0001bfc08 helper.children[localDir] = rotate(grandParent, otherLast):0xc0001bfc00 high = mid - 1:0xc0004a4fa8 highest:	ba.highest,:0xc00028cc08 highestValue = n.lastValue():0xc000225918 highestValue = n.valueAt(i):0xc000225930 highs:	highs,:0xc0004a50f0 hint = 16:0xc0001be130 hint = results.search(result):0xc00028c968 hint = roundUp(hint):0xc0001be168 hm := New(10):0xc0006aad48 hm := New(numItems * 2):0xc000826240 hm := hms[i]:0xc0004a47a0 hm := make(map[uint64]uint64, 10):0xc000a13e20 hm := make(map[uint64]uint64, numItems*2):0xc000a136c8 hm.Delete(5):0xc0001bf3d8 hm.Delete(6):0xc0001bf3f0 hm.Delete(i):0xc0006ab210 hm.Delete(j):0xc0004a47a8 hm.Exists(key):0xc0008278c0 hm.Set(5, 10):0xc000224a40 hm.Set(5, 5):0xc0006aad50 hm.Set(6, 6):0xc00000e0b8 hm.Set(i, i):0xc000c24af0 hm.Set(j, j):0xc0004a4790 hm.Set(k, k):0xc000826268 hm.Set(key, key):0xc0008278b8 hm[j] = j:0xc00028cca0 hm[k] = k:0xc000a136d0 hm[key] = key:0xc0004a46e8 hms := make([]*FastIntegerHashMap, 0, b.N):0xc0004a4788 hms := make([]map[uint64]uint64, 0, b.N):0xc00028cc98 hms = append(hms, hm):0xc0004a4798 i	int64:0xc0001bf6c8 i -= j:0xc0002251f0 i := (len(*keys) / 2) - 1:0xc0001be710 i := (len(n.keys) / 2):0xc000225240 i := 0:0xc00028c648 i := atomic.AddInt64(&done, 1):0xc0008272d0 i := bundle.(*entriesWrapper).entries.search(key):0xc000c24f18 i := cp.search(index):0xc0008277d8 i := cp.search(item.Value):0xc0001bf350 i := entries.search(entry.Key()):0xc00039ce90 i := entries.search(key):0xc0009133a8 i := h & (uint64(len(packets)) - 1):0xc000a12d58 i := key/uint64(yfast.bits) + 1:0xc000912c20 i := keySearch(lnode.keys, key):0xc0001bf920 i := keys.search(key):0xc0001be1e0 i := ks.search(k):0xc0001bf250 i := ks.search(key):0xc0008263b0 i := len(n.keys) / 2:0xc0009135f0 i := len(node.keys) / 2:0xc000826170 i := len(pattern) - 1:0xc000a13568 i := n.keys.search(kb.key):0xc000827938 i := n.keys.search(key):0xc000c24c70 i := n.search(aa.start):0xc000a134f8 i := n.search(comparator, k.Value):0xc000a13928 i := n.search(comparator, key.Value):0xc0008274f0 i := n.search(comparator, value):0xc0006ab298 i := n.search(key):0xc0001beea8 i := node.search(key):0xc000913420 i := nodes.search(index):0xc0004a57a0 i := nodes.search(node.value):0xc0009a05a8 i := nodes.search(value):0xc00000e9e8 i := o.search(item.Value):0xc0009135a0 i := p.search(key):0xc00000ef38 i := packets.find(key):0xc0009130a8 i := packets.find(packet.key):0xc00028c330 i := parent.search(k):0xc00028c8c8 i := parent.search(key):0xc000191458 i := parentPath.i:0xc000225ae0 i := pb.prev.i:0xc0002256c0 i := results.search(vertex):0xc00028ca70 i := s.Search(x):0xc0004a5140 i := sba.indices.get(index):0xc00000f558 i := sort.Search(len(ks.list), func(i int) bool {:0xc000225188 i := start2 - start1:0xc0002251a0 i := symSearch(u, w):0xc000c24f58 i := u.search(x):0xc0009129d0 i := uint8(1):0xc000224318 i := uintSlice(sba.indices[selfIndex:]).search(otherI):0xc0002257c0 i = (i + 1) & (uint64(len(packets)) - 1):0xc000a12d68 i = 0:0xc0006aab78 i = j:0xc000225610 i++:0xc0006aab50 i, inserted := sba.indices.insert(index):0xc0008271d0 i, pos := getIndexAndRemainder(k):0xc00039d2c8 i, r := getIndexAndRemainder(size):0xc0004a4b28 i--:0xc0006aaf38 i1 := NewImmutable():0xc0004a56e0 i1, _ = i1.Insert(k):0xc000224400 i1, deleted = i1.Delete(k):0xc000224410 i2, _ := i1.Insert(entries...):0xc00028d430 i2, _ := i1.Insert(m1, m2, m3):0xc000a13d28 i2, _ := i1.Insert(m1, m2, m3, m4, m5):0xc0000a55f0 i2, _ := i1.Insert(m2, m1, m3, m4):0xc00028d340 i2, overwritten := i1.Insert(m1, m2):0xc0004a56f8 i2, overwritten := i1.Insert(m1, m2, m3):0xc0006ab1a0 i3, deleted := i2.Delete(entries...):0xc00028d438 i3, deleted := i2.Delete(m1):0xc0000a5600 i3, deleted := i2.Delete(m1, m2, m3, m4):0xc00000faf0 i3, deleted := i2.Delete(m3):0xc00000f888 i3, deleted = i2.Delete(entries...):0xc00028d448 i3, deleted = i2.Delete(m3):0xc0006aa018 i3, overwritten := i2.Insert(m3):0xc0004a5730 i3, overwritten := i2.Insert(m4):0xc000a13d30 i3, overwritten := i2.Insert(m4, m5):0xc0006ab1d8 i4, deleted := i3.Delete(m2):0xc00000f8a8 i5, deleted := i4.Delete(m1):0xc00000f8c8 iNode := &iNode{main: main, gen: gen}:0xc000225150 ia := &insertAction{:0xc0001be278 ia := newInsertAction(keys):0xc00028cdb8 ia := newInsertAction(rects):0xc00028d250 ia.completer.Add(1):0xc0001be290 ia.completer.Done():0xc000191de8 ia.completer.Wait():0xc00028cdc8 ia.ns[i] = n:0xc0004a5510 ic := nm.insideContract(vertices, midpoint, reflection):0xc00028d5a0 id				= iv.ID():0xc000a12038 id			= iv.ID():0xc0001bfb70 id := make([]byte, 16):0xc0000a5058 id := mutable.ID():0xc000c25520 id := node.keyAt(0):0xc0000a4738 id := rt.ID():0xc0006aa228 id = key.ID():0xc0001bfe10 id, _ := iter.value():0xc0004a55a8 id:		id,:0xc00039cd40 ids := []int{6, 2, 9, 0, 3, 4, 7, 1, 8, 5}:0xc00000f578 idx += 1:0xc000a13790 idx := (hashcode >> lev) & 0x1f:0xc000c24150 idx := 0:0xc000a13778 idx := Empty.FindIndex(pred):0xc000a13c68 idx := l.FindIndex(func(sn interface{}) bool {:0xc000a13bb8 idx = l.FindIndex(pred):0xc000a13c78 if !affectedDimension {:0xc000224730 if !allowDuplicate && n != nil && n.Compare(cmp) == 0 {:0xc0001bf9f8 if !assert.Contains(t, result, p) {:0xc0004a5d40 if !assert.Equal(t, Keys{k1, k2, k3, k4}, tree.Get(k1, k2, k3, k4)) {:0xc0006ab380 if !assert.Equal(t, Keys{k1, k2, k3}, tree.Get(k1, k2, k3)) {:0xc000c24ce0 if !assert.Equal(t, Keys{k1}, tree.Get(k1)) {:0xc000826de8 if !assert.Equal(t, c, result[i]) {:0xc00000f9a8 if !assert.Equal(t, common.Comparators{m1, m2}, tree.Get(m1, m2)) {:0xc0001be698 if !assert.Equal(t, expected, result) {:0xc00000f990 if !assert.Equal(t, items, result) {:0xc0004a5da0 if !assert.Equal(t, items[5:10], result) {:0xc00028ce30 if !assert.Equal(t, keys, result) {:0xc0000a5678 if !assert.Equal(t, keys, tree.Get(keys...)) {:0xc0008271c0 if !assert.Equal(t, keys1, tree.Get(keys1...)) {:0xc0008274a8 if !assert.Equal(t, keys2, tree.Get(keys2...)) {:0xc0008274b8 if !assert.Equal(t, mutated.toItems(), result) {:0xc0000a4590 if !assert.Equal(t, n.keys.len()+1, n.nodes.len()) {:0xc000826c90 if !assert.Equal(t, ordered[i+1:].toItems(), result) {:0xc000c24100 if !assert.False(t, i < 0, fmt.Sprintf(`Too many parents. NODE: %+v, PATTERN: %+v`, bottomNode, pattern)) {:0xc000a13578 if !assert.False(tb, n.needsSplit(t.config.NodeWidth)) {:0xc000a13d78 if !assert.Len(t, n.keys, 2) {:0xc000c24da0 if !assert.Len(t, n.nodes, len(n.keys)+1) {:0xc0004a5490 if !assert.Len(t, q.items, 2) {:0xc0004a52e0 if !assert.Len(t, result, 1) {:0xc000913800 if !assert.Len(t, results[0], 1) || !assert.Len(t, results[1], 1) {:0xc000a13b28 if !assert.Nil(t, err) {:0xc00039d1d8 if !assert.NotNil(t, child) {:0xc000826db0 if !assert.NotNil(t, nd) {:0xc000826d00 if !assert.True(t, k.Compare(nd.key()) < 0) {:0xc000826d98 if !assert.True(t, k.Compare(nd.key()) >= 0) {:0xc000826d28 if !assert.True(t, n.keys[i].Compare(n.nodes[i].key()) >= 0) {:0xc0004a54a0 if !assert.True(t, n.nodes[len(n.nodes)-1].key().Compare(n.keys.last()) > 0) {:0xc0004a54b0 if !ba.Equals(other) {:0xc00039d2e8 if !ba.Intersects(other) {:0xc00000ea10 if !ba.anyset {:0xc00039d2a0 if !ba.blocks[i].intersects(block) {:0xc0004a4a20 if !ba.blocks[index].intersects(other.blocks[i]) {:0xc0002245d0 if !ba.blocks[selfIndex].equals(otherBlock) {:0xc0001bff38 if !bytes.Equal(sn.Key, entry.Key) {:0xc000224200 if !c.iinsert(root, entry, 0, nil, root.gen) {:0xc0004a5e80 if !checkNode(t, child) {:0xc000826db8 if !checker(item) {:0xc0004a5630 if !child.needsSplit(tree.nodeSize) {:0xc00000e970 if !ctrie.readOnly {:0xc0004a4418 if !equal(n.nodes.list[i], kb.left) {:0xc000225a48 if !firstSeen || !secondSeen {:0xc000191a80 if !fn(e.(*lastBundle).entry) {:0xc000a139e0 if !fn(id) {:0xc0004a55b0 if !fn(nodes[index]) {:0xc0004a4838 if !gcas(p, pMain, toContracted(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {:0xc0000a43d8 if !inserted {:0xc0001bf960 if !irt.apply(n.orderedNodes, interval, dimension+1, fn) {:0xc00000eae0 if !isInf(nm.config.Target) {:0xc000c255f0 if !isInternal(n.children[0]) && n.children[0] != predecessor && n.children[0] != node {:0xc000c24ef8 if !isInternal(n.children[0]) && n.children[0] != successor {:0xc000c24e78 if !isInternal(n.children[1]) && n.children[1] != predecessor {:0xc0006ab408 if !isInternal(n.children[1]) && n.children[1] != successor && n.children[1] != node {:0xc000c24ef0 if !isRed(node) && !isRed(node.children[dir]) {:0xc000a12148 if !isRed(t.children[otherLast]) && !isRed(t.children[last]) {:0xc000a124e0 if !iter.Next() {:0xc0009131e8 if !list.apply(low, high, fn) {:0xc000a13820 if !list.apply(low, high, func(n *node) bool {:0xc000a13828 if !n.interval.OverlapsAtDimension(interval, i) {:0xc00039cf80 if !n.isLeaf {:0xc000c24c50 if !n.needsSplit(ptree.ary) {:0xc0006ab430 if !n.needsSplit(tree.ary) {:0xc0004a48f8 if !newNode.dataMap.GetBit(index) && !newNode.nodeMap.GetBit(index) {:0xc000a134c0 if !next {:0xc000c24620 if !nm.checkIteration(vertices) {:0xc00028d510 if !node.IsLeaf {:0xc0000a4a78 if !o.equal(o[i], item) {:0xc0009135b8 if !ok {:0xc000c24640 if !ot.apply(n.orderedNodes, interval, dimension+1, fn) {:0xc000a13830 if !overlaps(n.interval.HighAtDimension(1), high, n.interval.LowAtDimension(1), low) {:0xc00039cf68 if !parent.needsSplit() {:0xc0000a5108 if !pq.allowDuplicates {:0xc000c25030 if !q.Empty() {:0xc0004a59d0 if !reflect.DeepEqual([]interface{}{`test`}, set.Flatten()) {:0xc000191a30 if !reflect.DeepEqual([]interface{}{}, set.Flatten()) {:0xc000224f88 if !reflect.DeepEqual(flatten1, flatten2) {:0xc000a13408 if !result {:0xc000a12d40 if !rt.apply(e.(*dimensionalBundle).sl, dimension+1, interval, fn) {:0xc000a139e8 if !sba.blocks[i].intersects(otherBlock) {:0xc0002257d8 if !sba.blocks[selfIndex].equals(otherBlock) {:0xc00000e8f0 if !set.Exists(`test1`) {:0xc00000f0d8 if !set.Exists(`test`) {:0xc0004a5158 if !succeeded {:0xc0004a5d50 if !t.context.nodeExists(n.ID) {:0xc0004a5650 if !t.context.nodeExists(node.ID) {:0xc0002255d8 if !t.context.nodeExists(parent.ID) {:0xc000225690 if !t.filter(cur, stop, n, fn) {:0xc0001bfb00 if !useCache {:0xc000827070 if !vertices[0].good {:0xc00028d4e8 if (*entries)[i].Key() != key {:0xc0009133b0 if (*entries)[i].Key() == entry.Key() {:0xc00039cea8 if (*items)[child].Compare((*items)[index]) < 0 {:0xc00039c490 if (*keys)[i].Compare(key) == 0 {:0xc0001be548 if (*nodes)[i].value != value || i == len(*nodes) {:0xc00000e9f0 if (*nodes)[i].value == node.value {:0xc0009a0558 if (*nodes)[i].value == value {:0xc000c24c40 if (*nodes)[j].value < index {:0xc0004a57c0 if (*u)[i] == x {:0xc000912a88 if (*z)[bzg] == nil {:0xc000a13740 if (sibling.lenValues()+node.lenValues())/2 >= needsMerged {:0xc0000a4a00 if NumberSequence2[i] == Seq2DecreaseKey1Orig {:0xc0006ab018 if _, ok := adds[n]; !ok {:0xc0004a5b30 if _, ok := err.(OutOfRangeError); !ok {:0xc00039cf50 if _, ok := g.adjacencyList[v][w]; ok {:0xc00039d190 if _, ok := mp[c.Value]; ok {:0xc0004a5950 if _, ok := seen[string(n.ID)]; ok {:0xc0001bfaf8 if _, ok := set.items[item]; !ok {:0xc0004a54f8 if aa.stop.Compare(k) < 1 || !aa.fn(k) {:0xc000a13520 if abort {:0xc000224ad8 if action != nil {:0xc00039d028 if assert.Len(t, results[0], 1) && assert.Len(t, results[1], 1) {:0xc000224518 if assert.Nil(t, err) {:0xc0004a4ee0 if assert.NoError(t, err) {:0xc0000a4fe0 if assert.True(ok) {:0xc0000a5750 if atomic.AddUint64(&counter, 1) == uint64(b.N) {:0xc000a13fa8 if atomic.CompareAndSwapPointer(:0xc0006aa030 if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)),:0xc0000a44b0 if atomic.CompareAndSwapUint64(&ptree.running, 0, 1) {:0xc00039d038 if atomic.CompareAndSwapUint64(&rb.dequeue, pos, pos+1) {:0xc0001bf308 if atomic.CompareAndSwapUint64(&rb.queue, pos, pos+1) {:0xc000a12f38 if atomic.CompareAndSwapUint64(&tree.running, 0, 1) {:0xc000826ed0 if atomic.LoadUint32(&f.filled) == 0 {:0xc0009131c0 if atomic.LoadUint32(&f.filled) == 1 {:0xc000c245a8 if atomic.LoadUint64(&ptree.disposed) == 1 {:0xc0004a5ce8 if atomic.LoadUint64(&rb.disposed) == 1 {:0xc000a12458 if b&block(1<<i) > 0 {:0xc000191a10 if b&test == test {:0xc00039ccb0 if b.calculateBytes != nil {:0xc0001bebc8 if b.disposed {:0xc0001beba8 if b.lock.TryLock() {:0xc00000f520 if b.maxBytes != 0 && b.availableBytes >= b.maxBytes {:0xc000c24d88 if b.maxItems != 0 && uint(len(b.items)) >= b.maxItems {:0xc000c24d80 if b.maxTime > 0 {:0xc00000f508 if b.ready() {:0xc0001bebd8 if ba, ok := other.(*sparseBitArray); ok {:0xc0006ab478 if ba.Equals(other) {:0xc00039d310 if ba.Intersects(other) {:0xc00000ea28 if ba.anyset {:0xc00039c410 if ba.blocks[i] == 0 {:0xc000191c08 if ba.blocks[i] > 0 {:0xc0001bff28 if best.euclideanDistance(v) >= delta {:0xc000c25600 if blink.root == nil {:0xc000913140 if bundle != nil {:0xc00000ea60 if bundle == nil {:0xc0001be6a8 if bytes.Equal(sn.Key, entry.Key) {:0xc000224450 if bytesRead < 0 {:0xc000a984a8 if c != nil {:0xc00039d320 if c == 100 {:0xc0001bf4b8 if c.casRoot(old, desc) {:0xc0006aa0b8 if c.casRoot(r, nv) {:0xc000224b08 if c.casRoot(r, ov) {:0xc000224ae0 if c.children[0] != nil {:0xc00039d330 if c.children[1] != nil {:0xc00039d340 if c.rdcssRoot(root, gcasRead(root, c), newRoot) {:0xc00000f860 if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {:0xc00028d178 if c.readOnly {:0xc00028d298 if c.readOnly || startGen == in.gen {:0xc000224430 if cache[i].forward[i] != nil {:0xc0001bfa80 if cache[i].forward[i] == nil {:0xc0001bfa98 if cached == nil {:0xc0004a5120 if cached, ok := c.items[key]; ok {:0xc0001be608 if cap((*z)) >= int(xsz) {:0xc000a13708 if cap(z.ChildKeys) >= int(xsz) {:0xc00028cb20 if cap(z.ChildValues) >= int(xsz) {:0xc00028caf8 if checker == nil {:0xc00000e908 if child == nil {:0xc00028c008 if child.needsSplit(tree.nodeSize) {:0xc0001bf040 if choices[i] < min {:0xc000c24cc0 if cn.bmp&flag == 0 {:0xc000224190 if cn.gen != i.gen {:0xc0002241a0 if comparator(o[i], stop) > 0 {:0xc00000e038 if config.Target == max {:0xc000826440 if config.Target == min {:0xc000826428 if cp[j].value < index {:0xc000827800 if cr, ok := left.(*lnode); ok {:0xc00000ef40 if ctx {:0xc0000a5368 if curr.Priority <= heap.min.Priority {:0xc0009137f0 if db.id == keyed.key() {:0xc000c24870 if db.id > keyed.key() {:0xc000c24878 if db.sl.Len() == 0 {:0xc000827458 if dba, ok := other.(*bitArray); ok {:0xc000827318 if dba.Capacity() == 0 || !dba.anyset {:0xc0006ab140 if deleted != nil {:0xc000a135e0 if dimension == insertDimension {:0xc0002245f0 if dimension > irt.dimensions || number == 0 {:0xc000a13190 if dimension > ot.dimensions || number == 0 {:0xc0004a5a00 if dimension > uint64(len(mi.dimensions)) {:0xc000190140 if dimension >= lastDimension {:0xc00028c358 if dimension >= rt.dimensions || number == 0 {:0xc00028cee0 if dir == 0 {:0xc00028cfc0 if dir > 0 {:0xc000225440 if dirs[top] != 0 {:0xc00028d0d0 if e != nil {:0xc0004a4948 if e == nil {:0xc00000f480 if e.Key() == key {:0xc00000f608 if eba, ok := ba.(*bitArray); ok {:0xc000c24158 if element != nil {:0xc0008266c8 if encodedanyset == 1 {:0xc0001bfe70 if entries[0] == nil {:0xc000827430 if entries[i].Key() == key {:0xc000c247f0 if entry != nil {:0xc0002248e0 if entry == nil {:0xc000191f90 if equal(n.nodes.list[i], kb.left) {:0xc000827948 if equal(parent.nodes.list[i], r1) {:0xc0006aab20 if err != io.EOF {:0xc0001bfea0 if err != nil {:0xc000a12cf8 if err := c.traverse(b, ch, cancel); err != nil {:0xc00000fa38 if err == ErrDisposed {:0xc0004a5de8 if err, ok := ifc.(error); ok {:0xc0008270c8 if expanded == best {:0xc00028d558 if expanded.less(nm.config, reflection) {:0xc00028d560 if expected {:0xc0000a4fe8 if f.filled == 0 {:0xc0004a5308 if f.triggered {:0xc000224f58 if f.wait == nil {:0xc00039ce50 if fi.packets.delete(key) {:0xc0004a4020 if float64(fi.count+1)/float64(len(fi.packets)) > ratio {:0xc00028c8f0 if formerWidth == 0 {:0xc0001bfa68 if found != nil {:0xc000a12748 if found, _ := found[uint64(i)]; !found {:0xc0000a4298 if gcas(i, main, &mainNode{cNode: cn.renewed(startGen, c)}, c) {:0xc0002241e8 if gcas(i, main, cntr, c) {:0xc0000a4118 if gcas(i, main, nln, c) {:0xc0000a4158 if generator.Float64() >= p {:0xc00028c320 if getLock {:0xc000a130e0 if grandParent != nil {:0xc0001bfc30 if guess.equalToVertex(vertex) {:0xc0006aaef0 if hasInternal(n) || (i == 1 && hasImmediateSibling) {:0xc000224478 if hasPredecessor {:0xc0000a5418 if hasSuccesor {:0xc0000a5150 if hash(1)%32 != 12 || hash(27)%32 != 12 || hash(42)%32 != 12 {:0xc0006ab238 if hashFactory == nil {:0xc0006ab4d0 if hasher == nil {:0xc00028c370 if heap == nil || other == nil {:0xc000c25050 if heap.IsEmpty() {:0xc00039ce08 if heap.Size() == 0 {:0xc000a12f18 if heap.Size() == 195 {:0xc000a12f08 if heap.Size() == 197 {:0xc000a12c20 if heap.Size() == 199 {:0xc000a12b48 if heap.min == nil {:0xc000913710 if hint < 0 {:0xc00028c960 if hint < len(results.vertices)-1 && results.vertices[hint].approximatelyEqualToVertex(result) {:0xc00028c978 if hint == 0 {:0xc0001be0a0 if hint > 0 && results.vertices[hint-1].approximatelyEqualToVertex(result) {:0xc00028c970 if i != 1 && !cache[i-1].Exists(node.value) {:0xc000826e30 if i != top-1 {:0xc00028d020 if i < 0 {:0xc000913538 if i < len(n.ChildValues) {:0xc000a13930 if i < len(o) && o.equal(o[i], item) {:0xc0001bf358 if i < len(result) {:0xc000c24128 if i < n.lenValues() {:0xc000225928 if i < xft.bits-1 {:0xc0001bf850 if i == -1 {:0xc00000f560 if i == 0 {:0xc0002251a8 if i == 5 {:0xc000826318 if i == b.N {:0xc000c25330 if i == int64(len(*u)) {:0xc000912a18 if i == int64(len(sba.indices)) {:0xc0002257c8 if i == int64(len(u)) {:0xc0001bf288 if i == irt.dimensions {:0xc00000f6c8 if i == j {:0xc0002251c0 if i == len(*entries) {:0xc00039ce98 if i == len(*keys) {:0xc0001be490 if i == len(*nodes) {:0xc000913018 if i == len(*ns) {:0xc0004a4e98 if i == len(cp) {:0xc0001bf368 if i == len(entries) {:0xc000c247e8 if i == len(lnode.keys) {:0xc0001bf930 if i == len(n.ChildValues) {:0xc0006ab2b8 if i == len(n.keys) {:0xc0001bef60 if i == len(node.keys) {:0xc000913428 if i == len(nodes) {:0xc000827050 if i == len(o) {:0xc0009135a8 if i == len(parent.keys) {:0xc000191460 if i == len(results.vertices) {:0xc00028ca80 if i == len(s) {:0xc0004a5148 if i == n.keys.len() {:0xc000a13500 if i == ot.dimensions {:0xc0008270e8 if i == parent.keys.len() {:0xc0006aab58 if i == parent.lenValues() {:0xc0000a47f8 if i == uint64(len(dba.blocks)) {:0xc0006ab160 if i == uint64(len(ks.list)) {:0xc0008263b8 if i == uint64(len(other.blocks)) {:0xc0006ab170 if i > 0 {:0xc00000ef48 if i > j {:0xc0002251e0 if i >= int64(len(*items)) {:0xc00000e990 if i >= int64(len(ifs)) {:0xc0008272d8 if i >= len(*nodes) {:0xc00000e178 if i >= uint64(len(ks.list)) {:0xc000a13308 if i%2 == 0 {:0xc000224550 if i%200 == 0 {:0xc0004a5a78 if i%3 == 0 {:0xc00000ef88 if i%N == 0 && i > 0 {:0xc00028cec8 if i, ok := positions[bundle.k.Value]; ok {:0xc0001bfcb0 if ic == best {:0xc00028d5a8 if ic.less(nm.config, nm.lastVertex(vertices)) {:0xc00028d5b0 if idx < 0 {:0xc000a13bc0 if ifc == nil {:0xc000c24728 if immediatePredecessor && n.parent == predecessor.parent {:0xc0000a5440 if immediateSuccessor && n.parent == successor.parent {:0xc0000a5188 if immutable.root != nil {:0xc000912758 if immutable.root == nil {:0xc0002253e0 if inParallel {:0xc000826fc8 if index == int64(len(*b)) {:0xc0001bf298 if index == len(nodes) {:0xc0004a4700 if index >= int64(len(xns)) {:0xc0001bf710 if index >= int64(todo) {:0xc00000f6a0 if index >= sl.Len() {:0xc0000a5800 if input[0] == 'B' {:0xc000a12ce0 if insertDimension == dimension {:0xc0004a5798 if inserted {:0xc0008271d8 if int64(e.(keyed).key()) >= highValue {:0xc000a139d8 if intersect(r, child) {:0xc000c253f8 if interval != nil {:0xc000c24850 if interval == nil {:0xc00039cf70 if intervalOverlaps(n, low, high, interval, maxDimension) {:0xc00000f1d8 if ints[i] < minInt {:0xc000225010 if ints[i] > maxInt {:0xc000c246d0 if isInf(config.Target) {:0xc0004a4bc8 if isInternal(n.children[0]) && isLeaf(n.children[1]) {:0xc00028cce8 if isInternal(n.children[1]) && isLeaf(n.children[0]) {:0xc000a13e78 if isInternal(n.parent.children[0]) && isInternal(n.parent.children[1]) {:0xc0000a5438 if isInternal(n.parent.children[1]) && isInternal(n.parent.children[0]) {:0xc0000a5180 if isLastDimension(dimension, rt.dimensions) {:0xc000827420 if isLastDimension(i, rt.dimensions) {:0xc00000f448 if isLastDimension(irt.dimensions, dimension) {:0xc00000ead8 if isLastDimension(irt.dimensions, i) {:0xc000826e28 if isLastDimension(ot.dimensions, dimension) {:0xc000a13818 if isLastDimension(ot.dimensions, i) {:0xc0004a5190 if isRed(node) {:0xc0000a5470 if isRed(node.children[0]) || isRed(node.children[1]) {:0xc0000a5478 if isRed(node.children[otherDir]) {:0xc000a124a8 if isRed(parent) && isRed(node) {:0xc0001bfbe8 if isRed(t.children[last]) {:0xc000a12500 if isRoot {:0xc000225660 if it == nil {:0xc00028cfb0 if it.children[0] == nil || it.children[1] == nil {:0xc00028d040 if item, ok := c.items[key]; ok {:0xc000826fa8 if item.(string) == `test` {:0xc000191a60 if iter.Value().Compare(key) == 0 {:0xc0009131f0 if iter.entries == nil || iter.index < 0 || iter.index >= len(iter.entries.entries) {:0xc000c247d0 if iter.first {:0xc000912038 if iter.index == iteratorExhausted {:0xc000826b48 if iter.index == iteratorExhausted ||:0xc000c246e8 if iter.index >= len(iter.entries.entries) {:0xc000c24610 if iter.index >= len(iter.node.keys) {:0xc000826b50 if iter.n == nil {:0xc000826838 if iter.node == nil {:0xc000826b60 if iterExhausted(iter) {:0xc000c245f8 if ivLow < node.min {:0xc0001bfbd8 if ivLow < nodeLow {:0xc0006aad88 if ivLow > nodeLow {:0xc0006aad80 if j != len(n.keys) {:0xc0006ab320 if j == 0 {:0xc0002251b8 if j == len(keys) {:0xc000225618 if j > int64(len(action.keys())) {:0xc0006ab3d0 if j > int64(len(action.rects())) {:0xc0001bf728 if k != nil && t.config.Comparator(k.Value, value) == 0 {:0xc0006aae10 if k < ba.lowest {:0xc00039d2b8 if k == ba.highest {:0xc0009136b0 if k == nil {:0xc0006aae38 if k >= ba.Capacity() {:0xc00039d290 if k.Compare(key) == 0 {:0xc00039d3d8 if kb.left != nil {:0xc0001bfd90 if kb.right.(*node).maxHilbert > n.maxHilbert {:0xc0008279a0 if key < xft.min.entry.Key() {:0xc00028ccc8 if key <= xft.min.entry.Key() {:0xc000a13e60 if key == nil {:0xc000a13148 if key > xft.max.entry.Key() {:0xc000a13e70 if key >= xft.max.entry.Key() {:0xc00028ccb8 if key.Compare(n.max()) < 1 {:0xc000a130d8 if key.value == mk.value {:0xc0000a52e0 if key.value > mk.value {:0xc0000a52e8 if ks.list[i] != k {:0xc0008273e0 if ks.list[i] == k {:0xc0004a5a38 if ks.list[i] == key {:0xc000c251b0 if ks.list[i].Compare(k) != 0 {:0xc0001bf258 if ks.list[i].Compare(k) == 0 {:0xc000827708 if ks.list[i].Compare(key) == 0 {:0xc0008263d0 if lastDimension {:0xc0004a57d0 if lastIndex >= selfIndex {:0xc0001bff48 if lb.id == keyed.key() {:0xc000826408 if lb.id > keyed.key() {:0xc000826438 if left != 0 && right != 0 && lh != rh {:0xc0000a5530 if left != 0 && right != 0 {:0xc0000a5540 if len(*items) == 0 {:0xc00028c988 if len(*items) > childR && (*items)[childR].Compare((*items)[childL]) < 0 {:0xc00039c480 if len(*nb.list) == 1 {:0xc000827610 if len(*nb.list) > 0 {:0xc0004a5590 if len(*ns) == 0 {:0xc0001bed10 if len(*w) == 0 {:0xc00000efe0 if len(action.keys()) > multiThreadAt {:0xc00039d0a8 if len(adds) == 0 && len(deletes) == 0 {:0xc0004a5ae8 if len(args) > 0 && args[0] == true {:0xc0004a4b58 if len(b) < 8 {:0xc000a12540 if len(bundles) == 0 {:0xc000a132b8 if len(cNode.entries) == 1 {:0xc0004a4770 if len(chunk) == 0 {:0xc0006aade8 if len(chunks) == 1 {:0xc0006aac78 if len(chunks[i]) == 0 {:0xc00028c7b0 if len(entries) == 0 {:0xc000191f78 if len(ew.entries) == 0 {:0xc0001be6c8 if len(id) == 0 {:0xc0001bfdc0 if len(ifs) == 0 {:0xc000827290 if len(indices) == len(n.ChildValues) {:0xc000a13958 if len(input) == 0 {:0xc000a12cd0 if len(items) == 0 {:0xc0004a4f90 if len(items) == 0 || items[0] == nil {:0xc0004a5a58 if len(items) > 0 {:0xc00039c9f0 if len(its) == 0 {:0xc000a120a0 if len(keys) == 0 {:0xc000913050 if len(keys) > numberOfItemsBeforeMultithread {:0xc00039d388 if len(mutated) == len(result) {:0xc0000a45a0 if len(n.keys) < 3 {:0xc0009135e0 if len(n.keys) == 0 {:0xc0004a5480 if len(n.keys) == 0 || n.right == nil {:0xc000a130d0 if len(node.keys) < 2 {:0xc000826168 if len(nodes) < 2 {:0xc000827170 if len(ordered) > 0 {:0xc0004a4290 if len(ordered[i+1:]) > 0 {:0xc000c24138 if len(other.indices) == 0 {:0xc00028c550 if len(pq.items) == 0 {:0xc0001bf468 if len(pq.items) > 0 {:0xc000c25040 if len(q.items) == 0 {:0xc0001bf528 if len(rects) == 0 {:0xc00000f258 if len(result) != 0 {:0xc000a139f0 if len(sba.indices) == 0 {:0xc00028c560 if len(set.flattened) != 0 {:0xc000a134d8 if len(set.flattened) != 1 {:0xc0001bf1e0 if len(t.Root) == 0 {:0xc0001bfac0 if len(toDelete) > 0 {:0xc000225a18 if len(toDelete) > len(node.ChildValues)/4 {:0xc000225638 if len(values) == 0 {:0xc0001be578 if lenU == 0 {:0xc0001bf970 if lenW == 0 {:0xc0001bf980 if length == 0 {:0xc00039d368 if length >= len(comparators) {:0xc0006aa110 if lerr.Get() != nil {:0xc0006aae20 if lev < exp2 {:0xc000225120 if lev > 0 && len(cn.array) == 1 {:0xc0004a4368 if lnode.keys[i].Compare(key) == 0 {:0xc0001bf948 if local == nil {:0xc000827598 if m == nil {:0xc0000a4480 if m.PutChan != nil {:0xc000c240d8 if main.cNode != nil {:0xc0002246c0 if main.tNode != nil {:0xc0000a4130 if math.Abs(best.distance-v.distance) >= delta {:0xc000c255f8 if math.Abs(float64(cache[top].balance)) == 1 {:0xc00028d0e8 if math.Abs(float64(diff)) > 1 {:0xc0001bf998 if math.Abs(float64(s.balance)) > 1 {:0xc000225508 if math.Abs(vertices[0].result-nm.config.Target) < delta {:0xc000c255e8 if math.IsInf(target, 1) {:0xc000913658 if max != -1 && max > node.max {:0xc0000a54a0 if max == -1 && node.max != node.interval.HighAtDimension(1) {:0xc0000a5510 if max > node.max {:0xc0001bfbc8 if maxBytes > 0 && calculate == nil {:0xc000191fc8 if mc == other.(mockComparator) {:0xc0004a4fd8 if mc > other.(mockComparator) {:0xc0004a4fe0 if me < otherMe {:0xc00039ce88 if me == otherU {:0xc000191758 if me > otherMe {:0xc00039ce80 if me > otherU {:0xc000191760 if mi > omi {:0xc000191778 if min != -1 && min < node.min {:0xc0000a5490 if min == -1 && node.min != node.interval.LowAtDimension(1) {:0xc0000a54d8 if min.child != nil {:0xc0009136e0 if min.next == min {:0xc000c24d00 if mk < otherK {:0xc00000e340 if mk == otherKey {:0xc0009127c8 if mk > otherK {:0xc00000e3a0 if mk > otherKey {:0xc0009127e0 if msgp.IsNil(bts) {:0xc000a13728 if n != nil && n.Compare(cmp) == 0 {:0xc0006ab670 if n != nil {:0xc000c24810 if n != other.vars[i] {:0xc00028cf48 if n == nil && highestValue == nil {:0xc0001bfae8 if n == nil && layer > 1 {:0xc00028ccd8 if n == nil {:0xc00039cd00 if n == nil || n.Compare(cmp) != 0 {:0xc00000f8f8 if n == nil || n.entry == nil {:0xc000c25560 if n, ok := wh.(*node); ok {:0xc0000a5648 if n.ChildValues[i] == key.Value {:0xc000827500 if n.IsLeaf && i == len(n.ChildKeys) {:0xc000827538 if n.IsLeaf && i == len(n.ChildValues) {:0xc0006ab2a0 if n.IsLeaf && len(bundles) >= n.lenValues()/16 {:0xc0004a5850 if n.IsLeaf {:0xc0006ab2a8 if n.balance == -bal {:0xc000225d10 if n.balance == bal {:0xc000c25450 if n.children[0] != nil && overlaps(n.children[0].max, high, n.children[0].min, low) {:0xc00000f1c8 if n.children[1] != nil && overlaps(n.children[1].max, high, n.children[1].min, low) {:0xc00000f1e8 if n.children[i] != nil {:0xc000913290 if n.children[leftOrRight] == nil || isLeaf(n.children[leftOrRight]) {:0xc0001bf840 if n.dataMap.GetBit(index) {:0xc00000f5c8 if n.entries[index] == nil {:0xc00000f5f0 if n.entry == nil {:0xc00000f360 if n.isLeaf && old == nil {:0xc0004a59c0 if n.isLeaf && oldKey == nil {:0xc0001bfd80 if n.isLeaf {:0xc000826878 if n.keys.byPosition(i) != kb.key {:0xc000225a40 if n.keys.len() == 0 {:0xc000826c48 if n.lenValues() == 0 {:0xc0002256f8 if n.level == 6 {:0xc00000f5e8 if n.needsSplit(ptree.ary) {:0xc0004a5bd0 if n.needsSplit(tree.ary) {:0xc000c254a8 if n.nodeMap.GetBit(index) {:0xc00000f5d8 if n.nodes.len() == 0 {:0xc000827978 if n.parent == nil {:0xc0004a5b10 if n.parent == predecessor.parent {:0xc0000a5428 if n.parent == successor.parent {:0xc0000a5160 if nb.newNode == nil {:0xc000827650 if nb.previousNode != nil {:0xc0008275f0 if needNextDimension {:0xc000191410 if needsDeletion(int64(e.(keyed).key()), index, number) {:0xc0002249d0 if needsMerged < 1 {:0xc0000a42d0 if newNode == nil {:0xc000225ab0 if newNode.dataMap.GetBit(index) {:0xc000a13478 if newNode.entries[index] == nil {:0xc000a13458 if newNode.entries[index].Key() == entry.Key() {:0xc000a13480 if newNode.level == 5 {:0xc000827250 if newNode.level == 6 {:0xc000a13450 if newNode.nodeMap.GetBit(index) {:0xc000a134c8 if newPriority >= node.Priority {:0xc000225398 if nln.lNode.length() == 1 {:0xc0000a4148 if nn.balance == 0 {:0xc0004a5e98 if node != nil {:0xc000913348 if node == nil {:0xc0004a5558 if node == parent.children[last] {:0xc0001bfbf8 if node.IsLeaf {:0xc0000a4a28 if node.Priority <= heap.min.Priority {:0xc000a13b90 if node.id == id {:0xc0001bfc10 if node.lenKeys() == 1 {:0xc0000a45f8 if node.lenValues() >= needsMerged {:0xc0000a4408 if node.next != node {:0xc0006ab520 if node.orderedNodes != nil {:0xc00028ca10 if node.parent != nil && node.Priority <= node.parent.Priority {:0xc000a13b80 if node.parent == nil {:0xc0006ab518 if node.parent.child == node {:0xc0006ab538 if node.parent.marked {:0xc0006ab570 if node.pointer == nil {:0xc0008273f0 if nodeLevel > sl.level {:0xc0001bfa20 if nodes[i].value == value {:0xc000827060 if nodes[index].value > high {:0xc0004a47d8 if normalized == 0 {:0xc0002254e8 if nsw.values[i] != nil {:0xc0001bfd08 if num == 0 {:0xc0000a4558 if numCPU > 1 {:0xc0008272a8 if numCPU%2 == 1 {:0xc0006aabf8 if number < 0 {:0xc000224718 if number < 1 {:0xc000c24dc8 if number > 0 {:0xc000224fc8 if oc == best {:0xc00028d580 if oc.less(nm.config, reflection) || oc.equal(nm.config, reflection) {:0xc00028d588 if offer {:0xc000a12f60 if ok {:0xc00039d210 if ok, _ := ba.GetBit(4); !ok {:0xc0006ab130 if ok, _ := ba.GetBit(5); ok {:0xc0006ab120 if oldTop != 0 {:0xc00028d0a0 if oldeMain == exp {:0xc000224af8 if one == -1 {:0xc000a12e28 if one == nil && two == nil {:0xc00000f708 if one > two {:0xc000a12e48 if one.Priority < two.Priority {:0xc00000f748 if other.Capacity() == 0 && !ba.anyset {:0xc0001bff08 if other.Capacity() == 0 && ba.highest > 0 {:0xc0001bff00 if other.Capacity() == 0 && sba.Capacity() > 0 {:0xc00000e2e8 if other.Capacity() == 0 {:0xc0002257a8 if other.Capacity() == 0 || !other.anyset {:0xc000a13040 if other.Capacity() > ba.Capacity() {:0xc0006ab5b8 if other.IsEmpty() {:0xc0006aa148 if other.Priority < curr.Priority {:0xc000913780 if otherBlock > 0 {:0xc00000e8d0 if otherIndex < sba.indices[selfIndex] {:0xc00000e8e0 if otherIndex > sba.indices[selfIndex] {:0xc00000e8e8 if otherValue >= uint64(len(ret.blocks)) {:0xc000913380 if overwritten != nil {:0xc000191fa0 if overwritten == nil {:0xc0004a51a8 if p.children[0] != nil {:0xc000225448 if p.children[1] != nil {:0xc000225470 if p.children[dirs[i]] != nil {:0xc00028d008 if p.head == nil {:0xc000c244d8 if pMain.cNode != nil {:0xc0000a4398 if pMain.cNode.bmp&flag != 0 {:0xc0000a43b0 if packet == nil {:0xc000225038 if packets[i] == nil {:0xc00028c338 if parent != nil && r1 != nil {:0xc0006aaaf0 if parent != nil {:0xc0000a4120 if parent == nil {:0xc00000ea88 if parent.children[0] != nil && parent.children[0].max > parent.max {:0xc0004a4a50 if parent.children[0] != nil && parent.children[0].min < parent.min {:0xc000a13e30 if parent.children[0] == n {:0xc000a13178 if parent.children[1] != nil && parent.children[1].max > parent.max {:0xc0004a4a68 if parent.children[1] != nil && parent.children[1].min < parent.min {:0xc000a13e40 if parent.children[1] == n {:0xc000a13180 if parent.interval.LowAtDimension(1) < parent.min {:0xc000a13e50 if parent.right == nil {:0xc0006aab60 if parent.right.keys.byPosition(0) != key {:0xc0006aab68 if parentPath == nil {:0xc000225a98 if pb := p.tail; pb != nil {:0xc00039cfe0 if pos == 0 {:0xc0009130d8 if pos >= uint64(len(ns.list)) {:0xc0004a5218 if position > sl.Len() {:0xc000a13a08 if pq.Disposed() {:0xc000c25020 if pq.allowDuplicates {:0xc0001bf420 if pq.disposed {:0xc0001bf418 if pred(curr.head) {:0xc000a13780 if pred(l.head) {:0xc0004a5878 if predecessor != nil && predecessor.parent == n {:0xc000224468 if predecessor != nil {:0xc0001bf898 if prepend {:0xc0000a4a18 if prev == nil {:0xc000224958 if prev.failed != nil {:0xc0000a44a0 if ptree.actions.Len() > 0 {:0xc00039d020 if ptree.kbRing.Len() == 0 {:0xc00039c370 if ptree.kbRing.Len() == ptree.kbRing.Cap() {:0xc000826d48 if ptree.root == nil {:0xc0004a5d10 if q == dummy.children[1] {:0xc000225520 if q == nil {:0xc000225498 if q.Empty() {:0xc0004a59e0 if q.Len() != 0 {:0xc0002253d0 if q.balance != 0 {:0xc0002254a0 if q.disposed {:0xc0001bf500 if r > 0 {:0xc0004a4b30 if r.Float64() > .5 {:0xc0006aae98 if r.rdcss != nil {:0xc0000a4528 if r.rdcss == nil {:0xc000224aa0 if rand.Float64() < .5 && len(oc) > 0 {:0xc0006aa1d8 if readOnly && c.readOnly {:0xc00028d160 if readOnly {:0xc00028d180 if reflection == best {:0xc00028d528 if reflection.less(nm.config, nm.lastDimensionVertex(vertices)) &&:0xc00028d530 if reflection.less(nm.config, nm.lastVertex(vertices)) {:0xc00028d570 if reflection.less(nm.config, vertices[0]) {:0xc00028d548 if result != nil {:0xc0000a50f8 if result == nil {:0xc000913180 if result {:0xc00028c2c8 if resultBlock > 0 {:0xc00000f0a0 if results.exists(vertex, i) {:0xc00028ca78 if root == nil {:0xc0001bf808 if root.gen == i.gen && !ctrie.readOnly {:0xc0000a44d8 if runtime.NumCPU() > 1 {:0xc00000f678 if rx == 1 {:0xc000913100 if ry == 0 {:0xc0009130f8 if s.comparator(s.stop, s.n.ChildValues[s.pointer]) < 0 {:0xc0000a56a8 if s.n.IsLeaf {:0xc0000a5688 if s.pointer == len(s.n.ChildValues) {:0xc0000a56a0 if s.pointer >= len(s.n.ChildKeys) {:0xc0000a5698 if s[i] == x {:0xc0000a4cd8 if sba, ok := other.(*sparseBitArray); ok {:0xc0006ab5c0 if sba.Capacity() == 0 {:0xc000a13048 if sba.blocks[i] == 0 {:0xc0006ab3b8 if sba.indices[i] != otherI {:0xc0002257d0 if se == otherSe {:0xc000912ff0 if se > otherSe {:0xc000912ff8 if selfIndex == len(sba.indices) && otherIndex == len(other.blocks) {:0xc000a13060 if selfIndex == len(sba.indices) && otherIndex == len(other.indices) {:0xc00028c578 if selfIndex == len(sba.indices) {:0xc00000f030 if selfIndex == len(sba.indices) || otherIndex == len(other.indices) {:0xc0004a51d0 if selfIndex >= uint64(len(sba.indices)) {:0xc00000e8d8 if selfValue == uint64(otherIndex) {:0xc000a13088 if selfValue >= uint64(len(other.blocks)) {:0xc000913328 if sema == nil {:0xc0001bf448 if set.Exists(`test1`) {:0xc0004a5168 if set.Exists(`test2`) {:0xc00000f0e0 if set.Len() != 0 {:0xc0006ab458 if set.Len() != 1 {:0xc000191d88 if set.Len() != 2 {:0xc000191d98 if set.flattened != nil {:0xc0009133d0 if setRoot && len(adds) > 1 {:0xc0004a5af0 if setRoot {:0xc0004a5b40 if siblingPosition < i {:0xc0000a4828 if side == 0 && !isInternal(n.parent.children[1]) && hasSuccesor {:0xc0000a5198 if side == 1 && !isInternal(n.parent.children[0]) && hasPredecessor {:0xc0000a5450 if sl.Len() == 0 {:0xc000827368 if sl.cache[i].forward[i] != n {:0xc00000f908 if sl.cache[i].forward[i] != nil {:0xc0004a4850 if sl.level < 1 {:0xc000c250b8 if stack != nil {:0xc000c24700 if start == 1 {:0xc0004a4228 if start1 < start2 && start2 < last {:0xc0001bf758 if start2 > mid {:0xc0001bf778 if startGen == in.gen {:0xc0002241d8 if string(node.ID) == string(t.Root) {:0xc0000a45e8 if string(t.Root) != string(n.ID) {:0xc000a13d88 if string(t.Root) == string(parent.ID) {:0xc000225ab8 if sub == i && main.tNode != nil {:0xc0000a43c0 if subNode.dataMap.GetBit(i) {:0xc0004a4740 if subNode.nodeMap.PopCount() == 0 && subNode.dataMap.PopCount() == 1 {:0xc0004a4728 if successor != nil && successor.parent == n {:0xc000224348 if successor != nil {:0xc0001bf888 if successor == nil {:0xc0001bf7e0 if t != nil {:0xc000a124d8 if t.NodeWidth > 0 {:0xc00000eb28 if t.Root == nil {:0xc000a13258 if t.Root == nil || len(keys) == 0 {:0xc0006aada8 if t.config.Comparator(n.lastValue(), value) < 0 {:0xc000225908 if t.config.Comparator(neighbor.Value, node.lastValue()) <= 0 {:0xc000225628 if t.context != nil {:0xc000c24800 if t.context.nodeExists(n.ID) {:0xc0006aa718 if t.root == nil {:0xc000912cb0 if tail.IsEmpty() {:0xc000c248a8 if testing.Short() {:0xc0000a4538 if timeout > 0 && time.Since(start) >= timeout {:0xc0001bf320 if timeout > 0 {:0xc0001bf2e8 if tn.hash == entry.hash && bytes.Equal(tn.Key, entry.Key) {:0xc0004a4428 if toIndex > selfIndex {:0xc0001bff18 if todo == 0 {:0xc00000f668 if top != 0 {:0xc00028d050 if tree.actions.Len() > 0 {:0xc000826ec0 if tree.root != nil {:0xc000a12778 if tree.root == nil {:0xc000224900 if tree.root == nil || tree.root == n {:0xc00028c870 if tree.root.needsSplit(tree.nodeSize) {:0xc000826720 if treeSlice[curr.degree] == nil {:0xc000913758 if two == -1 {:0xc000a12e38 if u.Len() > w.Len() {:0xc000c24f40 if u[i] == x {:0xc0001bf290 if u[mid].Compare(u[total-mid]) <= 0 {:0xc0006aa140 if u[mid].Compare(w[p-mid]) <= 0 {:0xc0001914f0 if uint64(len(ptree.cache)) >= ptree.bufferSize {:0xc00039d060 if uint64(len(tree.cache)) >= tree.bufferSize {:0xc000826ef0 if update != nil {:0xc0008273c0 if v == w {:0xc00039d170 if v.distance < min.distance {:0xc000225110 if value {:0xc000912630 if vars[0] < 1 || vars[1] < 1 {:0xc00028cd30 if vars[0] < 6 || vars[0] > 8 {:0xc00028cd68 if vars[1] < 0 || vars[1] > 2 {:0xc00028cd70 if vertex.good {:0xc00000e108 if vs, ok := summed[sum]; !ok {:0xc0006aaec8 if w != nil {:0xc0004a5338 if ws[i] != sema {:0xc000826f60 if x < r.xlow {:0xc0000a5010 if x > r.xhigh {:0xc0000a5038 if xft.max != nil && key > xft.max.entry.Key() {:0xc0001bf7e8 if xft.max == nil {:0xc000c24b50 if xft.max == nil || key > xft.max.entry.Key() {:0xc0001bf8e0 if xft.max.entry.Key() == key {:0xc0002244b8 if xft.min != nil && key < xft.min.entry.Key() {:0xc0001bf7c8 if xft.min == nil {:0xc000c24b60 if xft.min == nil || key < xft.min.entry.Key() {:0xc0001bf8f0 if xft.min.entry.Key() == key {:0xc0002244c8 if xft.root == nil || xft.max == nil {:0xc00028ccb0 if xft.root == nil || xft.min == nil {:0xc000a13e58 if xidx < yidx {:0xc000225160 if xidx == yidx {:0xc000225140 if y < r.ylow {:0xc0000a5020 if y > r.yhigh {:0xc0000a5048 if z.ChildKeys[ajw] == nil {:0xc0008276c8 if z[bai] == nil {:0xc000a13850 if z[xvk] == nil {:0xc000827330 ifc := args.Get(0):0xc000c24720 ifc := m.Called(entries).Get(0):0xc0009a0428 ifc, err := future.GetResult():0xc000827090 ifc, err := ptree.kbRing.Get():0xc00039c388 ifs := make(interfaces, 0, len(adds)):0xc0004a5b00 ifs = append(ifs, n):0xc0004a5b20 immediatePredecessor := false:0xc0000a5410 immediatePredecessor = true:0xc0000a5430 immediateSuccessor := false:0xc0000a5148 immediateSuccessor = true:0xc0000a5168 immutable := &Immutable{}:0xc000c255d0 immutable.dummy = node{:0xc00028c5e0 immutable.dummy.balance = 0:0xc0009129b0 immutable.dummy.children[0], immutable.dummy.children[1] = nil, nil:0xc000912980 immutable.init():0xc000c255d8 immutable.number++:0xc0002253f0 immutable.number--:0xc00028cfe8 immutable.resetDummy():0xc0002253f8 immutable.root = cache[0]:0xc00028d108 immutable.root = dummy.children[1]:0xc0002254d0 immutable.root = it:0xc00028d0b0 immutable.root = it.children[dir]:0xc00028d060 immutable.root = newNode(entry):0xc0002253e8 immutable.root = s:0xc000225528 in := &inode{:0xc000827190 in := branch.(*iNode):0xc0002241d0 in := constructMockInternalNode(nodes):0xc00028cb98 in := newInternalNode(tree.nodeSize):0xc00000eb38 in.keys = append(in.keys, key):0xc00000ebd8 in.nodes = append(in.nodes, left):0xc00000ec68 in.nodes = append(in.nodes, right):0xc00000ec90 index := -1:0xc0004a5620 index := 0:0xc00039c3d0 index := atomic.AddInt64(&done, 1):0xc00000f698 index := atomic.LoadInt64(&forCache.i):0xc0001bf708 index := int64(0):0xc00000e980 index := j - i:0xc000a13980 index := len(*items) - 1:0xc000c24ba8 index := nodes.search(low):0xc0004a4690 index := numItems - (i % numItems) - 1:0xc000826548 index := rand.Intn(len(oc)):0xc0006aa160 index := uint(i):0xc00000eb88 index := uint(mask(entry.KeyHash(), n.level)):0xc000a13440 index := uint(mask(keyHash, n.level)):0xc00000f5c0 index = child:0xc00039c9c8 index = i:0xc0004a5640 index = parent:0xc000c24bc8 index++:0xc00000e9b0 index, number,:0xc000a131b8 index, number, &modified, &deleted,:0xc0004a5a20 index, number, modified, deleted,:0xc0004a5820 index, position := getIndexAndRemainder(k):0xc0008271c8 index:		i - 1,:0xc000c24f20 index:		index,:0xc0008275b0 index:		int64(start) - 1,:0xc0004a55d8 index:	-1,:0xc000191e20 index:	i - 1,:0xc000827408 index: iteratorExhausted,:0xc0000a50d0 indexLen := uint64(len(ba.indices)):0xc00039cd80 indices := make([]int, 0, len(keys)):0xc000a13920 indices := make(uintSlice, 0, len(sba.indices)):0xc000913310 indices := make(uintSlice, 0, max):0xc00000e290 indices := make(uintSlice, len(sba.indices)):0xc000c251d8 indices = append(indices, i):0xc000a13938 indices = append(indices, other.indices[otherIndex:]...):0xc00028c588 indices = append(indices, otherValue):0xc00028c5c0 indices = append(indices, sba.indices[selfIndex:]...):0xc00028c598 indices = append(indices, sba.indices[selfIndex]):0xc00000f040 indices = append(indices, selfValue):0xc00000f088 indices:	indices,:0xc00000f0b8 inode := sub.(*iNode):0xc0000a41d0 input := newBitArray(numItems):0xc000191c98 input := newSparseBitArray():0xc00000ef78 input.SetBit(i):0xc00000ef90 insertDimension, dimension+1,:0xc000827858 insertDimension, dimension+1, maxDimension,:0xc0004a5818 insertDimension, index, number, deleted, affected,:0xc0002249c0 insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, true):0xc00028d130 insertTest(t, collisionHash, 1000):0xc0004a53a0 insertTest(t, defaultHasher, 10000):0xc0004a5398 inserted = true:0xc0001bf940 interval:	interval,:0xc000c24830 intervals := intervalsPool.Get().(Intervals):0xc000a12ea8 intervals := make(Intervals, 0, 10):0xc0004a4390 intervals := make(Intervals, 0, 5):0xc0008269a0 intervals := make(Intervals, 0, numItems):0xc00028cf50 intervals = append(intervals, constructSingleDimensionInterval(0, 1, 0)):0xc000a12eb0 intervals = append(intervals, iv):0xc00028cf58 intervals.Dispose():0xc000a12eb8 intervalsPool.Put(*ivs):0xc0006aaba0 intsToRead, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]):0xc000a98458 irt.add(&top, cache, entry, &added):0xc0006aaf70 irt.apply(irt.top, interval, 1, func(n *node) bool {:0xc000225720 irt.delete(&top, cache, entry, &deleted):0xc00028c950 isLastDimension := isLastDimension(lastDimension, dimension):0xc000c24c20 isLeaf:	isLeaf,:0xc0006aa800 isLeaf:	true,:0xc000225268 isRoot := bytes.Compare(node.ID, t.Root) == 0:0xc0002255d0 isRoot := bytes.Compare(parent.ID, t.Root) == 0:0xc000225688 isz, bts, err = msgp.ReadMapHeaderBytes(bts):0xc0002247c8 isz--:0xc0002247d8 it := newTree(1):0xc000c248d8 it := newTree(2):0xc000912f88 it = immutable.root:0xc00028cfa8 it = it.children[normalized]:0xc00028cfe0 it = it.copy():0xc00028d030 it, _, _, _ := constructSingleDimensionQueryTestTree():0xc00000fa00 it, _, iv2, _ := constructSingleDimensionQueryTestTree():0xc000c25418 it, iv1, _, iv3 := constructSingleDimensionQueryTestTree():0xc000a13fb0 it, iv1, iv2, _ := constructSingleDimensionQueryTestTree():0xc000a13f60 it, iv1, iv2, iv3 := constructMultiDimensionQueryTestTree():0xc0004a4200 it, iv1, iv2, iv3 := constructSingleDimensionQueryTestTree():0xc00028d328 it, p, q			*node:0xc00028cf88 it.Add(intervals...):0xc00028cf60 it.Add(intervals[int64(i)%numItems]):0xc00028d248 it.Add(iv):0xc000913240 it.Add(iv1):0xc000912fa0 it.Add(iv1, iv2, iv3):0xc0004a4358 it.Add(iv2):0xc000912fb8 it.Add(iv3):0xc000912fd0 it.Add(iv4):0xc0000a57a8 it.Delete(:0xc000826968 it.Delete(constructSingleDimensionInterval(0, 1, 1)):0xc000224420 it.Delete(intervals...):0xc0004a43a0 it.Delete(iv):0xc0000a57d0 it.Delete(iv1):0xc000224168 it.Delete(iv1, iv2, iv3):0xc0008267a0 it.Delete(iv2):0xc00028d4b8 it.Delete(iv3):0xc00028d5d8 it.Delete(toDelete):0xc000826330 it.Query(:0xc00000f9f0 it.Query(constructSingleDimensionInterval(0, numItems, 0)):0xc00000e350 it.add(iv):0xc000a13680 it.entry = heir.entry:0xc00028d098 item := &Payload{n.ID, buf}:0xc0002248a8 item := (*items)[size-1]:0xc00039c3b8 item := `test`:0xc0001bf148 item := k.ToItem():0xc0006aae40 item := strconv.Itoa(i):0xc000c250b0 item = `test2`:0xc000a134e8 item, err := rb.Get():0xc000826918 item, err = rb.Get():0xc000826930 item, ok := l.Get(0):0xc000826060 item, ok = l.Get(0):0xc000826078 item, ok = l.Get(1):0xc0008261d8 item1 := newItem(int64(1)):0xc00028d260 item2 := newItem(int64(1)):0xc00028d268 itemMap:		make(map[Item]struct{}, hint),:0xc000225948 itemTwo := `test1`:0xc0001bfc60 items := b.items:0xc00000f528 items := generateLinearItems(3):0xc0000a4460 items := generateLinearItems(num):0xc0000a5710 items := generateLinearItems(number):0xc00028cdf0 items := generateRandomItems(1000):0xc00000f9f8 items := generateRandomItems(5):0xc00000f970 items := generateRandomItems(num):0xc000224260 items := generateRandomItems(number):0xc0006aa218 items := make([]*Payload, 0, len(keys)):0xc000913060 items := make([]*Payload, 0, len(t.context.seenNodes)):0xc000224878 items := make([]Item, len(keys)):0xc0004a5108 items := make(items, 0, len(k)):0xc0004a4fe8 items := make(items, 0, len(o)):0xc00000e008 items := make(items, 0, num):0xc0004a5930 items := make(items, 0, t.Count):0xc000827918 items := q.items:0xc00000f688 items = append(items, &Payload{t.ID(), t.toBytes()}):0xc00000e148 items = append(items, c):0xc0004a5960 items = append(items, e.mp[string(k)]):0xc000913070 items = append(items, item):0xc0002248b8 items = append(items, key.ToItem()):0xc0004a4ff8 items = append(items, o[i]):0xc00000e040 items = append(items, t.commit()...):0xc00000e140 items = pq.items.get(number):0xc000c25028 items = q.items.get(number):0xc000c24e08 items, err := c.persister.Load(key):0xc0001be678 items, err := p.Load(id):0xc0004a5a50 items.swap(index, child):0xc00039c498 items.swap(index, parent):0xc000c24bc0 items.swap(size-1, 0):0xc00039c3b0 items:			make(priorityItems, 0, hint),:0xc000225940 items:		make([]interface{}, 0, maxItems),:0xc0001beb48 items:		map[string]*cached{},:0xc000191748 items: make([]interface{}, 0, hint),:0xc000c252a0 items: make(map[interface{}]struct{}, 10),:0xc000826390 itemsDisposed := q.Dispose():0xc00028cc60 itemsDisposed = q.Dispose():0xc00028cc78 items[i] = cached.item:0xc0004a5138 items[i] = nil:0xc0004a5128 items[i], items[len(items)-1-i] = items[len(items)-1-i], items[i]:0xc0004a54d0 items[index] = 0:0xc00000f6b0 iter := &Iterator{:0xc00000f3a0 iter := &iterator{:0xc000191b98 iter := ctrie.Iterator(cancel):0xc0000a5770 iter := sl.Iter(mockEntry(0)):0xc0004a4158 iter := sl.IterAtPosition(0):0xc0004a41c0 iter := tree.Iter(newMockKey(0)):0xc000191d38 iter := tree.Iter(newMockKey(2)):0xc0004a5780 iter := tree.Iter(newMockKey(4)):0xc000913548 iter := tree.Iter(newMockKey(5)):0xc000913558 iter := tree.Iter(searchKey):0xc0008274e0 iter := tree.root.find(key):0xc0009131e0 iter := xft.Iter(0):0xc000a13cb0 iter := xft.Iter(2):0xc0000a5840 iter := xft.Iter(5):0xc0004a58e0 iter := yfast.Iter(5):0xc0006ab5d8 iter = &Iterator{:0xc00000f3b8 iter = &iterator{:0xc000191be8 iter = nilIterator():0xc000191bf8 iter = sl.Iter(mockEntry(10)):0xc0004a4190 iter = sl.Iter(mockEntry(11)):0xc0004a4198 iter = sl.Iter(mockEntry(5)):0xc0004a4168 iter = sl.Iter(mockEntry(6)):0xc0004a4170 iter = sl.Iter(skipEntry(0)):0xc000224708 iter = sl.Iter(skipEntry(index)):0xc000224700 iter = sl.IterAtPosition(1):0xc0004a41c8 iter = sl.IterAtPosition(2):0xc0004a41d0 iter = xft.Iter(11):0xc000a13cc8 iter = xft.Iter(16):0xc000a13ce0 iter = xft.Iter(5):0xc0000a5850 iter = xft.Iter(6):0xc0000a5858 iter = yfast.Iter(0):0xc0006ab618 iter = yfast.Iter(13):0xc0006ab628 iter = yfast.Iter(5):0xc0006ab5e8 iter = yfast.Iter(6):0xc0006ab600 iter = yfast.Iter(7):0xc0006ab610 iter.Value():0xc0004a5ce0 iter.entries, ok = iter.xfastIterator.Value().(*entriesWrapper):0xc000c24638 iter.exhaust():0xc0008274e8 iter.first = false:0xc0009122f8 iter.index < 0 || iter.index >= len(iter.node.keys) {:0xc000c246f0 iter.index = 0:0xc000c24648 iter.index = iteratorExhausted:0xc000c24628 iter.index++:0xc000c24608 iter.n = iter.n.children[1]:0xc000912330 iter.n = iter.n.forward[0]:0xc000826840 iter.node = iter.node.pointer:0xc000826b58 itn := &node{:0xc000c24828 itn.id = interval.ID():0xc000c24858 iv := constructMockInterval(:0xc00028d150 iv := constructMockInterval(dimension{0, 10}, dimension{0, 10}):0xc000a12ff0 iv := constructMultiDimensionInterval(:0xc000913230 iv := constructSingleDimensionInterval(0, 10, uint64(i)):0xc0004a4398 iv := constructSingleDimensionInterval(0, 10, uint64(start)):0xc0008269a8 iv := constructSingleDimensionInterval(1, 5, 1):0xc0000a5818 iv := constructSingleDimensionInterval(5, 10, 0):0xc000c248e0 iv := constructSingleDimensionInterval(i, i+1, uint64(i)):0xc000a13678 iv := constructSingleDimensionInterval(int64(i), int64(i)+10, uint64(i)):0xc00000e9e0 iv := constructSingleDimensionInterval(start, start+1, uint64(start)):0xc00028cb50 iv := newMockInterval([]int64{0, 0}, []int64{math.MaxInt64, math.MaxInt64}):0xc0004a4258 iv = constructSingleDimensionInterval(4, 11, 1):0xc0004a45e0 iv = constructSingleDimensionInterval(7, 11, 1):0xc000a13538 iv = constructSingleDimensionInterval(7, 12, 1):0xc000c24d40 iv, iv.LowAtDimension(1),:0xc0001bfb20 iv.HighAtDimension(1),:0xc0001bfb28 iv1 := constructMultiDimensionInterval(:0xc000912f90 iv1 := constructSingleDimensionInterval(0, 10, 1):0xc0004a4338 iv1 := constructSingleDimensionInterval(0, 10, 21):0xc0008269c8 iv1 := constructSingleDimensionInterval(6, 10, 0):0xc000a13f48 iv2 := constructMultiDimensionInterval(:0xc000912fa8 iv2 := constructSingleDimensionInterval(0, 10, 1):0xc0004a43e8 iv2 := constructSingleDimensionInterval(0, 10, 2):0xc0004a4340 iv2 := constructSingleDimensionInterval(0, 10, 21):0xc0008269d0 iv2 := constructSingleDimensionInterval(4, 5, 1):0xc000a13f50 iv3 := constructMultiDimensionInterval(:0xc000912fc0 iv3 := constructSingleDimensionInterval(0, 10, 1):0xc0004a43f0 iv3 := constructSingleDimensionInterval(0, 10, 3):0xc0004a4348 iv3 := constructSingleDimensionInterval(7, 12, 2):0xc000a13f58 iv4 := constructSingleDimensionInterval(4, 5, 3):0xc0000a57a0 ivHigh		= interval.HighAtDimension(1):0xc000c24230 ivLow				= iv.LowAtDimension(1):0xc000a120c8 ivLow			= iv.LowAtDimension(1):0xc0001bfb80 ivLow		= interval.LowAtDimension(1):0xc000c24228 ivs := make(Intervals, 0, number):0xc00000e9d0 ivs = append(ivs, iv):0xc000c248c0 j -= i:0xc00000f548 j := atomic.AddInt64(&forCache.js[index], 1):0xc0001bf720 j := end - start2:0xc0002251b0 js	[]int64:0xc0001bf6d8 k := n.keys.last():0xc000826d88 k := search(parent, key):0xc00039d3d0 k = n.keys.byPosition(j):0xc000a13518 k, _ := n.keys.withPosition(action.keys()[j]):0xc0006ab3f0 k, _ := n.keys.withPosition(key):0xc000a136a8 k, _ := n.searchKey(t.config.Comparator, value):0xc0006aae08 k, l, r = n.split():0xc00028c858 k, left, right := n.split(offset, ptree.ary):0xc0006ab440 k, left, right := n.split(offset, tree.ary):0xc0004a4920 k1 := mockKey(10):0xc0004a4038 k1 := mockKey(5):0xc000826dc8 k1 := newMockKey(0):0xc0001bfd38 k1 := newMockKey(3):0xc000913680 k1, k2, k3 := mockKey(10), mockKey(5), mockKey(15):0xc00039c3c0 k1, k2, k3 := mockKey(15), mockKey(10), mockKey(5):0xc00028ca50 k1, k2, k3 := mockKey(5), mockKey(10), mockKey(15):0xc000c24e30 k1, k2, k3, k4 := mockKey(10), mockKey(15), mockKey(20), mockKey(5):0xc0006ab4c8 k1, k2, k3, k4 := mockKey(20), mockKey(15), mockKey(10), mockKey(5):0xc0006ab360 k1, k2, k3, k4 := mockKey(5), mockKey(10), mockKey(15), mockKey(20):0xc000a139b0 k2 := mockKey(15):0xc000f04008 k2 := mockKey(5):0xc0004a4040 k2 := newMockKey(3):0xc000913688 k2 := newMockKey(4):0xc000c24d90 k2 := newMockKey(5):0xc0001bfd40 k3 := mockKey(20):0xc000f04010 k4 := mockKey(25):0xc000a12f98 kb := ifc.(*keyBundle):0xc00039c390 kb := ptree.newKeyBundle(k):0xc0004a5c00 kb.dispose(ptree):0xc00000e930 kb.key = key:0xc00039c398 kb.key, kb.left, kb.right = nil, nil, nil:0xc000826d58 kb.left = nodes[i*2]:0xc0004a5c08 kb.right = nodes[i*2+1]:0xc0004a5c10 key *= 0xc4ceb9fe1a85ec53:0xc000826bd8 key *= 0xff51afd7ed558ccd:0xc000826b70 key := []byte(strconv.Itoa(numItems / 2)):0xc0008264e8 key := c.keyList.Back().Value.(string):0xc0004a4308 key := entry.Key():0xc0001bf7b0 key := keys[i]:0xc0002255a8 key := n.ChildKeys[0]:0xc000225b58 key := n.ChildKeys[len(n.ChildKeys)-1]:0xc000826460 key := n.entry.Key():0xc00000f370 key := n.keys.byPosition(i):0xc000c241b8 key := n.keys[i]:0xc0009135f8 key := newMockKey(2):0xc000c24b08 key := newMockKey(3):0xc00000f3e0 key := node.keys[i]:0xc0008261f0 key := other.(*mockKey):0xc0000a52d8 key := other.key():0xc000c24c68 key := parent.keyAt(i):0xc0000a4758 key := uint64(5):0xc000a12ef8 key := uint64(r.Int63()):0xc000191ab8 key ^= key >> 33:0xc000826b68 key, _ := n.keys.withPosition(k):0xc000a13140 key, i = n.searchKey(t.config.Comparator, value):0xc0001bfdf0 key, l, r := parent.split():0xc000191e80 key, left, right := child.split():0xc00000ea78 key, left, right := in.split():0xc00028cba0 key, left, right := node.split():0xc000a13a78 key.Value, t.Root,:0xc0004a40f8 key:		bundleKey,:0xc00000eba8 keyList:	list.New(),:0xc000191738 keySet := make([]common.Comparators, 0, b.N):0xc0004a5ee8 keySet := make([]keys, 0, b.N):0xc0001bfed0 keySet = append(keySet, constructRandomMockKeys(numItems)):0xc0001bfed8 keySet = append(keySet, generateRandomKeys(numItems)):0xc0004a5ef0 keyed := e.(keyed):0xc000c24868 keys := []mockEntry{:0xc0002243b8 keys := []string{"foo", "bar", "baz"}:0xc0004a4c30 keys := chunks[i]:0xc0004a40e0 keys := constructMockKeys(10):0xc000a133b0 keys := constructMockKeys(4):0xc0004a40d8 keys := constructMockKeys(5):0xc00039cbf8 keys := constructMockKeys(numItems):0xc0008274c8 keys := constructMockPayloads(1):0xc0002242b8 keys := constructMockPayloads(2):0xc0006ab590 keys := constructMockPayloads(3):0xc0006ab498 keys := constructMockPayloads(4):0xc000a13a70 keys := constructRandomMockKeys(100):0xc000a13758 keys := constructRandomMockKeys(numItems):0xc00000eb00 keys := generateKeys(10):0xc00028c028 keys := generateKeys(100):0xc0008271a8 keys := generateKeys(30000):0xc0004a46c8 keys := generateKeys(int(numItems)):0xc000826230 keys := generateKeys(numItems):0xc0006aa320 keys := generateRandomKeys(10):0xc000225378 keys := generateRandomKeys(100):0xc0002259c8 keys := generateRandomKeys(15):0xc000a13f10 keys := generateRandomKeys(16):0xc000225998 keys := generateRandomKeys(1600):0xc000224300 keys := generateRandomKeys(200):0xc0004a5ac8 keys := generateRandomKeys(numItems):0xc000225cf8 keys := keys{newMockKey(1), newMockKey(2), newMockKey(4)}:0xc00028c3c8 keys := make(Keys, 0, 10):0xc000c25178 keys := make(Keys, 0, len(its)):0xc000a12120 keys := make(Keys, 0, len(values)):0xc0001be5d0 keys := make(Keys, 0, num):0xc000c24670 keys := make([]common.Comparators, 0, b.N):0xc00000fad8 keys := make([]common.Comparators, 0, numLoops):0xc0004a5c68 keys := make([]uint64, 0, num):0xc000191aa8 keys := make([]uint64, 0, numItems):0xc000224ff8 keys := make(common.Comparators, 0, n.keys.len()):0xc0004a5bd8 keys := make(common.Comparators, 0, num):0xc0004a5008 keys := make(hilberts, 0, n.keys.len()):0xc000c254b0 keys := make(keys, 0, 10):0xc000191d50 keys := make(keys, 0, len(ids)):0xc00000f580 keys := make(keys, 0, len(nodes)-1):0xc000827178 keys := make(keys, 0, num):0xc000912760 keys := t.iterativeSplit(n):0xc000225b48 keys = append(keys, &Key{UUID: leftNode.ID, Value: leftValue}):0xc000c25198 keys = append(keys, &Key{Value: item.Value, Payload: item.Payload}):0xc000a12140 keys = append(keys, generateRandomKeys(10)):0xc0004a5c78 keys = append(keys, generateRandomKeys(numItems)):0xc00000fae0 keys = append(keys, iter.Value()):0xc000191d60 keys = append(keys, key):0xc000191ac0 keys = append(keys, mockKey(i)):0xc000191d20 keys = append(keys, mockKey(m%50)):0xc0004a5018 keys = append(keys, mockKey(uint64(i))):0xc0004a5300 keys = append(keys, mockKey(uint64(rand.Uint32()%uint32(100)))):0xc000c24678 keys = append(keys, newMockKey(i)):0xc000912778 keys = append(keys, newMockKey(id)):0xc00000f590 keys = append(keys, newMockKey(j*i+j)):0xc000c24ab8 keys = append(keys, newMockKey(rand.Int())):0xc000224fe8 keys = append(keys, nodes[i].(*lnode).keys[0]):0xc000827188 keys = keys.sort(t.config.Comparator):0xc0001be5e8 keys.reverse():0xc0009132b8 keys1 := generateRandomKeys(100):0xc000827490 keys1 := keys[:50]:0xc00000eb48 keys2 := generateRandomKeys(100):0xc000827498 keys2 := keys[50:]:0xc00000eb50 keys:		n.ChildKeys,:0xc0001bfce8 keys:		otherKeys,:0xc0008263d8 keys:	keys,:0xc000827198 keys:	make(Keys, 0, ary),:0xc0006aa820 keys:	make(keys, 0, size),:0xc0006aa6f8 keys:	newKeys(ptree.ary),:0xc0004a5b50 keys:	newKeys(tree.ary),:0xc000c25480 keys:	otherKeys,:0xc000913630 keys:	rightKeys,:0xc000225258 keys: keys,:0xc000c24ac8 keys: make(keys, 0, size),:0xc0002244f8 keys[0] = duplicate:0xc0004a4ef0 keys[2] = duplicate:0xc00039d380 keys[4] = duplicate:0xc00028c928 keys[i], keys[len(keys)-i-1] = keys[len(keys)-i-1], keys[i]:0xc00028cdd8 ks := make([]keys, 0, b.N):0xc000225760 ks = append(ks, constructRandomMockKeys(numItems)):0xc000225768 ks.deleteAt(i):0xc0008273e8 ks.insertAt(i, key):0xc000826858 ks.list = append(ks.list, -1):0xc000a13ae0 ks.list = append(ks.list, key):0xc0008263c0 ks.list = append(ks.list, nil):0xc0008276d8 ks.list = ks.list[:i]:0xc000a13248 ks.list = ks.list[:len(ks.list)-1]:0xc0001bf278 ks.list[i] = k:0xc0008276e8 ks.list[i] = key:0xc000826850 ks.list[j] = nil:0xc000a13240 ks.list[len(ks.list)-1] = nil:0xc0001bf270 l := Empty.Add("blah").Add("bleh"):0xc000225880 l := Empty.Add("foo"):0xc0006ab638 l := Empty.Add(1).Add(2).Add(3).Add(4):0xc00028cb78 l := list.Empty.Add(x).Add(y):0xc000225178 l = Empty.Add(1):0xc000a137a0 l = l.Add("bar").Add("baz"):0xc0006ab648 l = l.Add(1).Add("foo"):0xc000225890 l = l.Add(2):0xc000a137a8 l = l.Add(3):0xc000a137b0 l, err := Empty.Insert(1, 0):0xc000826058 l, err := Empty.Remove(0):0xc000a13798 l, err = l.Insert("a", 3):0xc0008261e8 l, err = l.Insert(2, 0):0xc000826070 l1 := Empty.Add(1):0xc0006aac88 l1 = l1.Add(2):0xc0006aacc0 l1, err := l.Remove(3):0xc000a137b8 l2, err := l.Remove(0):0xc000a137c8 l2, err := l1.Insert("a", 1):0xc0006aace8 l2, err = l.Remove(1):0xc000a137e8 l2, err = l.Remove(2):0xc0004a58c0 label		string:0xc0004a4c40 label:	"Items added, LRA eviction",:0xc0004a4cc8 label:	"Items added, LRU eviction",:0xc0004a4d10 label:	"Items added, key doesn't exist",:0xc0004a4c70 label:	"Items added, key exists",:0xc0004a4ca8 label:	"Items removed, key doesn't exist",:0xc0004a4e28 label:	"Items removed, key exists",:0xc0004a4e38 last = dir:0xc0001bfc18 last, otherDir, otherLast	int:0xc000a12030 lastDimension := isLastDimension(dimension, rt.dimensions):0xc0002258d8 lastDimension := isLastDimension(maxDimension, dimension):0xc0004a5790 lastIndex, _ := getIndexAndRemainder(ba.highest):0xc0001bff40 layer = 0:0xc0001bf818 layer, n := binarySearchHashMaps(xft.layers, key):0xc00028ccd0 layer, root := binarySearchHashMaps(xft.layers, key):0xc0001bf800 lb	*lastBundle:0xc00000f428 lb = &lastBundle{id: uint64(value), entry: entry}:0xc00000f468 lb = e.(*lastBundle):0xc00000f450 lb.entry = entry:0xc00000f460 left := make(nodes, i, cap(ns)):0xc0006aa8c0 left := newNode():0xc0004a47b8 left, minL, maxL := checkRedBlack(tb, node.children[0], dimension):0xc0000a54b0 left, right := keys.splitAt(i):0xc0001be788 left, right := n.nodes.splitAt(i + 1):0xc000913620 left, right := sl.SplitAt(1):0xc0008271f8 left, right := sl.SplitAt(4):0xc000a13c18 left, right := sl.SplitAt(49):0xc000225308 left.ChildKeys = leftKeys:0xc0004a49f0 left.ChildValues = leftValues:0xc0004a49e8 left.ID = newID():0xc0004a47c8 left.IsLeaf = n.IsLeaf:0xc0004a47c0 left.parent = parent:0xc0004a5838 left.right = right:0xc0004a4928 leftEntries := entries[:50]:0xc0002252e8 leftKeys := make(Keys, i+1):0xc0004a49b0 leftOrRight := (key & positions[xft.diff+i]) >> (xft.bits - 1 - i):0xc00000f388 leftOrRight := whichSide(n, n.parent):0xc000224328 leftOrRight = (key & positions[xft.diff+i]) >> (xft.bits - 1 - i):0xc0001bf838 leftOrRight = whichSide(n, n.parent):0xc000224480 leftValue, leftNode := n.splitAt(t.config.NodeWidth / 2):0xc000c25188 leftValues := make([]interface{}, i):0xc00028cc30 leftValues := make([]interface{}, i+1):0xc0004a4998 len(nodes),:0xc0009a04c8 lenU, lenW := len(u), len(w):0xc0001bf968 lenU1 := len(u1):0xc0001bf9a8 lenU2 := len(u2):0xc0001bf9b0 length += 1:0xc000c24898 length := len(*items):0xc00039d360 length := len(*ns) - i:0xc000c24be8 length := len(results.pbs) - num:0xc000c25158 length := n.keys.len():0xc0004a4900 length := uint(0):0xc000c24890 length := uint32(len(c.array)):0xc0001bf598 lerr := terr.New():0xc0006aadc8 lerr.Set(err):0xc0006aae00 lh, rh := 0, 0:0xc0000a5460 lhs := 1 / (math.Sqrt(2*math.Pi) * sigma):0xc0000a50b0 li := len(comparators) - i - 1:0xc0000a4870 list := &ot.top:0xc0004a5180 list := nodes:0xc000826e18 list := top:0xc000827588 list = &n.orderedNodes:0xc0008275d0 list = &node.orderedNodes:0xc0004a51c8 list = &nodes:0xc000826e48 list:		list,:0xc0008275a8 list: make([]*node, 0, size),:0xc000826f40 list: make(common.Comparators, 0, size),:0xc00000f770 list: make(hilberts, 0, size),:0xc0002257f0 list: make(rtree.Rectangles, 0, size),:0xc0006ab208 lnode.keys = append(lnode.keys, key):0xc0001bf938 lnode.keys.insertAt(i, key):0xc0001bf958 lnode.keys[i] = key:0xc0001bf950 local, _ := q.Get(1):0xc000a13b08 local, err := q.Get(1):0xc000224508 local, index = list.get(value):0xc000827590 localDir := intFromBool(grandParent.children[1] == parent):0xc000a124f8 localDir := intFromBool(helper.children[1] == grandParent):0xc0001bfbf0 localOverwrittens := make([]Keys, len(nodes)):0xc000a13298 localOverwrittens[i] = overwrittens:0xc0004a5668 lock.Lock():0xc0004a4b00 lock.Unlock():0xc0004a4b18 lock:		newMutex(),:0xc0001beb60 log.Printf(`CHILD %d: %+v`, i, child):0xc00028c010 log.Printf(`EXPECTED: %+v, RECEIVED: %+v`, c, result[i]):0xc000224938 log.Printf(`EXPECTED: %+v`, c):0xc000c24120 log.Printf(`KEY: %+v, XLOW: %+v, YLOW: %+v, XHIGH: %+v, YHIGH: %+v`, n.keys.list[i], xlow, ylow, xhigh, yhigh):0xc000826950 log.Printf(`LEN EXPECTED: %+v, RESULT: %+v`, len(ordered[i+1:]), len(result)):0xc000c24108 log.Printf(`NODE: %+v, LEN(ids): %+v, LEN(values): %+v`, n, n.lenKeys(), n.lenValues()):0xc0001bfff0 log.Printf(`NODE: %+v, MBR: %+v, %p`, n, n.mbr, n):0xc000826868 log.Printf(`NODE: %+v`, n):0xc0001bffe8 log.Printf(`RECEIVED: %+v`, result[i]):0xc000c24130 log.Println(`EMPTY TREE.`):0xc000912d80 log.Println(`PRINTING TREE`):0xc000912c88 lookup:		r,:0xc00028c778 low = mid + 1:0xc0004a4e58 low, high := 0, len(keys)-1:0xc0004a4b48 low, high := 0, len(layers)-1:0xc00039d1f0 low, high := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension):0xc000a13810 lowValue, highValue := interval.LowAtDimension(dimension), interval.HighAtDimension(dimension):0xc000a139b8 lowest:		ba.lowest,:0xc00028cc00 lows:	lows,:0xc0004a50e8 ls.mu.Lock():0xc000224538 ls.mu.Unlock():0xc000224870 ls.src.Seed(seed):0xc000a12c98 m := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&in.main)))):0xc000224948 m := Bitmap32(0):0xc000c24740 m := Bitmap32(0x33333333):0xc00028c930 m := Bitmap32(0x4):0xc000c24750 m := Bitmap32(0x55555555):0xc000191e00 m := Bitmap64(0):0xc000225058 m := Bitmap64(0x3333333333333333):0xc000a13120 m := Bitmap64(0x4):0xc0004a54d8 m := Bitmap64(0x55555555):0xc0004a54e8 m := New(32):0xc0006ab248 m := rand.Int():0xc0004a5010 m = (*mainNode)(atomic.LoadPointer(:0xc0000a44c8 m = (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&i.main)))):0xc0000a4508 m.Called():0xc000912188 m.Called(interval, fn):0xc0009a0420 m.Delete(27):0xc0006ab268 m.PopCount():0xc00028c940 m.PutChan <- true:0xc000c240e0 m.Set(1, 1):0xc0006ab250 m.Set(27, 27):0xc0006ab258 m.Set(42, 42):0xc0006ab260 m.lock <- struct{}{}:0xc0006aad20 m1 := mockEntry(1):0xc0006ab188 m1 := mockEntry(10):0xc00000f878 m1 := mockEntry(20):0xc000827348 m1 := mockEntry(5):0xc0004a56e8 m1 := mockKey(1):0xc000913210 m1 := newMockEntry(3):0xc000191f48 m1 := newMockEntry(3, 3):0xc000c24250 m1 := newMockEntry(3, 5):0xc000a130b0 m1 := newMockEntry(5):0xc000c24910 m1 := newMockEntry(5, 6):0xc000c24d08 m1 := newMockEntry(6):0xc00000fb68 m2 := mockEntry(10):0xc0004a56f0 m2 := mockEntry(15):0xc000827350 m2 := mockEntry(5):0xc0006ab190 m2 := mockKey(10):0xc0001be688 m2 := mockKey(5):0xc00028d2a0 m2 := newMockEntry(10):0xc0004a4150 m2 := newMockEntry(2):0xc00039c228 m2 := newMockEntry(4, 6):0xc000a130b8 m2 := newMockEntry(5):0xc000191f50 m2 := newMockEntry(5, 6):0xc000c24d10 m2 := newMockEntry(6):0xc000c24918 m2 := newMockEntry(6, 6):0xc000c24258 m3 := mockEntry(1):0xc0004a5728 m3 := mockEntry(10):0xc0006ab198 m3 := mockEntry(15):0xc0006ab5a0 m3 := mockEntry(20):0xc00000f880 m3 := mockEntry(5):0xc0002252a0 m3 := newMockEntry(2):0xc000c24920 m3 := newMockEntry(7):0xc0006ab200 m3 := newMockEntry(9):0xc0008260d8 m3 := newMockEntry(9, 9):0xc000c24260 m4 := mockEntry(1):0xc0006ab5a8 m4 := mockEntry(15):0xc0006ab1c8 m4 := mockEntry(20):0xc0002252a8 m4 := mockEntry(5):0xc000827358 m5 := mockEntry(1):0xc000827360 m5 := mockEntry(15):0xc0002252b0 m5 := mockEntry(20):0xc0006ab1d0 m5 := mockEntry(5):0xc0006ab5b0 main		= (*mainNode)(atomic.LoadPointer(mainPtr)):0xc0004a4448 main := (*mainNode)(atomic.LoadPointer(mainPtr)):0xc0000a41e0 main := gcasRead(i, c):0xc00000fa18 main := gcasRead(i, ctrie):0xc0004a5370 main := gcasRead(root, c):0xc00028d170 main := newMainNode(x, xhc, y, yhc, lev+w, gen):0xc000225148 main = gcasRead(i, c):0xc0000a4128 main:	&mainNode{cNode: &cNode{array: make([]branch, 0), gen: gen}},:0xc00000f850 mainPtr		= (*unsafe.Pointer)(unsafe.Pointer(&i.main)):0xc0004a4440 mainPtr := (*unsafe.Pointer)(unsafe.Pointer(&inode.main)):0xc0000a41d8 mapping := make(map[string]*Node, 10):0xc0002255b0 mapping := make(map[string]*Node, len(nodes)):0xc000225a60 mapping[string(n.ID)] = cp:0xc0000a4780 mapping[string(node.ID)] = cp:0xc0002255e8 mapping[string(parent.ID)] = cp:0xc0002256a0 mapping[string(parent.ID)] = newNode:0xc000225ad0 mapping[string(parent.ID)] = parent:0xc0002256b0 mask := uint32(flag - 1):0xc000c24168 match := n.keys[i]:0xc0001bef98 max			= iv.HighAtDimension(1):0xc0001bfb78 max := len(sba.indices):0xc00000e288 max := max(maxL, maxR):0xc0000a5508 max := maxInt64(int64(len(sba.indices)), int64(len(other.indices))):0xc00028c570 max := maxUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))):0xc0006ab150 max := maxUint64(uint64(sba.Capacity()), uint64(other.Capacity())):0xc000a13050 max, ok := es.max():0xc000827110 max, ok = es.max():0xc000827120 max:		max,:0xc000c24840 maxBytes:	maxBytes,:0xc000191ff0 maxDimension,:0xc000827860 maxDimension:	maxDimension,:0xc000a13f80 maxInt := ints[0]:0xc000c246c0 maxInt = ints[i]:0xc000c246d8 maxItems:	maxItems,:0xc000191fe8 maxT = curr:0xc000913790 maxT = other:0xc0009137a0 maxT.marked = false:0xc0009137d8 maxT.next = maxT:0xc0009137c0 maxT.next.prev = maxT.prev:0xc0009137a8 maxT.parent = minT:0xc0009137d0 maxT.prev = maxT:0xc0009137b8 maxT.prev.next = maxT.next:0xc0009137b0 maxTime:	maxTime,:0xc000191fe0 mbr:	&rectangle{},:0xc000c25490 me := new(mockEntry):0xc0006aabb0 me.On(`Key`).Return(key):0xc0006aabb8 mergedHeap, _ := heap1.Merge(&heap2):0xc00039d108 mergedHeap.DecreaseKey(nodeh2_1, SomeNumberAroundMinus1003):0xc00039d120 mergedHeap.Delete(nodeh2_2):0xc00039d140 mi.LowAtDimension(dimension) < iv.HighAtDimension(dimension):0xc0000a4730 mid := (start + stop) / 2:0xc0001914c0 mid := (start1 + last) / 2:0xc0001bf760 mid = (high + low) / 2:0xc0004a4d18 mid = (low + high) / 2:0xc00039d200 middle := (*keys)[i]:0xc0001be730 midpoint := findMidpoint(vertices[:len(vertices)-1]...):0xc00028d518 min := choices[0]:0xc000c24cb0 min := heap.min:0xc000c24cf8 min := min(minL, minR):0xc0000a54d0 min := minUint64(uint64(len(dba.blocks)), uint64(len(other.blocks))):0xc0001bee50 min := uint64(len(dba.blocks)):0xc000224bb8 min := vertices[0]:0xc000225100 min = choices[i]:0xc000c24cc8 min = v:0xc000225118 min, _ := heap.Min():0xc000191cd0 min, _ := heap1.Min():0xc000c24988 min, _ := mergedHeap.DequeueMin():0xc00039d128 min, _ = heap.Min():0xc000a124a0 min, _ = heap2.Min():0xc000c24998 min, _ = mergedHeap.DequeueMin():0xc00039d148 min, err := heap.DecreaseKey(elem, 0):0xc0001bf220 min, err := heap.DecreaseKey(nil, 0):0xc000c24c90 min, err := heap.DecreaseKey(node, 20):0xc0001bf238 min, err := heap.DequeueMin():0xc0000a5568 min, err := heap.Min():0xc000191df8 min, err = heap.DequeueMin():0xc000a12b18 min, err = heap.Min():0xc0000a5570 min, max := t.verify(key.ID(), tb):0xc000a13db0 min:		min,:0xc000c24838 minInt := ints[0]:0xc000225008 minInt = ints[i]:0xc000225018 minT = curr:0xc000913798 minT = other:0xc000913788 minT.child = mergeLists(minT.child, maxT):0xc0009137c8 minT.degree++:0xc0009137e0 missingValue := int64(3):0xc000224780 mm = make(map[interface{}]struct{}):0xc0009132d8 mm, ok := g.adjacencyList[v]:0xc0009132d0 mockEntry(0),:0xc0002243c0 mockEntry(1),:0xc0002243c8 mockEntry(2),:0xc0002243f8 mockEntry(3),:0xc0002243d0 mockEntry(4),:0xc0002243d8 mockEntry(5),:0xc0002243e0 mockEntry(6),:0xc0002243e8 mockEntry(7),:0xc0002243f0 modified := make(Entries, 0, 1):0xc0002258b0 modified := make(Entries, 0, 100):0xc0004a5a08 modified, deleted := make(Entries, 0, 100), make(Entries, 0, 100):0xc000a131a0 modified, deleted := tree.InsertAtDimension(1, 1, -1):0xc0002246a8 modified, deleted := tree.InsertAtDimension(1, 1, -2):0xc000c25650 modified, deleted := tree.InsertAtDimension(1, 1, 0):0xc0006aa068 modified, deleted := tree.InsertAtDimension(1, 1, 1):0xc0004a42d0 modified, deleted := tree.InsertAtDimension(1, 1, 2):0xc0008269b0 modified, deleted := tree.InsertAtDimension(1, 4, -1):0xc0008269f0 modified, deleted := tree.InsertAtDimension(1, 4, 1):0xc000224620 modified, deleted := tree.InsertAtDimension(2, 1, -1):0xc0002246b8 modified, deleted := tree.InsertAtDimension(2, 1, -2):0xc0006aa060 modified, deleted := tree.InsertAtDimension(2, 1, 1):0xc000826790 modified, deleted := tree.InsertAtDimension(2, 1, 2):0xc000224668 modified, deleted := tree.InsertAtDimension(2, 4, -1):0xc0002246d0 modified, deleted := tree.InsertAtDimension(2, 4, 1):0xc0004a4360 modified, deleted := tree.InsertAtDimension(3, 1, -1):0xc000224940 modified, deleted,:0xc000827868 mp := make(map[interface{}]*nodeBundle, len(keys)):0xc0004a40e8 mp := make(map[interface{}]struct{}, num):0xc0004a5938 mp: make(map[string]*Payload),:0xc000a13808 mp[c.Value] = struct{}{}:0xc0004a5958 mp[key.Value] = &nodeBundle{path: path, k: key}:0xc0004a4110 mustRemove -= int64(c.items[key].item.Size()):0xc0004a4310 mustRemove := int64(c.size+toAdd) - int64(c.cap):0xc0004a4118 mutable := rt.AsMutable():0xc00028ce08 mutable := tr.AsMutable():0xc0006aa248 mutable = rt.AsMutable():0xc00028ce58 mutable.(*Tr).pprint(mutable.(*Tr).Root):0xc00028ce38 mutable.(*Tr).verify(mutable.(*Tr).Root, t):0xc00028ce20 mutable.AddItems(items...):0xc00028d370 mutable.AddItems(items[10:]...):0xc0002246e8 mutable.AddItems(items[25:]...):0xc0000a4458 mutable.AddItems(items[:10]...):0xc0002246e0 mutable.AddItems(items[:25]...):0xc0000a4448 mutable.AddItems(oc.toItems()...):0xc0006aa100 mutable.DeleteItems(c.Value):0xc0000a42c8 mutable.DeleteItems(itemsToValues(items...)...):0xc0000a5718 mutable.DeleteItems(itemsToValues(items[:100]...)...):0xc000224350 mutable.DeleteItems(itemsToValues(items[i])...):0xc0006aa310 mutable.DeleteItems(items[0].Value, items[1].Value, items[2].Value):0xc00028d378 mutable:	true,:0xc000c24ee0 mutate = executeInterfacesInParallel:0xc0004a5b80 mutate = executeInterfacesInSerial:0xc0004a5b88 mutate(ifs, func(ifc interface{}) {:0xc0004a5b90 mutated := oc.copy():0xc0000a4568 mutated := oc.delete(c):0xc0006aa180 mutated = mutated.add(c):0xc0000a4570 n	*node:0xc0001bf2d0 n := &Node{}:0xc0000a55a8 n := &node{}:0xc000191400 n := (*ns)[len(*ns)-1]:0xc0001bed40 n := emptyNode(0, 32):0xc00028c780 n := getParent(ptree.root, action.keys()[j]):0xc0006ab3e0 n := getParent(ptree.root, k):0xc000a13130 n := getParent(ptree.root, key):0xc000a136a0 n := getParent(ptree.root, q.start):0xc00039d0d0 n := getParent(tree.root, hb.hilbert, hb.rect):0xc0001bf748 n := getParent(tree.root, key.hilbert, key.rect):0xc000c24b20 n := ifc.(*node):0xc0004a5b98 n := immutable.root:0xc000224e28 n := insertTest(nil, defaultHasher, b.N):0xc000913820 n := insertTest(t, defaultHasher, 10000):0xc0001bf470 n := insertTest(t, hashfunc, count):0xc00000f2d8 n := mid + start2:0xc0001bf768 n := newLeafNode(3):0xc00000f3d8 n := newLeafNode(tree.nodeSize):0xc000826250 n := newNode():0xc00028c6a8 n := node.parent:0xc000c24ee8 n := predecessor.parent:0xc0006ab400 n := root.children[dir]:0xc000c25430 n := root.children[takeOpposite(dir)].copy():0xc000225d00 n := sl.head:0xc000827390 n := successor.parent:0xc000c24e68 n := t.context.getNode(id):0xc000c24808 n := t.context.getNode(t.Root):0xc0002256f0 n := t.createRoot():0xc000a13260 n := xft.layers[xft.bits-1][key]:0xc0001bf7b8 n := xft.max:0xc0000a53f0 n := xft.min:0xc0000a5118 n := xft.min.parent:0xc0004a42b0 n := xft.predecessor(key):0xc000225c58 n := xft.successor(key):0xc000225c50 n = &rb.nodes[pos&rb.mask]:0xc000a12470 n = cp:0xc0000a47c8 n = insert(n, &entry{defaultHasher(i), i, -i}):0xc0000a43d0 n = insert(n, &entry{defaultHasher(i), i, i}):0xc0006ab290 n = insert(n, &entry{hashfunc(i), i, -i}):0xc0006ab1f8 n = insert(n, &entry{hashfunc(i), i, i}):0xc00028c790 n = insertTest(t, collisionHash, 1000):0xc0001bf4d0 n = local:0xc0008275c8 n = ls.src.Int63():0xc000224578 n = n.children[0]:0xc000224f28 n = n.children[1]:0xc000224f98 n = n.children[leftOrRight]:0xc0001bf880 n = n.copy():0xc0004a5658 n = n.forward[offset]:0xc0008273b0 n = n.parent:0xc0000a51a0 n = n.right:0xc000a13528 n = parent:0xc00028c8e8 n = parent.searchNode(key):0xc0006aa9f8 n = predecessor:0xc0000a5458 n = remove(n, defaultHasher(i), i):0xc000913830 n = remove(n, hashfunc(i), i):0xc0004a4938 n = right:0xc000a13108 n = root:0xc0001bf820 n = successor:0xc0000a51a8 n = xft.root:0xc0001bf810 n, _ := on.get(entry.ValueAtDimension(i)):0xc0008270e0 n, _ := sl.search(cmp, nil, nil):0xc000c255a8 n, _ := sl.search(cmp, sl.cache, sl.posCache):0xc00000f8f0 n, _ := sl.searchByPosition(pos, nil, nil):0xc000c25558 n, _ := sl.searchByPosition(position+1, nil, nil):0xc000826420 n, _ := t.contextOrCachedNode(id, true):0xc0001bffe0 n, _ = sl.search(cmp, nil, nil):0xc0006ab668 n, _, err := t.iterativeFindWithoutPath(value, t.Root):0xc0006aadf8 n, err := c.loadNode(t, key):0xc000826a10 n, err := nodeFromBytes(t, items[0].Payload):0xc0001be680 n, err := t.contextOrCachedNode(ID(id), true):0xc000a132c0 n, err := t.contextOrCachedNode(id, true):0xc000a13d50 n, err := t.contextOrCachedNode(key.UUID, true):0xc0000a4760 n, err = t.contextOrCachedNode(id, t.mutable):0xc0001bfde8 n, highestValue, err := t.iterativeFindWithoutPath(cur, t.Root):0xc0001bfae0 n, ok := layers[mid][key&masks[diff+mid]]:0xc00039d208 n, pos := sl.search(cmp, nil, nil):0xc00028c040 n, pos := sl.search(cmp, sl.cache, sl.posCache):0xc000225c68 n, pos := sl.searchByPosition(position, sl.cache, sl.posCache):0xc00028d128 n.(*node).parent = nn:0xc0004a5d58 n.ChildKeys = append(n.ChildKeys, bundle.k):0xc0001bfcd0 n.ChildKeys = append(n.ChildKeys, key):0xc000827540 n.ChildKeys = append(n.ChildKeys, nil):0xc000827548 n.ChildKeys = append(n.ChildKeys, other.ChildKeys...):0xc000225990 n.ChildKeys = n.ChildKeys[:0]:0xc000a13960 n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-1]:0xc0006aa2f0 n.ChildKeys = n.ChildKeys[:len(n.ChildKeys)-len(indices)]:0xc000a139a0 n.ChildKeys = n.ChildKeys[i+1:]:0xc0004a49d8 n.ChildKeys = nsw.keys:0xc0001bfd30 n.ChildKeys[0] = key:0xc0004a5ca8 n.ChildKeys[i] = bundle.k:0xc0001bfcc0 n.ChildKeys[i] = key:0xc000827510 n.ChildKeys[i] = nil:0xc000a13950 n.ChildKeys[j] = nil:0xc0004a49d0 n.ChildKeys[len(n.ChildKeys)-1] = nil:0xc0006aa178 n.ChildValues = append(n.ChildValues, 0):0xc000827520 n.ChildValues = append(n.ChildValues, bundle.k.Value):0xc0001bfcc8 n.ChildValues = append(n.ChildValues, key.Value):0xc0008274f8 n.ChildValues = append(n.ChildValues, nil):0xc000225bf8 n.ChildValues = append(n.ChildValues, other.ChildValues...):0xc000225988 n.ChildValues = append(n.ChildValues, value):0xc0004a4bb0 n.ChildValues = n.ChildValues[:0]:0xc000a13968 n.ChildValues = n.ChildValues[:len(n.ChildValues)-1]:0xc0008279c0 n.ChildValues = n.ChildValues[:len(n.ChildValues)-len(indices)]:0xc000a13998 n.ChildValues = n.ChildValues[i+1:]:0xc0004a49a8 n.ChildValues = nsw.values:0xc0001bfd28 n.ChildValues, n.ChildKeys = n.flatten():0xc000224888 n.ChildValues, n.ChildKeys = nil, nil:0xc0002248a0 n.ChildValues[0] = value:0xc000225c08 n.ChildValues[i] = key.Value:0xc000827530 n.ChildValues[i] = nil:0xc000a13948 n.ChildValues[i] = value:0xc0006ab598 n.ChildValues[len(n.ChildValues)-1] = 0:0xc0008279b8 n.IsLeaf = true:0xc00028c6b0 n.adjustRange():0xc0009132a0 n.balance = 0:0xc0004a5eb0 n.balance = bal:0xc000225d40 n.balance = int8(bal):0xc0004a5ec0 n.children[0] = node:0xc000c24e80 n.children[0] = predecessor:0xc0001bf8a8 n.children[0], n.children[1] = nil, nil:0xc000224338 n.children[0].query(low, high, interval, maxDimension, fn):0xc00000f1d0 n.children[1] = node:0xc0006ab410 n.children[1] = successor:0xc0001bf8b0 n.children[1].query(low, high, interval, maxDimension, fn):0xc00000f1f0 n.children[i].adjustRanges():0xc000913298 n.children[leftOrRight] = nn:0xc0001bf870 n.data = item:0xc000a12f78 n.data = nil:0xc0001bf338 n.deleteKeyAt(0):0xc000225b60 n.deleteKeyAt(i):0xc000827570 n.deleteKeyAt(len(n.ChildKeys) - 1):0xc000826470 n.deleteValueAt(0):0xc000c242c8 n.deleteValueAt(i):0xc000827568 n.deleteValueAt(len(n.ChildValues) - 1):0xc000225bc0 n.entry = cmp:0xc0001bfa08 n.entry = entry:0xc000191428 n.insert(t.config.Comparator, key):0xc000225b10 n.insert(tree, k2):0xc000c24d98 n.insert(tree, key):0xc000826258 n.keys = n.keys[:i]:0xc0006ab350 n.keys = ourKeys:0xc000913640 n.keys.delete(key):0xc000a13dd8 n.keys.deleteAt(i):0xc000225a50 n.keys.insertAt(i, kb.key):0xc000827968 n.keys.insertAt(key, i):0xc000c24c78 n.keys[i], n.keys[j] = n.keys[j], n.keys[i]:0xc000c255c0 n.keys[j] = nil:0xc0006ab328 n.lock.RUnlock():0xc000a13100 n.lock.Unlock():0xc00028c8a8 n.maxHilbert = kb.key:0xc000827960 n.maxHilbert = kb.right.(*node).maxHilbert:0xc0008279a8 n.maxHilbert = n.keys.last():0xc000225c48 n.maxSeen = key:0xc0006ab348 n.mbr = newRectangleFromRects(n.nodes.list):0xc000225c38 n.mbr.adjust(kb.left):0xc000827990 n.mbr.adjust(kb.right):0xc000827998 n.nodes = n.nodes[:i+1]:0xc0006ab358 n.nodes = right:0xc000913648 n.nodes.deleteAt(i):0xc000225a58 n.nodes.insertAt(i+1, kb.right):0xc000827988 n.nodes.insertAt(i, kb.left):0xc000827970 n.nodes.insertAt(index+1, kb.right):0xc0001bfdb8 n.nodes.insertAt(other, i):0xc000c24c80 n.nodes.list[i] = kb.left:0xc000827958 n.nodes.push(kb.left):0xc0001bfd98 n.nodes.push(kb.right):0xc0001bfda0 n.nodes.replaceAt(i, kb.left):0xc000827980 n.nodes.replaceAt(index, kb.left):0xc0001bfdb0 n.nodes[j] = nil:0xc0006ab330 n.orderedNodes = make(orderedNodes, 0, 10):0xc000191418 n.parent = nn:0xc000a13df8 n.parent.children[leftOrRight] = nil:0xc000224330 n.print(output):0xc000a13918 n.right = nn:0xc000225270 n.right.lock.Lock():0xc000a130e8 n.right.lock.RLock():0xc000a130f8 n.value = value:0xc000191408 n.values[i], n.values[j] = n.values[j], n.values[i]:0xc000c255b8 n1 := newNode(4, constructMockEntry(1, 4), false):0xc000826678 n1 := newNode(e1, 8):0xc000191b90 n1 := newNode(nil, e1):0xc00000f3b0 n1 := newTestNode(true, 3):0xc000191e30 n1 := newTestNode(true, 4):0xc00028c6c0 n1.children[1] = n2:0xc00000f3d0 n1.forward[0] = n2:0xc000191be0 n1.keys.insert(mockKey(1)):0xc000191e38 n2 := newNode(1, constructMockEntry(2, 1), false):0xc000826680 n2 := newNode(e2, 8):0xc000191bd8 n2 := newNode(nil, e2):0xc00000f3c8 n2 := newTestNode(true, 3):0xc000191e40 n2 := newTestNode(true, 4):0xc00028c6c8 n2.keys.insert(mockKey(5)):0xc000191e48 n3 := newNode(2, constructMockEntry(3, 2), false):0xc0002258a0 n3 := newNode(4, constructMockEntry(1, 4), false):0xc0008266a8 n3 := newTestNode(true, 3):0xc000191e50 n3 := newTestNode(true, 4):0xc00028c6d0 n3.keys.insert(mockKey(10)):0xc000191e58 n4 := newTestNode(true, 3):0xc000191e60 n4 := newTestNode(true, 4):0xc00028c6d8 n4.keys.insert(mockKey(15)):0xc000191e68 n5 := newTestNode(true, 4):0xc00028c6e0 n5.keys.insert(mockKey(20)):0xc00028c6e8 n:		n,:0xc0008278a8 n:	n,:0xc000c25568 n:	n1,:0xc000191ba0 n:	xft.successor(key),:0xc000c243a8 nandDenseWithDenseBitArray(dba, other):0xc0004a5c58 nandDenseWithSparseBitArray(ba, other):0xc00028cda0 nandSparseWithDenseBitArray(sba, other):0xc000224560 nandSparseWithSparseBitArray(sba, other):0xc0004a5a88 nb := &immutableNodeBundle{:0xc0008275a0 nb := &nodeBundle{list: list, index: index}:0xc0004a5560 nb := ot.path[i]:0xc0004a5580 nb := path[i]:0xc0008275e8 nb.list = &nodes:0xc000827608 nb.list.deleteAt(nb.index):0xc0004a5588 nb.previousNode.entry,:0xc000827628 nb.previousNode.value,:0xc000827620 ncn := &cNode{bmp: bmp ^ flag, array: array, gen: gen}:0xc0008268a0 ncn := &cNode{bmp: bmp | flag, array: array, gen: gen}:0xc0001bf5d8 ncn := &cNode{bmp: c.bmp, array: array, gen: gen}:0xc00000f630 ncn := &mainNode{cNode: cn.updated(pos, &sNode{entry}, i.gen)}:0xc000224220 ncn := &mainNode{cNode: rn.inserted(pos, flag, &sNode{entry}, i.gen)}:0xc0002241b0 ncn := &mainNode{cNode: rn.updated(pos, nin, i.gen)}:0xc000224218 ncn := cn.removed(pos, flag, i.gen):0xc0000a4108 ncn := pMain.cNode.updated(pos, resurrect(i, main), i.gen):0xc0000a43c8 nd := n.nodes.byPosition(n.nodes.len() - 1):0xc000826d90 nd := n.nodes.list[i]:0xc000826ce8 needsMerged := t.config.NodeWidth / 2:0xc0000a42a0 needsMerged = 1:0xc0000a43a0 neighbor := keys[j]:0xc000225620 newEntry := constructMockEntry(10, 10, 10):0xc0000a5888 newEntry := constructMockEntry(10, oldEntry.ValueAtDimension(1),:0xc0004a4c08 newHeap, err := heap.Merge(nil):0xc0001bfe28 newInsertAction(keys),:0xc0006aafa0 newInsertAction(rects),:0xc000c24bd8 newNode := mapping[string(parent.ID)]:0xc000225aa8 newNode := n:0xc000a13448 newNode := newNode(entry.ValueAtDimension(i), entry, false):0xc000826e58 newNode = t.context.getNode(parent.ID):0xc000225ac8 newNode(entry.ValueAtDimension(i), entry, false),:0xc0004a51a0 newNode.dataMap = newNode.dataMap.ClearBit(index):0xc000a134a8 newNode.dataMap = newNode.dataMap.SetBit(index):0xc000a13468 newNode.entries[index] = cNode:0xc000a134a0 newNode.entries[index] = cNode.entries[0]:0xc0004a4778 newNode.entries[index] = e:0xc0004a4750 newNode.entries[index] = entry:0xc000a13460 newNode.entries[index] = insert(newNode.entries[index].(*node), entry):0xc000a134d0 newNode.entries[index] = nil:0xc0004a4708 newNode.entries[index] = subNode:0xc000827280 newNode.nodeMap = newNode.nodeMap.ClearBit(index):0xc0004a4758 newNode.nodeMap = newNode.nodeMap.SetBit(index):0xc000827278 newNodes := make(map[string]*path):0xc000225a78 newNodes[string(parent.ID)] = path:0xc000225af0 newPriority, node.Priority):0xc0002253a8 newRoot := &iNode{:0xc00000f848 newWs := make(waiters, 0, len(*w)):0xc000826f50 newWs = append(newWs, ws[i]):0xc000826f68 next := iter.xfastIterator.Next():0xc000c24618 nextLayerDelete := make(map[*node][]*keyBundle):0xc0004a5b70 nextLayerWrite := make(map[*node][]*keyBundle):0xc0004a5b68 nextLayerWrite[parent] = append(nextLayerWrite[parent], &keyBundle{key: k, left: nodes[i*2], right: nodes[i*2+1]}):0xc000c254c0 nextLayerWrite[parent] = append(nextLayerWrite[parent], kb):0xc0004a5c18 nextblock, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]):0xc000a98590 nextuint, bytesRead = Uint64FromBytes(incoming[curLoc : curLoc+intsize]):0xc000a985b0 nin := &iNode{gen: gen}:0xc0004a5368 nin := &iNode{main: newMainNode(sn, sn.hash, nsn, nsn.hash, lev+w, i.gen), gen: i.gen}:0xc000224210 nl, _ := l.Remove(uint(idx)):0xc000a13bd0 nl, _ := l.Tail():0xc0008272f8 nl, err := l.tail.Insert(val, pos-1):0xc0006ab228 nl, err := l.tail.Remove(pos - 1):0xc000827308 nln := &mainNode{lNode: main.lNode.inserted(entry)}:0xc0004a41b0 nln := &mainNode{lNode: main.lNode.removed(entry)}:0xc0000a4140 nln = entomb(nln.lNode.entry()):0xc0000a4150 nm := newNelderMead(config):0xc0004a5f00 nm.distance = determineDistance(nm.result, config.Target):0xc000a138b0 nm.evaluate():0xc0004a5f08 nm.result, nm.good = config.Fn(nm.vars):0xc000a138a8 nm.results.insert(vertices[0]):0xc00028d4f0 nm.results.reSort(vertices[0]):0xc00028d5c8 nm.shrink(vertices):0xc00028d5c0 nn := &node{:0xc000225250 nn := n.children[takeOpposite(dir)]:0xc0004a5e90 nn := newNode(:0xc000827618 nn := newNode(cmp, nodeLevel):0xc0001bfa40 nn := newNode(cp[j].value+number, cp[j].entry, !lastDimension):0xc0008277e8 nn := newNode(false, rightKeys, rightNodes):0xc0006ab338 nn := newNode(oldNode.value, oldNode.entry, !lastDimension):0xc000827848 nn = newNode(n, entry):0xc0001bf860 nn = newNode(n, nil):0xc0001bf858 nn.balance = 0:0xc0004a5ec8 nn.forward[i] = cache[i].forward[i]:0xc0001bfa50 nn.maxHilbert = nn.keys.last():0xc0004a5d60 nn.maxHilbert = rightKeys.last():0xc000225c40 nn.maxSeen = n.max():0xc0006ab340 nn.mbr = newRectangleFromRects(rightNodes.list):0xc000225c30 nn.orderedNodes = cp[j].orderedNodes:0xc0008277f0 nn.orderedNodes = nodes:0xc000827638 nn.orderedNodes = oldNode.orderedNodes.immutableInsert(:0xc000827850 nn.widths[i] = 0:0xc0001bfa70 nn.widths[i] = posCache[i] + formerWidth + 1 - pos:0xc0001bfa78 node				= &dummy:0xc000a12098 node			= tree.root:0xc0001bfb58 node := &lnode{:0xc000c24ac0 node := get(d.root, d.hasher(key), key):0xc000913340 node := heap.Enqueue(1):0xc0001bf230 node := heap.Enqueue(SomeNumber):0xc000912528 node := newNode(value, entry, !isLastDimension):0xc000c24c30 node := pb.n:0xc0002255c8 node := t.context.getNode(ID(id)):0xc000225a88 node = cp:0xc0002255f0 node = n:0xc00039d218 node = newNode(iv, ivLow, max, 1):0xc0001bfb98 node = parent:0xc0002256d0 node, _ := heap.DequeueMin():0xc00039cdb0 node, _ = list.getOrAdd(entry, i, irt.dimensions):0xc000826e78 node, _ = list.getOrAdd(entry, i, ot.dimensions):0xc0004a51c0 node, index = list.get(value):0xc0004a5550 node, sibling = sibling, node:0xc0000a4830 node.Priority = priority:0xc000a13b78 node.append(sibling):0xc0000a4aa0 node.appendChild(key):0xc0000a4a90 node.appendValue(correctedValue):0xc0000a4a88 node.appendValue(parentValue):0xc0000a5588 node.children[0].red = false:0xc0001bfbb8 node.children[1] = tree.root:0xc000a12108 node.children[1].red = false:0xc0001bfbc0 node.delete(t.config.Comparator, k):0xc000225650 node.keys = ourKeys:0xc000826228 node.marked = false:0xc0006ab4f0 node.max = max:0xc0001bfbd0 node.min = ivLow:0xc0001bfbe0 node.multiDelete(t.config.Comparator, toDelete...):0xc000225640 node.next = node:0xc0006ab560 node.next.prev = node.prev:0xc0006ab528 node.orderedNodes = *list:0xc000826e70 node.orderedNodes.flatten(entries):0xc00028ca18 node.orderedNodes.insert(:0xc0004a5810 node.parent = nil:0xc0006ab588 node.parent.child = nil:0xc0006ab548 node.parent.child = node.next:0xc0006ab540 node.parent.degree--:0xc0006ab550 node.parent.marked = true:0xc0006ab580 node.prev = node:0xc0006ab558 node.prev.next = node.next:0xc0006ab530 node.red = true:0xc0001bfbb0 node:	node,:0xc000827400 node:	node.pointer,:0xc0008273f8 nodeLevel := generateLevel(sl.maxLevel):0xc0001bfa18 nodeSize:	nodeSize,:0xc00039d250 nodeh1_1 := heap1.Enqueue(SomeLargerNumberAround15):0xc00028c4f0 nodeh2_1 := heap2.Enqueue(SomeNumberAroundMinus1000):0xc00028c518 nodeh2_2 := heap2.Enqueue(SomeNumberAround0):0xc00028c528 nodes := []*node{t.root}:0xc00039ca30 nodes := constructMockNodes(2):0xc000225b90 nodes := constructMockNodes(4):0xc00028cb90 nodes := constructMockNodes(5):0xc000225b68 nodes := make([]*node, 0, n.nodes.len()):0xc0004a5be0 nodes := make(map[string][]*nodeBundle, 10):0xc0004a4128 nodes := make(nodes, 0, num):0xc000c24aa8 nodes := make(orderedNodes, 0):0xc000826670 nodes := make(orderedNodes, len(*list)):0xc000826e38 nodes := make(orderedNodes, len(*nb.list)):0xc0008275f8 nodes = append(nodes, c.children[0]):0xc00039d338 nodes = append(nodes, c.children[1]):0xc00039d348 nodes = append(nodes, node):0xc000c24ad0 nodes = newNodes:0xc000225b20 nodes = nodes[:len(nodes)-1]:0xc00039ca60 nodes, err := t.determinePaths(keys):0xc000a13278 nodes.add(n1):0xc000224740 nodes.add(n2):0xc000224750 nodes.deleteAt(index - i):0xc0004a5800 nodes:	left,:0xc000913638 nodes:	make(nodes, 0, ary+1),:0xc0006aa898 nodes:	make(nodes, 0, size+1),:0xc0006aa700 nodes:	newNodes(ptree.ary),:0xc0004a5b58 nodes:	newNodes(tree.ary),:0xc000c25488 nodes:	newNodes(uint64(cap(n.nodes.list))),:0xc000c241c8 nodes:	nodes,:0xc0008271a0 nodes:	ns,:0xc0008276f8 nodes:	rightNodes,:0xc000225c20 nodes[i-1].(*lnode).pointer = node:0xc000c24ad8 nodes[string(pb.path.peek().n.ID)] = append(nodes[string(pb.path.pop().n.ID)], pb):0xc0004a4188 normalized = normalizeComparison(dir):0xc000225438 normalized = normalizeComparison(p.entry.Compare(entry)):0xc0002254e0 normalized = normalizeComparison(s.entry.Compare(entry)):0xc000225510 ns := make(orderedNodes, 0):0xc000827748 ns := make(orderedNodes, 0, numItems):0xc000a13ba0 ns.add(n1):0xc000827750 ns.add(n2):0xc000827758 ns.add(n3):0xc0002258a8 ns.add(newNode(int64(i), constructMockEntry(uint64(i), int64(i)), false)):0xc000a13bb0 ns.apply(0, 0, func(n *node) bool {:0xc000827788 ns.apply(0, 100, func(n *node) bool {:0xc0008277c8 ns.apply(0, 5, func(n *node) bool {:0xc0008277b0 ns.apply(1, 1, func(n *node) bool {:0xc000827768 ns.apply(2, 3, func(n *node) bool {:0xc000827798 ns.apply(4, 5, func(n *node) bool {:0xc0008277a0 ns.apply(5, 10, func(n *node) bool {:0xc0008277c0 ns.insert(2, 2, 2, 0, -5, &modified, &deleted):0xc0002258c0 ns.list = append(ns.list, n):0xc0006aab80 ns.list = append(ns.list, nil):0xc00028c610 ns.list = ns.list[:i]:0xc0000a4cb8 ns.list = ns.list[:len(ns.list)-1]:0xc000a13388 ns.list[i] = n:0xc00028c620 ns.list[j] = nil:0xc0000a4a70 ns:		make([]*node, len(keys)),:0xc00039d3e8 ns:		make([]*node, len(rects)),:0xc0001be288 ns[i] = nil:0xc00039cbe8 nsn := &sNode{entry}:0xc000224208 nsw := &nodeSortWrapper{:0xc0001bfcd8 nsw.keys = nsw.keys[i:]:0xc0001bfd18 nsw.keys[i] = nil:0xc0001bfd20 nsw.values = nsw.values[i:]:0xc0001bfd10 num := 11:0xc0006aa300 num := 15:0xc0000a42b8 num := 20:0xc000c240b8 num := 200:0xc000224248 num := 5:0xc0000a5708 num := 50:0xc0000a4440 num := int(rand.Int31n(100)):0xc0000a4550 num := len(vertices):0xc000913560 num++:0xc0000a4560 numBits := uint64(162432):0xc00000f938 numCPU := 1:0xc00000f670 numCPU := int64(runtime.NumCPU()):0xc0006aabf0 numCPU := runtime.NumCPU():0xc0001bf6f0 numCPU := uint64(runtime.NumCPU()):0xc0008272a0 numCPU = minUint64(numCPU, uint64(len(ifs))):0xc0008272b8 numCPU = runtime.NumCPU() - 1:0xc00000f680 numCPU++:0xc0006aac00 numCPU--:0xc0008272b0 numCalls := uint64(0):0xc000224630 numCells := 100000:0xc0006ab100 numItems := 1000:0xc000a12e58 numItems := 10000:0xc00000eaf8 numItems := 100000:0xc0001bfec8 numItems := 1000000:0xc0004a4408 numItems := b.N:0xc00000e940 numItems := int64(1000):0xc000827720 numItems := int64(100000):0xc0004a5a90 numItems := int64(b.N):0xc00028d240 numItems := uint64(100):0xc000c24ae8 numItems := uint64(1000):0xc000826218 numItems := uint64(100000):0xc0006aa070 numItems := uint64(1280):0xc00000ef70 numItems := uint64(160000):0xc00000f2f0 numItems := uint64(168000):0xc00039d268 numItemsX := 10000:0xc000224a60 numItemsY := 100:0xc000224a68 numLoops := 3:0xc0004a5c60 numRoutines := 8:0xc0002245d8 numThreads := 8:0xc000c241d0 number := 100:0xc00028cde8 number := 1000000:0xc0006aa238 number := 15:0xc0002246d8 number := 400:0xc0004a5d68 number := 5:0xc00028d368 number := cfg.NodeWidth * 5:0xc000224a98 number = -number:0xc000224fd0 number:	immutable.number,:0xc0009127d8 nums := ba.ToNums():0xc0004a5468 nums := make([]uint64, 0, 0):0xc000224b28 nums := make([]uint64, 0, ba.highest-ba.lowest/4):0xc0000a52b8 nums := make([]uint64, 0, diff/4):0xc000c24d68 nv	= desc.nv:0xc000224ad0 nv:		nv,:0xc0006aa0b0 o = append(o, 0x83, 0xa1, 0x75):0xc00000e558 o = append(o, 0x84, 0xa1, 0x75):0xc00000f208 o = append(o, 0x84, 0xa2, 0x69, 0x64):0xc000827670 o = append(o, 0xa1, 0x63):0xc00000f218 o = append(o, 0xa1, 0x70):0xc00000e6d8 o = append(o, 0xa1, 0x72):0xc00000f228 o = append(o, 0xa1, 0x76):0xc00000e5c8 o = append(o, 0xa2, 0x63, 0x6b):0xc0008276b0 o = append(o, 0xa2, 0x63, 0x76):0xc000827690 o = append(o, 0xa2, 0x69, 0x6c):0xc000827680 o = append(o, 0xa2, 0x6e, 0x77):0xc00000f238 o = bts:0xc00028c608 o = msgp.AppendArrayHeader(o, uint32(len(z))):0xc000826940 o = msgp.AppendArrayHeader(o, uint32(len(z.ChildKeys))):0xc0008276b8 o = msgp.AppendArrayHeader(o, uint32(len(z.ChildValues))):0xc000827698 o = msgp.AppendBool(o, z.IsLeaf):0xc000827688 o = msgp.AppendBytes(o, []byte(z)):0xc000a12ef0 o = msgp.AppendBytes(o, []byte(z.ID)):0xc000827678 o = msgp.AppendBytes(o, []byte(z.UUID)):0xc00000e5b8 o = msgp.AppendBytes(o, z.Payload):0xc00000e708 o = msgp.AppendInt(o, z.Count):0xc00000f220 o = msgp.AppendInt(o, z.NodeWidth):0xc00000f240 o = msgp.AppendNil(o):0xc000827338 o = msgp.Require(b, z.Msgsize()):0xc000a12ee8 o, err = msgp.AppendIntf(o, z.ChildValues[cmr]):0xc0008276a8 o, err = msgp.AppendIntf(o, z.Value):0xc00000e698 o, err = z.ChildKeys[ajw].MarshalMsg(o):0xc0008276d0 o, err = z.Root.MarshalMsg(o):0xc00000f230 o, err = z.UUID.MarshalMsg(o):0xc00000f210 o, err = z[xvk].MarshalMsg(o):0xc000827340 o[i], o[j] = o[j], o[i]:0xc00028c808 oc := make(orderedItems, 0):0xc0000a4548 oc := make(orderedItems, 0, len(items)):0xc0004a59a0 oc := nm.outsideContract(vertices, midpoint, reflection):0xc00028d578 oc := toOrdered(generateRandomItems(1000)):0xc0006aa0e0 oc := toOrdered(items):0xc0006aa1c0 oc = mutated:0xc0000a45c8 oc = oc.add(c):0xc0006aa1f8 oc = oc.add(item):0xc0001bfea8 oc = oc.delete(c):0xc0006aa1e8 offset *= float64(i / N):0xc00028ced0 offset += uint64(len(chunk)):0xc0008263f8 offset := float64(2):0xc00028cec0 offset := int64(rand.Intn(100)):0xc000225290 offset := length - i:0xc0004a4918 offset := value - index:0xc000224fd8 offset = sl.level - i:0xc000827398 ok, err := ba.GetBit(position):0xc0000a4fd8 ok, err := rb.Offer("foo"):0xc000826900 ok, err := rb.Offer(i):0xc00028d228 ok, err := result.GetBit(1500):0xc000a132e0 ok, err := result.GetBit(i):0xc0000a53a0 ok, err := result.GetBit(s - 1):0xc0000a53a8 ok, err = rb.Offer("bar"):0xc000826908 ok, err = rb.Offer("baz"):0xc000826910 ok, err = result.GetBit(1500):0xc0004a5988 ok, err = result.GetBit(1700):0xc0004a5990 ok, err = result.GetBit(2000):0xc0000a53c8 ok, err = result.GetBit(2500):0xc000a13300 ok, err = result.GetBit(s - 1):0xc000a132e8 ok, err = result.GetBit(s - 2):0xc0000a53b0 old := ks.list[i]:0xc0001bf260 old := n.insert(kb):0xc0004a59b8 old := n.nodes.list[i]:0xc000827950 old = ks.list[i]:0xc000826848 old:		old,:0xc0006aa098 oldEntry			Entry:0xc00028cfa0 oldEntry := (*entries)[i]:0xc00039ceb0 oldEntry := entries[2]:0xc0004a4c00 oldEntry := lb.entry:0xc00000f458 oldEntry := n.entry:0xc0001bfa00 oldEntry := p.entry:0xc000225488 oldEntry = it.entry:0xc00028cff0 oldEntry.ValueAtDimension(2)):0xc0004a4c10 oldKey := (*keys)[i]:0xc0001be640 oldKey, _ := n.keys.insert(kb.key):0xc0001bfd78 oldKey, index := n.keys.insert(kb.key):0xc0001bfda8 oldLength := tree.Len():0xc000a13f28 oldNode := nodes[i]:0xc000827840 oldTop := top:0xc00028d038 oldeMain := gcasRead(ov, c):0xc000224af0 omi := other.(mockItem):0xc000191770 on := irt.top:0xc00000f6c0 on := ot.top:0xc0008270d8 on = n.orderedNodes:0xc0008270f0 one := vertices[0]:0xc0000a56d0 one.next = two.next:0xc00000f728 one.next.prev = one:0xc00000f730 oneNext := one.next:0xc00000f720 oode.provided, oode.max,:0xc00028c298 option := func(*cache) {:0xc00028c468 option(c):0xc000191858 optionApplied := false:0xc00028c460 optionApplied = true:0xc00028c470 orDenseWithDenseBitArray(dba, other):0xc000a13b50 orSparseWithDenseBitArray(sba, other):0xc000913528 orSparseWithSparseBitArray(sba, other):0xc00000f300 ordered := toOrdered(items):0xc000c240c8 ordered = ordered.delete(c):0xc0004a4280 ot.apply(ot.top, interval, 1, func(n *node) bool {:0xc000827660 ot.number -= uint64(len(deleted)):0xc0004a5a28 ot.number++:0xc0004a51b0 ot.number--:0xc0004a5570 ot.path = append(ot.path, nb):0xc0004a5568 ot.path = ot.path[:0]:0xc0006aa620 ot.resetPath():0xc0004a5538 ot.top.insert(dimension, 1, ot.dimensions,:0xc0004a5a18 other := newBitArray(1000):0xc000826398 other := newBitArray(2000):0xc000a132c8 other := newBitArray(300):0xc0008266e8 other := newBitArray(512):0xc00028c9c0 other := newBitArray(ba.Capacity()):0xc000826480 other := newBitArray(numItems):0xc000912028 other := newBitArray(s + 1):0xc00039d2e0 other := newSparseBitArray():0xc0004a53b0 other := treeSlice[curr.degree]:0xc000913768 other = newBitArray(ba.Capacity() + 1):0xc00000ea38 other.SetBit(0):0xc00039d308 other.SetBit(1):0xc0004a53f0 other.SetBit(10):0xc0006ab3a8 other.SetBit(100):0xc0004a53d0 other.SetBit(1001):0xc0004a53e0 other.SetBit(128):0xc00028c9d0 other.SetBit(150):0xc0008266f0 other.SetBit(1500):0xc000a132d0 other.SetBit(1501):0xc0001bf628 other.SetBit(156):0xc000826708 other.SetBit(159999):0xc00028ca38 other.SetBit(18):0xc0001bf610 other.SetBit(2000):0xc0000a53b8 other.SetBit(222):0xc0001bf620 other.SetBit(2680):0xc0004a5400 other.SetBit(30):0xc0004a5410 other.SetBit(300):0xc000826820 other.SetBit(5):0xc00000ea20 other.SetBit(9):0xc0004a53c8 other.SetBit(i):0xc0000a5378 other.SetBit(s * 2):0xc000225788 other.SetBit(s + 1):0xc00039d300 other.SetBit(s - 1):0xc0000a5390 other.SetBit(s*2 + 1):0xc000225790 other.blocks[selfValue]):0xc0006aaf18 other.min = nil:0xc000c25070 other.size = 0:0xc000c25080 otherDir := takeOpposite(dir):0xc000c25348 otherDir = takeOpposite(dir):0xc000a12128 otherI, otherBlock := iter.Value():0xc0002257b8 otherIndex := 0:0xc00000e310 otherIndex++:0xc00000f078 otherIndex, otherBlock := iter.Value():0xc00000e300 otherK := other.(mockKey):0xc00000e328 otherKey := other.(mockKey):0xc000912780 otherKeys := make(keys, i, cap(n.keys)):0xc000913608 otherKeys := make(keys, i, cap(node.keys)):0xc0008261f8 otherLast		= 1:0xc0001bfb68 otherLast = takeOpposite(last):0xc0001bfc20 otherMe := other.(mockEntry):0xc00039ce78 otherNode := &inode{:0xc000913628 otherNode := &lnode{:0xc000826238 otherSe := other.(skipEntry):0xc000912fe8 otherU := other.(mockEntry):0xc000191750 otherValue := other.indices[otherIndex]:0xc00000f060 ourKeys := make(keys, len(n.keys)-i-1, cap(n.keys)):0xc000913600 ourKeys := make(keys, len(node.keys)-i, cap(node.keys)):0xc000826208 out := make(chan Entry):0xc000a13cf8 out <- ce:0xc00000f7a8 out <- e:0xc00000f780 outBytes, err := input.Serialize():0xc00000ef98 output := newBitArray(0):0xc000191cb0 output := newSparseBitArray():0xc00000efc8 output, err := Unmarshal(outputBytes):0xc000826650 output, err = Unmarshal(nil):0xc000827168 output.Printf(`KEY: %+v`, k):0xc000225be0 output.Printf(`NODE: %+v, %p`, n, n):0xc000a13900 output.Println(`NIL NODE`):0xc000a13910 output.Println(`PRINTING B-LINK`):0xc0001be3e8 outputBytes, err := Marshal(input):0xc000826558 outputBytes[0] = 'C':0xc000827158 ov	= desc.old:0xc000224ac0 overhang := (len(comparators) - length) / 2:0xc0006aa120 overwritten := (*nodes)[i]:0xc0009a05a0 overwritten := bundle.(*entriesWrapper).entries.insert(entry):0xc00000ea68 overwritten := list.add(:0xc0004a5198 overwritten := list.add(newNode):0xc000826e60 overwritten := make(Entries, 0, len(entries)):0xc000c24a40 overwritten := make(Keys, 0, len(keys)):0xc00039d398 overwritten := make(Keys, len(keys)):0xc0008260d0 overwritten := make(common.Comparators, 0, len(comparators)):0xc00028d110 overwritten := make(rangetree.Entries, len(entries)):0xc0001bf578 overwritten := n.insert(t.config.Comparator, bundle.k):0xc0004a5868 overwritten := n.keys.insert(key):0xc000c24c60 overwritten := nodes.add(n1):0xc000826688 overwritten := ot.add(entry):0xc000191f98 overwritten := rt.Add(m1):0xc0002250c0 overwritten := rt.Add(m1, m2):0xc000191f58 overwritten := sl.Insert(m1):0xc0004a5e28 overwritten := sl.Insert(m1, m2):0xc00000fb70 overwritten := tree.Add(entries...):0xc0004a4bf0 overwritten := tree.Add(entry):0xc0000a5870 overwritten = append(overwritten, blink.insert(k, &stack)):0xc00039d3a0 overwritten = append(overwritten, cp.insert(e)):0xc000225740 overwritten = append(overwritten, sl.insert(cmp)):0xc00028d118 overwritten = append(overwritten, yfast.insert(e)):0xc000c24a48 overwritten = nodes.add(n2):0xc000826698 overwritten = nodes.add(n3):0xc0008266b0 overwritten = rt.Add(m2):0xc0002250d8 overwritten = sl.Insert(m2):0xc000a13ff0 overwritten = tree.Add(newEntry):0xc0004a4c18 overwrittenKey = n.ChildKeys[i]:0xc000827508 overwritten[i] = rt.add(e):0xc0001bf588 overwritten[offset+uint64(i)] = result:0xc000826350 overwrittens := make(Entries, len(entries)):0xc000191f80 overwrittens := make(Keys, 0, 10):0xc0001bfc90 overwrittens := make(Keys, 0, len(bundles)):0xc0004a5860 overwrittens = append(overwrittens, chunk...):0xc0004a56b0 overwrittens = append(overwrittens, n.ChildKeys[i]):0xc0001bfcb8 overwrittens = append(overwrittens, overwritten):0xc0004a5870 overwrittens, err := insertLastDimension(t, n, bundles):0xc0004a5660 overwrittens, err := t.add(keys):0xc000a12438 overwrittens[i] = overwritten.entry:0xc000191fa8 p := packets[i]:0xc00039cee8 p := parent.(*inode):0xc00000ef30 p := start1 + i:0xc0002251d0 p = cache[i]:0xc00028d000 p = q:0xc0002254b8 p, s, q		*node:0xc000225408 p.balance++:0xc0002254f8 p.balance--:0xc0002254f0 p.children[0] = q:0xc000225458 p.children[1] = q:0xc000225480 p.children[dirs[i]] = q:0xc00028d018 p.children[normalized] = q:0xc0002254c8 p.entry = entry:0xc000225490 p.head = pb:0xc000c244e8 p.keys.insertAt(i, key):0xc00000ef58 p.nodes.insertAt(i+1, right):0xc00000ef68 p.nodes[i-1].(*lnode).pointer = cr:0xc00000ef50 p.nodes[i] = left:0xc00000ef60 p.tail = pb:0xc000c24508 p.tail = pb.prev:0xc00039cfe8 pMain		= (*mainNode)(atomic.LoadPointer(pMainPtr)):0xc0004a4458 pMainPtr	= (*unsafe.Pointer)(unsafe.Pointer(&p.main)):0xc0004a4450 packets := make(packets, roundUp(uint64(len(fi.packets))+1)):0xc000225028 packets.set(p):0xc00039cef0 packets.set(packet):0xc000225040 packets:	make(packets, hint),:0xc0001be218 packets[i] = nil:0xc00039ced8 packets[i] = packet:0xc00028c340 packets[i].value = packet.value:0xc00028c348 panic("Cannot modify read-only snapshot"):0xc00000fa98 panic("Ctrie is in an invalid state"):0xc000224228 panic("reading random: " + err.Error()):0xc0000a5068 panic(`Can't only insert key in an internal node.`):0xc000c24c58 panic(`Cannot construct rectangle with no dimensions.`):0xc00000f260 panic(`Dimension is greater than possible dimensions.`):0xc00028c360 panic(`INCORRECT PARAMS FOR SYM MERGE.`):0xc0006aa118 panic(`Invalid universe size provided.`):0xc000912740 panic(`Ran out of dimensions before for loop completed.`):0xc00000f4a8 panic(`Reached past for loop without finding last dimension.`):0xc0001bf6b8 panic(`Ring buffer in a compromised state during a put operation.`):0xc000a12f50 panic(`Ring buffer in compromised state during a get operation.`):0xc0001bf310 panic(`SHOULD ONLY HAVE ONE ROOT`):0xc0004a5af8 panic(`unable to encode node`):0xc000224898 panic(`unable to encode tree`):0xc000a131f0 panic(err):0xc0000a55b8 panic(fmt.Sprintf(`Dimension: %d out of range.`, dimension)):0xc000190148 panic(fmt.Sprintf(`Node: %+v, %p not a child of: %+v, %p`, n, n, parent, parent)):0xc000a13188 parent := int((index - 1) / 2):0xc000c24bb0 parent := mapping[string(parentBundle.n.ID)]:0xc0000a47d8 parent := n.parent:0xc0004a5bb8 parent := newTestNode(false, 3):0xc000191e28 parent := newTestNode(false, 4):0xc00028c6b8 parent := newTestNode(true, 3):0xc000f04000 parent := newTestNode(true, 4):0xc000a12f90 parent := parentBundle.n:0xc000225680 parent := parentPath.n:0xc000225aa0 parent = blink.root:0xc000913168 parent = cp:0xc0002256a8 parent = dummyRoot:0xc0004a5bc0 parent = getParent(parent, nil, key):0xc000191438 parent = getParent(parent, stack, key):0xc0000a50d8 parent = int((index - 1) / 2):0xc000c24bd0 parent = moveRight(parent, key, false):0xc000191448 parent = moveRight(parent, key, true):0xc0000a50e8 parent = moveRight(parent, r.key(), true):0xc00028c8c0 parent = n:0xc0006aaa20 parent = newNode:0xc000225ad8 parent = newNode(false, make(Keys, 0, tree.ary), make(nodes, 0, tree.ary+1)):0xc00028c878 parent = parent.children[last]:0xc000a124c0 parent = parent.right:0xc0006aab70 parent = stack.pop():0xc00028c860 parent = tree.root:0xc00028c8b8 parent, grandParent	*node:0xc0001bfb50 parent, last,:0xc000a12510 parent.children[dir] = node:0xc0001bfba0 parent.children[last] = rotate(node, dir):0xc000a124b8 parent.children[otherDir] = child.children[dir]:0xc000c25358 parent.children[otherDir] = rotate(parent.children[otherDir], otherDir):0xc000c253c0 parent.children[parentDir] = node.children[childDir]:0xc000a12770 parent.deleteKeyAt(i + 1):0xc0000a4ab0 parent.deleteKeyAt(i):0xc0000a4aa8 parent.deleteValueAt(i):0xc0000a4ab8 parent.deleteValueAt(valueIndex):0xc0000a5590 parent.keys = Keys{k1, k2, k3, k4}:0xc000a12fa0 parent.keys = Keys{k1, k2, k3}:0xc000f04018 parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15), mockKey(20)}:0xc00028c6f8 parent.keys = Keys{mockKey(5), mockKey(10), mockKey(15)}:0xc000191e78 parent.keys.insert(k):0xc00028c888 parent.keys.insertAt(k, i):0xc00028c8d0 parent.lock.Lock():0xc0000a50e0 parent.lock.RLock():0xc000191440 parent.lock.RUnlock():0xc000c24710 parent.lock.Unlock():0xc0000a5100 parent.max = parent.children[0].max:0xc0004a4a60 parent.max = parent.children[1].max:0xc0004a4a70 parent.max = parent.interval.HighAtDimension(1):0xc0004a4a48 parent.maxSeen = r.max():0xc00028c880 parent.min = parent.children[0].min:0xc000a13e38 parent.min = parent.children[1].min:0xc000a13e48 parent.min = parent.interval.LowAtDimension(1):0xc000a13e28 parent.nodes = nodes{n1, n2, n3, n4, n5}:0xc00028c6f0 parent.nodes = nodes{n1, n2, n3, n4}:0xc000191e70 parent.nodes.insertAt(r, i+1):0xc00028c8e0 parent.nodes.push(l):0xc00028c890 parent.nodes.push(r):0xc00028c898 parent.nodes[i] = l:0xc00028c8d8 parent.red = false:0xc000a124e8 parent.red = true:0xc000c25368 parent.replaceKeyAt(&Key{UUID: cp.ID}, i):0xc0000a47c0 parent.replaceKeyAt(&Key{UUID: node.ID}, i):0xc0002256c8 parent.replaceKeyAt(&Key{UUID: node.ID}, valueIndex):0xc0000a5598 parent.replaceValueAt(i, correctedValue):0xc0000a4a58 parent.replaceValueAt(i, node.lastValue()):0xc0000a4a40 parent.replaceValueAt(i, value):0xc0000a4a98 parent:		parent,:0xc000191db8 parent:	n.parent,:0xc000225c28 parentBundle := path.pop():0xc0000a47d0 parentBundle := pb.prev:0xc000225678 parentDir := intFromBool(parent.children[1] == node):0xc000a12760 parentPath := path.pop():0xc000225a90 parentValue := parent.valueAt(i):0xc0000a4a48 parentValue := parent.valueAt(valueIndex):0xc0000a4ae8 parts := make([]Comparators, numParts):0xc000a12a38 parts := make([]Keys, numParts):0xc0000a4770 parts := make([][]interface{}, numParts):0xc00028d490 parts := make([]common.Comparators, numParts):0xc0009128c8 parts := make([]items, numParts):0xc000a12ca8 parts := make([]keys, numParts):0xc000c24778 parts := make([]rtree.Rectangles, numParts):0xc000a131d8 parts[i] = comparators[i*int64(len(comparators))/numParts : (i+1)*int64(len(comparators))/numParts]:0xc000a12a40 parts[i] = its[i*int64(len(its))/int64(numParts) : (i+1)*int64(len(its))/int64(numParts)]:0xc000a12cb8 parts[i] = keys[i*int64(len(keys))/int64(numParts) : (i+1)*int64(len(keys))/int64(numParts)]:0xc00028c910 parts[i] = keys[i*int64(len(keys))/numParts : (i+1)*int64(len(keys))/numParts]:0xc000912f80 parts[i] = ks[i*int64(len(ks))/numParts : (i+1)*int64(len(ks))/numParts]:0xc000c24780 parts[i] = slice[i*int64(len(slice))/numParts : (i+1)*int64(len(slice))/numParts]:0xc000a131e0 parts[i] = values[i*int64(len(values))/int64(numParts) : (i+1)*int64(len(values))/int64(numParts)]:0xc00028d498 path := &path{}:0xc0001bfdc8 path := bundles[0].path:0xc0004a5670 path := make([]*immutableNodeBundle, 0, 5):0xc000827578 path = append(path, nb):0xc0008275c0 path, err := t.iterativeFind(:0xc0004a40f0 path, err := t.iterativeFind(key.Value, t.Root):0xc0002255b8 path.append(pb):0xc0001bfe00 path.pop():0xc0002256e0 path:		make([]*nodeBundle, 0, dimensions),:0xc000c25308 path[i-1].newNode = nn:0xc000827640 pb := &pathBundle{i: i, n: n}:0xc0001bfdf8 pb := path.peek():0xc0002255c0 pb = pb.prev:0xc0002256d8 pb.prev = nil:0xc00039cff0 pb.prev = p.tail:0xc000c24530 pbs:	bundles,:0xc000912088 pbs[i], pbs[j] = pbs[j], pbs[i]:0xc000c24968 peekExpected := `a`:0xc00028d2c0 peekItem, ok := q.items.peek():0xc0008268b0 peekResult, err := q.Peek():0xc00028d2b8 persister:	persister,:0xc0004a5600 pointer := n.search(comparator, start):0xc000827890 pointer--:0xc000827898 pointer:	node,:0xc0008263e8 pointer:	pointer,:0xc0008278b0 points := constructMockPoints(100):0xc0004a5d20 points := constructMockPoints(numItems):0xc000c25518 points := constructRandomMockPoints(100):0xc00000f7b0 points := constructRandomMockPoints(3):0xc0004a58f8 pool.New = func() interface{} {:0xc0008262b8 pool.Put(set):0xc000288618 popResult, err := q.Get(1):0xc00028d2d8 pos	= atomic.LoadUint64(&rb.dequeue):0xc0001bf2d8 pos += n.widths[offset]:0xc0008273a8 pos := atomic.LoadUint64(&rb.queue):0xc000a12440 pos := ba.blocks[i].findLeftPosition():0xc00039d010 pos := ba.blocks[i].findRightPosition():0xc000191c18 pos := bitCount(bmp & mask):0xc000c24170 pos = atomic.LoadUint64(&rb.dequeue):0xc0001bf318 pos = atomic.LoadUint64(&rb.queue):0xc000a12f58 position = sl.Len():0xc00028d120 positions := make(map[interface{}]int, len(keys)):0xc0006aadb0 positions := make(map[interface{}]int, len(n.ChildValues)):0xc0001bfc88 positions[key] = i:0xc0006aadb8 positions[value] = i:0xc0001bfca0 pq.disposeLock.Lock():0xc000a13aa0 pq.disposed = true:0xc000a13ab8 pq.itemMap[item] = struct{}{}:0xc0001bf438 pq.items = nil:0xc000a13ad0 pq.items.push(item):0xc0001bf428 pq.lock.Lock():0xc0001bf408 pq.lock.Unlock():0xc000c24ff0 pq.waiters = nil:0xc000a13ad8 pq.waiters.put(sema):0xc000c25010 pred := func(item interface{}) bool {:0xc000225860 predecessor := yfast.Predecessor(5):0xc000a13a38 predecessor = n.children[0]:0xc0000a5400 predecessor = successor.children[0]:0xc0001bf890 predecessor = xft.max:0xc0001bf7f0 predecessor = xft.predecessor(key):0xc0001bf7f8 predecessor = yfast.Predecessor(100):0xc000a13a68 predecessor = yfast.Predecessor(11):0xc000a13a50 predecessor = yfast.Predecessor(13):0xc000a13a40 predecessor = yfast.Predecessor(4):0xc000a13a60 predecessor = yfast.Predecessor(5):0xc000a13a58 predecessor, i := es.predecessor(5):0xc000a13590 predecessor, i = es.predecessor(0):0xc000a135a0 predecessor, i = es.predecessor(10):0xc000a135c8 predecessor, i = es.predecessor(2):0xc000a135a8 predecessor, i = es.predecessor(5):0xc000a135b8 predecessor.children[1] = n:0xc0001bf8a0 predecessor.children[1] = successor:0xc000224498 prepend := false:0xc0000a4820 prepend = true:0xc0000a49f0 prev := (*mainNode)(atomic.LoadPointer(:0xc0000a4488 prev := (*mainNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&m.prev)))):0xc000224950 prevPtr := (*unsafe.Pointer)(unsafe.Pointer(&n.prev)):0xc0006aa020 previousNode:	n,:0xc0008275b8 println(`PRINTING TREE`):0xc0004a5d08 ptree := &ptree{}:0xc000a13fc8 ptree.actions = queue.NewRingBuffer(ptree.bufferSize):0xc0000a5320 ptree.actions.Dispose():0xc0004a5cf0 ptree.actions.Put(action):0xc00039d030 ptree.apply(n, q):0xc00039d0d8 ptree.applyNode(n, adds, deletes):0xc0004a5bc8 ptree.ary = ary:0xc0000a5308 ptree.bufferSize = bufferSize:0xc0000a5300 ptree.cache = append(ptree.cache, a):0xc00039d058 ptree.cache = make([]interface{}, 0, bufferSize):0xc0000a5310 ptree.cache = ptree.cache[:0]:0xc000a136e8 ptree.cache[i] = nil:0xc000a136e0 ptree.checkAndRun(aa):0xc000225c98 ptree.checkAndRun(ga):0xc000c24340 ptree.checkAndRun(ia):0xc00028cdc0 ptree.checkAndRun(nil):0xc00039d0e8 ptree.checkAndRun(ra):0xc000c24328 ptree.cleanMap(mp):0xc000a13558 ptree.disposeChannel = make(chan bool):0xc0000a5340 ptree.fetchKeysInParallel(xns):0xc000a13418 ptree.fetchKeysInSerial(xns):0xc000a13420 ptree.init(bufferSize, ary):0xc000a13fd0 ptree.kbRing = queue.NewRingBuffer(1024):0xc0000a5328 ptree.kbRing.Put(&keyBundle{}):0xc0000a5338 ptree.kbRing.Put(kb):0xc000826d60 ptree.mpChannel <- adds:0xc0004a5c28 ptree.mpChannel <- deletes:0xc0004a5c30 ptree.mpChannel = make(chan map[*node][]*keyBundle, 1024):0xc0000a5348 ptree.operationRunner(interfaces{action}, false):0xc00039d0b8 ptree.operationRunner(interfaces{action}, true):0xc00039d0b0 ptree.read(action):0xc00039d088 ptree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel):0xc0004a5c38 ptree.recursiveMutate(writeOperations, deleteOperations, false, threaded):0xc0001be260 ptree.reset():0xc00039d098 ptree.root = n:0xc0004a5bb0 ptree.root = newNode(true, newKeys(ary), newNodes(ary)):0xc0000a5318 ptree.root.print(output):0xc0004a5d18 ptree.splitNode(n, parent, &nodes, &keys):0xc0004a5be8 pushEntries(e.(*node), stop, out):0xc00000f790 pushEntries(n, stop, out):0xc000a13d08 q := New(0):0xc0001bfaa8 q := New(1):0xc0008267c0 q := New(10):0xc00000f0f0 q := New(int64(b.N)):0xc00000f8e8 q := New(numItems):0xc0002246a0 q := NewPriorityQueue(1, false):0xc0004a52b8 q := NewPriorityQueue(2, true):0xc000c242a8 q := NewPriorityQueue(b.N, false):0xc000c25320 q := action.(*applyAction):0xc00039d0c8 q := newMockRectangle(0, 0, 20, 20):0xc0001bff58 q := newMockRectangle(0, 0, 25, 25):0xc0006ab508 q := newMockRectangle(0, 0, 30, 30):0xc00000f9e0 q := newMockRectangle(0, 0, 5, 5):0xc00028cd10 q := newMockRectangle(0, 0, int32(len(points)), int32(len(points))):0xc0004a5d28 q := newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32):0xc00000f7b8 q := newMockRectangle(5, 0, 5, 10):0xc0004a4a78 q := newMockRectangle(5, 5, 15, 15):0xc000a133e0 q := qs[i]:0xc000224688 q = New(10):0xc00028cc70 q = newMockRectangle(0, 0, 0, 10):0xc0004a4a98 q = newMockRectangle(0, 0, 10, 0):0xc0004a4aa0 q = newMockRectangle(0, 0, 20, 20):0xc00028cd18 q = newMockRectangle(0, 0, 4, 4):0xc0001bff68 q = newMockRectangle(0, 15, 20, 15):0xc0004a4a90 q = newMockRectangle(0, 20, 20, 20):0xc0004a4ab8 q = newMockRectangle(0, 5, 10, 5):0xc0004a4a80 q = newMockRectangle(11, 11, 20, 20):0xc0001bff78 q = newMockRectangle(15, 0, 15, 20):0xc0004a4a88 q = newMockRectangle(20, 0, 20, 20):0xc0004a4aa8 q = newMockRectangle(20, 20, 30, 30):0xc00028cd28 q = newMockRectangle(6, 6, 20, 20):0xc00028cd20 q = newNode(entry):0xc0002254c0 q = nil:0xc000225460 q = p.children[0].copy():0xc000225450 q = p.children[1].copy():0xc000225478 q = p.children[dirs[i]].copy():0xc00028d010 q = s:0xc000225500 q.Dispose():0xc00000f6b8 q.Get(1):0xc000c25328 q.Poll(1, time.Millisecond):0xc0004a4378 q.Poll(1, time.Nanosecond):0xc0001bfab8 q.Put():0xc0001bf690 q.Put(`1`):0xc000c24a78 q.Put(`2`):0xc000c24a80 q.Put(`a`):0xc000c252b0 q.Put(`a`, `b`, `c`):0xc000224510 q.Put(`b`):0xc00028d2a8 q.Put(`c`):0xc00028d2b0 q.Put(`test2`):0xc00000f120 q.Put(`test`):0xc00000f0f8 q.Put(i):0xc000224628 q.Put(j):0xc000224698 q.Put(mockItem(1)):0xc0004a52d8 q.Put(mockItem(1), mockItem(3), mockItem(2)):0xc000a13b20 q.Put(mockItem(2)):0xc0004a52c0 q.Put(mockItem(i)):0xc000c25338 q.complete():0xc00039d0e0 q.disposed = true:0xc000a138b8 q.items = append(q.items, items...):0xc0001bf510 q.items = nil:0xc000a138e0 q.lock.Lock():0xc0001bf4f8 q.lock.Unlock():0xc0001bf508 q.waiters = nil:0xc000a138e8 q.waiters.put(sema):0xc000c24de8 q.waiters.remove(sema):0xc000c24e20 qs := make([]*Queue, 0, b.N):0xc000224678 qs = append(qs, q):0xc000224680 r := &rectangle{:0xc00000f278 r := &rectangle{}:0xc000191d28 r := (*iNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&c.root)))):0xc0000a4520 r := bytes.NewReader(incoming[1:]):0xc0001bfe50 r := newRectangeFromRect(rect):0xc00028c770 r := rand.Int31():0xc0004a56d0 r := rand.New(rand.NewSource(time.Now().UnixNano())):0xc000191aa0 r.adjust(rects[i]):0xc00000f288 r.xhigh = x:0xc0000a5040 r.xlow = x:0xc0000a5018 r.yhigh = y:0xc0000a5050 r.ylow = y:0xc0000a5028 r1 := newMockRectangle(0, 0, 10, 10):0xc000a133c8 r1 := newMockRectangle(0, 0, 20, 20):0xc000225540 r1 := newMockRectangle(5, 5, 5, 5):0xc00028cd00 r2 := newMockRectangle(0, 0, 20, 20):0xc0004a5e78 r2 := newMockRectangle(1, 1, 19, 19):0xc00000f9b0 r2 := newMockRectangle(10, 10, 10, 10):0xc00028cd08 r2 := newMockRectangle(5, 5, 15, 15):0xc000225548 r3 := newMockRectangle(10, 10, 20, 20):0xc0008278d0 r3 := newMockRectangle(2, 2, 18, 18):0xc00000f9b8 r4 := newMockRectangle(15, 15, 25, 25):0xc0006ab4f8 r4 := newMockRectangle(3, 3, 17, 17):0xc00000f9c0 ra := newRemoveAction(keys):0xc000c24320 ra := newRemoveAction(rects):0xc000225ce8 ra.completer.Wait():0xc000c24330 rand.Seed(time.Now().Unix()):0xc000913080 rb := &RingBuffer{}:0xc000a13398 rb := NewRingBuffer(10):0xc000225800 rb := NewRingBuffer(2):0xc0008268f0 rb := NewRingBuffer(3):0xc000826018 rb := NewRingBuffer(4):0xc0004a46a0 rb := NewRingBuffer(5):0xc00039d1c0 rb := NewRingBuffer(64):0xc000a13f90 rb := NewRingBuffer(uint64(b.N)):0xc00028d220 rb.Dispose():0xc000c24210 rb.Get():0xc0004a46b0 rb.Offer(i):0xc00000f868 rb.Poll(time.Millisecond):0xc000225808 rb.Put(1):0xc0004a46a8 rb.Put(`1`):0xc000225828 rb.Put(`2`):0xc000225830 rb.Put(`test`):0xc000225810 rb.Put(i):0xc000225bc8 rb.Put(j):0xc0004a5e00 rb.init(size):0xc000a133a0 rb.mask = size - 1:0xc0000a51d0 rb.nodes = make(nodes, size):0xc0000a51b8 rb.nodes[i] = node{position: i}:0xc0000a51c8 rdcss: &rdcssDescriptor{:0xc0006aa090 readOnly:	readOnly,:0xc000a13c60 ready:		make(chan bool, 1),:0xc000827100 rects := make(rtree.Rectangles, 0, n.nodes.len()):0xc000c253f0 rects := make(rtree.Rectangles, 0, num):0xc00028c728 rects := tree.search(ga.lookup):0xc000c24b30 rects = append(rects, child):0xc000c25400 rects = append(rects, newMockRectangle(i, i, i, i)):0xc00028c738 rects = append(rects, newMockRectangle(r, r, r, r)):0xc0004a56d8 red:		true,:0xc000c24848 reflection := nm.reflect(vertices, midpoint):0xc00028d520 removeTest(t, collisionHash, 1000):0xc00039d358 removeTest(t, defaultHasher, 10000):0xc00039d350 require.Equal(t, len(expected), len(result)):0xc00000f998 require.Equal(t, mutated.toItems(), result):0xc0006aa1b0 require.Equal(t, oc.toItems(), result):0xc0006aa1d0 require.Nil(t, err):0xc00000f978 require.NoError(b, err):0xc0006aa220 require.NoError(t, err):0xc000a12b28 require.NoError(tb, err):0xc000a13d58 require.NotNil(t, e1):0xc0006ab050 require.NotNil(t, e2):0xc0006ab058 require.NotNil(t, e3):0xc0006ab060 response:	&sync.WaitGroup{},:0xc000827108 restItems, _ := q.Get(3):0xc000826508 result += fmt.Sprintf(`VERTEX INDEX: %+v, VERTEX: %+v`, i, v):0xc000225578 result += fmt.Sprintln(``):0xc000225580 result := MultithreadedSortComparators(comparators):0xc000a12ed8 result := NelderMead(config):0xc00000f1a0 result := ``:0xc000225568 result := ba.ToNums():0xc000225ce0 result := ba.blocks[i]&block(1<<pos) != 0:0xc0004a4078 result := ba.copy().(*bitArray):0xc0004a5cb0 result := blink.insert(chunk[i], &stack):0xc0008261b8 result := child.insert(tree, key):0xc0001bf018 result := es.get(5):0xc000c24b88 result := insert(blink, parent, stack, key):0xc000913178 result := it.Query(:0xc000913250 result := it.Query(constructSingleDimensionInterval(0, 10, 0)):0xc000a13688 result := it.Query(constructSingleDimensionInterval(0, numItems, 0)):0xc0004a4bb8 result := it.Query(constructSingleDimensionInterval(1, 10, 0)):0xc0000a5820 result := it.Query(constructSingleDimensionInterval(1, 14, 0)):0xc00028d330 result := it.Query(constructSingleDimensionInterval(1, 3, 0)):0xc00000fa08 result := it.Query(constructSingleDimensionInterval(13, 13, 0)):0xc00000fa90 result := it.Query(constructSingleDimensionInterval(3, 5, 0)):0xc000c25420 result := it.Query(constructSingleDimensionInterval(3, 6, 0)):0xc000a13f68 result := it.Query(constructSingleDimensionInterval(4, 5, 0)):0xc000a13fe0 result := it.Query(constructSingleDimensionInterval(6, 8, 0)):0xc000a13fb8 result := iter.exhaust():0xc000191d40 result := make(Entries, 0, 1):0xc0000a4040 result := make(Entries, 0, len(entries)):0xc000913470 result := make(Keys, len(keys)):0xc0006aadd0 result := make([]uint64, 0, 0):0xc00039cdf0 result := make(common.Comparators, 0, len(comparators)):0xc0006ab658 result := make(common.Comparators, len(keys)):0xc000224908 result := make(rtree.Rectangles, 0, 10):0xc0000a5628 result := new(Entry):0xc00000ea80 result := orDenseWithDenseBitArray(dba, other):0xc0004a5980 result := orSparseWithDenseBitArray(sba, other):0xc000a132d8 result := orSparseWithSparseBitArray(sba, other):0xc0000a5398 result := parent.insert(key):0xc0000a50f0 result := q.items.getUntil(checker):0xc00000e918 result := results[0]:0xc00000f110 result := roundUp(21):0xc00028c398 result := rt.Query(newMockInterval([]int64{1, 1}, []int64{7, 7})):0xc000c24268 result := rt.Query(newMockInterval([]int64{1}, []int64{7})):0xc0008260f0 result := rt.deleteRecursive(db.sl, dimension+1, entry):0xc000827450 result := set.All(item):0xc0001bfc50 result := symSearch(u, w):0xc0001be030 result := tree.Get(entries...):0xc000224000 result := tree.Insert(k1):0xc000826dd8 result := tree.Insert(k1, k2):0xc0004a4048 result := tree.Insert(k1, k2, k3):0xc00028ca60 result := tree.Insert(k1, k2, k3, k4):0xc0006ab370 result := tree.Insert(keys...):0xc0002259a8 result := tree.Insert(reversed...):0xc0004a46e0 result := tree.Query(:0xc000a12da8 result := tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 0})):0xc0000a5090 result := tree.Query(constructMockInterval(dimension{0, 100}, dimension{0, 100})):0xc00000f7f8 result := tree.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})):0xc00000e118 result := tree.Query(constructMockInterval(dimension{0, 11}, dimension{0, 11})):0xc000225718 result := tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})):0xc000225cb8 result := tree.Query(constructMockInterval(dimension{0, 5}, dimension{0, 5})):0xc000c25118 result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})):0xc0002246b0 result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})):0xc000826798 result := tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})):0xc000224670 result := tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})):0xc0004a4330 result := tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})):0xc0008269b8 result := tree.Query(constructSingleDimensionInterval(0, 10, 0)):0xc0008269e0 result := tree.Query(mockKey(0), mockKey(10)):0xc00000faa0 result := tree.Query(mockKey(0), mockKey(5)):0xc000225d50 result := tree.Query(mockKey(0), mockKey(len(keys))):0xc0000a5670 result := tree.Search(constructInfiniteRect()):0xc0004a5918 result := tree.Search(q):0xc000a133e8 result := tree.Search(r2):0xc000225558 result := tree.root.insert(tree, key):0xc000826528 result := tree.search(ga.lookup):0xc000826f08 result := tree1.Query(constructMockInterval(dimension{0, 10}, dimension{0, 10})):0xc000a13210 result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})):0xc0000a4218 result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})):0xc0008264d0 result := tree1.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})):0xc0000a40c0 result := tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})):0xc000c25590 result := tree1.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})):0xc0000a40a8 result := tree1.Query(iv):0xc000a12ff8 result := tree2.Query(iv):0xc000c243c0 result := tree3.Query(iv):0xc0004a4698 result := tree4.Query(iv):0xc000c24358 result := xft.Predecessor(10):0xc0004a5e58 result := xft.Predecessor(4):0xc00028cf38 result := xft.Predecessor(5):0xc0004a5e18 result := xft.Predecessor(i):0xc0000a56f8 result := xft.Predecessor(math.MaxUint64):0xc00000f968 result := xft.Successor(5):0xc0004a4b88 result := xft.Successor(6):0xc0004a47b0 result := xft.Successor(i):0xc0004a5c48 result := yfast.Delete(3):0xc000224840 result := yfast.get(3):0xc0004a5048 result = NelderMead(config):0xc00028cd88 result = append(result, e):0xc0008262c0 result = append(result, immutable.get(e)):0xc000913480 result = append(result, irt.get(entry)):0xc0006ab4b8 result = append(result, n.entry):0xc0006ab678 result = append(result, nil):0xc0006ab680 result = append(result, ot.get(entry)):0xc00000f648 result = append(result, wh):0xc0000a5658 result = es.get(1):0xc000c24b90 result = es.get(10):0xc000c24b98 result = it.Query(:0xc000913278 result = orDenseWithDenseBitArray(dba, other):0xc000a13d20 result = orSparseWithDenseBitArray(sba, other):0xc000a132f8 result = orSparseWithSparseBitArray(sba, other):0xc0000a53c0 result = results[0]:0xc00000f130 result = roundUp(uint64(1<<31) - 234):0xc00028c3a8 result = roundUp(uint64(1<<63) - 324):0xc00028c3b8 result = rt.Query(iv):0xc0004a4268 result = rt.Query(newMockInterval([]int64{0, 0}, []int64{3, 3})):0xc000c24280 result = rt.Query(newMockInterval([]int64{0, 0}, []int64{7, 4})):0xc000c24298 result = rt.Query(newMockInterval([]int64{0}, []int64{3})):0xc000826120 result = rt.Query(newMockInterval([]int64{10, 10}, []int64{13, 13})):0xc000c24288 result = rt.Query(newMockInterval([]int64{10}, []int64{13})):0xc000826128 result = rt.Query(newMockInterval([]int64{6, 1}, []int64{7, 6})):0xc000c24290 result = rt.Query(newMockInterval([]int64{6, 6}, []int64{10, 10})):0xc000c24270 result = rt.Query(newMockInterval([]int64{6}, []int64{10})):0xc000826100 result = rt.Query(newMockInterval([]int64{9, 9}, []int64{11, 11})):0xc000c24278 result = rt.Query(newMockInterval([]int64{9}, []int64{11})):0xc000826110 result = set.All(item, itemTwo):0xc0001bfc68 result = symSearch(u, w):0xc0001be070 result = tree.Get(constructMockEntry(10000, 5000, 5000)):0xc000224160 result = tree.Insert(duplicate):0xc000a13f30 result = tree.Query(constructMockInterval(dimension{0, 0}, dimension{0, 1})):0xc000a13668 result = tree.Query(constructMockInterval(dimension{0, 1}, dimension{0, 0})):0xc000a13660 result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{0, 2})):0xc000225cc8 result = tree.Query(constructMockInterval(dimension{0, 2}, dimension{10, 20})):0xc000a13650 result = tree.Query(constructMockInterval(dimension{0, 4}, dimension{0, 4})):0xc000a13638 result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{1, 10})):0xc0000a4430 result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})):0xc0008264d8 result = tree.Query(constructMockInterval(dimension{1, 10}, dimension{3, 10})):0xc0000a40c8 result = tree.Query(constructMockInterval(dimension{1, 2}, dimension{1, 2})):0xc000a13640 result = tree.Query(constructMockInterval(dimension{10, 20}, dimension{0, 2})):0xc000a13658 result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{0, 10})):0xc000c255a0 result = tree.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})):0xc0000a4230 result = tree.Query(constructMockInterval(dimension{3, 10}, dimension{1, 10})):0xc0000a40b0 result = tree.Query(constructMockInterval(dimension{3, 4}, dimension{3, 4})):0xc000a13628 result = tree.Query(mockKey(0), mockKey(1)):0xc000225d60 result = tree.Query(mockKey(1), mockKey(10)):0xc000225d70 result = tree.Query(mockKey(1), mockKey(5)):0xc00000fab0 result = tree.Query(mockKey(2), mockKey(10)):0xc000225d68 result = tree.Query(mockKey(5), mockKey(10)):0xc00000fac0 result = tree.Query(mockKey(6), mockKey(10)):0xc00000fab8 result = tree.Search(q):0xc0001bff70 result = tree.Search(r1):0xc000225560 result = tree1.Query(constructMockInterval(dimension{1, 10}, dimension{2, 10})):0xc000826a00 result = tree1.Query(constructMockInterval(dimension{2, 10}, dimension{1, 10})):0xc0000a4220 result = tree2.Query(:0xc000a12dc0 result = tree2.Query(iv):0xc000a13010 result = tree3.Query(iv):0xc000a13028 result = tree5.Query(iv):0xc000c24370 result = tree6.Query(iv):0xc000c24388 result = yfast.Delete(5):0xc0002250b0 result = yfast.Delete(7):0xc000224858 result = yfast.Delete(8):0xc000225090 result = yfast.get(250):0xc0004a5078 result = yfast.get(7):0xc0004a5058 result = yfast.get(8):0xc0004a5068 result, _ := fn(NelderMead(config)):0xc000191b68 result, _ := mutable.(*Tr).toList(itemsToValues(items...)...):0xc000224358 result, _ = ba.GetBit(s * 2):0xc0000a47e8 result, _ = ba.GetBit(s*2 + 1):0xc0000a4808 result, err := ba.GetBit(5):0xc0001bf1f0 result, err := ba.GetBit(7):0xc00028cf70 result, err := f.GetResult():0xc00039cc30 result, err := mutable.(*Tr).toList(int64(1)):0xc00028d288 result, err := mutable.(*Tr).toList(itemsToValues(expected...)...):0xc0004a5e60 result, err := mutable.(*Tr).toList(itemsToValues(items...)...):0xc0004a5d98 result, err := mutable.(*Tr).toList(itemsToValues(items[5:10]...)...):0xc00028ce28 result, err := mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...):0xc0006aa1c8 result, err := mutable.(*Tr).toList(itemsToValues(ordered...)...):0xc000c240f8 result, err := mutable.DeleteItems(items[1].Value, items[2].Value):0xc0000a4468 result, err := q.Get(0):0xc000c24e40 result, err := q.Get(1):0xc0004a59f0 result, err := q.Get(2):0xc000c24a58 result, err := q.Peek():0xc00028d360 result, err := q.Poll(2, 0):0xc0004a44a8 result, err := q.TakeUntil(func(item interface{}) bool {:0xc0000a57e0 result, err := rb.Get():0xc00039d1e0 result, err := rb.Poll(0):0xc000225818 result, err := rt.(*Tr).toList(itemsToValues(expected...)...):0xc00000f988 result, err := rt.(*Tr).toList(itemsToValues(items...)...):0xc000c25540 result, err := rt.(*Tr).toList(itemsToValues(oc.toItems()...)...):0xc0006aa188 result, err := rtMutated.(*Tr).toList(itemsToValues(mutated.toItems()...)...):0xc0000a4588 result, err := sba.GetBit(s - 1):0xc000224580 result, err = ba.GetBit(16):0xc00028c300 result, err = ba.GetBit(3):0xc00028c2c0 result, err = ba.GetBit(5):0xc00028c2e0 result, err = ba.GetBit(7):0xc0000a47b0 result, err = ba.GetBit(9):0xc0000a52a8 result, err = f.GetResult():0xc0004a50c8 result, err = mutable.(*Tr).toList(itemsToValues(items...)...):0xc00028ce70 result, err = mutable.(*Tr).toList(itemsToValues(items[10:]...)...):0xc0000a41a0 result, err = mutable.(*Tr).toList(itemsToValues(mutated.toItems()...)...):0xc0006aa1a0 result, err = mutable.(*Tr).toList(itemsToValues(oc.toItems()...)...):0xc0006aa208 result, err = q.Get(-1):0xc000c24e48 result, err = q.Get(1):0xc000c24a88 result, err = q.Get(2):0xc000c24a98 result, err = q.Poll(1, time.Millisecond):0xc0004a44e0 result, err = q.Poll(2, time.Millisecond):0xc0004a44f0 result, err = rb.Get():0xc0004a4ed8 result, err = rb.Poll(time.Millisecond):0xc000225838 result, err = rt.(*Tr).toList(itemsToValues(items...)...):0xc0000a41b0 result, err = rt.(*Tr).toList(itemsToValues(oc.toItems()...)...):0xc0000a45b8 result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen):0xc00000fb28 result, exists, ok := c.iremove(root, entry, 0, nil, root.gen):0xc00000fb48 result, index := left.GetWithPosition(le):0xc000225320 result, index := right.GetWithPosition(re):0xc000225348 result, ok := args.Get(0).(common.Comparator):0xc000191d68 result.Priority = priority:0xc00000eac0 result.child = nil:0xc00000eaa0 result.degree = 0:0xc00000ea90 result.marked = false:0xc00000ea98 result.next = result:0xc00000eab0 result.parent = nil:0xc00000eaa8 result.prev = result:0xc00000eab8 result:		result,:0xc000224920 resultBlock = sba.blocks[selfIndex]:0xc000913330 resultBlock = sba.blocks[selfIndex].and(other.blocks[otherIndex]):0xc0004a51d8 resultBlock = sba.blocks[selfIndex].nand(other.blocks[otherIndex]):0xc00000f098 resultBlock = sba.blocks[selfIndex].nand(other.blocks[selfValue]):0xc000913338 resultMin := mergeLists(heap.min, other.min):0xc000c25068 resultSize := heap.size + other.size:0xc000c25060 result[positions[value]] = k:0xc0006aae18 results := make(Keys, 0, len(keys)):0xc000191ed0 results := make([][]Item, 2):0xc000a13b00 results := make([][]interface{}, 2):0xc000224500 results := make(nodes, 0, 2):0xc000827760 results := make(rangetree.Entries, 0, len(entries)):0xc0002252c0 results := newResults(v, config, 1000):0xc00000fbd0 results := sba.ToNums():0xc000224598 results := tree.Query(constructMockInterval(dimension{10, 11}, dimension{10, 11})):0xc0000a5878 results = append(results, n):0xc000827770 results = append(results, rt.get(e)):0xc0002252c8 results = append(results, tree.get(k)):0xc000191ed8 results = results[:0]:0xc000827780 results, err := q.Get(1):0xc00000f108 results, err = q.Get(1):0xc00000f128 results.insert(vertex):0xc000c252c0 results.pbs = results.pbs[:length]:0xc000c25170 results.pbs.calculateProbabilities(bestGuess, sigma):0xc000c252d8 results.pbs.sort():0xc000c252e0 results.pbs[i] = nil:0xc000c25168 results.vertices = append(results.vertices, nil):0xc00028ca90 results.vertices = append(results.vertices, vertex):0xc00028ca88 results.vertices[i] = vertex:0xc00028caa0 results:	results,:0xc00000fbe0 results[0] = local:0xc000a13b10 results[0][0] == mockItem(2) && results[1][0] == mockItem(1),:0xc000a13b40 results[1] = local:0xc000a13b18 resultx, resulty := Decode(h):0xc00028cab8 ret := newBitArray(0):0xc000a12ce8 ret := newSparseBitArray():0xc000a12d18 ret := tmp.(*bitArray):0xc000913370 ret.anyset = true:0xc0001bfe78 ret.blocks = append(ret.blocks, nextblock):0xc0001bfe98 ret.blocks = make([]block, intsToRead):0xc000a98560 ret.blocks[i] = block(nextblock):0xc000a98598 ret.blocks[otherValue] = sba.blocks[otherValue].nand(other.blocks[otherIndex]):0xc000913388 ret.indices = make(uintSlice, intsToRead):0xc000a985a8 ret.indices[i] = nextuint:0xc000a985b8 ret.setHighest():0xc000913398 ret.setLowest():0xc000913390 return:0xc000826d50 return !ba.anyset:0xc000c241b0 return !isInternal(n):0xc0006aad98 return !results.vertices[i].less(results.config, result):0xc000827048 return &Ctrie{:0xc000a13c48 return &Dtrie{:0xc00028c380 return &Dtrie{root, d.hasher}:0xc000913360 return &Error{}:0xc00000f010 return &FastIntegerHashMap{:0xc0001be188 return &Item{:0xc0000a5078 return &Iterator{:0xc0000a52b0 return &Node{:0xc0001bf550 return &PriorityQueue{:0xc000225938 return &Queue{:0xc000c25298 return &Selectable{}:0xc00000ef18 return &Set{:0xc000826388 return &SimpleGraph{:0xc00028c9a0 return &Tr{:0xc000c24ea0 return &basicBatcher{:0xc000191fd8 return &bitArrayIterator{:0xc0004a55c8 return &bitArray{:0xc00028cbf8 return &blink{ary: ary, numRoutines: numRoutines}:0xc0004a4930 return &btree{:0xc00039d248 return &cNode{bmp: c.bmp, array: array, gen: gen}:0xc000a138a0 return &cacher{:0xc0004a55f8 return &context{:0xc0009132f0 return &delayedPersister{newEphemeral()}:0xc000a13870 return &ephemeral{:0xc000a13800 return &fakehash{}:0xc000224368 return &immutableRangeTree{:0xc0008278c8 return &inode{:0xc0006aa6f0 return &iterator{:0xc0000a50c8 return &iterator{}:0xc0002245b8 return &keyBundle{key: key}:0xc00039c378 return &keys{:0xc0002257e8 return &lNode{l.removed(entry).Add(&sNode{entry})}:0xc0004a5a48 return &lNode{nl}:0xc000a13bd8 return &list{head, e}:0xc00028c2b8 return &list{head, l}:0xc00000ea40 return &list{l.head, nl}, nil:0xc000827310 return &lnode{:0xc0002244e0 return &mainNode{cNode: &cNode{bmp, []branch{iNode}, gen}}:0xc000225158 return &mainNode{cNode: &cNode{bmp, []branch{x, y}, gen}}:0xc000225168 return &mainNode{cNode: &cNode{bmp, []branch{y, x}, gen}}:0xc000225170 return &mainNode{cNode: cn}:0xc0004a4388 return &mainNode{lNode: &lNode{l}}:0xc000225180 return &mainNode{tNode: &tNode{m}}:0xc0004a43a8 return &mockEntry{:0xc00039cd38 return &mockEntry{key}:0xc0000a4d08 return &mockEntry{values: values}:0xc00039ccd0 return &mockHash32{fnv.New32a()}:0xc000a130a0 return &mockInterval{:0xc00028c2a8 return &mockInterval{[]*dimension{&dimension{low: low, high: high}}, id}:0xc0000a4750 return &mockInterval{dimensions: dimensions, id: id}:0xc0000a4768 return &mockKey{value}:0xc000826fa0 return &mockRectangle{:0xc00028c680 return &mutex{lock: make(chan struct{}, 1)}:0xc0006aad18 return &nelderMead{:0xc00000fbd8 return &nmVertex{:0xc000913588 return &nodes{:0xc000826f38 return &node{:0xc0006aa668 return &node{entries: make([]Entry, capacity), level: level}:0xc0001919e0 return &orderedTree{:0xc000c252f8 return &removeAction{:0xc0006aaf98 return &results{:0xc000912080 return &sNode{&Entry{Key: t.Key, hash: t.hash, Value: t.Value}}:0xc000a13a00 return &sema{:0xc0008270f8 return &sliceIterator{:0xc0008278a0 return &sparseBitArrayIterator{:0xc000191e10 return &sparseBitArray{:0xc00000f0b0 return &sparseBitArray{}:0xc0002257f8 return &tree{:0xc000a13f78 return (&keySortWrapper{comparator, k}).sort():0xc000191060 return (*items)[0], true:0xc00039d370 return (*nodes)[i], false:0xc000c24c48 return (b & (1 << pos)) != 0:0xc000224460 return (hash >> (5 * level)) & 0x01f:0xc000912718 return (sba.indices[len(sba.indices)-1] + 1) * s:0xc0004a5848 return (xhigh + xlow) / 2, (yhigh + ylow) / 2:0xc00039ccf8 return *keys, right:0xc0001beaa8 return *ns, right:0xc000c24c18 return -1:0xc00000e370 return -1, i:0xc000c251a0 return 0:0xc00000e3f8 return 0, -1:0xc000a128c0 return 0, ErrVertexNotFound:0xc00028c670 return 0, false:0xc0009130b0 return 0, nil:0xc0004a4218 return 0, node.min, node.max:0xc0000a5558 return 1:0xc00000e3c8 return 1 - value:0xc0004a5dc0 return 1, -1, -1:0xc0000a5468 return 3 + math.Sin(vars[0]) + 2*math.Pow(math.Cos(vars[1]), 2), true:0xc000225958 return 42:0xc0000a4010 return Config{:0xc00039cf20 return EmptyHeapError("Cannot delete element from an empty heap"):0xc000c24e88 return ErrDisposed:0xc0001bebb8 return ErrParallelEdge:0xc00039d198 return ErrSelfLoop:0xc00039d178 return FloatingFibonacciHeap{nil, 0}:0xc000a12dd8 return FloatingFibonacciHeap{resultMin, resultSize}, nil:0xc000c25088 return FloatingFibonacciHeap{}, NilError("One of the heaps to merge is nil. Cannot merge"):0xc000c25058 return Intervals:0xc000c24248 return NilError("Cannot delete node: given node is nil"):0xc000c24e90 return OutOfRangeError(k):0xc00039d298 return []*hilbertBundle{&hilbertBundle{}}:0xc0006aabc8 return []interface{}{}:0xc0004a5610 return []interface{}{}, nil:0xc000c24dd0 return `No entries in this tree.`:0xc000a12830 return aa:0xc0001bf3d0 return add:0xc000191df0 return adj, nil:0xc00028c660 return affected, deleted:0xc00028cf18 return andDenseWithDenseBitArray(ba, dba):0xc0001bf9e8 return andSparseWithDenseBitArray(other.(*sparseBitArray), ba):0xc0001bf9f0 return andSparseWithDenseBitArray(sba, other.(*bitArray)):0xc00000e900 return andSparseWithSparseBitArray(sba, ba):0xc00000e8f8 return append(l.tail.Map(f), f(l.head)):0xc0004a58c8 return append(s, x):0xc0000a4cd0 return apply:0xc0004a56c8 return args.Bool(0):0xc00039cd58 return args.Error(0):0xc000c24140 return args.Get(0).([]interface{}), args.Error(1):0xc00039cd30 return args.Get(0).(rangetree.Entries), args.Get(1).(rangetree.Entries):0xc0009a0418 return args.Get(0).(uint64):0xc0002249c8 return atomic.CompareAndSwapPointer(:0xc000224b20 return atomic.LoadInt32(&desc.rdcss.committed) == 1:0xc0006aa0c8 return atomic.LoadPointer(prevPtr) == nil:0xc0006aa050 return atomic.LoadUint64(&blink.number):0xc00039d3a8 return atomic.LoadUint64(&ptree.number):0xc000225bf0 return atomic.LoadUint64(&rb.disposed) == 1:0xc000a13390 return atomic.LoadUint64(&rb.queue) - atomic.LoadUint64(&rb.dequeue):0xc000913540 return atomic.LoadUint64(&sl.num):0xc00000f958 return atomic.LoadUint64(&tree.number):0xc00028d300 return b & ^(1 << pos):0xc000288968 return b & ^block(1<<position):0xc000c240c0 return b & other:0xc000a12d70 return b &^ other:0xc0006aaba8 return b == other:0xc000826d78 return b | (1 << pos):0xc000288960 return b | block(1<<position):0xc00039ccc8 return b | other:0xc00039cdc0 return b&block(1<<position) != 0:0xc000826d70 return b&other == other:0xc000826d80 return ba:0xc000224dd0 return ba.intersectsDenseBitArray(other.(*bitArray)):0xc0006ab5d0 return ba.intersectsSparseBitArray(sba):0xc0006ab5c8 return best:0xc00000e168 return blink.multithreadedInsert(keys):0xc00039d390 return buf:0xc000a131f8 return bundles:0xc00028c800 return bytes.Equal(e.Key, sn.(*sNode).Key):0xc0001bfef0 return c:0xc000191880 return c.iinsert(i, entry, lev, parent, startGen):0xc0002241f0 return c.iinsert(in, entry, lev+w, i, startGen):0xc0002241e0 return c.ilookup(i, entry, lev, parent, startGen):0xc000224440 return c.ilookup(in, entry, lev+w, i, startGen):0xc000224438 return c.iremove(i, entry, lev, parent, startGen):0xc0000a4100 return c.iremove(in, entry, lev+w, i, startGen):0xc0000a40f8 return c.keyList.PushFront(key):0xc000826fc0 return c.loadNode(t, key):0xc000827078 return c.lookup(&Entry{Key: key, hash: c.hash(key)}):0xc000826400 return c.lookup(entry):0xc00000fb38 return c.rdcssComplete(abort):0xc0000a4530 return c.rdcssReadRoot(false):0xc0000a4518 return c.remove(&Entry{Key: key, hash: c.hash(key)}):0xc0004a4a10 return c.remove(entry):0xc00000fb50 return c.seenNodes[string(id)]:0xc0000a4cf8 return c.size:0xc000c247e0 return c.snapshot(c.readOnly):0xc000c242e8 return c.snapshot(true):0xc00028cde0 return c[i].Compare(c[j]) < 0:0xc0002245c8 return cache:0xc000224a10 return cap(keys) == len(keys):0xc0001beac0 return ch:0xc00039ce70 return checkNode(t, tree.root):0xc000224930 return child:0xc000c253a0 return chunks[0]:0xc0006aac80 return cleanReadOnly(main.tNode, lev, parent, c, entry):0xc000224600 return closed:0xc000c24658 return cmps:0xc000225ca8 return comparator(item1.Value, item2.Value) == 0:0xc00000ea48 return comparator(n.ChildValues[i], value) >= 0:0xc0000a55a0 return comparator(o[i].Value, o[j].Value) < 0:0xc00000f308 return comparator(o[i].Value, value) >= 0:0xc000827140 return comparators:0xc000a12e18 return cp:0xc000a12d88 return cp, deleted:0xc000c25340 return cp, overwritten:0xc000225748 return d:0xc000912f60 return d.Persister.Load(keys...):0xc000827470 return data, nil:0xc0001bf348 return db.id:0xc000c24880 return dba.copy():0xc0006ab148 return deleted:0xc00000e530 return deletedEntries:0xc000a135f0 return dimension == lastDimension-1:0xc00028c368 return disposed:0xc000c24d20 return disposedItems:0xc000a138f0 return e:0xc00000f610 return e.(*lastBundle).entry:0xc0001bf6a8 return e.Add(val), nil:0xc0009130e0 return e.err:0xc000913098 return e.hash:0xc000826748 return e.key:0xc0004a4f78 return e.value:0xc000191480 return eba.Serialize():0xc000c24178 return entomb(branch.(*sNode)):0xc0004a4380 return entries:0xc000191ae8 return entriesPool.Get().(Entries):0xc000224868 return entries[0].(*lastBundle).entry:0xc000827440 return entries[i-1], i - 1:0xc000913530 return entries[i]:0xc000c247f8 return entries[i], i:0xc0006aa0e8 return entries[i].Key() >= key:0xc000224a20 return entries[len(entries)-1].Key(), true:0xc000913520 return entry:0xc0001be6e0 return err:0xc000191d80 return errCanceled:0xc00000fa58 return errors.New("Invalid data for BitArray"):0xc000a984c8 return ew.key:0xc000826750 return f:0xc00028c768 return f.Fill(v, nil):0xc000913308 return f.err:0xc0004a5348 return f.item, f.err:0xc000224f68 return f.val, f.err:0xc0009131d0 return f.wchan():0xc000c24660 return false:0xc000c24600 return false, ErrDisposed:0xc000a12468 return false, OutOfRangeError(k):0xc0004a4070 return false, nil:0xc000a12f68 return fi.count:0xc000a130c0 return fi.packets.exists(key):0xc000288170 return fi.packets.get(key):0xc0000a52f8 return flag, pos:0xc000c25648 return fmt.Sprint(n.entries):0xc00000f018 return fmt.Sprintf("<COLLISIONS %v>%v", len(n.entries), n.entries):0xc0001918a8 return fmt.Sprintf(`Index %d is out of range.`, err):0xc000288ab0 return fmt.Sprintf(`Provided dimension: %d is:0xc00028c288 return fmt.Sprintf(fmt.Sprintf("%%0%db", s), uint64(b)):0xc000224490 return fn:0xc0000a44c0 return fn(n.entry):0xc000827668 return fnv.New32a():0xc0000a4fc0 return found:0xc0001be3c8 return found.(*sNode).Value, true:0xc0001bfef8 return func(c *cache) {:0xc000c24680 return g.e:0xc00039ce40 return g.v:0xc000191d00 return ga:0xc000224a30 return ga.result:0xc0009130f0 return gcas(i, main, ncn, c):0xc0002241b8 return gcas(i, main, nln, c):0xc0004a41b8 return gcas(i, main, toCompressed(main.cNode, lev), ctrie):0xc0002246c8 return gcasComplete(i, m, ctrie):0xc0000a4510 return gcasComplete(in, m, ctrie):0xc000224a38 return get:0xc000c24650 return get(n.entries[index].(*node), keyHash, key):0xc00000f5e0 return hasResult:0xc00000e730 return hasher.Sum32():0xc0004a5298 return head.(*sNode):0xc000827880 return heap.min, nil:0xc00039ce18 return heap.size:0xc00000f0e8 return heap.size == 0:0xc00039ce20 return high >= otherLow && low <= otherHigh:0xc0000a4d10 return i:0xc00039ccb8 return i, false:0xc000912a90 return i, true:0xc000912a58 return iNode:0xc0004a43b8 return ia:0xc0001be298 return ia.ns:0xc00000e170 return ia.result:0xc0000a53e8 return ia.rs:0xc00000e968 return id:0xc0000a5070 return idx:0xc000a13788 return ifc.(*Node), nil:0xc000827098 return ifc.(rangetree.Entries):0xc000c24730 return immutable:0xc000c255e0 return immutable, Entries{}:0xc000225730 return immutable.number:0xc000826080 return in:0xc00000ef28 return insertByMerge(t.config.Comparator, n, bundles):0xc0004a5858 return insertNode(sl, n, cmp, pos, sl.cache, sl.posCache, false):0xc000225c70 return int(byte(b >> 24)):0xc0000a5218 return int(byte(b >> 56)):0xc000c24a38 return int32(0):0xc000912708 return int32(1):0xc000912700 return int64(len(q.items)):0xc0004a58f0 return int64(len(u)):0xc00028c200 return int64(sort.Search(len(u), func(i int) bool { return uint64(u[i]) >= x })):0xc000c24668 return intFromBool(ivID > nodeID):0xc0006aad90 return irt:0xc0006aaf40 return irt, nil, nil:0xc000a13198 return irt.dimensions > 1:0xc000224f78 return irt.number:0xc0006ab4c0 return isInternal(n.children[0]) || isInternal(n.children[1]):0xc00000f028 return it, iv1, iv2, iv3:0xc000912fd8 return item:0xc00039c9e0 return item != `a`:0xc000826530 return item != `c`:0xc0000a57e8 return item == 1:0xc000225868 return item.element:0xc000826fb8 return items:0xc0004a5000 return items, err:0xc000827920 return items, nil:0xc000913078 return iter:0xc000827410 return iter.Value():0xc0009131f8 return iter.entries.entries[iter.index]:0xc000c247d8 return iter.index < int64(len(iter.sba.indices)):0xc000912fe0 return iter.index == iteratorExhausted:0xc00000e788 return iter.n != nil:0xc000912320 return iter.n.entry:0xc000191cb8 return iter.node.keys[iter.index]:0xc000c246f8 return iter.sba.indices[iter.index], iter.sba.blocks[iter.index]:0xc00028c5d8 return iterate(d.root, stop):0xc000224de8 return itn:0xc000c24860 return k:0xc00039d3e0 return k / s, k % s:0xc0006aa618 return k.UUID[:16]:0xc000a12e20 return kb:0xc00039c3a0 return key:0xc000826d68 return key, n, nn:0xc000225278 return key, otherNode, n:0xc000913650 return key, otherNode, node:0xc0008263f0 return keySearch(keys, key):0xc00028cb58 return keys:0xc000191ac8 return keys.insertAt(key, i):0xc0001be460 return keys.toItems(), nil:0xc0001be600 return keys[0]:0xc0001beab8 return keys[i].Compare(key) >= 0:0xc000826660 return keys[len(keys)-1]:0xc0001beab0 return ks, &keys{list: right}:0xc000a13250 return ks.list[i]:0xc000a13310 return ks.list[i] >= key:0xc000827560 return ks.list[i], i:0xc000827710 return ks.list[i].Compare(key) > -1:0xc000225190 return ks.list[len(ks.list)-1]:0xc000827558 return l:0xc000a13bc8 return l.Add(val), nil:0xc0006ab220 return l.Length():0xc000c25318 return l.head, true:0xc00000f248 return l.tail, true:0xc00000f250 return l.tail.Find(pred):0xc0004a5880 return l.tail.Get(pos - 1):0xc00000f570 return lb.id:0xc000c24908 return left + 1, node.min, node.max:0xc0000a5550 return left, node.min, node.max:0xc0000a5548 return left, right:0xc0006aa990 return len(c):0xc0004a40c0 return len(n.ChildKeys):0xc0004a4b80 return len(n.ChildValues):0xc0004a4ba8 return len(n.values):0xc000c255b0 return len(o):0xc0000a52f0 return len(pbs):0xc0004a4e80 return len(pq.items):0xc0001bfe40 return len(pq.items) == 0:0xc000a13868 return len(q.items) == 0:0xc000827418 return len(s):0xc000191478 return len(sba.indices) == 0:0xc000a138f8 return len(sorter.vertices):0xc0002248c8 return len(sw.keys):0xc000191120 return len(v.values):0xc000913088 return len(val), nil:0xc00028c678 return length:0xc000c248b0 return lerr.Get():0xc0006aae28 return level:0xc00028c328 return log.New(os.Stderr, "", log.LstdFlags):0xc000a12ca0 return low:0xc0004a4fd0 return low, node:0xc00039d220 return m:0xc000224960 return m.Called().Get(0).(uint64):0xc000a12f30 return m.Called(entries).Get(0).(rangetree.Entries):0xc0009a0068 return main.tNode.untombed():0xc0004a43b0 return math.Abs(nm.result-other.result) < 2*delta:0xc000c243e0 return math.Abs(target - value):0xc000913678 return math.IsInf(num, -1) || math.IsInf(num, 1):0xc0001bf3a0 return math.Pow(3*math.Pow(float64(guesses), 1/float64(dimensions)), -1):0xc0009132c8 return math.Pow(vars[0], 2) - 4*vars[0] + math.Pow(vars[1], 2) - vars[1] - vars[0]*vars[1], true:0xc00000f188 return math.Sqrt(sum):0xc000a13e18 return maxInt:0xc000c246e0 return me:0xc0006aabc0 return me.dimensions[dimension-1]:0xc0001becd0 return me.id:0xc0001becc8 return me.key:0xc0000a4d00 return me.values[dimension]:0xc000a12b88 return mi.HighAtDimension(dimension) > iv.LowAtDimension(dimension) &&:0xc0000a4268 return mi.dimensions[dimension-1].high:0xc0006aa7f8 return mi.dimensions[dimension-1].low:0xc000190158 return mi.highs[dimension]:0xc00039cce0 return mi.id:0xc00028c418 return mi.lows[dimension]:0xc00039ccd8 return mid:0xc0004a4fc8 return middle, left, right:0xc0001be7e0 return min:0xc000c24cd0 return min, nil:0xc000913718 return minInt:0xc000225020 return mockEntry(key):0xc000a12cc8 return modified, deleted:0xc0004a5a30 return mr.xhigh, mr.yhigh:0xc00000f140 return mr.xlow, mr.ylow:0xc000224f90 return n:0xc000191430 return n, highestValue, nil:0xc000225920 return n, nil:0xc000c24818 return n, pos + 1:0xc000a13a18 return n.ChildKeys[i]:0xc000a13b70 return n.ChildKeys[i], i:0xc0006ab2b0 return n.ChildKeys[len(n.ChildKeys)-1], i:0xc0006ab2c0 return n.ChildValues, n.ChildKeys:0xc000a139a8 return n.ChildValues[0]:0xc000a13be0 return n.ChildValues[i]:0xc000a13b68 return n.ChildValues[len(n.ChildValues)-1]:0xc000225980 return n.children[0]:0xc00028ccf8 return n.children[0].children[1]:0xc000a13e80 return n.children[1]:0xc000a13e88 return n.children[1].children[0]:0xc00028ccf0 return n.comparator(n.values[i], n.values[j]) < 0:0xc0000a5730 return n.entries[index]:0xc00000f5d0 return n.entry:0xc000224e78 return n.entry == nil:0xc00039cd08 return n.entry, pos - 1:0xc00028c058 return n.entry.Compare(e):0xc0008266d8 return n.firstValue(), n.lastValue():0xc000a13da0 return n.forward[0], pos + 1:0xc0008273d8 return n.keys.last():0xc000912000 return n.keys.len() >= ary:0xc000c25310 return n.keys.needsSplit():0xc000c24ca8 return n.keys.search(key):0xc0006ab388 return n.lenValues() > max:0xc0001bffb8 return n.maxSeen:0xc0002250f0 return n.mbr.xhigh, n.mbr.yhigh:0xc000225b98 return n.mbr.xlow, n.mbr.ylow:0xc000826458 return n.nodes.byPosition(uint64(i)):0xc000225bd0 return n.nodes[i]:0xc0004a5998 return n.splitInternal():0xc0004a48b0 return n.splitInternal(i, capacity):0xc000c242e0 return n.splitInternalAt(i):0xc0004a4b78 return n.splitLeaf():0xc0004a48a8 return n.splitLeaf(i, capacity):0xc000c242d8 return n.splitLeafAt(i):0xc0004a4b70 return nandDenseWithDenseBitArray(ba, dba):0xc000c24db8 return nandDenseWithSparseBitArray(ba, other.(*sparseBitArray)):0xc000c24dc0 return nandSparseWithDenseBitArray(sba, other.(*bitArray)):0xc00000e958 return nandSparseWithSparseBitArray(sba, ba):0xc00000e950 return ncn:0xc0001bf5e0 return new(dimensions):0xc000225c60 return newBitArray(size, args...):0xc00028cc58 return newBitArrayIterator(ba):0xc0004a42e8 return newCompressedBitArrayIterator(sba):0xc0006ab428 return newCtrie(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly):0xc00028d190 return newCtrie(root, c.hashFactory, readOnly):0xc00028d188 return newCtrie(root, hashFactory, false):0xc0006ab4e8 return newItem(int64(rand.Intn(int(maxValue)))):0xc000225588 return newMockRectangle(0, 0, math.MaxInt32, math.MaxInt32):0xc00028c998 return newNode:0xc000a13470 return newOrderedTree(dimensions):0xc000225978 return newSparseBitArray():0xc0006aa150 return newTree(bufferSize, ary):0xc0004a5e20 return newTree(cfg):0xc000c252f0 return newTree(dimensions):0xc00028d1f0 return nil:0xc000191468 return nil, -1:0xc0006aa0d8 return nil, 0:0xc00028c048 return nil, 1:0xc000827370 return nil, EmptyHeapError("Cannot decrease key in an empty heap"):0xc000225388 return nil, EmptyHeapError("Cannot dequeue minimum of empty heap"):0xc000c24ce8 return nil, EmptyHeapError("Trying to get minimum element of empty heap"):0xc00039ce10 return nil, ErrDisposed:0xc0001bf2f8 return nil, ErrEmptyList:0xc0009130e8 return nil, ErrEmptyQueue:0xc0008268b8 return nil, ErrTimeout:0xc0001bf328 return nil, ErrTreeNotFound:0xc0004a5a60 return nil, ErrVertexNotFound:0xc00028c638 return nil, NilError("Cannot decrease key: given node is nil"):0xc000225390 return nil, err:0xc000a12d00 return nil, errors.New("batcher: must provide CalculateBytes function"):0xc000191fd0 return nil, errors.New("no data in input"):0xc000a12cd8 return nil, errors.New("not a valid BitArray"):0xc000c245f0 return nil, errors.New("unrecognized encoding"):0xc000a12d20 return nil, false:0xc0004a4648 return nil, false, false:0xc000224448 return nil, false, true:0xc000224428 return nil, fmt.Errorf("The given new priority: %v, is larger than or equal to the old: %v",:0xc0002253a0 return nil, highestValue, err:0xc000225900 return nil, highestValue, nil:0xc000225910 return nil, i:0xc000827058 return nil, lerr.Get():0xc0004a5698 return nil, nil:0xc000913058 return nil, nil, nil:0xc0009135e8 return nilIterator():0xc0004a5090 return nin:0xc0004a5388 return nl, nil:0xc000827300 return nl.Add(l.head), nil:0xc0006ab230 return nm.distance < other.distance:0xc000826450 return nm.distance == other.distance:0xc0004a4bd8 return nm.evaluateWithConstraints(vertices, toScalar):0xc000c253e8 return nm.result < other.result:0xc000826430 return nm.result == other.result:0xc0004a4bd0 return nm.result > other.result:0xc000826448 return nm.results.vertices[0].vars:0xc0004a5f10 return node:0xc0004a5598 return node != nil && node.red:0xc000224548 return node, nil:0xc0002253b8 return node, true:0xc000c24c38 return node.Value():0xc000913350 return node.keys.search(key):0xc0000a5000 return node.nodes[i+1].find(key):0xc000913450 return node.nodes[i].find(key):0xc000913458 return node.nodes[len(node.nodes)-1].find(key):0xc000913430 return nodes:0xc000c24ae0 return nodes, nil:0xc0004a41d8 return nodes.addAt(i, node):0xc0009a05c8 return nodes.deleteAt(i):0xc00000e9f8 return nodes[i], i:0xc000827068 return node{:0xc0000a51e8 return ns, &nodes{list: right}:0xc0000a4cc0 return ns.list[pos]:0xc0004a5220 return ns.list[pos].(*node):0xc0009132c0 return nums:0xc0000a52d0 return nv:0xc000224b18 return o:0xc0009135b0 return oc:0xc0001bfeb0 return offset >= 0 && offset < number:0xc000224fe0 return ok:0xc0004a4a58 return old:0xc0001bf280 return old, i:0xc000826860 return oldEntry:0xc00039cec0 return oldKey:0xc0001be6d8 return one:0xc000a12e40 return orDenseWithDenseBitArray(ba, dba):0xc000827320 return orSparseWithDenseBitArray(other.(*sparseBitArray), ba):0xc000827328 return orSparseWithDenseBitArray(sba, other.(*bitArray)):0xc0006ab488 return orSparseWithSparseBitArray(sba, ba):0xc0006ab480 return ot.dimensions > 1:0xc0009131d8 return ot.number:0xc000225280 return other.copy():0xc00028c568 return out:0xc000a13d10 return ov:0xc000224ae8 return overwritten:0xc0004a51b8 return overwrittenKey:0xc000827518 return overwrittens:0xc000191fb0 return overwrittens, nil:0xc0004a56c0 return overwrittens.toItems(), nil:0xc000a12450 return p.tail:0xc0004a5350 return packets[i] != nil:0xc00000f1f8 return packets[i].value, true:0xc0009130b8 return parent:0xc00000e9a0 return parent.keys[i]:0xc000191470 return parts:0xc000a12cc0 return path, nil:0xc0001bfe08 return pb:0xc00039cff8 return pbs[i].probability < pbs[j].probability:0xc000913300 return peekItem, nil:0xc0008268c8 return pq.disposed:0xc000a13ab0 return pq.items[0]:0xc000c25048 return ptree:0xc000a13fd8 return q.Poll(number, 0):0xc0006ab280 return q.disposed:0xc0001bfe48 return r:0xc000191d30 return rangetree.Entries{}, rangetree.Entries{}:0xc00028cee8 return rb:0xc000a133a8 return rb.Poll(0):0xc0008260b0 return rb.put(item, true):0xc0004a5478 return rects:0xc00028c740 return remove:0xc000826f98 return result:0xc000913190 return result, exists:0xc00000fb40 return result, nil:0xc0004a4080 return results:0xc000191ee0 return ret:0xc0009133a0 return ret, nil:0xc000a12d08 return returnItems:0xc00000e9c0 return reversed:0xc0009128b0 return rhs * lhs:0xc0000a50c0 return root:0xc000c25478 return rotate(parent, dir):0xc000c253c8 return rt, nil:0xc0004a5a70 return rt.deleteRecursive(rt.top, 0, entry):0xc0008276f0 return rt.number:0xc000a13600 return rtree.Rectangles{}:0xc0000a5620 return s:0xc00039ccc0 return s.n.ChildKeys[s.pointer], s.pointer:0xc00000fad0 return s.pointer < len(s.n.ChildValues) && s.comparator(s.stop, s.n.ChildValues[s.pointer]) >= 0:0xc0000a5690 return s[i] < s[j]:0xc00000e748 return s[i] == x:0xc0004a5150 return s[i] >= x:0xc0004a40b0 return sba.Serialize():0xc000c243f8 return sba.blocks[i].get(position), nil:0xc00000f568 return sba.copy():0xc00028c558 return sema:0xc00000f008 return set:0xc00039c9f8 return set.flattened:0xc0009133d8 return singleton:0xc000a12df8 return size:0xc000191dd8 return sl:0xc00028cf30 return sl, nil:0xc0000a5808 return sl, right:0xc0004a48a0 return sl.iter(cmp):0xc00000fae8 return sl.iterAtPosition(pos + 1):0xc000c25570 return sn.(*sNode).Entry:0xc00000fa70 return sn.Value, true, true:0xc0002245f8 return sort.Search(:0xc0009a04b0 return sort.Search(len(entries), func(i int) bool {:0xc000224a18 return sort.Search(len(keys), func(i int) bool {:0xc000826658 return sort.Search(len(n.ChildValues), func(i int) bool {:0xc0000a4600 return sort.Search(len(o), func(i int) bool {:0xc000827138 return sort.Search(len(results.vertices), func(i int) bool {:0xc000827040 return sort.Search(len(s), func(i int) bool {:0xc0004a40a0 return sorter.vertices[i].less(sorter.config, sorter.vertices[j]):0xc0002248c0 return splitAt(sl, index):0xc0000a5810 return start:0xc0001915e8 return start, start + offset:0xc000225298 return string(e):0xc00028c280 return sw.comparator(sw.keys[i].Value, sw.keys[j].Value) < 0:0xc00028c748 return sw.keys:0xc000913418 return t, nil:0xc00000e2b8 return t.Count:0xc00039c008 return t.UUID:0xc000c24a50 return t.cacher.getNode(t, id, cache):0xc000c24820 return t.walkupDelete(key, parent, path, mapping):0xc0000a4ac0 return test >= value:0xc000224a28 return tn.Value, true, true:0xc0004a4430 return toContracted(&cNode{bmp: cn.bmp, array: tmpArray}, lev):0xc0000a41f8 return tree:0xc0006aaf90 return tree, entries:0xc000224778 return tree, ivs:0xc000c248d0 return tree, modified, deleted:0xc000a131d0 return tree.Add(entries...), entries:0xc0000a56c8 return tree.number:0xc00039d240 return tree.root.find(key):0xc0004a5098 return true:0xc0002248b0 return true, nil:0xc000a12f88 return two:0xc000a12e30 return u:0xc0001bf988 return u[i] < u[j]:0xc0006aab30 return uint(len(str.(string))):0xc00028c818 return uint32(0xffffffff):0xc000191dc0 return uint32(v):0xc0004a5230 return uint64(i):0xc000225198 return uint64(iter.index) <= iter.stopIndex:0xc000191ec8 return uint64(iter.index), iter.ba.blocks[iter.index]:0xc00039d260 return uint64(len(ba.blocks)) * s:0xc00000f148 return uint64(len(fi.packets)):0xc0001be088 return uint64(len(ks.list)):0xc0008270d0 return uint64(len(lnode.keys)) >= nodeSize:0xc00028c1f0 return uint64(len(n.keys)) >= nodeSize:0xc00028ca48 return uint64(len(ns.list)):0xc0001bebe8 return uint64(len(rb.nodes)):0xc000827148 return uint64(se):0xc00028c350 return uint64(ti):0xc0000a4cc8 return uint64(yfast.bits)*i - 1:0xc000912c58 return v:0xc000191b30 return v.comparator(v.values[i], v.values[j]) < 0:0xc000a12e50 return val, 8:0xc000a129d0 return val, ok, true:0xc000224610 return value:0xc000c242d0 return value, left:0xc0004a49f8 return values:0xc00028cc28 return vars[0] * vars[1], true:0xc000191b40 return vertex:0xc00000e0e8 return vertices[len(vertices)-1]:0xc000c25548 return vertices[len(vertices)-2]:0xc0004a5ee0 return vs:0xc0006aaf00 return w:0xc0001bf978 return w.Bytes(), nil:0xc00039cda8 return writeOperations, deleteOperations, toComplete:0xc000827038 return x >> 24:0xc0000a4410 return x, y:0xc000191f38 return x.(int) * x.(int):0xc00028cb68 return xft:0xc00028d148 return xft.max:0xc00028ccc0 return xft.max.entry:0xc000c24b58 return xft.min:0xc000a13e68 return xft.min.entry:0xc000c24b68 return xft.num:0xc0004a4ec0 return xhigh2 >= rect1.xlow && xlow2 <= rect1.xhigh && yhigh2 >= rect1.ylow && ylow2 <= rect1.yhigh:0xc00028c4c0 return xlow1 == xlow2 && xhigh1 == xhigh2 && ylow1 == ylow2 && yhigh1 == yhigh2:0xc000912960 return yfast:0xc000c250a0 return yfast.iter(key):0xc0004a58d0 return yfast.num:0xc00000f5b0 returnItems := make([]Item, 0, number):0xc00028c980 returnItems := make([]interface{}, 0, length):0xc0004a5618 returnItems := make([]interface{}, 0, number):0xc00000e978 returnItems = append(returnItems, (*items)[i]):0xc00000e998 returnItems = append(returnItems, item):0xc0004a5638 returnItems = append(returnItems, items.pop()):0xc00028c990 reversed := keys.reverse():0xc0004a46d8 reversed := make(Keys, len(keys)):0xc0001beae0 reversed := make([]*Item, len(items)):0xc0004a5d70 reversed := make(common.Comparators, len(cmps)):0xc000912820 reversed := reverseKeys(keys):0xc0008271b0 reversed = reverse(reversed):0xc0004a5d80 reversed[len(cmps)-1-i] = cmps[i]:0xc000912898 reversed[len(keys)-1-i] = keys[i]:0xc0001beb30 rhs := 1 - math.Exp(math.Pow(distance, 2)/(2*math.Pow(sigma, 2))):0xc0000a50b8 right := &SkipList{}:0xc0004a4800 right := make(Keys, len(*keys)-i-1, cap(*keys)):0xc0001be7e8 right := make([]*node, uint64(len(ns.list))-i, capacity):0xc0000a48a8 right := make(common.Comparators, uint64(len(ks.list))-i, capacity):0xc000a13228 right := make(hilberts, uint64(len(ks.list))-i, capacity):0xc0004a48b8 right := make(nodes, len(ns)-i, cap(ns)):0xc0006aa8e8 right := make(nodes, length, cap(*ns)):0xc000c24bf0 right := make(rtree.Rectangles, uint64(len(ns.list))-i, capacity):0xc00000f200 right = n.right:0xc000a130f0 right, minR, maxR := checkRedBlack(tb, node.children[1], dimension):0xc0000a54c0 right.cache = make(nodes, sl.maxLevel):0xc0004a4818 right.head = newNode(nil, sl.maxLevel):0xc0004a4828 right.head.forward[i] = sl.cache[i].forward[i]:0xc0004a4848 right.head.widths[i] = sl.cache[i].widths[i] - (index - sl.posCache[i]):0xc0004a4858 right.level = sl.level:0xc0004a4810 right.maxLevel = sl.maxLevel:0xc0004a4808 right.num = sl.Len() - index:0xc0004a4870 right.parent = parent:0xc0004a5840 right.posCache = make(widths, sl.maxLevel):0xc0004a4820 right.resetMaxLevel():0xc0004a4898 right:	n.right,:0xc000225260 rightEntries := entries[50:]:0xc0002252f0 rightKeys := make(Keys, len(n.keys)-1-i, cap(n.keys)):0xc0006aa778 rightNodes := make(nodes, len(rightKeys)+1, cap(n.nodes)):0xc0006ab300 rn := cn:0xc000224198 rn = cn.renewed(i.gen, c):0xc0002241a8 root := &iNode{main: &mainNode{cNode: &cNode{}}}:0xc0006ab4e0 root := c.readRoot():0xc00028d168 root := ctrie.rdcssReadRoot(true):0xc0000a4498 root := insert(d.root, &entry{d.hasher(key), key, value}):0xc000913358 root := newNode():0xc000225b28 root := remove(d.root, d.hasher(key), key):0xc000191de0 root = doubleRotate(root, dir):0xc000225d30 root = doubleRotate(root, takeOpposite(dir)):0xc000c25470 root = immutable.root.copy():0xc000912768 root = rotate(root, dir):0xc000225d18 root = rotate(root, takeOpposite(dir)):0xc000c25460 root.appendChild(&Key{UUID: n.ID}):0xc000225b40 root.balance = -bal:0xc000225d38 root.balance = 0:0xc0004a5eb8 root.balance = int8(-bal):0xc0004a5ea8 root.balance, n.balance = 0, 0:0xc000c25458 root.children[takeOpposite(dir)] = n:0xc000225d08 root.insert(t.config.Comparator, key):0xc000225b50 root:		newLeafNode(nodeSize),:0xc00039d258 root:		root,:0xc000a13c50 root:	emptyNode(0, 32),:0xc00028c388 root:	root,:0xc0009127d0 rotate(int32(s), int32(rx), int32(ry), &x, &y):0xc000191f18 rotate(s, rx, ry, &x, &y):0xc000912f40 rs:		bundlesFromRects(rects...),:0xc0001be280 rt := New(cfg):0xc00028ce00 rt := New(defaultConfig()):0xc0004a5d88 rt := new(1):0xc000191f40 rt := new(2):0xc000a130a8 rt := newOrderedTree(2):0xc000c24300 rt = rtMutated:0xc0000a45d0 rt, _ = Load(cfg.Persister, rt.ID(), comparator):0xc0000a4190 rt, _ = mutable.Commit():0xc0000a4188 rt, err := mutable.Commit():0xc0000a42d8 rt, err := treeFromBytes(p, items[0].Payload, comparator):0xc0004a5a68 rt, err = Load(cfg.Persister, id, comparator):0xc000c25530 rt, err = Load(cfg.Persister, rt.ID(), comparator):0xc00028ce88 rt, err = mutable.Commit():0xc00028ce80 rt.(*Tr).verify(rt.(*Tr).Root, t):0xc00028ce90 rt.Add(entries...):0xc0000a4078 rt.Add(entries[i%numItems]):0xc000c24308 rt.Add(entries[index]):0xc000826550 rt.Add(m1):0xc000224370 rt.Add(m1, m2):0xc00039c230 rt.Add(m1, m2, m3):0xc0008260e8 rt.Delete(entries[i%numItems]):0xc000826598 rt.Get(entries[i%numItems]):0xc0000a4080 rt.InsertAtDimension(0, 0, -1):0xc0000a40d8 rt.InsertAtDimension(0, 0, 1):0xc0000a40d0 rt.apply(rt.top, 0, interval, fn):0xc000225750 rt.apply(rt.top, 0, interval, func(e rangetree.Entry) bool {:0xc000a13a28 rt.dimensions = dimensions:0xc000a13110 rt.flatten(e.(*dimensionalBundle).sl, dimension+1, affected):0xc000225a10 rt.flatten(e.(*dimensionalBundle).sl, dimension+1, deleted):0xc000225a30 rt.flatten(iter.Value().(*dimensionalBundle).sl, dimension+1, entries):0xc0002258f0 rt.insert(e.(*dimensionalBundle).sl, dimension+1,:0xc0002249b8 rt.insert(rt.top, 0, dimension, index, number, &deleted, &affected):0xc00028cf08 rt.number -= uint64(len(deleted)):0xc00028cf10 rt.number++:0xc00000f470 rt.number--:0xc000827438 rt.top = skip.New(uint64(0)):0xc000a13118 rtMutated, err := mutable.Commit():0xc0000a4578 rtMutated.(*Tr).pprint(rtMutated.(*Tr).Root):0xc0000a4598 rtMutated.(*Tr).verify(rtMutated.(*Tr).Root, t):0xc0000a4580 runtime.Gosched():0xc000a12f70 rwg.Add(10):0xc0004a5de0 rwg.Done():0xc0004a5df0 rwg.Wait():0xc00028d1f8 rx = 1 & (t / 2):0xc000191f08 rx = boolToInt(x&s > 0):0xc000912ee8 ry = 1 & (t ^ rx):0xc000191f10 ry = boolToInt(y&s > 0):0xc000912f08 s += 3 + msgp.ArrayHeaderSize:0xc0004a4a38 s += msgp.GuessSize(z.ChildValues[cmr]):0xc0004a4a30 s += msgp.NilSize:0xc000a13858 s += z.ChildKeys[ajw].Msgsize():0xc0004a4a40 s += z[bai].Msgsize():0xc000a13860 s := Int64Slice{1, 3, 6}:0xc0006aa0a0 s := Int64Slice{3, 6, 1, 0, -1}:0xc0004a4088 s := make(slice.Int64Slice, 0, numItems):0xc000826970 s = 1 + 2 + msgp.BytesPrefixSize + len([]byte(z.UUID)) + 2 + msgp.GuessSize(z.Value) + 2 + msgp.BytesPrefixSize + len(z.Payload):0xc000c24be0 s = 1 + 2 + z.UUID.Msgsize() + 2 + msgp.IntSize + 2 + z.Root.Msgsize() + 3 + msgp.IntSize:0xc0004a4320 s = 1 + 3 + msgp.BytesPrefixSize + len([]byte(z.ID)) + 3 + msgp.BoolSize + 3 + msgp.ArrayHeaderSize:0xc0004a4a28 s = append(s, 0):0xc0000a4ce0 s = append(s, j):0xc000826980 s = insertBalance(s, normalized):0xc000225518 s = msgp.ArrayHeaderSize:0xc000a13840 s = msgp.BytesPrefixSize + len([]byte(z)):0xc00028c628 s = q:0xc0002254b0 s = s.Insert(2):0xc000a12e88 s = s.Insert(7):0xc000a12e98 s.Insert(int64(i)):0xc000826988 s.Search(int64(i)):0xc0004a4410 s.Sort():0xc0004a4570 s.pointer++:0xc0000a5680 s1, s2, s3, s4 := newSema(), newSema(), newSema(), newSema():0xc0008265a0 s[i] = x:0xc0000a4cf0 s[i], s[j] = s[j], s[i]:0xc00039cf88 sba := newBitArray(300):0xc000a13608 sba := newSparseBitArray():0xc0004a53a8 sba.Reset():0xc0008263a0 sba.SetBit(1):0xc0004a53e8 sba.SetBit(1000):0xc0004a53d8 sba.SetBit(1200):0xc00028c9e0 sba.SetBit(150):0xc0008266f8 sba.SetBit(1500):0xc00028c9d8 sba.SetBit(155):0xc000826700 sba.SetBit(2000):0xc0000a53d0 sba.SetBit(2500):0xc000a132f0 sba.SetBit(2680):0xc0004a53f8 sba.SetBit(280):0xc0004a53c0 sba.SetBit(3):0xc0004a53b8 sba.SetBit(30):0xc0004a5408 sba.SetBit(300):0xc000826818 sba.SetBit(5):0xc000826000 sba.SetBit(500):0xc00028c9c8 sba.SetBit(i):0xc0000a5370 sba.SetBit(s * 2):0xc000224570 sba.SetBit(s + 1):0xc000224588 sba.SetBit(s - 1):0xc0000a5388 sba.ToNums():0xc0004a4c28 sba.blocks = sba.blocks[:0]:0xc0006ab418 sba.blocks.deleteAtIndex(i):0xc0006ab3c0 sba.blocks.insert(i):0xc0008271e0 sba.blocks[i] = sba.blocks[i].insert(position):0xc0008271e8 sba.blocks[i] = sba.blocks[i].remove(position):0xc0006ab3b0 sba.blocks[i].toNums(offset*s, &nums):0xc000c24d78 sba.indices = sba.indices[:0]:0xc0006ab420 sba.indices.deleteAtIndex(i):0xc0006ab3c8 sba:	sba,:0xc000191e18 searchKey := newMockKey(0):0xc0008274d8 secondSeen := false:0xc000191a50 secondSeen = true:0xc000191a78 seen := make(map[string]struct{}, 10):0xc0001bfad0 seenKeys := map[string]bool{}:0xc00028d410 seenKeys[string(entry.Key)] = true:0xc00028d418 seenNodes: make(map[string]*Node, 10),:0xc0009132f8 seen[string(n.ID)] = struct{}{}:0xc0001bfb10 select {:0xc00039cc10 selfIndex := 0:0xc00000e2b0 selfIndex = i:0xc0002257e0 selfIndex = toIndex:0xc0001bff30 selfIndex++:0xc00000f050 selfValue := sba.indices[selfIndex]:0xc00000f058 sema := (*w)[0]:0xc00000efe8 sema := newSema():0xc000c24de0 sema := pq.waiters.get():0xc0001bf440 sema := q.waiters.get():0xc0001bf518 sema.ready <- true:0xc0001bf458 sema.response.Add(1):0xc0001bf450 sema.response.Done():0xc000c24e10 sema.response.Wait():0xc0001bf460 seq := atomic.LoadUint64(&n.position):0xc000a12478 set := New():0xc000191a20 set := New(`test`, `test1`):0xc00000f0d0 set := pool.Get().(*Set):0xc00039c9e8 set.Add(1):0xc0004a5920 set.Add(`test1`):0xc000191a40 set.Add(`test`):0xc000191a28 set.Add(item):0xc0001bf160 set.Clear():0xc0006ab450 set.Exists(1):0xc0004a5928 set.Flatten():0xc0001bf178 set.Len():0xc000827478 set.Remove(`test`):0xc000224f80 set.Remove(item):0xc000c24e50 set.flattened = append(set.flattened, item):0xc0009133f0 set.flattened = make([]interface{}, 0, len(set.items)):0xc0009133e0 set.flattened = nil:0xc000191d10 set.flattened = set.flattened[:0]:0xc000288610 set.flattened[i] = nil:0xc000288608 set.items = map[interface{}]struct{}{}:0xc000913400 set.items[item] = struct{}{}:0xc000191d18 set.lock.Lock():0xc000191a00 set.lock.RLock():0xc0004a52a0 set.lock.RUnlock():0xc0004a52b0 set.lock.Unlock():0xc000913408 setMax(child):0xc000c25380 setMax(n):0xc0009132b0 setMax(parent):0xc000c25388 setMin(child):0xc000c25390 setMin(n):0xc0009132a8 setMin(parent):0xc000c25398 setRoot = true:0xc0004a5b18 sgraph := NewSimpleGraph():0xc00039cf90 sgraph.AddEdge("A", "A"):0xc0004a4f20 sgraph.AddEdge("A", "B"):0xc00039cfa0 sgraph.AddEdge("A", "C"):0xc00039cfc0 sgraph.AddEdge("B", "A"):0xc0004a4f28 sgraph.AddEdge("B", "C"):0xc00039cfb0 sgraph.AddEdge("C", "A"):0xc00039cfc8 sgraph.AddEdge("C", "C"):0xc00039cfd0 sgraph.AddEdge("C", "D"):0xc0004a4f38 sgraph.AddEdge("D", "D"):0xc00039cfd8 sgraph.AddEdge("E", "F"):0xc0004a4f40 sgraph.AddEdge("E", "G"):0xc0004a4f48 sgraph.AddEdge("H", "G"):0xc0004a4f50 sibling, err := getSibling(parent, siblingPosition):0xc0000a4818 sibling.prependKey(key):0xc0000a4a38 sibling.prependValue(correctedValue):0xc0000a4a30 sibling.prependValue(parentValue):0xc0000a4a50 siblingPosition := i:0xc0000a47f0 siblingPosition++:0xc0000a4810 siblingPosition--:0xc0000a4800 side = whichSide(n, n.parent):0xc0000a5178 sigma := calculateSigma(len(results.config.Vars), len(results.vertices)):0xc000c252d0 singleton := newEntry(priority):0xc000a12de0 size := int64(len(set.items)):0xc0009133f8 size := len(*items):0xc00039c3a8 size := uint(0):0xc000c25408 size = roundUp(size):0xc0000a51b0 size++:0xc000191dd0 sl	= rt.top:0xc00000f418 sl := &SkipList{}:0xc00000fb88 sl := &skipListRT{}:0xc00028cf20 sl := New(uint64(0)):0xc0002252f8 sl := New(uint8(0)):0xc000c24928 sl := NewImmutable():0xc0004a4238 sl = db.sl:0xc00000f4a0 sl = e.(*dimensionalBundle).sl:0xc0001bf6b0 sl, _ = sl.Delete(entries[i%numItems]):0xc0004a4250 sl, _ = sl.Insert(entries...):0xc0004a4240 sl, _ = sl.Insert(entries[i%numItems]):0xc0004a4248 sl.ByPosition(uint64(i % numItems)):0xc0000a4088 sl.Delete(db):0xc000827460 sl.Delete(e):0xc00028d1e0 sl.Delete(entries...):0xc0004a4278 sl.Delete(entries[i]):0xc0008262c8 sl.Delete(m1):0xc00000f7c0 sl.Delete(m2):0xc00000f7d8 sl.Delete(toDelete...):0xc000225a38 sl.Get(entries[i%numItems]):0xc000c24018 sl.Insert(db):0xc00000f490 sl.Insert(e1...):0xc00028d1c8 sl.Insert(e2...):0xc00028d1d0 sl.Insert(entries...):0xc000225300 sl.Insert(entries[i%numItems]):0xc0000a4008 sl.Insert(lb):0xc00000f478 sl.Insert(m1):0xc00028d458 sl.Insert(m1, m2):0xc000c24b70 sl.Insert(m1, m2, m3):0xc0008271f0 sl.Insert(newMockEntry(uint64(i))):0xc000826358 sl.InsertAtPosition(0, entries[i%numItems]):0xc000c24028 sl.InsertAtPosition(0, m2):0xc000c24938 sl.InsertAtPosition(0, m3):0xc000c24940 sl.InsertAtPosition(2, m1):0xc000c24930 sl.ReplaceAtPosition(0, m3):0xc000826160 sl.cache = make(nodes, sl.maxLevel):0xc000c24fc0 sl.cache[i].forward[i] = n.forward[i]:0xc00000f920 sl.cache[i].forward[i] = nil:0xc0004a4868 sl.cache[i].widths[i] += n.widths[i] - 1:0xc00000f918 sl.cache[i].widths[i] = 0:0xc0004a4860 sl.cache[i].widths[i]--:0xc00000f910 sl.head = newNode(nil, sl.maxLevel):0xc000c24fd0 sl.head.widths[sl.level] = 0:0xc00000f930 sl.init(dimensions):0xc00028cf28 sl.init(ifc):0xc00000fb90 sl.insertAtPosition(position, cmp):0xc00000e0b0 sl.level = 1:0xc000c250c0 sl.level = nodeLevel:0xc0001bfa38 sl.level--:0xc000c250d0 sl.maxLevel = 16:0xc000c24fa0 sl.maxLevel = 32:0xc000c24fa8 sl.maxLevel = 64:0xc000c24fb8 sl.maxLevel = 8:0xc000c24f98 sl.posCache = make(widths, sl.maxLevel):0xc000c24fc8 sl.replaceAtPosition(position, cmp):0xc00028d1a8 sl.resetMaxLevel():0xc0004a4888 sl.searchByPosition(index, sl.cache, sl.posCache):0xc0004a4830 slice := make([]float64, 0, N):0xc000a13bf0 slice = append(slice, 2*1E10*(rand.Float64()-0.5)):0xc000a13c00 sliceE := make([]*Entry, 0, N):0xc00028cea8 sliceE = append(sliceE, heap.Enqueue(sliceFlt[i])):0xc00028ceb8 sliceFlt := make([]float64, 0, N):0xc00028cea0 sliceFlt = append(sliceFlt, 2*1E10*(float64(i)-0.5)):0xc00028ceb0 sn := branch.(*sNode):0xc0002241f8 snapshot := c.ReadOnlySnapshot():0xc00028d208 snapshot := ctrie.ReadOnlySnapshot():0xc0000a42f0 snapshot := ctrie.Snapshot():0xc000a13e90 snapshot = ctrie.Snapshot():0xc000a13ea8 snapshot.Insert([]byte("bat"), "man"):0xc000a13eb8 snapshot.Remove([]byte("blah")):0xc0000a4318 snapshot.Remove([]byte(strconv.Itoa(i))):0xc000a13eb0 snapshot.traverse(snapshot.readRoot(), ch, cancel):0xc00028d210 snapshot2 := snapshot.Snapshot():0xc000a13ee0 snapshot2.Remove([]byte("bat")):0xc000a13ef8 snapshot2.Remove([]byte("blah")):0xc0000a4330 sort.Ints(indices):0xc000a13970 sort.Sort(comparators):0xc0004a4000 sort.Sort(nsw):0xc0001bfcf8 sort.Sort(orderedItems(items)):0xc000c25538 sort.Sort(pbs):0xc000c24770 sort.Sort(s):0xc0004a40b8 sort.Sort(sorter):0xc000a135f8 sort.Sort(sw):0xc000913410 sort.Sort(v):0xc000a12a00 sortBucket(chunks[i]):0xc0006aac28 sorter := sorter{:0xc0001bf900 sorter.sort():0xc0001bf918 sorter.vertices[i], sorter.vertices[j] = sorter.vertices[j], sorter.vertices[i]:0xc0002252d0 split(tree, n, child):0xc0001bf0e8 split(tree, parent, stack):0xc0000a5110 splitAt := ptree.ary - 1:0xc0006ab438 splitAt := tree.ary - 1:0xc0004a4908 splitNodes := make(map[string]Keys):0xc000225a70 splitNodes[string(parent.ID)] = append(splitNodes[string(parent.ID)], t.iterativeSplit(node)...):0xc000225ae8 spunUp.Add(numThreads):0xc000c241e8 spunUp.Done():0xc000c241f8 spunUp.Wait():0xc000c24208 stack := make(nodes, 0, blink.ary):0xc0008261a8 stack.push(parent):0xc000c24708 stack.reset():0xc000826310 start	time.Time:0xc0001bf2e0 start := int64(rand.Intn(int(maxValue))):0xc000225288 start = mid + 1:0xc000191518 start = symBinarySearch(u, n-last, mid, n-1):0xc0001bf780 start = symBinarySearch(u, start1, start2, n-1):0xc0001bf788 start = time.Now():0xc0001bf2f0 start, _ := getIndexAndRemainder(ba.lowest):0xc0004a55c0 start, stop, p := 0, len(u), len(w)-1:0xc0001913c0 start:		start,:0xc0001bf3b8 starts := []int64{0, 4, 2, 1, 3}:0xc000826138 starts := []int{0, 4, 2, 1, 3}:0xc000826990 starts := []uint64{0, 4, 2, 1, 3}:0xc000c25100 stop := make(chan struct{}):0xc0001bf4a8 stop = mid:0xc000191588 stop, _ := getIndexAndRemainder(ba.highest):0xc0004a55b8 stop:		stop,:0xc0001bf3c0 stopIndex:	stop,:0xc0004a55e0 sub := pMain.cNode.array[pos]:0xc0000a43b8 subNode := newNode.entries[index].(*node):0xc0004a4718 subNode = emptyNode(newNode.level+1, 32):0xc000827260 subNode = emptyNode(newNode.level+1, 4):0xc000827258 subNode = insert(subNode, entry):0xc000827270 subNode = insert(subNode, newNode.entries[index]):0xc000827268 subNode = remove(subNode, keyHash, key):0xc0004a4720 succeeded := true:0xc0004a5d30 succeeded = false:0xc0004a5d48 successor := yfast.Successor(0):0xc000225208 successor = n.children[1]:0xc0000a5138 successor = xft.min:0xc0001bf7d0 successor = xft.successor(key):0xc0001bf7d8 successor = yfast.Successor(0):0xc000225220 successor = yfast.Successor(100):0xc0006ab2f0 successor = yfast.Successor(14):0xc0006ab2e8 successor = yfast.Successor(3):0xc000225228 successor = yfast.Successor(4):0xc000225230 successor = yfast.Successor(8):0xc000225238 successor, i := es.successor(5):0xc000a13328 successor, i = es.successor(0):0xc000a13340 successor, i = es.successor(10):0xc000a13378 successor, i = es.successor(2):0xc000a13358 successor, i = es.successor(5):0xc000a13370 successor, predecessor := n.children[1], n.children[0]:0xc000224310 successor.children[0] = n:0xc0001bf8b8 successor.children[0] = predecessor:0xc0002244a8 sum += math.Pow(otherPoint-nm.vars[i], 2):0xc000a13e10 sum += v:0xc0006aaea8 sum += v.vars[i]:0xc000913578 sum := float64(0):0xc0006aae78 summed := make(map[float64]vertices, num):0xc0006aae50 summed[sum] = vs:0xc0006aaee0 sw.keys[i], sw.keys[j] = sw.keys[j], sw.keys[i]:0xc00000f0c8 swap(u, w, 2):0xc0004a5768 switch action.operation() {:0xc00039d078 switch b := br.(type) {:0xc00000fa30 switch branch.(type) {:0xc0002241c8 switch dif := seq - (pos + 1); {:0xc0001bf300 switch dif := seq - pos; {:0xc000a12488 switch diff := int(otherValue) - int(selfValue); {:0xc00028c5a8 switch found.Compare(key) {:0xc000913440 switch ifc.(type) {:0xc000c24f90 switch intType.(type) {:0xc000912198 switch keys[mid].Compare(key) {:0xc0004a4d58 switch match.Compare(key) {:0xc0001befc8 switch msgp.UnsafeString(field) {:0xc0002247e8 switch policy {:0xc000c24688 switch result = n.entry.Compare(entry); {:0xc000224e50 switch sub.(type) {:0xc0000a41c8 switch t := br.(type) {:0xc000a13880 switch v := value.(type) {:0xc0004a5228 switch {:0xc00000f068 symMerge(u, 0, lenU, len(u)):0xc0001bf9e0 symMerge(u, 0, lenU1, len(u)):0xc0001bf9c8 symMerge(u, mid, end, last):0xc0001bf7a8 symMerge(u, start1, start, mid):0xc0001bf7a0 symMerge(w, 0, lenU2, len(w)):0xc0001bf9d0 symRotate(u, start, start2, end):0xc0001bf798 symSwap(u, p-i, p+j-i, i):0xc00000f540 symSwap(u, p-i, p, i):0xc00000f550 symSwap(u, p-i, p, j):0xc0002251e8 symSwap(u, start1, start2, i):0xc0002251c8 t /= 4:0xc000191f30 t := &Tr{}:0xc00000eb10 t := *x:0xc000913118 t := h:0xc000191ef8 t := parent.children[otherLast]:0xc000a124d0 t := time.NewTimer(timeout):0xc0000a5258 t, (results[0][0] == mockItem(1) && results[1][0] == mockItem(2)) ||:0xc000a13b38 t.Count += len(keys) - len(overwrittens):0xc0004a56b8 t.Count -= len(keys):0xc0001be5f8 t.Error("test values don't hash to the same value"):0xc0006ab240 t.Errorf("could not find expected interval %d", i):0xc0000a42a8 t.Errorf(`BA not reset.`):0xc0000a52a0 t.Errorf(`Cache not cleared.`):0xc000a134f0 t.Errorf(`Correct existence not determined`):0xc0004a5160 t.Errorf(`Correct nonexistence not determined.`):0xc0004a5170 t.Errorf(`Expected clear.`):0xc0006ab128 t.Errorf(`Expected empty queue.`):0xc0004a59d8 t.Errorf(`Expected equality.`):0xc00039d2f0 t.Errorf(`Expected false at position %d`, 3):0xc00028c2d0 t.Errorf(`Expected false at position: %d`, 5):0xc00028c2e8 t.Errorf(`Expected false.`):0xc0001bfc70 t.Errorf(`Expected inequality.`):0xc00039d318 t.Errorf(`Expected len: %d, received: %d`, 0, len(result)):0xc000a139f8 t.Errorf(`Expected len: %d, received: %d`, 0, len(set.flattened)):0xc000a134e0 t.Errorf(`Expected len: %d, received: %d`, 0, q.Len()):0xc0002253d8 t.Errorf(`Expected len: %d, received: %d`, 0, set.Len()):0xc0006ab460 t.Errorf(`Expected len: %d, received: %d`, 1, len(set.flattened)):0xc0001bf208 t.Errorf(`Expected len: %d, received: %d`, 1, set.Len()):0xc000191d90 t.Errorf(`Expected len: %d, received: %d`, 2, set.Len()):0xc000191da0 t.Errorf(`Expected non-empty queue.`):0xc0004a59e8 t.Errorf(`Expected out of range error.`):0xc00039cf58 t.Errorf(`Expected set.`):0xc0006ab138 t.Errorf(`Expected true at position: %d`, 16):0xc00028c308 t.Errorf(`Expected true at position: %d`, 5):0xc000a12d48 t.Errorf(`Expected true.`):0xc0001bfc58 t.Errorf(`Flatten cache is not the same as original result. Got %+v, expected %+v`, flatten2, flatten1):0xc000a13410 t.Errorf(`Incorrect result returned: %+v`, set.Flatten()):0xc000191a38 t.Errorf(`Is intersecting.`):0xc00000ea18 t.Errorf(`Is not intersecting.`):0xc00000ea30 t.Errorf(`Not all items seen in set.`):0xc000191a88 t.Fail():0xc0000a4180 t.FailNow():0xc00028ce50 t.Fatal("final node is not empty"):0xc0004a4950 t.Fatal(err):0xc000a12d38 t.Log(testCase.label):0xc0004a5aa8 t.Logf("ExecuteInParallel called us with %+v", item):0xc000224640 t.Logf(`EXPECTED: %+v, RESULT: %+v`, c, result[i]):0xc00028ce48 t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, k, nd):0xc000826d30 t.Logf(`N: %+v %p, n.keys[i]: %+v, n.nodes[i]: %+v`, n, n, n.keys[i], n.nodes[i]):0xc0004a54a8 t.Logf(`NODE: %+v, %p`, n, n):0xc0001beca0 t.Logf(`RESULT: %+v`, c):0xc0004a5db0 t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, n.nodes[len(n.nodes)-1].key(), n.keys.last()):0xc0004a54b8 t.Logf(`m: %+v, %p, n.nodes[len(n.nodes)-1].key(): %+v, n.keys.last(): %+v`, n, n, nd, k):0xc000826da0 t.NodeWidth = t.config.NodeWidth:0xc00000e138 t.Root = cp.ID:0xc000225ac0 t.Root = id.UUID:0xc0000a4740 t.Root = n.ID:0xc000a13268 t.Root = nil:0xc000225700 t.Root = node.ID:0xc000225668 t.Root = parent.ID:0xc0002256b8 t.Root = root.ID:0xc000225b30 t.Skipf(`skipping generative add`):0xc0000a4540 t.Skipf(`skipping generative delete`):0xc0006aa0d0 t.Skipf(`skipping generative operations`):0xc0006aa1b8 t.Stop():0xc0000a5270 t.cacher = newCacher(cfg.Persister):0xc00000f658 t.cacher.clear():0xc0004a4e88 t.config = cfg:0xc00000f650 t.context = nil:0xc0004a4e90 t.context.addNode(cp):0xc0006aa728 t.context.addNode(leftNode):0xc000c25190 t.context.addNode(n):0xc000a13270 t.context.addNode(root):0xc000225b38 t.pprint(key.ID()):0xc00028c020 t.red = true:0xc000a124f0 t.reset():0xc00000e160 t.root.print(log):0xc000912e08 t.walkupInsert(tree):0xc0004a56a0 tail, _ := curr.Tail():0xc000c248a0 tail, ok := Empty.Tail():0xc0000a4fa8 tail, ok := l.Tail():0xc000a137e0 tail, ok := l1.Tail():0xc0006aacb0 tail, ok = l.Tail():0xc000a137f8 tail, ok = l1.Tail():0xc0006aacd8 tail, ok = l2.Tail():0xc0006aad00 tail, ok = tail.Tail():0xc0006aad10 takeItems, _ := q.TakeUntil(func(item interface{}) bool {:0xc000826500 target = -math.MaxFloat64:0xc000913670 target = math.MaxFloat64:0xc000913660 tb.Errorf(`Black violation: left: %d, right: %d`, left, right):0xc0000a5538 tb.Errorf(`Max not set correctly, max: %+v, node: %+v`, max, node):0xc0000a5528 tb.Errorf(`Max not set correctly, node: %+v`, node):0xc0000a5518 tb.Errorf(`Max not set correctly: %+v, node: %+v`, max, node):0xc0000a54a8 tb.Errorf(`Min not set correctly, node: %+v`, node):0xc0000a54e0 tb.Errorf(`Min not set correctly: %+v, node: %+v`, min, node):0xc0000a5498 tb.Errorf(`Min not set correctly: %+v`, node):0xc0000a5500 tb.Errorf(`Min not set correctly: node: %+v, child: %+v`, node, node.children[0]):0xc0000a54f0 tb.Errorf(`Node is red and has red children: %+v`, node):0xc0000a5480 tb.Logf(`NODE NEEDS SPLIT: NODE: %+v`, n):0xc000a13d80 test := block(1 << i):0xc00039cca8 testCase.useCache(testCase.cache):0xc0004a5ab0 testCases := []struct {:0xc0004a4c38 testKey := newMockKey(5):0xc00028c3d0 testKey = newMockKey(0):0xc00028c3f0 testKey = newMockKey(2):0xc00028c3e0 testKey = newMockKey(3):0xc00028c400 time.Sleep(5 * time.Millisecond):0xc000827468 time.Sleep(5):0xc000913598 time.Sleep(time.Millisecond):0xc0001be650 timeout := time.After(30 * time.Minute):0xc0001be6e8 timeout := time.Duration(30 * time.Minute):0xc0000a53d8 timeout = time.After(b.maxTime):0xc00000f510 timeoutC = time.After(timeout):0xc000c24df8 tmp := sba.copy():0xc000913368 tmp, bts, err = msgp.ReadBytesBytes(bts, []byte((*z))):0xc00028c5f8 tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.ID)):0xc00028cad0 tmp, bts, err = msgp.ReadBytesBytes(bts, []byte(z.UUID)):0xc0006aafa8 tmpArray := make([]branch, len(cn.array)):0xc0000a41b8 tmpArray[i] = resurrect(inode, main):0xc0000a41e8 tmpArray[i] = sub:0xc0000a41f0 toBeSorted := make(Comparators, len(comparators)):0xc0006aabd8 toComplete := make(actions, 0, len(xns)/2):0xc000826ff0 toComplete = append(toComplete, action):0xc000827020 toDelete := make([]*Key, 0, len(keys)):0xc000225598 toDelete = append(toDelete, e):0xc0002249d8 toDelete = append(toDelete, j):0xc0004a57c8 toDelete = append(toDelete, key):0xc000225600 toDelete = append(toDelete, neighbor):0xc000225630 toDelete = iv:0xc000826328 toDelete = make(common.Comparators, 0, 100):0xc000224720 toDelete = toDelete[:0]:0xc000225658 toIndex, otherBlock := iter.Value():0xc0001bff10 toScalar := midpoint.subtract(nm.lastVertex(vertices)):0xc000c253d0 toScalar := reflection.subtract(midpoint):0xc0004a5ed0 toScalar := vertices[i].subtract(one):0xc0000a56e0 toScalar = midpoint.add(toScalar):0xc000c253e0 toScalar = midpoint.subtract(toScalar):0xc0000a56b8 toScalar = toScalar.multiply(alpha):0xc000c253d8 toScalar = toScalar.multiply(beta):0xc0004a5ed8 toScalar = toScalar.multiply(gamma):0xc0000a56b0 toScalar = toScalar.multiply(sigma):0xc0000a56e8 toVisit := make([]*Entry, 0, heap.size):0xc000913728 toVisit = append(toVisit, curr):0xc000913738 todo := make([]Comparators, len(chunks)/2):0xc0006aac48 todo = todo[:len(chunks)/2]:0xc0006aac50 todo, done := uint64(len(q.items)), int64(-1):0xc00000f660 todo[i/2] = SymMerge(chunks[i], chunks[i+1]):0xc0006aac68 top := 30:0xc0000a4260 top := make(orderedNodes, len(irt.top)):0xc0006aaf50 top++:0xc00028cfd8 top, done, dir, normalized	int:0xc00028cf90 top--:0xc00028d0c8 tr := New(defaultConfig()):0xc0006aa240 tree := &tree{}:0xc00028d318 tree := make(map[string]*path, runtime.NumCPU()):0xc000a132a0 tree := newBTree(1024):0xc00000eb08 tree := newBTree(16):0xc000225770 tree := newBTree(3):0xc0004a40d0 tree := newBTree(4):0xc00039c000 tree := newBTree(64):0xc000a13760 tree := newBTree(ary):0xc0008274d0 tree := newImmutableRangeTree(1):0xc000a12d90 tree := newImmutableRangeTree(2):0xc0001bf590 tree := newImmutableRangeTree(irt.dimensions):0xc0006aaf78 tree := newOrderedTree(2):0xc000224618 tree := newTree(1):0xc00000e9c8 tree := newTree(1024, 1024):0xc00000eb40 tree := newTree(12, 8):0xc0004a5ad0 tree := newTree(16, 16):0xc000913200 tree := newTree(16, 4):0xc000c254d8 tree := newTree(16, 8):0xc0002259a0 tree := newTree(17, 8):0xc0004a46d0 tree := newTree(3, 1):0xc00028ca58 tree := newTree(3, 3):0xc000a133d0 tree := newTree(3, 8):0xc000a13f18 tree := newTree(4, 1):0xc0006ab368 tree := newTree(4, 4):0xc000225758 tree := newTree(64, 1):0xc000c25550 tree := newTree(8, 1):0xc000826dd0 tree := newTree(8, 8):0xc0004a5518 tree := newTree(9, 8):0xc000224308 tree = tree.Add(e):0xc000827740 tree, _ := constructMultiDimensionalImmutableTree(3):0xc000224398 tree, _ := constructMultiDimensionalImmutableTree(numItems):0xc0000a4478 tree, _ := constructMultiDimensionalOrderedTree(1):0xc0000a5860 tree, _ := constructMultiDimensionalOrderedTree(numItems):0xc0006aa078 tree, _ := constructMultiDimensionalOrderedTree(uint64(numItems)):0xc000826578 tree, _ := constructSingleDimensionTestTree(20):0xc0008269c0 tree, entries := constructMultiDimensionalImmutableTree(2):0xc000c25578 tree, entries := constructMultiDimensionalImmutableTree(3):0xc0008264c0 tree, entries := constructMultiDimensionalOrderedTree(1):0xc0000a4f08 tree, entries := constructMultiDimensionalOrderedTree(10):0xc00000e110 tree, entries := constructMultiDimensionalOrderedTree(2):0xc0004a5f18 tree, entries := constructMultiDimensionalOrderedTree(3):0xc000826788 tree, entries := constructMultiDimensionalOrderedTree(4):0xc000a13618 tree.Add(constructMockEntry(i, int64(i), int64(i))):0xc000225710 tree.Add(constructMockEntry(start, int64(start), int64(start))):0xc000c25110 tree.Add(constructSingleDimensionInterval(int64(i*10), int64((i+1)*10), uint64(i))):0xc0000a4278 tree.Add(entries...):0xc000224770 tree.Add(iv1, iv2):0xc0008269d8 tree.Add(iv1, iv2, iv3):0xc0004a43f8 tree.Add(ivs...):0xc000c248c8 tree.Apply(constructMockInterval(dimension{0, 100}, dimension{0, 100}),:0xc0008262a8 tree.Apply(iv, fn):0xc000826590 tree.Delete(constructMockEntry(0, 0, 0)):0xc0000a57b8 tree.Delete(entries...):0xc00000f7f0 tree.Delete(entries[2]):0xc000225cb0 tree.Delete(entries[5]):0xc000225d78 tree.Delete(keys1...):0xc00000eb60 tree.Delete(keys[i%numItems]):0xc00028d4b0 tree.Delete(m1):0xc0004a5520 tree.Delete(m1, m2):0xc000a133b8 tree.Delete(points...):0xc0004a5910 tree.Delete(points[i%numItems]):0xc0004a5ef8 tree.Delete(r1):0xc000225380 tree.Delete(r1, r2, r3, r4):0xc000c254d0 tree.Delete(r2):0xc000225550 tree.Delete(reversed...):0xc0006ab2d0 tree.Get(entries[i%len(entries)]):0xc000224a90 tree.Get(keys...):0xc00028d450 tree.Get(keys[i%numItems]):0xc0001bfec0 tree.Get(keys[i]...):0xc0004a5c90 tree.Get(ks[i]...):0xc000225780 tree.Insert(duplicate):0xc00028c920 tree.Insert(k1, k2):0xc0001bfd48 tree.Insert(key):0xc000c24b10 tree.Insert(keySet[i]...):0xc0001bfee0 tree.Insert(keys...):0xc0004a4140 tree.Insert(keys1...):0xc0008274a0 tree.Insert(keys2...):0xc0008274b0 tree.Insert(keys[i%numItems]):0xc00000e948 tree.Insert(keys[i]...):0xc0004a5c88 tree.Insert(ks[i]...):0xc000225778 tree.Insert(m1):0xc000913218 tree.Insert(m1, m2):0xc0001be690 tree.Insert(points...):0xc0004a5900 tree.Insert(points[i%numItems]):0xc0000a57f8 tree.Insert(r1):0xc000a133d8 tree.Insert(r1, r2):0xc0001bff50 tree.Insert(r1, r2, r3):0xc0008278d8 tree.Insert(r1, r2, r3, r4):0xc0006ab500 tree.Insert(r2):0xc00000f9c8 tree.Insert(r3):0xc00000f9d0 tree.Insert(r4):0xc00000f9d8 tree.Insert(reversed...):0xc0008271b8 tree.InsertAtDimension(1, 0, -1):0xc000c25660 tree.InsertAtDimension(1, 0, 1):0xc0006aa080 tree.InsertAtDimension(2, 0, -1):0xc000c25668 tree.InsertAtDimension(2, 0, 1):0xc0000a4438 tree.Query(iv):0xc00028d158 tree.Query(mockKey(0), mockKey(numItems)):0xc000224230 tree.Query(mockKey(numItems/2), mockKey(numItems/2+1)):0xc0006aa328 tree.Search(newMockRectangle(i, i, i+10, i+10)):0xc00028d3f0 tree.Search(newMockRectangle(i, i, int32(numItems), int32(numItems))):0xc00028d4d0 tree.Traverse(func(i Interval) {:0xc0000a4250 tree.Traverse(func(id Interval) {:0xc0000a4288 tree.actions = queue.NewRingBuffer(tree.bufferSize):0xc00039ca28 tree.actions.Dispose():0xc00028d308 tree.actions.Put(action):0xc000826ec8 tree.add(iv):0xc00039c340 tree.applyNode(n, adds, deletes):0xc000c254a0 tree.ary = ary:0xc00039ca08 tree.bufferSize = bufferSize:0xc00039ca00 tree.cache = append(tree.cache, a):0xc000826ee8 tree.cache = make([]interface{}, 0, bufferSize):0xc00039ca10 tree.cache = tree.cache[:0]:0xc000912018 tree.cache[i] = nil:0xc000912010 tree.checkAndRun(ga):0xc00028d2f8 tree.checkAndRun(ia):0xc00028d258 tree.checkAndRun(nil):0xc000826f30 tree.checkAndRun(ra):0xc000225cf0 tree.delete(iv):0xc00028c060 tree.dummy.children[0], tree.dummy.children[1] = nil, nil:0xc0008260b8 tree.dummy.red = false:0xc0008260c0 tree.fetchKeysInParallel(xns):0xc000826fd0 tree.fetchKeysInSerial(xns):0xc000826fd8 tree.init(bufferSize, ary):0xc00028d320 tree.insert(key):0xc000826c20 tree.lock.Lock():0xc00028c868 tree.lock.Unlock():0xc00028c8b0 tree.number = 1:0xc000826260 tree.number = irt.number + added:0xc0006aaf88 tree.number = irt.number - deleted:0xc00028c958 tree.number = irt.number - uint64(len(deleted)):0xc000a131c8 tree.number++:0xc000826718 tree.number--:0xc000a12750 tree.operationRunner(interfaces{action}, false):0xc000826f28 tree.operationRunner(interfaces{action}, true):0xc000826f20 tree.print(getConsoleLogger()):0xc000826df0 tree.recursiveMutate(nextLayerWrite, nextLayerDelete, setRoot, inParallel):0xc000c254c8 tree.recursiveMutate(writeOperations, deleteOperations, false, threaded):0xc00039d3b8 tree.reset():0xc000826f18 tree.resetDummy():0xc0001bfb40 tree.root = dummy.children[1]:0xc0001bfc48 tree.root = n:0xc000c25498 tree.root = newNode(:0xc0001bfb18 tree.root = newNode(true, newKeys(ary), newNodes(ary)):0xc00039ca18 tree.root = parent:0xc00028c8a0 tree.root = split(tree, nil, tree.root):0xc000826728 tree.root.adjustRanges():0xc00028c118 tree.root.mbr = &rectangle{}:0xc00039ca20 tree.root.query(ivLow, ivHigh, interval, tree.maxDimension, func(node *node) {:0xc000c24238 tree.root.red = false:0xc0001bfb38 tree.splitNode(n, parent, &nodes, &keys):0xc000c254b8 tree.top = irt.top.immutableInsert(:0xc000a131a8 tree.top = top:0xc0006aaf80 tree1 := tree.Add(e1):0xc000a12fd8 tree1 := tree.Add(e1, e2, e3):0xc000c243b0 tree1 := tree.Add(entries...):0xc000a13208 tree1, modified, deleted := tree.InsertAtDimension(1, 1, -1):0xc0000a4200 tree1, modified, deleted := tree.InsertAtDimension(1, 1, -2):0xc0000a4418 tree1, modified, deleted := tree.InsertAtDimension(1, 1, 0):0xc000224a58 tree1, modified, deleted := tree.InsertAtDimension(1, 1, 1):0xc000c25580 tree1, modified, deleted := tree.InsertAtDimension(1, 1, 2):0xc0000a40a0 tree1, modified, deleted := tree.InsertAtDimension(1, 4, -1):0xc0000a42b0 tree1, modified, deleted := tree.InsertAtDimension(1, 4, 1):0xc0002243a0 tree1, modified, deleted := tree.InsertAtDimension(2, 1, -1):0xc0008269f8 tree1, modified, deleted := tree.InsertAtDimension(2, 1, -2):0xc000224a48 tree1, modified, deleted := tree.InsertAtDimension(2, 1, 1):0xc0008264c8 tree1, modified, deleted := tree.InsertAtDimension(2, 1, 2):0xc0000a40b8 tree1, modified, deleted := tree.InsertAtDimension(2, 4, -1):0xc0000a4390 tree1, modified, deleted := tree.InsertAtDimension(2, 4, 1):0xc0000a4098 tree1, modified, deleted := tree.InsertAtDimension(3, 1, -1):0xc000224a50 tree2 := tree.Add(entry):0xc000a12da0 tree2 := tree1.Add(e2):0xc000a12fe0 tree2 := tree1.Delete(e2, e3):0xc000c243b8 tree3 := tree2.Add(e3):0xc000a12fe8 tree3 := tree2.Delete(e1):0xc000c243d0 tree3 := tree2.Delete(entry):0xc0004a4300 tree4 := tree3.Delete(e3):0xc000c24350 tree5 := tree4.Delete(e2):0xc000c24368 tree6 := tree5.Delete(e1):0xc000c24380 tree7 := tree3.Delete(constructMockEntry(0, int64(3), int64(3))):0xc000c24398 treeLock.Lock():0xc0004a5678 treeLock.Unlock():0xc0004a5688 treeSlice := make([]*Entry, 0, heap.size):0xc000913720 treeSlice = append(treeSlice, nil):0xc000913750 treeSlice[curr.degree] = curr:0xc000913760 treeSlice[curr.degree] = nil:0xc000913770 tree[string(n.ID)] = path:0xc0004a5680 trees := make([]*btree, 0, numItems):0xc0004a4ac8 trees := make([]*orderedTree, 0, b.N):0xc0000a5828 trees := make([]*ptree, 0, b.N):0xc0000a57c0 trees := make([]*ptree, 0, numItems):0xc00000fb10 trees := make([]*tree, 0, b.N):0xc0004a42b8 trees = append(trees, it):0xc0004a42c0 trees = append(trees, newBTree(8)):0xc0004a4ad0 trees = append(trees, newTree(8, 8)):0xc00000fb18 trees = append(trees, tree):0xc00028d4c0 trees[i].Delete(entries...):0xc0000a5830 trees[i].Delete(intervals...):0xc0004a42c8 trees[i].Delete(keys...):0xc00028d4c8 trees[i].Get(chunks[j]...):0xc0004a4b10 trees[i].Insert(chunks[j]...):0xc0004a4b08 trees[i].Insert(keys...):0xc0000a57c8 trie := New(factory):0xc000826360 trie.Insert([]byte("foobar"), 1):0xc000826368 trie.Insert([]byte("foobar"), 3):0xc000826478 trie.Insert([]byte("zogzog"), 2):0xc000826370 trie.Remove([]byte("foobar")):0xc0008264a8 true, make(Keys, 0, blink.ary), make(nodes, 0, blink.ary+1),:0xc000913150 two.next = oneNext:0xc00000f738 two.next.prev = two:0xc00000f740 u := constructMockComparators(1):0xc00028cc40 u := constructMockComparators(1, 3, 5):0xc0004a4b90 u := constructMockComparators(1, 3, 5, 7, 9):0xc000a13e00 u := constructMockComparators(1, 3, 7):0xc000c250e0 u := constructMockComparators(1, 3, 7, 12, 15):0xc00000eae8 u := constructMockComparators(1, 5):0xc00000f4b0 u := constructMockComparators(1, 5, 7, 9):0xc0001be008 u := constructMockComparators(2, 4):0xc00000eac8 u := constructMockComparators(5, 7, 9, 10, 11, 12):0xc0006aa2f8 u := constructMockComparators(6, 7):0xc00000e0f8 u = SymMerge(u, nil):0xc0004a4ba0 u = SymMerge(u, w):0xc00000f4c8 u = append(u, w...):0xc0001bf9d8 u = append(u1, w1...):0xc0001bf9b8 u = constructMockComparators(1, 5, 7):0xc0001be050 u, w = w, u:0xc000c24f48 u1 := constructMockComparators(1, 5, 2, 8):0xc0004a5758 u1 = make(Comparators, i):0xc000c24f60 u1, w1, u2, w2 := prepareForSymMerge(u, w):0xc0001bf9a0 u2 = make(Comparators, len(u)-i):0xc000c24f78 u[i], u[j] = u[j], u[i]:0xc0006aab28 u[i], w[i-index] = w[i-index], u[i]:0xc000191fc0 u[start1+i], u[start2+i] = u[start2+i], u[start1+i]:0xc0001bed08 uint32(0x0000FFFF),:0xc00028c448 uint32(0x00FF00FF),:0xc00028c440 uint32(0x0F0F0F0F),:0xc00028c438 uint32(0x33333333),:0xc00028c430 uint32(0x55555555),:0xc00028c428 uint64(0x0000FFFF0000FFFF),:0xc0004a5208 uint64(0x00FF00FF00FF00FF),:0xc0004a5200 uint64(0x0F0F0F0F0F0F0F0F),:0xc0004a51f8 uint64(0x3333333333333333),:0xc0004a51f0 uint64(0x5555555555555555),:0xc0004a51e8 uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56:0xc000a129c8 uint64(i), &dimension{0, 10}, &dimension{0, 10},:0xc0004a4438 uint64(i), &dimension{i, i + 1}, &dimension{i, i + 1},:0xc000225538 uint64(i), &dimension{start, start + 1}, &dimension{start, start + 1},:0xc000826150 uint64(start), &dimension{0, 10}, &dimension{0, 10},:0xc0006aa058 unsafe.Pointer(&mainNode{failed: prev})):0xc0000a4500 unsafe.Pointer(m), unsafe.Pointer(fn)) {:0xc0000a44b8 unsafe.Pointer(old), unsafe.Pointer(n)) {:0xc0006aa040 unsafe.Pointer(prev),:0xc0000a44f8 updateTest(t, collisionHash, 1000):0xc0004a4960 updateTest(t, defaultHasher, 10000):0xc0004a4958 update[offset] = n:0xc0008273c8 useCache	func(c Cache):0xc0004a4c50 useCache: func(c Cache) {:0xc0004a4c80 v := &nmVertex{vars: config.Vars}:0xc00000fbc8 v := r.Float64() * 1000:0xc0006aae90 v = -v:0xc0006aaea0 v |= v >> 1:0xc000191af8 v |= v >> 16:0xc000191b18 v |= v >> 2:0xc000191b00 v |= v >> 32:0xc000191b20 v |= v >> 4:0xc000191b08 v |= v >> 8:0xc000191b10 v++:0xc000191b28 v, err := sgraph.Adj("A"):0xc000c251e8 v, err := sgraph.Degree("A"):0xc0004a4ef8 v, err = sgraph.Adj("A"):0xc000c251f0 v, err = sgraph.Adj("B"):0xc000c25208 v, err = sgraph.Adj("C"):0xc000c25258 v, err = sgraph.Adj("E"):0xc000c25268 v, err = sgraph.Adj("G"):0xc000c25280 v, err = sgraph.Degree("A"):0xc0004a4f10 v, err = sgraph.Degree("B"):0xc0004a4f30 v, err = sgraph.Degree("C"):0xc0004a4f60 v, err = sgraph.Degree("D"):0xc0004a4f68 v, err = sgraph.Degree("E"):0xc0004a55e8 v, err = sgraph.Degree("G"):0xc0004a55f0 v--:0xc000191af0 v.evaluate(config):0xc00000f638 v.probability = calculateVVP(bestGuess, v.vertex, sigma):0xc000c24768 v.values[i], v.values[j] = v.values[j], v.values[i]:0xc0004a4af0 v1 = comparators[:overhang]:0xc0006aa128 v1, w, v2 := decomposeForSymMerge(3, comparators):0xc00039cf00 v1, w, v2 := decomposeForSymMerge(5, comparators):0xc0009131a0 v1, w, v2 := decomposeForSymMerge(7, comparators):0xc00000f168 v1, w, v2 := decomposeForSymMerge(len(u), w):0xc000c24f50 v2 = comparators[overhang+length:]:0xc0006aa138 v:		0,:0xc00028c9b0 val := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |:0xc000a128d0 val, exists := trie.Lookup([]byte("foobar")):0xc000826488 val, ok := ctrie.Lookup([]byte("foo")):0xc0009134a0 val, ok := ctrie.Lookup([]byte(strconv.Itoa(i))):0xc00000f330 val, ok := ctrie.Remove([]byte(strconv.Itoa(i))):0xc00000f348 val, ok := g.adjacencyList[v]:0xc00028c668 val, ok := main.lNode.lookup(entry):0xc000224608 val, ok := snapshot.Lookup([]byte("bat")):0xc000a13ec8 val, ok := snapshot.Lookup([]byte(strconv.Itoa(i))):0xc000a13e98 val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i))):0xc0000a4328 val, ok = ctrie.Lookup([]byte("foo")):0xc0009134b8 val, ok = ctrie.Lookup([]byte("fooooo")):0xc0009134c0 val, ok = ctrie.Lookup([]byte(strconv.Itoa(i))):0xc0009134e0 val, ok = ctrie.Remove([]byte("foo")):0xc000913500 val, ok = ctrie.Remove([]byte("fooooo")):0xc000913510 val, ok = snapshot.Lookup([]byte("bat")):0xc000a13f08 val, ok = snapshot2.Lookup([]byte("bat")):0xc000a13ef0 value	int64:0xc00000f408 value	uint64:0xc0001bf698 value := entry.ValueAtDimension(dimension):0xc000c24c28 value := entry.ValueAtDimension(i):0xc0004a5548 value := n.ChildValues[0]:0xc000c242c0 value := n.ChildValues[i]:0xc0004a47d0 value := n.ChildValues[len(n.ChildValues)-1]:0xc000225bb8 value := rand.Int63():0xc000a12028 value = entry.ValueAtDimension(i):0xc00000f438 value = uint64(entry.ValueAtDimension(i)):0xc0001bf6a0 value, _ := hm.Get(i):0xc000c24af8 value, key = sibling.popFirstValue(), sibling.popFirstKey():0xc0000a4a60 value, ok := hm.Get(5):0xc0006aad60 value, ok := hm.Get(6):0xc00000e0c8 value, ok := m.Get(42):0xc0006ab270 valueIndex := i:0xc0000a4ac8 valueIndex--:0xc0000a4ae0 values := make([]interface{}, 0, len(items)):0xc00028cc18 values = append(values, item.Value):0xc00028cc20 values:		n.ChildValues,:0xc0001bfce0 var (:0xc0001bf2c8 var a interface{}:0xc00039d040 var alreadyChecked *node:0xc000827388 var bal int8:0xc000c25438 var bytesRead int:0xc000a983c0 var child node:0xc0001beec8 var counter int64:0xc0000a4340 var curLoc = uint64(1):0xc000a98338 var d int64:0xc000912e78 var deleted Entries:0xc000224408 var deleted rangetree.Entries:0xc00028cef8 var dummyRoot *node:0xc0004a5b38 var e Entry:0xc0004a4730 var e common.Comparator:0xc000a139c0 var e1, e2, e3 *Entry:0xc0006ab008 var encodedanyset uint8:0xc00039c408 var err error:0xc0004a50b0 var field []byte:0xc0002247b0 var forCache struct {:0xc0001bf6c0 var getSibling = func(parent *Node, i int) (*Node, error) {:0xc0000a4748 var heap FloatingFibonacciHeap:0xc0001bfe18 var highestValue interface{}:0xc0002258f8 var i int:0xc0001bfdd8 var identifier uint8 = 'B':0xc000c24e38 var identifier uint8 = 'S':0xc00039cd68 var index int:0xc0004a5540 var inserted bool:0xc0001bf928 var intsToRead uint64:0xc000a98348 var intsize = uint64(s / 8):0xc000a98260 var isz uint32:0xc0002247c0 var items []Item:0xc000c24ff8 var items []interface{}:0xc000c24dd8 var iter skip.Iterator:0xc0002245e8 var k Key:0xc00028c848 var k common.Comparator:0xc000a13508 var key *Key:0xc0001bfde0 var l, r *node:0xc00028c840 var leftOrRight uint64:0xc0001bf828 var level uint8:0xc00028c310 var local *node:0xc000827580 var lock sync.Mutex:0xc0004a4ad8 var mid int:0xc0004a4cf0 var min *Entry:0xc000a12ab0 var minT, maxT *Entry:0xc000913778 var mutate func(interfaces, func(interface{})):0xc0004a5b78 var n *Node:0xc0001bfdd0 var n *node:0xc0006aa9e8 var nextblock block:0xc0001bfe80 var nextblock uint64:0xc000a98550 var nextuint uint64:0xc000a985a0 var nn *node:0xc0001bf848 var node *node:0xc0004a5178 var offset uint64:0xc000826188 var offset uint8:0xc000827380 var ok bool:0xc000c24630 var old common.Comparator:0xc0008263c8 var old hilbert:0xc000c251a8 var overwrittenKey *Key:0xc00000e938 var overwrittens Keys:0xc000a13280 var parent *node:0xc000913130 var pos uint64 = 0:0xc000827378 var predecessor *node:0xc0000a53f8 var predecessor, successor *node:0xc0001bf7c0 var result int:0xc000224e38 var result interface{}:0xc0004a50a8 var result rangetree.Entries:0xc0004a4260 var resultBlock block:0xc00000e318 var right *node:0xc000a130c8 var root *node:0xc000912750 var rwg sync.WaitGroup:0xc0004a5dd0 var rx, ry int32:0xc000912e30 var ry, rx int64:0xc000191ee8 var selfIndex int64:0xc0002257b0 var selfIndex uint64:0xc00000e2f0 var side int:0xc0000a5120 var spunUp sync.WaitGroup:0xc000c241e0 var start int:0xc0001bf770 var subNode *node:0xc000827248 var successor *node:0xc0000a5128 var timeout <-chan time.Time:0xc00000f500 var timeoutC <-chan time.Time:0xc000c24df0 var tmp []byte:0xc00028c5f0 var toDelete *mockInterval:0xc0008262d0 var toDelete []int:0xc0004a57a8 var toDelete common.Comparators:0xc000224710 var treeLock sync.Mutex:0xc000a13290 var value interface{}:0xc0000a4a08 var wg sync.WaitGroup:0xc0006aabe8 var write sync.Mutex:0xc0004a5b60 var wwg sync.WaitGroup:0xc0004a5dc8 var x, y int32:0xc000191ef0 var xsz uint32:0xc000a136f8 vars := make([]float64, 0, dimensions):0xc0006aae80 vars := make([]float64, 0, len(nm.vars)):0xc000a13c30 vars := make([]float64, 0, num):0xc000913568 vars = append(vars, nm.vars[i]*scalar):0xc000826130 vars = append(vars, nm.vars[i]+other.vars[i]):0xc000a13c40 vars = append(vars, nm.vars[i]-other.vars[i]):0xc000826410 vars = append(vars, sum/float64(num)):0xc000913580 vars = append(vars, v):0xc0006aaeb0 vars: vars,:0xc0006aaec0 vertex = best.add((vertex.subtract(best).multiply(alpha))):0xc00000e150 vertex.evaluate(nm.config):0xc00000e0d8 vertices := make(vertices, 0, num+1):0xc000912030 vertices := nm.results.grab(len(nm.config.Vars) + 1):0xc00028d4d8 vertices = append(vertices, generateRandomVerticesFromGuess(guess, num)...):0xc000912068 vertices = append(vertices, guess):0xc000912048 vertices = nm.results.grab(len(nm.config.Vars) + 1):0xc00028d5d0 vertices.evaluate(nm.config):0xc00028d508 vertices.sort(config):0xc00000f640 vertices:	vertices,:0xc0001bf910 vertices[0].evaluate(nm.config):0xc00028d4e0 vertices[i] = one.add(toScalar):0xc0000a56f0 vertices[len(vertices)-1] = expanded:0xc00028d568 vertices[len(vertices)-1] = ic:0xc00028d5b8 vertices[len(vertices)-1] = oc:0xc00028d590 vertices[len(vertices)-1] = reflection:0xc00028d540 vs := make(vertices, 0, num):0xc0006aae60 vs = append(vs, guess):0xc0006aaed8 vs = append(vs, results.pbs[i].vertex):0xc000c25148 vs = make(vertices, 0, dimensions):0xc0006aaed0 w := constructMockComparators(0, 3, 5, 7, 9):0xc00028cc48 w := constructMockComparators(1, 3, 5, 7, 9):0xc0004a4a00 w := constructMockComparators(1, 3, 7):0xc00000ead0 w := constructMockComparators(1, 3, 7, 12, 15):0xc000c250f8 w := constructMockComparators(1, 3, 9, 10):0xc0001be010 w := constructMockComparators(1, 5):0xc00000e100 w := constructMockComparators(2, 4):0xc000c250e8 w := constructMockComparators(2, 8):0xc00000f4b8 w := constructMockComparators(2, 8, 11, 13):0xc0004a5750 w := constructMockComparators(5, 7, 9, 10, 11, 12):0xc0001bffd0 w := constructMockComparators(6, 7):0xc000c24e58 w := f.wait:0xc0004a5328 w := new(bytes.Buffer):0xc00039cd60 w := waiters{}:0xc0008265a8 w = append(u2, w2...):0xc0001bf9c0 w = comparators[overhang : overhang+length]:0xc0006aa130 w = constructMockComparators(1, 3, 9):0xc0001be058 w.put(s1):0xc0008265b8 w.put(s2):0xc0008265c8 w.put(s3):0xc0008265d0 w.put(s4):0xc0008265d8 w.remove(s1):0xc0008265f8 w.remove(s2):0xc0008265e8 w.remove(s3):0xc000826618 w.remove(s4):0xc000826608 w1 := constructMockComparators(7, 9, 11, 13):0xc0004a5760 w1 = append(v1, w[:len(w)-i]...):0xc000c24f70 w2 = append(w[len(w)-i:], v2...):0xc000c24f88 wait := make(chan bool):0xc00000f4e0 wait <- true:0xc00000f4f0 waiter.ready <- true:0xc000a13ac8 waiter.response.Add(1):0xc000a138c8 wg.Add(1):0xc0004a50b8 wg.Add(2):0xc000913590 wg.Add(4):0xc00000e2c0 wg.Add(5):0xc000c25130 wg.Add(int(numCPU)):0xc0008272c0 wg.Add(len(chunks) / 2):0xc0006aac58 wg.Add(len(chunks)):0xc0006aac10 wg.Add(len(nodes)):0xc000a13288 wg.Add(len(splitNodes)):0xc000225af8 wg.Add(numCPU):0xc0001bf6f8 wg.Add(numLoops):0xc0004a5c80 wg.Add(numRoutines):0xc0004a4ae0 wg.Add(numThreads):0xc000c241d8 wg.Done():0xc0006aac30 wg.Wait():0xc0006aac40 wh := whs[0]:0xc0000a5640 wh.(*node).print(log):0xc000826998 whs := tree.root.searchRects(r):0xc0000a5630 whs = append(whs, n.searchRects(r)...):0xc0000a5650 whs = whs[1:]:0xc0000a5660 widths:		make(widths, maxLevels),:0xc0006aa780 widths[offset] = pos:0xc0008273d0 write.Lock():0xc0004a5bf0 write.Unlock():0xc0004a5c20 writeOperations := make(map[*node][]*keyBundle):0xc000826fe0 writeOperations, deleteOperations, toComplete := ptree.fetchKeys(xns, threaded):0xc0001be258 writeOperations, deleteOperations, toComplete := tree.fetchKeys(xns, threaded):0xc00039d3b0 writeOperations[n] = append(writeOperations[n], &keyBundle{key: action.rects()[i].hilbert, left: action.rects()[i].rect}):0xc000827018 writeOperations[n] = append(writeOperations[n], ptree.newKeyBundle(action.keys()[i])):0xc000a13428 ws := *w:0xc000826f48 wwg.Add(10):0xc0004a5dd8 wwg.Done():0xc0004a5e08 wwg.Wait():0xc0004a5e10 x *= 0x01010101:0xc0000a4400 x += int32(s * rx):0xc000191f20 x -= (x >> 1) & 0x55555555:0xc0000a43e8 x := New(uint8(0)):0xc0004a43c8 x := get(n, hashfunc(i), i):0xc00000f2e0 x = ((x >> 2) & 0x33333333) + (x & 0x33333333):0xc0000a43f0 x = ((x >> 4) + x) & 0x0f0f0f0f:0xc0000a43f8 x++:0xc0001bf5d0 x, y := Decode(h):0xc0006ab098 x, y := int32(math.MaxInt32), int32(math.MaxInt32):0xc00028caa8 x, y := rect.LowerLeft():0xc0000a5008 x, y = Decode(h):0xc0006ab0c0 x, y = rect.UpperRight():0xc0000a5030 x.Insert(newMockEntry(0)):0xc0004a43d0 xfastIter := yfast.xfast.Iter(key):0xc000c24f00 xfastIter.Next():0xc000c24f08 xfastIterator:	xfastIter,:0xc000c24f28 xft := &XFastTrie{}:0xc00028d138 xft := New(uint64(0)):0xc0000a4160 xft := New(uint8(0)):0xc0001bf5e8 xft.Delete(0):0xc0000a4068 xft.Delete(1):0xc000826770 xft.Delete(10):0xc000c25610 xft.Delete(128):0xc0008267b8 xft.Delete(64):0xc0000a40f0 xft.Insert(e):0xc0000a4240 xft.Insert(e1):0xc00000e048 xft.Insert(e1, e2):0xc0000a4060 xft.Insert(e1, e2, e3):0xc0000a40e8 xft.Insert(e2):0xc00000e078 xft.Insert(e3):0xc000a13c98 xft.Insert(newMockEntry(i)):0xc0000a4168 xft.Successor(uint64(i)):0xc0000a4170 xft.bits = bits:0xc000c249e8 xft.delete(key):0xc000a13cf0 xft.diff = 64 - bits:0xc000c249f0 xft.init(ifc):0xc00028d140 xft.insert(e):0xc000c24f38 xft.layers = make([]map[uint64]*node, bits):0xc000c249e0 xft.layers[i] = make(map[uint64]*node, 50):0xc000c24a00 xft.layers[i][key&masks[xft.diff+i]] = nn:0xc0001bf878 xft.max = n:0xc0001bf8e8 xft.max = predecessor:0xc0002244c0 xft.min = n:0xc0001bf8f8 xft.min = successor:0xc0002244d0 xft.num = 0:0xc000c24a08 xft.num++:0xc0001bf868 xft.num--:0xc0002244d8 xft.root = newNode(nil, nil):0xc000c24a10 xft.walkUpNode(root, n, predecessor, successor):0xc0001bf8d8 xft.walkUpPredecessor(n, successor, predecessor):0xc0002244a0 xft.walkUpPredecessor(root, n, predecessor):0xc0001bf8d0 xft.walkUpSuccessor(n, predecessor, successor):0xc0002244b0 xft.walkUpSuccessor(root, n, successor):0xc0001bf8c8 xhigh, yhigh := rect.UpperRight():0xc00039ccf0 xhigh, yhigh := rects[0].UpperRight():0xc00000f270 xhigh, yhigh := wh.UpperRight():0xc000826920 xhigh1, yhigh1 := r1.UpperRight():0xc000912900 xhigh2, yhigh2 := r2.UpperRight():0xc0009128d0 xhigh2, yhigh2 := rect2.UpperRight():0xc00028c4b0 xhigh:	xhigh,:0xc00028c698 xidx := (xhc >> lev) & 0x1f:0xc000225128 xlow, ylow := rect.LowerLeft():0xc00039cce8 xlow, ylow := rects[0].LowerLeft():0xc00000f268 xlow, ylow := wh.LowerLeft():0xc0008268f8 xlow1, ylow1 := r1.LowerLeft():0xc0009128c0 xlow2, ylow2 := r2.LowerLeft():0xc000912930 xlow2, ylow2 := rect2.LowerLeft():0xc00028c4b8 xlow:	xlow,:0xc00028c688 xs := make([]*XFastTrie, 0, b.N):0xc0004a43c0 xs = append(xs, x):0xc0004a43d8 xs[i].Delete(0):0xc0004a43e0 xsz, bts, err = msgp.ReadArrayHeaderBytes(bts):0xc000a13700 y += int32(s * ry):0xc000191f28 yfast := &YFastTrie{}:0xc000c25090 yfast := New(uint32(0)):0xc0006ab6a8 yfast := New(uint64(0)):0xc0006ab688 yfast := New(uint8(0)):0xc0004a5020 yfast.Delete(uint64(i)):0xc0004a4780 yfast.Get(uint64(numItems / 2)):0xc0006ab6b8 yfast.Insert(e1):0xc000224fa8 yfast.Insert(e1, e2):0xc000225218 yfast.Insert(e1, e2, e3):0xc0004a5040 yfast.Insert(e2):0xc000224fb0 yfast.Insert(e3):0xc000225200 yfast.Insert(entries...):0xc0006ab6b0 yfast.Insert(entries[i]):0xc0006ab698 yfast.Predecessor(uint64(i)):0xc00000e030 yfast.Successor(uint64(i)):0xc0004a5ae0 yfast.bits = 16:0xc000912710 yfast.bits = 32:0xc000912728 yfast.bits = 64:0xc000912738 yfast.bits = 8:0xc000912298 yfast.init(ifc):0xc000c25098 yfast.num++:0xc00000ea70 yfast.num--:0xc0001be6c0 yfast.xfast = xfast.New(intType):0xc000912748 yfast.xfast.Delete(bundleKey):0xc0001be6d0 yfast.xfast.Insert(ew):0xc00000f310 yhigh:	yhigh,:0xc00028c6a0 yidx := (yhc >> lev) & 0x1f:0xc000225130 ylow:	ylow,:0xc00028c690 z.ChildKeys = make(Keys, xsz):0xc00028cb30 z.ChildKeys = z.ChildKeys[:xsz]:0xc00028cb28 z.ChildKeys[ajw] = new(Key):0xc00028cb40 z.ChildKeys[ajw] = nil:0xc00028cb38 z.ChildValues = make([]interface{}, xsz):0xc00028cb08 z.ChildValues = z.ChildValues[:xsz]:0xc00028cb00 z.ChildValues[cmr], bts, err = msgp.ReadIntfBytes(bts):0xc00028cb10 z.Count, bts, err = msgp.ReadIntBytes(bts):0xc000224808 z.ID = ID(tmp):0xc00028cad8 z.IsLeaf, bts, err = msgp.ReadBoolBytes(bts):0xc00028cae8 z.NodeWidth, bts, err = msgp.ReadIntBytes(bts):0xc000224828 z.Payload, bts, err = msgp.ReadBytesBytes(bts, z.Payload):0xc0006aafd0 z.UUID = ID(tmp):0xc0006aafb0 z.Value, bts, err = msgp.ReadIntfBytes(bts):0xc0006aafc0 {:0xc000190138 }:0xc000190150 } else if !isRed(node.children[otherDir]) {:0xc000a124c8 } else if !reflection.less(nm.config, nm.lastVertex(vertices)) {:0xc00028d598 } else if NumberSequence2[i] == Seq2DecreaseKey2Orig {:0xc0006ab028 } else if NumberSequence2[i] == Seq2DecreaseKey3Orig {:0xc0006ab038 } else if _, ok := pq.itemMap[item]; !ok {:0xc0001bf430 } else if action != nil {:0xc00039d070 } else if dir < 0 {:0xc000225468 } else if i == n.lenValues() {:0xc000a13dc0 } else if i%3 == 0 {:0xc000224558 } else if i%300 == 0 {:0xc0004a5a80 } else if input[0] == 'S' {:0xc000a12d10 } else if int(nn.balance) == bal {:0xc0004a5ea0 } else if isRed(node.children[0]) && isRed(node.children[1]) {:0xc0001bfba8 } else if isRed(t.children[otherLast]) {:0xc000a12518 } else if item.(string) == `test1` {:0xc000191a70 } else if j == int64(len(action.keys())) {:0xc0006ab3d8 } else if j == int64(len(action.rects())) {:0xc0001bf730 } else if k == ba.lowest {:0xc0009136b8 } else if k > ba.highest {:0xc00039d2c0 } else if math.Abs(float64(cache[top].balance)) > 1 {:0xc00028d0f0 } else if math.IsInf(target, -1) {:0xc000913668 } else if max > node.interval.HighAtDimension(1) && max != node.max {:0xc0000a5520 } else if mi == omi {:0xc000191780 } else if min != -1 && node.children[0] != nil && node.children[0].min != node.min {:0xc0000a54e8 } else if min != -1 && node.children[0] == nil && node.min != node.interval.LowAtDimension(1) {:0xc0000a54f8 } else if n != nil {:0xc0001bfaf0 } else if n == nil {:0xc00028cce0 } else if n.balance == bal {:0xc000225d20 } else if one != nil && two == nil {:0xc00000f710 } else if one == nil && two != nil {:0xc00000f718 } else if otherIndex == len(other.blocks) {:0xc000a13070 } else if otherIndex == len(other.indices) {:0xc00000f038 } else if predecessor != nil {:0xc0001bf8c0 } else if sba, ok := ba.(*sparseBitArray); ok {:0xc000c24188 } else if selfIndex == len(sba.indices) {:0xc00028c580 } else {:0xc000191420 }():0xc0004a50d0 }(ID(id), keys):0xc000225b18 }(chunk, offset):0xc0008263e0 }(i):0xc0006aac38 }(i, id, bundles):0xc0004a5690 }(i, j):0xc0004a4b20 }):0xc000826668 }) {:0xc000a13838 },:0xc0001be638 }, nil:0xc0001beb70 }, start, stop):0xc000225c90 }, values...):0xc0001be5e0 }, {:0xc0004a4ca0 }{{:0xc0004a4c68 }}:0xc0004a5a98] misses:7210}}
